{"number": 1, "statement": "Given an array of integers, return indices of the two numbers such that they add up to a specific target.\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\n", "solutions": ["public int[] twoSum(int[] nums, int target) {\n    for (int i = 0; i < nums.length; i++) {\n        for (int j = i + 1; j < nums.length; j++) {\n            if (nums[j] == target - nums[i]) {\n                return new int[] { i, j };\n            }\n        }\n    }\n    throw new IllegalArgumentException(\"No two sum solution\");\n}\n", "public int[] twoSum(int[] nums, int target) {\n    Map<Integer, Integer> map = new HashMap<>();\n    for (int i = 0; i < nums.length; i++) {\n        map.put(nums[i], i);\n    }\n    for (int i = 0; i < nums.length; i++) {\n        int complement = target - nums[i];\n        if (map.containsKey(complement) && map.get(complement) != i) {\n            return new int[] { i, map.get(complement) };\n        }\n    }\n    throw new IllegalArgumentException(\"No two sum solution\");\n}\n", "public int[] twoSum(int[] nums, int target) {\n    Map<Integer, Integer> map = new HashMap<>();\n    for (int i = 0; i < nums.length; i++) {\n        int complement = target - nums[i];\n        if (map.containsKey(complement)) {\n            return new int[] { map.get(complement), i };\n        }\n        map.put(nums[i], i);\n    }\n    throw new IllegalArgumentException(\"No two sum solution\");\n}\n"]}
{"number": 2, "statement": "You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\n", "solutions": ["public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n    ListNode dummyHead = new ListNode(0);\n    ListNode p = l1, q = l2, curr = dummyHead;\n    int carry = 0;\n    while (p != null || q != null) {\n        int x = (p != null) ? p.val : 0;\n        int y = (q != null) ? q.val : 0;\n        int sum = carry + x + y;\n        carry = sum / 10;\n        curr.next = new ListNode(sum % 10);\n        curr = curr.next;\n        if (p != null) p = p.next;\n        if (q != null) q = q.next;\n    }\n    if (carry > 0) {\n        curr.next = new ListNode(carry);\n    }\n    return dummyHead.next;\n}\n"]}
{"number": 3, "statement": "Given a string, find the length of the longest substring without repeating characters.\n", "solutions": ["public class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        int n = s.length();\n        int ans = 0;\n        for (int i = 0; i < n; i++)\n            for (int j = i + 1; j <= n; j++)\n                if (allUnique(s, i, j)) ans = Math.max(ans, j - i);\n        return ans;\n    }\n    public boolean allUnique(String s, int start, int end) {\n        Set<Character> set = new HashSet<>();\n        for (int i = start; i < end; i++) {\n            Character ch = s.charAt(i);\n            if (set.contains(ch)) return false;\n            set.add(ch);\n        }\n        return true;\n    }\n}\n", "public class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        int n = s.length();\n        Set<Character> set = new HashSet<>();\n        int ans = 0, i = 0, j = 0;\n        while (i < n && j < n) {\n            // try to extend the range [i, j]\n            if (!set.contains(s.charAt(j))){\n                set.add(s.charAt(j++));\n                ans = Math.max(ans, j - i);\n            }\n            else {\n                set.remove(s.charAt(i++));\n            }\n        }\n        return ans;\n    }\n}\n", "public class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        int n = s.length(), ans = 0;\n        Map<Character, Integer> map = new HashMap<>(); // current index of character\n        // try to extend the range [i, j]\n        for (int j = 0, i = 0; j < n; j++) {\n            if (map.containsKey(s.charAt(j))) {\n                i = Math.max(map.get(s.charAt(j)), i);\n            }\n            ans = Math.max(ans, j - i + 1);\n            map.put(s.charAt(j), j + 1);\n        }\n        return ans;\n    }\n}\n", "public class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        int n = s.length(), ans = 0;\n        int[] index = new int[128]; // current index of character\n        // try to extend the range [i, j]\n        for (int j = 0, i = 0; j < n; j++) {\n            i = Math.max(index[s.charAt(j)], i);\n            ans = Math.max(ans, j - i + 1);\n            index[s.charAt(j)] = j + 1;\n        }\n        return ans;\n    }\n}\n"]}
{"number": 4, "statement": "There are two sorted arrays nums1 and nums2 of size m and n respectively.\nFind the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).\nYou may assume nums1 and nums2cannot be both empty.\n", "solutions": ["class Solution {\n    public double findMedianSortedArrays(int[] A, int[] B) {\n        int m = A.length;\n        int n = B.length;\n        if (m > n) { // to ensure m<=n\n            int[] temp = A; A = B; B = temp;\n            int tmp = m; m = n; n = tmp;\n        }\n        int iMin = 0, iMax = m, halfLen = (m + n + 1) / 2;\n        while (iMin <= iMax) {\n            int i = (iMin + iMax) / 2;\n            int j = halfLen - i;\n            if (i < iMax && B[j-1] > A[i]){\n                iMin = i + 1; // i is too small\n            }\n            else if (i > iMin && A[i-1] > B[j]) {\n                iMax = i - 1; // i is too big\n            }\n            else { // i is perfect\n                int maxLeft = 0;\n                if (i == 0) { maxLeft = B[j-1]; }\n                else if (j == 0) { maxLeft = A[i-1]; }\n                else { maxLeft = Math.max(A[i-1], B[j-1]); }\n                if ( (m + n) % 2 == 1 ) { return maxLeft; }\n                int minRight = 0;\n                if (i == m) { minRight = B[j]; }\n                else if (j == n) { minRight = A[i]; }\n                else { minRight = Math.min(B[j], A[i]); }\n                return (maxLeft + minRight) / 2.0;\n            }\n        }\n        return 0.0;\n    }\n}\n"]}
{"number": 5, "statement": "Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.\n", "solutions": ["public String longestPalindrome(String s) {\n    if (s == null || s.length() < 1) return \"\";\n    int start = 0, end = 0;\n    for (int i = 0; i < s.length(); i++) {\n        int len1 = expandAroundCenter(s, i, i);\n        int len2 = expandAroundCenter(s, i, i + 1);\n        int len = Math.max(len1, len2);\n        if (len > end - start) {\n            start = i - (len - 1) / 2;\n            end = i + len / 2;\n        }\n    }\n    return s.substring(start, end + 1);\n}\nprivate int expandAroundCenter(String s, int left, int right) {\n    int L = left, R = right;\n    while (L >= 0 && R < s.length() && s.charAt(L) == s.charAt(R)) {\n        L--;\n        R++;\n    }\n    return R - L - 1;\n}\n"]}
{"number": 6, "statement": "The string \"PAYPALISHIRING\" is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)\nP   A   H   N\nA P L S I I G\nY   I   R\nAnd then read line by line: \"PAHNAPLSIIGYIR\"\nWrite the code that will take a string and make this conversion given a number of rows:\nstring convert(string s, int numRows);\n", "solutions": ["class Solution {\npublic:\n    string convert(string s, int numRows) {\n        if (numRows == 1) return s;\n        vector<string> rows(min(numRows, int(s.size())));\n        int curRow = 0;\n        bool goingDown = false;\n        for (char c : s) {\n            rows[curRow] += c;\n            if (curRow == 0 || curRow == numRows - 1) goingDown = !goingDown;\n            curRow += goingDown ? 1 : -1;\n        }\n        string ret;\n        for (string row : rows) ret += row;\n        return ret;\n    }\n};\n", "class Solution {\npublic:\n    string convert(string s, int numRows) {\n        if (numRows == 1) return s;\n        string ret;\n        int n = s.size();\n        int cycleLen = 2 * numRows - 2;\n        for (int i = 0; i < numRows; i++) {\n            for (int j = 0; j + i < n; j += cycleLen) {\n                ret += s[j + i];\n                if (i != 0 && i != numRows - 1 && j + cycleLen - i < n)\n                    ret += s[j + cycleLen - i];\n            }\n        }\n        return ret;\n    }\n};\n"]}
{"number": 7, "statement": "Given a 32-bit signed integer, reverse digits of an integer.\n", "solutions": ["class Solution {\npublic:\n    int reverse(int x) {\n        int rev = 0;\n        while (x != 0) {\n            int pop = x % 10;\n            x /= 10;\n            if (rev > INT_MAX/10 || (rev == INT_MAX / 10 && pop > 7)) return 0;\n            if (rev < INT_MIN/10 || (rev == INT_MIN / 10 && pop < -8)) return 0;\n            rev = rev * 10 + pop;\n        }\n        return rev;\n    }\n};\n"]}
{"number": 9, "statement": "Determine whether an integer is a palindrome. An integerisapalindrome when itreads the same backward as forward.\n", "solutions": ["public class Solution {\n    public bool IsPalindrome(int x) {\n        // Special cases:\n        // As discussed above, when x < 0, x is not a palindrome.\n        // Also if the last digit of the number is 0, in order to be a palindrome,\n        // the first digit of the number also needs to be 0.\n        // Only 0 satisfy this property.\n        if(x < 0 || (x % 10 == 0 && x != 0)) {\n            return false;\n        }\n        int revertedNumber = 0;\n        while(x > revertedNumber) {\n            revertedNumber = revertedNumber * 10 + x % 10;\n            x /= 10;\n        }\n        // When the length is an odd number, we can get rid of the middle digit by revertedNumber/10\n        // For example when the input is 12321, at the end of the while loop we get x = 12, revertedNumber = 123,\n        // since the middle digit doesn't matter in palidrome(it will always equal to itself), we can simply get rid of it.\n        return x == revertedNumber || x == revertedNumber/10;\n    }\n}\n"]}
{"number": 10, "statement": "Given an input string (s) and a pattern (p), implement regular expression matching with support for '.' and '*'.\n'.' Matches any single character.\n'*' Matches zero or more of the preceding element.\nThe matching should cover the entire input string (not partial).\nNote:\nscould be empty and contains only lowercase letters a-z.\np could be empty and contains only lowercase letters a-z, and characters like.or*.\n", "solutions": ["def match(text, pattern):\n    if not pattern: return not text\n    first_match = bool(text) and pattern[0] in {text[0], '.'}\n    return first_match and match(text[1:], pattern[1:])\n", "class Solution {\n    public boolean isMatch(String text, String pattern) {\n        if (pattern.isEmpty()) return text.isEmpty();\n        boolean first_match = (!text.isEmpty() &&\n                               (pattern.charAt(0) == text.charAt(0) || pattern.charAt(0) == '.'));\n        if (pattern.length() >= 2 && pattern.charAt(1) == '*'){\n            return (isMatch(text, pattern.substring(2)) ||\n                    (first_match && isMatch(text.substring(1), pattern)));\n        } else {\n            return first_match && isMatch(text.substring(1), pattern.substring(1));\n        }\n    }\n}\n", "enum Result {\n    TRUE, FALSE\n}\nclass Solution {\n    Result[][] memo;\n    public boolean isMatch(String text, String pattern) {\n        memo = new Result[text.length() + 1][pattern.length() + 1];\n        return dp(0, 0, text, pattern);\n    }\n    public boolean dp(int i, int j, String text, String pattern) {\n        if (memo[i][j] != null) {\n            return memo[i][j] == Result.TRUE;\n        }\n        boolean ans;\n        if (j == pattern.length()){\n            ans = i == text.length();\n        } else{\n            boolean first_match = (i < text.length() &&\n                                   (pattern.charAt(j) == text.charAt(i) ||\n                                    pattern.charAt(j) == '.'));\n            if (j + 1 < pattern.length() && pattern.charAt(j+1) == '*'){\n                ans = (dp(i, j+2, text, pattern) ||\n                       first_match && dp(i+1, j, text, pattern));\n            } else {\n                ans = first_match && dp(i+1, j+1, text, pattern);\n            }\n        }\n        memo[i][j] = ans ? Result.TRUE : Result.FALSE;\n        return ans;\n    }\n}\n", "class Solution {\n    public boolean isMatch(String text, String pattern) {\n        boolean[][] dp = new boolean[text.length() + 1][pattern.length() + 1];\n        dp[text.length()][pattern.length()] = true;\n        for (int i = text.length(); i >= 0; i--){\n            for (int j = pattern.length() - 1; j >= 0; j--){\n                boolean first_match = (i < text.length() &&\n                                       (pattern.charAt(j) == text.charAt(i) ||\n                                        pattern.charAt(j) == '.'));\n                if (j + 1 < pattern.length() && pattern.charAt(j+1) == '*'){\n                    dp[i][j] = dp[i][j+2] || first_match && dp[i+1][j];\n                } else {\n                    dp[i][j] = first_match && dp[i+1][j+1];\n                }\n            }\n        }\n        return dp[0][0];\n    }\n}\n"]}
{"number": 11, "statement": "Given n non-negative integers a1, a2, ..., an, where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.\nNote:You may not slant the container and n is at least 2.\nThe above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can containis 49. \n", "solutions": ["public class Solution {\n    public int maxArea(int[] height) {\n        int maxarea = 0;\n        for (int i = 0; i < height.length; i++)\n            for (int j = i + 1; j < height.length; j++)\n                maxarea = Math.max(maxarea, Math.min(height[i], height[j]) * (j - i));\n        return maxarea;\n    }\n}\n", "public class Solution {\n    public int maxArea(int[] height) {\n        int maxarea = 0, l = 0, r = height.length - 1;\n        while (l < r) {\n            maxarea = Math.max(maxarea, Math.min(height[l], height[r]) * (r - l));\n            if (height[l] < height[r])\n                l++;\n            else\n                r--;\n        }\n        return maxarea;\n    }\n}\n"]}
{"number": 12, "statement": "Roman numerals are represented by seven different symbols:I, V, X, L, C, D and M.\nSymbol       Value\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000\nFor example,two is written as IIin Roman numeral, just two one's added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II.\nRoman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:\nI can be placed before V (5) and X (10) to make 4 and 9.\nX can be placed before L (50) and C (100) to make 40 and 90.\nC can be placed before D (500) and M (1000) to make 400 and 900.\nGiven an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999.\n", "solutions": ["int[] values = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};    \nString[] symbols = {\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\npublic String intToRoman(int num) {\n    StringBuilder sb = new StringBuilder();\n    // Loop through each symbol, stopping if num becomes 0.\n    for (int i = 0; i < values.length && num >= 0; i++) {\n        // Repeat while the current symbol still fits into num.\n        while (values[i] <= num) {\n            num -= values[i];\n            sb.append(symbols[i]);\n        }\n    }\n    return sb.toString();\n}\n", "public String intToRoman(int num) {\n    \n    String[] thousands = {\"\", \"M\", \"MM\", \"MMM\"};\n    String[] hundreds = {\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"}; \n    String[] tens = {\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"};\n    String[] ones = {\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"};\n    \n    return thousands[num / 1000] + hundreds[num % 1000 / 100] + tens[num % 100 / 10] + ones[num % 10];\n}\n"]}
{"number": 13, "statement": "Roman numerals are represented by seven different symbols:I, V, X, L, C, D and M.\nSymbol       Value\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000\nFor example,two is written as IIin Roman numeral, just two one's added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II.\nRoman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:\nI can be placed before V (5) and X (10) to make 4 and 9.\nX can be placed before L (50) and C (100) to make 40 and 90.\nC can be placed before D (500) and M (1000) to make 400 and 900.\nGiven a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999.\n", "solutions": ["class Solution {\n    \n    static Map<String, Integer> values = new HashMap<>();\n    \n    static {\n        values.put(\"M\", 1000);\n        values.put(\"D\", 500);\n        values.put(\"C\", 100);\n        values.put(\"L\", 50);\n        values.put(\"X\", 10);\n        values.put(\"V\", 5);\n        values.put(\"I\", 1);\n    }\n    public int romanToInt(String s) {\n        \n        int sum = 0;\n        int i = 0;\n        while (i < s.length()) {\n            String currentSymbol = s.substring(i, i + 1);\n            int currentValue = values.get(currentSymbol);\n            int nextValue = 0;\n            if (i + 1 < s.length()) {\n                String nextSymbol = s.substring(i + 1, i + 2);\n                nextValue = values.get(nextSymbol);\n            }\n            \n            if (currentValue < nextValue) {\n                sum += (nextValue - currentValue);\n                i += 2;\n            }\n            else {\n                sum += currentValue;\n                i += 1;\n            }\n            \n        }\n        return sum;\n    }\n}\n", "class Solution {\n    \n    static Map<String, Integer> values = new HashMap<>();\n    static {\n        values.put(\"I\", 1);\n        values.put(\"V\", 5);\n        values.put(\"X\", 10);\n        values.put(\"L\", 50);\n        values.put(\"C\", 100);\n        values.put(\"D\", 500);\n        values.put(\"M\", 1000);\n        values.put(\"IV\", 4);\n        values.put(\"IX\", 9);\n        values.put(\"XL\", 40);\n        values.put(\"XC\", 90);\n        values.put(\"CD\", 400);\n        values.put(\"CM\", 900);\n    }\n    public int romanToInt(String s) {\n        \n        int sum = 0;\n        int i = 0;\n        while (i < s.length()) {\n            if (i < s.length() - 1) {\n                String doubleSymbol = s.substring(i, i + 2);\n                // Check if this is the length-2 symbol case.\n                if (values.containsKey(doubleSymbol)) {\n                    sum += values.get(doubleSymbol);\n                    i += 2;\n                    continue;\n                }\n            }\n            // Otherwise, it must be the length-1 symbol case.\n            String singleSymbol = s.substring(i, i + 1);\n            sum += values.get(singleSymbol);\n            i += 1;\n        }\n        return sum;\n    }\n}\n", "class Solution {\n    \n    static Map<String, Integer> values = new HashMap<>();\n    \n    static {\n        values.put(\"M\", 1000);\n        values.put(\"D\", 500);\n        values.put(\"C\", 100);\n        values.put(\"L\", 50);\n        values.put(\"X\", 10);\n        values.put(\"V\", 5);\n        values.put(\"I\", 1);\n    }\n    public int romanToInt(String s) {\n        \n        String lastSymbol = s.substring(s.length() - 1);\n        int lastValue = values.get(lastSymbol);\n        int total = lastValue;\n        for (int i = s.length() - 2; i >= 0; i--) {\n            String currentSymbol = s.substring(i, i + 1);\n            int currentValue = values.get(currentSymbol);\n            if (currentValue < lastValue) {\n                total -= currentValue;\n            } else {\n                total += currentValue;\n            }\n            lastValue = currentValue;\n        }\n        return total;\n    }\n}\n"]}
{"number": 14, "statement": "Write a function to find the longest common prefix string amongst an array of strings.\nIf there is no common prefix, return an empty string \"\".\n", "solutions": [" public String longestCommonPrefix(String[] strs) {\n    if (strs.length == 0) return \"\";\n    String prefix = strs[0];\n    for (int i = 1; i < strs.length; i++)\n        while (strs[i].indexOf(prefix) != 0) {\n            prefix = prefix.substring(0, prefix.length() - 1);\n            if (prefix.isEmpty()) return \"\";\n        }        \n    return prefix;\n}\n", "public String longestCommonPrefix(String[] strs) {\n    if (strs == null || strs.length == 0) return \"\";\n    for (int i = 0; i < strs[0].length() ; i++){\n        char c = strs[0].charAt(i);\n        for (int j = 1; j < strs.length; j ++) {\n            if (i == strs[j].length() || strs[j].charAt(i) != c)\n                return strs[0].substring(0, i);             \n        }\n    }\n    return strs[0];\n}\n", "public String longestCommonPrefix(String[] strs) {\n    if (strs == null || strs.length == 0) return \"\";    \n        return longestCommonPrefix(strs, 0 , strs.length - 1);\n}\nprivate String longestCommonPrefix(String[] strs, int l, int r) {\n    if (l == r) {\n        return strs[l];\n    }\n    else {\n        int mid = (l + r)/2;\n        String lcpLeft =   longestCommonPrefix(strs, l , mid);\n        String lcpRight =  longestCommonPrefix(strs, mid + 1,r);\n        return commonPrefix(lcpLeft, lcpRight);\n   }\n}\nString commonPrefix(String left,String right) {\n    int min = Math.min(left.length(), right.length());       \n    for (int i = 0; i < min; i++) {\n        if ( left.charAt(i) != right.charAt(i) )\n            return left.substring(0, i);\n    }\n    return left.substring(0, min);\n}\n", "public String longestCommonPrefix(String[] strs) {\n    if (strs == null || strs.length == 0)\n        return \"\";\n    int minLen = Integer.MAX_VALUE;\n    for (String str : strs)\n        minLen = Math.min(minLen, str.length());\n    int low = 1;\n    int high = minLen;\n    while (low <= high) {\n        int middle = (low + high) / 2;\n        if (isCommonPrefix(strs, middle))\n            low = middle + 1;\n        else\n            high = middle - 1;\n    }\n    return strs[0].substring(0, (low + high) / 2);\n}\nprivate boolean isCommonPrefix(String[] strs, int len){\n    String str1 = strs[0].substring(0,len);\n    for (int i = 1; i < strs.length; i++)\n        if (!strs[i].startsWith(str1))\n            return false;\n    return true;\n}\n", "public String longestCommonPrefix(String q, String[] strs) {\n    if (strs == null || strs.length == 0)\n         return \"\";  \n    if (strs.length == 1)\n         return strs[0];\n    Trie trie = new Trie();      \n    for (int i = 1; i < strs.length ; i++) {\n        trie.insert(strs[i]);\n    }\n    return trie.searchLongestPrefix(q);\n}\nclass TrieNode {\n    // R links to node children\n    private TrieNode[] links;\n    private final int R = 26;\n    private boolean isEnd;\n    // number of children non null links\n    private int size;    \n    public void put(char ch, TrieNode node) {\n        links[ch -'a'] = node;\n        size++;\n    }\n    public int getLinks() {\n        return size;\n    }\n    //assume methods containsKey, isEnd, get, put are implemented as it is described\n   //in  https://leetcode.com/articles/implement-trie-prefix-tree/)\n}\npublic class Trie {\n    private TrieNode root;\n    public Trie() {\n        root = new TrieNode();\n    }\n//assume methods insert, search, searchPrefix are implemented as it is described\n//in  https://leetcode.com/articles/implement-trie-prefix-tree/)\n    private String searchLongestPrefix(String word) {\n        TrieNode node = root;\n        StringBuilder prefix = new StringBuilder();\n        for (int i = 0; i < word.length(); i++) {\n            char curLetter = word.charAt(i);\n            if (node.containsKey(curLetter) && (node.getLinks() == 1) && (!node.isEnd())) {\n                prefix.append(curLetter);\n                node = node.get(curLetter);\n            }\n            else\n                return prefix.toString();\n         }\n         return prefix.toString();\n    }\n}\n"]}
{"number": 15, "statement": "Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.\nNote:\nThe solution set must not contain duplicate triplets.\n", "solutions": ["vector<vector<int>> threeSum(vector<int>& nums) {\n    sort(begin(nums), end(nums));\n    vector<vector<int>> res;\n    for (int i = 0; i < nums.size() && nums[i] <= 0; ++i)\n        if (i == 0 || nums[i - 1] != nums[i])\n            twoSumII(nums, i, res);\n    return res;\n}\nvoid twoSumII(vector<int>& nums, int i, vector<vector<int>> &res) {\n    int lo = i + 1, hi = nums.size() - 1;\n    while (lo < hi) {\n        int sum = nums[i] + nums[lo] + nums[hi];\n        if (sum < 0 || (lo > i + 1 && nums[lo] == nums[lo - 1]))\n            ++lo;\n        else if (sum > 0 || (hi < nums.size() - 1 && nums[hi] == nums[hi + 1]))\n            --hi;\n        else\n            res.push_back({ nums[i], nums[lo++], nums[hi--]});\n    }\n}\n", "vector<vector<int>> threeSum(vector<int>& nums) {\n    vector<vector<int>> res;\n    set<pair<int, int>> found; // or define hash<pair<int, int>> and use unordered_set.\n    for (int i = 0; i < nums.size(); ++i) {\n        unordered_set<int> seen;\n        for (int j = i + 1; j < nums.size(); ++j) {\n            int complement = -nums[i] - nums[j];\n            if (seen.count(complement)) {\n                int v1 = min(nums[i], min(complement, nums[j]));\n                int v2 = max(nums[i], max(complement, nums[j]));\n                if (found.insert({v1, v2}).second)\n                    res.push_back({nums[i], complement, nums[j]});\n            }\n            seen.insert(nums[j]);\n        }\n    }\n    return res;\n}\n", "vector<vector<int>> threeSum(vector<int>& nums) {\n    vector<vector<int>> res;\n    set<pair<int, int>> found; // or define hash<pair<int, int>> and use unordered_set.\n    unordered_set<int> dups;\n    unordered_map<int, int> seen;\n    for (int i = 0; i < nums.size(); ++i)\n        if (dups.insert(nums[i]).second)\n            for (int j = i + 1; j < nums.size(); ++j) {\n                int complement = -nums[i] - nums[j];\n                auto it = seen.find(complement);\n                if (it != end(seen) && it->second == i) {\n                    int v1 = min(nums[i], min(complement, nums[j]));\n                    int v2 = max(nums[i], max(complement, nums[j]));\n                    if (found.insert({v1, v2}).second)\n                        res.push_back({nums[i], complement, nums[j]});\n                }\n                seen[nums[j]] = i;\n            }\n    return res;\n}\n"]}
{"number": 16, "statement": "Given an array nums of n integers and an integer target, find three integers in numssuch that the sum is closest totarget. Return the sum of the three integers. You may assume that each input would have exactly one solution.\n", "solutions": ["int threeSumClosest(vector<int>& nums, int target) {\n    int diff = INT_MAX, sz = nums.size();\n    sort(begin(nums), end(nums));\n    for (int i = 0; i < sz; ++i) {\n        int lo = i + 1, hi = sz - 1;\n        while (lo < hi) {\n            int sum = nums[i] + nums[lo] + nums[hi];\n            if (abs(target - sum) < abs(diff))\n                diff = target - sum;\n            if (sum < target)\n                ++lo;\n            else\n                --hi;\n        }\n        if (diff == 0 || target <= nums[i])\n            break;\n    }\n    return target - diff;\n}\n", "int threeSumClosest(vector<int>& nums, int target) {\n    int diff = INT_MAX, sz = nums.size();\n    sort(begin(nums), end(nums));\n    for (int i = 0; i < sz; ++i) {\n        for (int j = i + 1; j < sz - 1; ++j) {\n            int complement = target - nums[i] - nums[j];\n            auto it = upper_bound(begin(nums) + j + 1, end(nums), complement);\n            int hi = it - begin(nums), lo = hi - 1;\n            if (hi < sz && abs(complement - nums[hi]) < abs(diff))\n                diff = complement - nums[hi];\n            if (lo > j && abs(complement - nums[lo]) < abs(diff))\n                diff = complement - nums[lo];\n        }\n        if (diff == 0 || target <= nums[i])\n            break;\n    }\n    return target - diff;\n}\n"]}
{"number": 17, "statement": "Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent.\nA mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.\n", "solutions": ["class Solution {\n  Map<String, String> phone = new HashMap<String, String>() {{\n    put(\"2\", \"abc\");\n    put(\"3\", \"def\");\n    put(\"4\", \"ghi\");\n    put(\"5\", \"jkl\");\n    put(\"6\", \"mno\");\n    put(\"7\", \"pqrs\");\n    put(\"8\", \"tuv\");\n    put(\"9\", \"wxyz\");\n  }};\n  List<String> output = new ArrayList<String>();\n  public void backtrack(String combination, String next_digits) {\n    // if there is no more digits to check\n    if (next_digits.length() == 0) {\n      // the combination is done\n      output.add(combination);\n    }\n    // if there are still digits to check\n    else {\n      // iterate over all letters which map \n      // the next available digit\n      String digit = next_digits.substring(0, 1);\n      String letters = phone.get(digit);\n      for (int i = 0; i < letters.length(); i++) {\n        String letter = phone.get(digit).substring(i, i + 1);\n        // append the current letter to the combination\n        // and proceed to the next digits\n        backtrack(combination + letter, next_digits.substring(1));\n      }\n    }\n  }\n  public List<String> letterCombinations(String digits) {\n    if (digits.length() != 0)\n      backtrack(\"\", digits);\n    return output;\n  }\n}\n"]}
{"number": 19, "statement": "Given a linked list, remove the n-th node from the end of list and return its head.\n", "solutions": ["public ListNode removeNthFromEnd(ListNode head, int n) {\n    ListNode dummy = new ListNode(0);\n    dummy.next = head;\n    int length  = 0;\n    ListNode first = head;\n    while (first != null) {\n        length++;\n        first = first.next;\n    }\n    length -= n;\n    first = dummy;\n    while (length > 0) {\n        length--;\n        first = first.next;\n    }\n    first.next = first.next.next;\n    return dummy.next;\n}\n", "public ListNode removeNthFromEnd(ListNode head, int n) {\n    ListNode dummy = new ListNode(0);\n    dummy.next = head;\n    ListNode first = dummy;\n    ListNode second = dummy;\n    // Advances first pointer so that the gap between first and second is n nodes apart\n    for (int i = 1; i <= n + 1; i++) {\n        first = first.next;\n    }\n    // Move first to the end, maintaining the gap\n    while (first != null) {\n        first = first.next;\n        second = second.next;\n    }\n    second.next = second.next.next;\n    return dummy.next;\n}\n"]}
{"number": 20, "statement": "Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.\nAn input string is valid if:\nOpen brackets must be closed by the same type of brackets.\nOpen brackets must be closed in the correct order.\nNote that an empty string isalso considered valid.\n", "solutions": ["class Solution {\n  // Hash table that takes care of the mappings.\n  private HashMap<Character, Character> mappings;\n  // Initialize hash map with mappings. This simply makes the code easier to read.\n  public Solution() {\n    this.mappings = new HashMap<Character, Character>();\n    this.mappings.put(')', '(');\n    this.mappings.put('}', '{');\n    this.mappings.put(']', '[');\n  }\n  public boolean isValid(String s) {\n    // Initialize a stack to be used in the algorithm.\n    Stack<Character> stack = new Stack<Character>();\n    for (int i = 0; i < s.length(); i++) {\n      char c = s.charAt(i);\n      // If the current character is a closing bracket.\n      if (this.mappings.containsKey(c)) {\n        // Get the top element of the stack. If the stack is empty, set a dummy value of '#'\n        char topElement = stack.empty() ? '#' : stack.pop();\n        // If the mapping for this bracket doesn't match the stack's top element, return false.\n        if (topElement != this.mappings.get(c)) {\n          return false;\n        }\n      } else {\n        // If it was an opening bracket, push to the stack.\n        stack.push(c);\n      }\n    }\n    // If the stack still contains elements, then it is an invalid expression.\n    return stack.isEmpty();\n  }\n}\n"]}
{"number": 21, "statement": "Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.\n", "solutions": ["class Solution {\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n        if (l1 == null) {\n            return l2;\n        }\n        else if (l2 == null) {\n            return l1;\n        }\n        else if (l1.val < l2.val) {\n            l1.next = mergeTwoLists(l1.next, l2);\n            return l1;\n        }\n        else {\n            l2.next = mergeTwoLists(l1, l2.next);\n            return l2;\n        }\n    }\n}\n", "class Solution {\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n        // maintain an unchanging reference to node ahead of the return node.\n        ListNode prehead = new ListNode(-1);\n        ListNode prev = prehead;\n        while (l1 != null && l2 != null) {\n            if (l1.val <= l2.val) {\n                prev.next = l1;\n                l1 = l1.next;\n            } else {\n                prev.next = l2;\n                l2 = l2.next;\n            }\n            prev = prev.next;\n        }\n        // exactly one of l1 and l2 can be non-null at this point, so connect\n        // the non-null list to the end of the merged list.\n        prev.next = l1 == null ? l2 : l1;\n        return prehead.next;\n    }\n}\n"]}
{"number": 22, "statement": "Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.\nFor example, given n = 3, a solution set is:\n[\n  \"((()))\",\n  \"(()())\",\n  \"(())()\",\n  \"()(())\",\n  \"()()()\"\n]\n", "solutions": ["class Solution {\n    public List<String> generateParenthesis(int n) {\n        List<String> combinations = new ArrayList();\n        generateAll(new char[2 * n], 0, combinations);\n        return combinations;\n    }\n    public void generateAll(char[] current, int pos, List<String> result) {\n        if (pos == current.length) {\n            if (valid(current))\n                result.add(new String(current));\n        } else {\n            current[pos] = '(';\n            generateAll(current, pos+1, result);\n            current[pos] = ')';\n            generateAll(current, pos+1, result);\n        }\n    }\n    public boolean valid(char[] current) {\n        int balance = 0;\n        for (char c: current) {\n            if (c == '(') balance++;\n            else balance--;\n            if (balance < 0) return false;\n        }\n        return (balance == 0);\n    }\n}\ndef generateParenthesis(self, N):\n    if N == 0: return ['']\n    ans = []\n    for c in xrange(N):\n        for left in self.generateParenthesis(c):\n            for right in self.generateParenthesis(N-1-c):\n                ans.append('({}){}'.format(left, right))\n    return ans\n", "class Solution {\n    public List<String> generateParenthesis(int n) {\n        List<String> ans = new ArrayList();\n        backtrack(ans, \"\", 0, 0, n);\n        return ans;\n    }\n    public void backtrack(List<String> ans, String cur, int open, int close, int max){\n        if (cur.length() == max * 2) {\n            ans.add(cur);\n            return;\n        }\n        if (open < max)\n            backtrack(ans, cur+\"(\", open+1, close, max);\n        if (close < open)\n            backtrack(ans, cur+\")\", open, close+1, max);\n    }\n}\n", "class Solution {\n    public List<String> generateParenthesis(int n) {\n        List<String> ans = new ArrayList();\n        if (n == 0) {\n            ans.add(\"\");\n        } else {\n            for (int c = 0; c < n; ++c)\n                for (String left: generateParenthesis(c))\n                    for (String right: generateParenthesis(n-1-c))\n                        ans.add(\"(\" + left + \")\" + right);\n        }\n        return ans;\n    }\n}\n"]}
{"number": 23, "statement": "Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.\n", "solutions": ["class Solution(object):\n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        self.nodes = []\n        head = point = ListNode(0)\n        for l in lists:\n            while l:\n                self.nodes.append(l.val)\n                l = l.next\n        for x in sorted(self.nodes):\n            point.next = ListNode(x)\n            point = point.next\n        return head.next\n", "from Queue import PriorityQueue\nclass Solution(object):\n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        head = point = ListNode(0)\n        q = PriorityQueue()\n        for l in lists:\n            if l:\n                q.put((l.val, l))\n        while not q.empty():\n            val, node = q.get()\n            point.next = ListNode(val)\n            point = point.next\n            node = node.next\n            if node:\n                q.put((node.val, node))\n        return head.next\n", "class Solution(object):\n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        amount = len(lists)\n        interval = 1\n        while interval < amount:\n            for i in range(0, amount - interval, interval * 2):\n                lists[i] = self.merge2Lists(lists[i], lists[i + interval])\n            interval *= 2\n        return lists[0] if amount > 0 else lists\n    def merge2Lists(self, l1, l2):\n        head = point = ListNode(0)\n        while l1 and l2:\n            if l1.val <= l2.val:\n                point.next = l1\n                l1 = l1.next\n            else:\n                point.next = l2\n                l2 = l1\n                l1 = point.next.next\n            point = point.next\n        if not l1:\n            point.next=l2\n        else:\n            point.next=l1\n        return head.next\n"]}
{"number": 24, "statement": "Given alinked list, swap every two adjacent nodes and return its head.\nYou may not modify the values in the list's nodes, only nodes itself may be changed.\n", "solutions": ["/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        // If the list has no node or has only one node left.\n        if ((head == null) || (head.next == null)) {\n            return head;\n        }\n        // Nodes to be swapped\n        ListNode firstNode = head;\n        ListNode secondNode = head.next;\n        // Swapping\n        firstNode.next  = swapPairs(secondNode.next);\n        secondNode.next = firstNode;\n        // Now the head is the second node\n        return secondNode;\n    }\n}\n", "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        // Dummy node acts as the prevNode for the head node\n        // of the list and hence stores pointer to the head node.\n        ListNode dummy = new ListNode(-1);\n        dummy.next = head;\n        ListNode prevNode = dummy;\n        while ((head != null) && (head.next != null)) {\n            // Nodes to be swapped\n            ListNode firstNode = head;\n            ListNode secondNode = head.next;\n            // Swapping\n            prevNode.next = secondNode;\n            firstNode.next = secondNode.next;\n            secondNode.next = firstNode;\n            // Reinitializing the head and prevNode for next swap\n            prevNode = firstNode;\n            head = firstNode.next; // jump\n        }\n        // Return the new head node.\n        return dummy.next;\n    }\n}\n"]}
{"number": 25, "statement": "Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.\nk is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.\n", "solutions": ["/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    \n    public ListNode reverseLinkedList(ListNode head, int k) {\n        \n        // Reverse k nodes of the given linked list.\n        // This function assumes that the list contains \n        // atleast k nodes.\n        ListNode new_head = null;\n        ListNode ptr = head;\n        \n        while (k > 0) {\n            \n            // Keep track of the next node to process in the\n            // original list\n            ListNode next_node = ptr.next;\n            \n            // Insert the node pointed to by \"ptr\"\n            // at the beginning of the reversed list\n            ptr.next = new_head;\n            new_head = ptr;\n            \n            // Move on to the next node\n            ptr = next_node;\n            \n            // Decrement the count of nodes to be reversed by 1\n            k--;\n        }\n            \n            \n        // Return the head of the reversed list\n        return new_head;\n    \n    }\n            \n    public ListNode reverseKGroup(ListNode head, int k) {\n        \n        int count = 0;\n        ListNode ptr = head;\n        \n        // First, see if there are atleast k nodes\n        // left in the linked list.\n        while (count < k && ptr != null) {\n            ptr = ptr.next;\n            count++;\n        }\n            \n        \n        // If we have k nodes, then we reverse them\n        if (count == k) {\n            \n            // Reverse the first k nodes of the list and\n            // get the reversed list's head.\n            ListNode reversedHead = this.reverseLinkedList(head, k);\n            \n            // Now recurse on the remaining linked list. Since\n            // our recursion returns the head of the overall processed\n            // list, we use that and the \"original\" head of the \"k\" nodes\n            // to re-wire the connections.\n            head.next = this.reverseKGroup(ptr, k);\n            return reversedHead;\n        }\n            \n        return head;\n    }\n}\n", "class Solution {\n    \n    public ListNode reverseLinkedList(ListNode head, int k) {\n        \n        // Reverse k nodes of the given linked list.\n        // This function assumes that the list contains \n        // atleast k nodes.\n        ListNode new_head = null;\n        ListNode ptr = head;\n        \n        while (k > 0) {\n            \n            // Keep track of the next node to process in the\n            // original list\n            ListNode next_node = ptr.next;\n            \n            // Insert the node pointed to by \"ptr\"\n            // at the beginning of the reversed list\n            ptr.next = new_head;\n            new_head = ptr;\n            \n            // Move on to the next node\n            ptr = next_node;\n            \n            // Decrement the count of nodes to be reversed by 1\n            k--;\n        }\n            \n            \n        // Return the head of the reversed list\n        return new_head;\n    \n    }\n            \n    public ListNode reverseKGroup(ListNode head, int k) {\n        \n        ListNode ptr = head;\n        ListNode ktail = null;\n        \n        // Head of the final, moified linked list\n        ListNode new_head = null;\n        \n        // Keep going until there are nodes in the list\n        while (ptr != null) {\n            \n            int count = 0;\n            \n            // Start counting nodes from the head\n            ptr = head;\n            \n            // Find the head of the next k nodes\n            while (count < k && ptr != null) {\n                ptr = ptr.next;\n                count += 1;\n            }\n            // If we counted k nodes, reverse them        \n            if (count == k) {\n                \n                // Reverse k nodes and get the new head\n                ListNode revHead = this.reverseLinkedList(head, k);\n                \n                // new_head is the head of the final linked list\n                if (new_head == null)\n                    new_head = revHead;\n                \n                // ktail is the tail of the previous block of \n                // reversed k nodes\n                if (ktail != null)\n                    ktail.next = revHead;\n                    \n                ktail = head; \n                head = ptr;\n            }\n        }\n            \n         // attach the final, possibly un-reversed portion\n        if (ktail != null)\n            ktail.next = head;\n        \n        return new_head == null ? head : new_head;\n    }\n}\n"]}
{"number": 26, "statement": "Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length.\nDo not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.\n", "solutions": ["public int removeDuplicates(int[] nums) {\n    if (nums.length == 0) return 0;\n    int i = 0;\n    for (int j = 1; j < nums.length; j++) {\n        if (nums[j] != nums[i]) {\n            i++;\n            nums[i] = nums[j];\n        }\n    }\n    return i + 1;\n}\n"]}
{"number": 27, "statement": "Given an array nums and a value val, remove all instances of that value in-place and return the new length.\nDo not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.\nThe order of elements can be changed. It doesn't matter what you leave beyond the new length.\n", "solutions": ["public int removeElement(int[] nums, int val) {\n    int i = 0;\n    for (int j = 0; j < nums.length; j++) {\n        if (nums[j] != val) {\n            nums[i] = nums[j];\n            i++;\n        }\n    }\n    return i;\n}\n", "public int removeElement(int[] nums, int val) {\n    int i = 0;\n    int n = nums.length;\n    while (i < n) {\n        if (nums[i] == val) {\n            nums[i] = nums[n - 1];\n            // reduce array size by one\n            n--;\n        } else {\n            i++;\n        }\n    }\n    return n;\n}\n"]}
{"number": 28, "statement": "Implement strStr().\nReturn the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.\n", "solutions": ["class Solution {\n  public int strStr(String haystack, String needle) {\n    int L = needle.length(), n = haystack.length();\n    for (int start = 0; start < n - L + 1; ++start) {\n      if (haystack.substring(start, start + L).equals(needle)) {\n        return start;\n      }\n    }\n    return -1;\n  }\n}\n", "class Solution {\n  public int strStr(String haystack, String needle) {\n    int L = needle.length(), n = haystack.length();\n    if (L == 0) return 0;\n    int pn = 0;\n    while (pn < n - L + 1) {\n      // find the position of the first needle character\n      // in the haystack string\n      while (pn < n - L + 1 && haystack.charAt(pn) != needle.charAt(0)) ++pn;\n      // compute the max match string\n      int currLen = 0, pL = 0;\n      while (pL < L && pn < n && haystack.charAt(pn) == needle.charAt(pL)) {\n        ++pn;\n        ++pL;\n        ++currLen;\n      }\n      // if the whole needle string is found,\n      // return its start position\n      if (currLen == L) return pn - L;\n      // otherwise, backtrack\n      pn = pn - currLen + 1;\n    }\n    return -1;\n  }\n}\n", "class Solution {\n  // function to convert character to integer\n  public int charToInt(int idx, String s) {\n    return (int)s.charAt(idx) - (int)'a';\n  }\n  public int strStr(String haystack, String needle) {\n    int L = needle.length(), n = haystack.length();\n    if (L > n) return -1;\n    // base value for the rolling hash function\n    int a = 26;\n    // modulus value for the rolling hash function to avoid overflow\n    long modulus = (long)Math.pow(2, 31);\n    // compute the hash of strings haystack[:L], needle[:L]\n    long h = 0, ref_h = 0;\n    for (int i = 0; i < L; ++i) {\n      h = (h * a + charToInt(i, haystack)) % modulus;\n      ref_h = (ref_h * a + charToInt(i, needle)) % modulus;\n    }\n    if (h == ref_h) return 0;\n    // const value to be used often : a**L % modulus\n    long aL = 1;\n    for (int i = 1; i <= L; ++i) aL = (aL * a) % modulus;\n    for (int start = 1; start < n - L + 1; ++start) {\n      // compute rolling hash in O(1) time\n      h = (h * a - charToInt(start - 1, haystack) * aL\n              + charToInt(start + L - 1, haystack)) % modulus;\n      if (h == ref_h) return start;\n    }\n    return -1;\n  }\n}\n"]}
{"number": 29, "statement": "Given two integers dividend and divisor, divide two integers without using multiplication, division and mod operator.\nReturn the quotient after dividing dividend by divisor.\nThe integer division should truncate toward zero, which means losing its fractional part. For example, truncate(8.345) = 8 and truncate(-2.7335) = -2.\n", "solutions": ["int divide(int dividend, int divisor) {\n    // Special case: overflow.\n    if (dividend == INT_MIN && divisor == -1) {\n        return INT_MAX;\n    }\n    /* We need to convert both numbers to negatives\n     * for the reasons explained above.\n     * Also, we count the number of negatives signs. */\n    int negatives = 2;\n    if (dividend > 0) {\n        negatives--;\n        dividend = -dividend;\n    }\n    if (divisor > 0) {\n        negatives--;\n        divisor = -divisor;\n    }\n    /* Count how many times the divisor has to be added\n     * to get the dividend. This is the quotient. */\n    int quotient = 0;\n    while (dividend - divisor <= 0) {\n        dividend -= divisor;\n        quotient--;\n    }\n    /* If there was originally one negative sign, then\n     * the quotient remains negative. Otherwise, switch\n     * it to positive. */\n    if (negatives != 1) {\n        return -quotient;\n    }\n    return quotient;\n}\n", "int HALF_INT_MIN = -1073741824;\nint divide(int dividend, int divisor) {\n    // Special case: overflow.\n    if (dividend == INT_MIN && divisor == -1) {\n        return INT_MAX;\n    }\n    /* We need to convert both numbers to negatives.\n     * Also, we count the number of negatives signs. */\n    int negatives = 2;\n    if (dividend > 0) {\n        negatives--;\n        dividend = -dividend;\n    }\n    if (divisor > 0) {\n        negatives--;\n        divisor = -divisor;\n    }\n    int quotient = 0;\n    /* Once the divisor is bigger than the current dividend,\n     * we can't fit any more copies of the divisor into it. */\n    while (divisor >= dividend) {\n        /* We know it'll fit at least once as divivend >= divisor.\n         * Note: We use a negative powerOfTwo as it's possible we might have\n         * the case divide(INT_MIN, -1). */\n        int powerOfTwo = -1;\n        int value = divisor;\n        /* Check if double the current value is too big. If not, continue doubling.\n        * If it is too big, stop doubling and continue with the next step */\n        while (value >= HALF_INT_MIN && value + value >= dividend) {\n            value += value;\n            powerOfTwo += powerOfTwo;\n        }\n        // We have been able to subtract divisor another powerOfTwo times.\n        quotient += powerOfTwo;\n        // Remove value so far so that we can continue the process with remainder.\n        dividend -= value;\n    }\n    /* If there was originally one negative sign, then\n     * the quotient remains negative. Otherwise, switch\n     * it to positive. */\n    if (negatives != 1) {\n        quotient = -quotient;\n    }\n    return quotient;\n}\n", "int HALF_INT_MIN = -1073741824;\nint divide(int dividend, int divisor) {\n    // Special case: overflow.\n    if (dividend == INT_MIN && divisor == -1) {\n        return INT_MAX;\n    }\n    /* We need to convert both numbers to negatives.\n     * Also, we count the number of negatives signs. */\n    int negatives = 2;\n    if (dividend > 0) {\n        negatives--;\n        dividend = -dividend;\n    }\n    if (divisor > 0) {\n        negatives--;\n        divisor = -divisor;\n    }\n    std::vector<int> doubles;\n    std::vector<int> powersOfTwo;\n    /* Nothing too exciting here, we're just making a list of doubles of 1 and\n     * the divisor. This is pretty much the same as Approach 2, except we're\n     * actually storing the values this time. */\n    int powerOfTwo = -1;\n    while (divisor >= dividend) {\n        doubles.push_back(divisor);\n        powersOfTwo.push_back(powerOfTwo);\n        // Prevent needless overflows from occurring...\n        if (divisor < HALF_INT_MIN) {\n            break;\n        }\n        divisor += divisor;\n        powerOfTwo += powerOfTwo;\n    }\n    int quotient = 0;\n    /* Go from largest double to smallest, checking if the current double fits.\n     * into the remainder of the dividend */\n    for (int i = doubles.size() - 1; i >= 0; i--) {\n        if (doubles[i] >= dividend) {\n            // If it does fit, add the current powerOfTwo to the quotient.\n            quotient += powersOfTwo[i];\n            // Update dividend to take into account the bit we've now removed.\n            dividend -= doubles[i];\n        }\n    }\n    /* If there was originally one negative sign, then\n     * the quotient remains negative. Otherwise, switch\n     * it to positive. */\n    if (negatives != 1) {\n        return -quotient;\n    }\n    return quotient;\n}\n", "int HALF_INT_MIN = -1073741824;\nint divide(int dividend, int divisor) {\n    // Special case: overflow.\n    if (dividend == INT_MIN && divisor == -1) {\n        return INT_MAX;\n    }\n    /* We need to convert both numbers to negatives.\n     * Also, we count the number of negatives signs. */\n    int negatives = 2;\n    if (dividend > 0) {\n        negatives--;\n        dividend = -dividend;\n    }\n    if (divisor > 0) {\n        negatives--;\n        divisor = -divisor;\n    }\n     /* In the first loop, we simply find the largest double of divisor. This is\n     * very similar to the start of what we did in Approach 2.\n     * The >= is because we're working in negatives. In essence, that\n     * piece of code is checking that we're still nearer to 0 than we\n     * are to INT_MIN. */\n    int highestDouble = divisor;\n    int highestPowerOfTwo = -1;\n    while (highestDouble >= HALF_INT_MIN && dividend <= highestDouble + highestDouble) {\n        highestPowerOfTwo += highestPowerOfTwo;\n        highestDouble += highestDouble;\n    }\n    /* In the second loop, we work out which powers of two fit in, by\n     * halving highestDouble and highestPowerOfTwo repeatedly.\n     * We can do this using bit shifting so that we don't break the\n     * rules of the question :-) */\n    int quotient = 0;\n    while (dividend <= divisor) {\n        if (dividend <= highestDouble) {\n            quotient += highestPowerOfTwo;\n            dividend -= highestDouble;\n        }\n        /* We know that these are always even, so no need to worry about the\n         * annoying \"bit-shift-odd-negative-number\" case. */\n        highestPowerOfTwo >>= 1;\n        highestDouble >>= 1;\n    }\n    /* If there was originally one negative sign, then\n     * the quotient remains negative. Otherwise, switch\n     * it to positive. */\n    if (negatives != 1) {\n        return -quotient;\n    }\n    return quotient;\n}\n", "int HALF_INT_MIN = -1073741824;\nint divide(int dividend, int divisor) {\n    // Special cases: overflow.\n    if (dividend == INT_MIN && divisor == -1) {\n        return INT_MAX;\n    }\n    if (dividend == INT_MIN && divisor == 1) {\n        return INT_MIN;\n    }\n    /* We need to convert both numbers to negatives.\n     * Also, we count the number of negatives signs. */\n    int negatives = 2;\n    if (dividend > 0) {\n        negatives--;\n        dividend = -dividend;\n    }\n    if (divisor > 0) {\n        negatives--;\n        divisor = -divisor;\n    }\n    /* We want to find the largest doubling of the divisor in the negative 32-bit\n     * integer range that could fit into the dividend.\n     * Note if it would cause an overflow by being less than HALF_INT_MIN,\n     * then we just stop as we know double it would not fit into INT_MIN anyway. */\n    int maxBit = 0;\n    while (divisor >= HALF_INT_MIN && divisor + divisor >= dividend) {\n        maxBit += 1;\n        divisor += divisor;\n    }\n    int quotient = 0;\n    /* We start from the biggest bit and shift our divisor to the right\n     * until we can't shift it any further */\n    for (int bit = maxBit; bit >= 0; bit--) {\n        /* If the divisor fits into the dividend, then we should set the current\n         * bit to 1. We can do this by subtracting a 1 shifted by the appropriate\n         * number of bits. */\n        if (divisor >= dividend) {\n            quotient -= (1 << bit);\n            /* Remove the current divisor from the dividend, as we've now\n             * considered this part. */\n            dividend -= divisor;\n        }\n        /* Shift the divisor to the right so that it's in the right place\n         * for the next positon we're checking at. */\n        divisor = (divisor + 1) >> 1;\n    }\n    /* If there was originally one negative sign, then\n     * the quotient remains negative. Otherwise, switch\n     * it to positive. */\n    if (negatives != 1) {\n        quotient = -quotient;\n    }\n    return quotient;\n}\n"]}
{"number": 31, "statement": "Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.\nIf such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).\nThe replacement must be in-place and use only constantextra memory.\nHere are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.\n1,2,3 \u2192 1,3,2\n3,2,1 \u2192 1,2,3\n1,1,5 \u2192 1,5,1\n", "solutions": ["public class Solution {\n    public void nextPermutation(int[] nums) {\n        int i = nums.length - 2;\n        while (i >= 0 && nums[i + 1] <= nums[i]) {\n            i--;\n        }\n        if (i >= 0) {\n            int j = nums.length - 1;\n            while (j >= 0 && nums[j] <= nums[i]) {\n                j--;\n            }\n            swap(nums, i, j);\n        }\n        reverse(nums, i + 1);\n    }\n    private void reverse(int[] nums, int start) {\n        int i = start, j = nums.length - 1;\n        while (i < j) {\n            swap(nums, i, j);\n            i++;\n            j--;\n        }\n    }\n    private void swap(int[] nums, int i, int j) {\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }\n}\n"]}
{"number": 32, "statement": "Given a string containing just the characters '(' and ')', find the length of the longest valid (well-formed) parentheses substring.\n", "solutions": ["public class Solution {\n    public boolean isValid(String s) {\n        Stack<Character> stack = new Stack<Character>();\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == '(') {\n                stack.push('(');\n            } else if (!stack.empty() && stack.peek() == '(') {\n                stack.pop();\n            } else {\n                return false;\n            }\n        }\n        return stack.empty();\n    }\n    public int longestValidParentheses(String s) {\n        int maxlen = 0;\n        for (int i = 0; i < s.length(); i++) {\n            for (int j = i + 2; j <= s.length(); j+=2) {\n                if (isValid(s.substring(i, j))) {\n                    maxlen = Math.max(maxlen, j - i);\n                }\n            }\n        }\n        return maxlen;\n    }\n}\n", "public class Solution {\n    public int longestValidParentheses(String s) {\n        int maxans = 0;\n        int dp[] = new int[s.length()];\n        for (int i = 1; i < s.length(); i++) {\n            if (s.charAt(i) == ')') {\n                if (s.charAt(i - 1) == '(') {\n                    dp[i] = (i >= 2 ? dp[i - 2] : 0) + 2;\n                } else if (i - dp[i - 1] > 0 && s.charAt(i - dp[i - 1] - 1) == '(') {\n                    dp[i] = dp[i - 1] + ((i - dp[i - 1]) >= 2 ? dp[i - dp[i - 1] - 2] : 0) + 2;\n                }\n                maxans = Math.max(maxans, dp[i]);\n            }\n        }\n        return maxans;\n    }\n}\n", "public class Solution {\n    public int longestValidParentheses(String s) {\n        int maxans = 0;\n        Stack<Integer> stack = new Stack<>();\n        stack.push(-1);\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == '(') {\n                stack.push(i);\n            } else {\n                stack.pop();\n                if (stack.empty()) {\n                    stack.push(i);\n                } else {\n                    maxans = Math.max(maxans, i - stack.peek());\n                }\n            }\n        }\n        return maxans;\n    }\n}\n", "public class Solution {\n    public int longestValidParentheses(String s) {\n        int left = 0, right = 0, maxlength = 0;\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == '(') {\n                left++;\n            } else {\n                right++;\n            }\n            if (left == right) {\n                maxlength = Math.max(maxlength, 2 * right);\n            } else if (right >= left) {\n                left = right = 0;\n            }\n        }\n        left = right = 0;\n        for (int i = s.length() - 1; i >= 0; i--) {\n            if (s.charAt(i) == '(') {\n                left++;\n            } else {\n                right++;\n            }\n            if (left == right) {\n                maxlength = Math.max(maxlength, 2 * left);\n            } else if (left >= right) {\n                left = right = 0;\n            }\n        }\n        return maxlength;\n    }\n}\n"]}
{"number": 33, "statement": "Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.\n(i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]).\nYou are given a target value to search. If found in the array return its index, otherwise return -1.\nYou may assume no duplicate exists in the array.\nYour algorithm's runtime complexity must be in the order ofO(logn).\n", "solutions": ["class Solution {\n  int [] nums;\n  int target;\n  public int find_rotate_index(int left, int right) {\n    if (nums[left] < nums[right])\n      return 0;\n    while (left <= right) {\n      int pivot = (left + right) / 2;\n      if (nums[pivot] > nums[pivot + 1])\n        return pivot + 1;\n      else {\n        if (nums[pivot] < nums[left])\n          right = pivot - 1;\n        else\n          left = pivot + 1;\n      }\n    }\n    return 0;\n  }\n  public int search(int left, int right) {\n    /*\n    Binary search\n    */\n    while (left <= right) {\n      int pivot = (left + right) / 2;\n      if (nums[pivot] == target)\n        return pivot;\n      else {\n        if (target < nums[pivot])\n          right = pivot - 1;\n        else\n          left = pivot + 1;\n      }\n    }\n    return -1;\n  }\n  public int search(int[] nums, int target) {\n    this.nums = nums;\n    this.target = target;\n    int n = nums.length;\n    if (n == 0)\n      return -1;\n    if (n == 1)\n      return this.nums[0] == target ? 0 : -1;\n    int rotate_index = find_rotate_index(0, n - 1);\n    // if target is the smallest element\n    if (nums[rotate_index] == target)\n      return rotate_index;\n    // if array is not rotated, search in the entire array\n    if (rotate_index == 0)\n      return search(0, n - 1);\n    if (target < nums[0])\n      // search in the right side\n      return search(rotate_index, n - 1);\n    // search in the left side\n    return search(0, rotate_index);\n  }\n}\n", "class Solution {\n  public int search(int[] nums, int target) {\n    int start = 0, end = nums.length - 1;\n    while (start <= end) {\n      int mid = start + (end - start) / 2;\n      if (nums[mid] == target) return mid;\n      else if (nums[mid] >= nums[start]) {\n        if (target >= nums[start] && target < nums[mid]) end = mid - 1;\n        else start = mid + 1;\n      }\n      else {\n        if (target <= nums[end] && target > nums[mid]) start = mid + 1;\n        else end = mid - 1;\n      }\n    }\n    return -1;\n  }\n}\n"]}
{"number": 34, "statement": "Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value.\nYour algorithm's runtime complexity must be in the order of O(log n).\nIf the target is not found in the array, return [-1, -1].\n", "solutions": ["class Solution {\n    public int[] searchRange(int[] nums, int target) {\n        int[] targetRange = {-1, -1};\n        // find the index of the leftmost appearance of `target`.\n        for (int i = 0; i < nums.length; i++) {\n            if (nums[i] == target) {\n                targetRange[0] = i;\n                break;\n            }\n        }\n        // if the last loop did not find any index, then there is no valid range\n        // and we return [-1, -1].\n        if (targetRange[0] == -1) {\n            return targetRange;\n        }\n        // find the index of the rightmost appearance of `target` (by reverse\n        // iteration). it is guaranteed to appear.\n        for (int j = nums.length-1; j >= 0; j--) {\n            if (nums[j] == target) {\n                targetRange[1] = j;\n                break;\n            }\n        }\n        return targetRange;\n    }\n}\n", "class Solution {\n    // returns leftmost (or rightmost) index at which `target` should be\n    // inserted in sorted array `nums` via binary search.\n    private int extremeInsertionIndex(int[] nums, int target, boolean left) {\n        int lo = 0;\n        int hi = nums.length;\n        while (lo < hi) {\n            int mid = (lo + hi) / 2;\n            if (nums[mid] > target || (left && target == nums[mid])) {\n                hi = mid;\n            }\n            else {\n                lo = mid+1;\n            }\n        }\n        return lo;\n    }\n    public int[] searchRange(int[] nums, int target) {\n        int[] targetRange = {-1, -1};\n        int leftIdx = extremeInsertionIndex(nums, target, true);\n        // assert that `leftIdx` is within the array bounds and that `target`\n        // is actually in `nums`.\n        if (leftIdx == nums.length || nums[leftIdx] != target) {\n            return targetRange;\n        }\n        targetRange[0] = leftIdx;\n        targetRange[1] = extremeInsertionIndex(nums, target, false)-1;\n        return targetRange;\n    }\n}\n"]}
{"number": 35, "statement": "Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.\nYou may assume no duplicates in the array.\n", "solutions": ["pivot = left + (right - left) / 2;\n", "pivot = ((unsigned int)left + (unsigned int)right)) >> 1;\n", "class Solution {\n  public:\n  int searchInsert(vector<int>& nums, int target) {\n    int pivot, left = 0, right = nums.size() - 1;\n    while (left <= right) {\n      pivot = left + (right - left) / 2;\n      if (nums[pivot] == target) return pivot;\n      if (target < nums[pivot]) right = pivot - 1;\n      else left = pivot + 1;\n    }\n    return left;\n  }\n};\n"]}
{"number": 36, "statement": "Determine if a9x9 Sudoku boardis valid.Only the filled cells need to be validatedaccording to the following rules:\nEach rowmust contain thedigits1-9 without repetition.\nEach column must contain the digits1-9without repetition.\nEach of the 9 3x3 sub-boxes of the grid must contain the digits1-9without repetition.\nA partially filled sudoku which is valid.\nThe Sudoku board could be partially filled, where empty cells are filled with the character '.'.\n", "solutions": ["class Solution {\n  public boolean isValidSudoku(char[][] board) {\n    // init data\n    HashMap<Integer, Integer> [] rows = new HashMap[9];\n    HashMap<Integer, Integer> [] columns = new HashMap[9];\n    HashMap<Integer, Integer> [] boxes = new HashMap[9];\n    for (int i = 0; i < 9; i++) {\n      rows[i] = new HashMap<Integer, Integer>();\n      columns[i] = new HashMap<Integer, Integer>();\n      boxes[i] = new HashMap<Integer, Integer>();\n    }\n    // validate a board\n    for (int i = 0; i < 9; i++) {\n      for (int j = 0; j < 9; j++) {\n        char num = board[i][j];\n        if (num != '.') {\n          int n = (int)num;\n          int box_index = (i / 3 ) * 3 + j / 3;\n          // keep the current cell value\n          rows[i].put(n, rows[i].getOrDefault(n, 0) + 1);\n          columns[j].put(n, columns[j].getOrDefault(n, 0) + 1);\n          boxes[box_index].put(n, boxes[box_index].getOrDefault(n, 0) + 1);\n          // check if this value has been already seen before\n          if (rows[i].get(n) > 1 || columns[j].get(n) > 1 || boxes[box_index].get(n) > 1)\n            return false;\n        }\n      }\n    }\n    return true;\n  }\n}\n"]}
{"number": 38, "statement": "The count-and-say sequence is the sequence of integers with the first five terms as following:\n1.     1\n2.     11\n3.     21\n4.     1211\n5.     111221\n1 is read off as \"one 1\" or 11.\n11 is read off as \"two 1s\" or 21.\n21 is read off as \"one 2, then one 1\" or 1211.\nGiven an integer nwhere 1 \u2264 n \u2264 30, generate the nth term of the count-and-say sequence. You can do so recursively, in other words from the previous memberread off the digits, counting the number of digits in groups of the same digit.\nNote: Each term of the sequence of integers will be represented as a string.\n", "solutions": ["class Solution {\n  public String countAndSay(int n) {\n    LinkedList<Integer> prevSeq = new LinkedList<Integer>();\n    prevSeq.add(1);\n    // Using -1 as the delimiter\n    prevSeq.add(-1);\n    List<Integer> finalSeq = this.nextSequence(n, prevSeq);\n    StringBuffer seqStr = new StringBuffer();\n    for (Integer digit : finalSeq) {\n      seqStr.append(String.valueOf(digit));\n    }\n    return seqStr.toString();\n  }\n  protected LinkedList<Integer> nextSequence(int n, LinkedList<Integer> prevSeq) {\n    if (n <= 1) {\n      // remove the delimiter before return\n      prevSeq.pollLast();\n      return prevSeq;\n    }\n    LinkedList<Integer> nextSeq = new LinkedList<Integer>();\n    Integer prevDigit = null;\n    Integer digitCnt = 0;\n    for (Integer digit : prevSeq) {\n      if (prevDigit == null) {\n        prevDigit = digit;\n        digitCnt += 1;\n      } else if (digit == prevDigit) {\n        // in the middle of the sub-sequence\n        digitCnt += 1;\n      } else {\n        // end of a sub-sequence\n        nextSeq.add(digitCnt);\n        nextSeq.add(prevDigit);\n        // reset for the next sub-sequence\n        prevDigit = digit;\n        digitCnt = 1;\n      }\n    }\n    // add the delimiter for the next recursion\n    nextSeq.add(-1);\n    return this.nextSequence(n - 1, nextSeq);\n  }\n}\n", "import java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nclass Solution {\n  public String countAndSay(int n) {\n    String currSeq = \"1\";\n    // Pattern to match the repetitive digits\n    String regexPattern = \"(.)\\\\1*\";\n    Pattern pattern = Pattern.compile(regexPattern);\n    for (int i = 1; i < n; ++i) {\n      Matcher m = pattern.matcher(currSeq);\n      StringBuffer nextSeq = new StringBuffer();\n      // each group contains identical and adjacent digits\n      while (m.find()) {\n        nextSeq.append(m.group().length() + String.valueOf(m.group().charAt(0)));\n      }\n      // prepare for the next iteration\n      currSeq = nextSeq.toString();\n    }\n    return currSeq;\n  }\n}\n"]}
{"number": 41, "statement": "Given an unsorted integer array, find the smallest missingpositive integer.\n", "solutions": ["class Solution {\n  public int firstMissingPositive(int[] nums) {\n    int n = nums.length;\n    // Base case.\n    int contains = 0;\n    for (int i = 0; i < n; i++)\n      if (nums[i] == 1) {\n        contains++;\n        break;\n      }\n    if (contains == 0)\n      return 1;\n    // nums = [1]\n    if (n == 1)\n      return 2;\n    // Replace negative numbers, zeros,\n    // and numbers larger than n by 1s.\n    // After this convertion nums will contain \n    // only positive numbers.\n    for (int i = 0; i < n; i++)\n      if ((nums[i] <= 0) || (nums[i] > n))\n        nums[i] = 1;\n    // Use index as a hash key and number sign as a presence detector.\n    // For example, if nums[1] is negative that means that number `1`\n    // is present in the array. \n    // If nums[2] is positive - number 2 is missing.\n    for (int i = 0; i < n; i++) {\n      int a = Math.abs(nums[i]);\n      // If you meet number a in the array - change the sign of a-th element.\n      // Be careful with duplicates : do it only once.\n      if (a == n)\n        nums[0] = - Math.abs(nums[0]);\n      else\n        nums[a] = - Math.abs(nums[a]);\n    }\n    // Now the index of the first positive number \n    // is equal to first missing positive.\n    for (int i = 1; i < n; i++) {\n      if (nums[i] > 0)\n        return i;\n    }\n    if (nums[0] > 0)\n      return n;\n    return n + 1;\n  }\n}\n"]}
{"number": 42, "statement": "Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.\nThe above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Thanks Marcos for contributing this image!\n", "solutions": ["int trap(vector<int>& height)\n{\n\tif(height == null)\n\t\treturn 0;\n    int ans = 0;\n    int size = height.size();\n    vector<int> left_max(size), right_max(size);\n    left_max[0] = height[0];\n    for (int i = 1; i < size; i++) {\n        left_max[i] = max(height[i], left_max[i - 1]);\n    }\n    right_max[size - 1] = height[size - 1];\n    for (int i = size - 2; i >= 0; i--) {\n        right_max[i] = max(height[i], right_max[i + 1]);\n    }\n    for (int i = 1; i < size - 1; i++) {\n        ans += min(left_max[i], right_max[i]) - height[i];\n    }\n    return ans;\n}\n", "int trap(vector<int>& height)\n{\n    int ans = 0, current = 0;\n    stack<int> st;\n    while (current < height.size()) {\n        while (!st.empty() && height[current] > height[st.top()]) {\n            int top = st.top();\n            st.pop();\n            if (st.empty())\n                break;\n            int distance = current - st.top() - 1;\n            int bounded_height = min(height[current], height[st.top()]) - height[top];\n            ans += distance * bounded_height;\n        }\n        st.push(current++);\n    }\n    return ans;\n}\n", "int trap(vector<int>& height)\n{\n    int left = 0, right = height.size() - 1;\n    int ans = 0;\n    int left_max = 0, right_max = 0;\n    while (left < right) {\n        if (height[left] < height[right]) {\n            height[left] >= left_max ? (left_max = height[left]) : ans += (left_max - height[left]);\n            ++left;\n        }\n        else {\n            height[right] >= right_max ? (right_max = height[right]) : ans += (right_max - height[right]);\n            --right;\n        }\n    }\n    return ans;\n}\n"]}
{"number": 44, "statement": "Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for '?' and '*'.\n'?' Matches any single character.\n'*' Matches any sequence of characters (including the empty sequence).\nThe matching should cover the entire input string (not partial).\nNote:\nscould be empty and contains only lowercase letters a-z.\np could be empty and contains only lowercase letters a-z, and characters like ?or*.\n", "solutions": ["class Solution:\n    def remove_duplicate_stars(self, p):\n        if p == '':\n            return p\n        p1 = [p[0],]\n        for x in p[1:]:\n            if p1[-1] != '*' or p1[-1] == '*' and x != '*':\n                p1.append(x)\n        return ''.join(p1) \n        \n    def helper(self, s, p):\n        dp = self.dp\n        if (s, p) in dp:\n            return dp[(s, p)]\n        if p == s or p == '*':\n            dp[(s, p)] = True\n        elif p == '' or s == '':\n            dp[(s, p)] = False\n        elif p[0] == s[0] or p[0] == '?':\n            dp[(s, p)] = self.helper(s[1:], p[1:])\n        elif p[0] == '*':\n            dp[(s, p)] = self.helper(s, p[1:]) or self.helper(s[1:], p)\n        else:\n            dp[(s, p)] = False\n        return dp[(s, p)]\n        \n    def isMatch(self, s, p):\n        p = self.remove_duplicate_stars(p)\n        # memoization hashmap to be used during the recursion\n        self.dp = {}\n        return self.helper(s, p)\n", "class Solution {\n  public boolean isMatch(String s, String p) {\n    int sLen = s.length(), pLen = p.length();\n    // base cases\n    if (p.equals(s) || p.equals(\"*\")) return true;\n    if (p.isEmpty() || s.isEmpty()) return false;\n    // init all matrix except [0][0] element as False\n    boolean[][] d = new boolean[pLen + 1][sLen + 1];\n    d[0][0] = true;\n    // DP compute\n    for(int pIdx = 1; pIdx < pLen + 1; pIdx++) {\n      // the current character in the pattern is '*'\n      if (p.charAt(pIdx - 1) == '*') {\n        int sIdx = 1;\n        // d[p_idx - 1][s_idx - 1] is a string-pattern match\n        // on the previous step, i.e. one character before.\n        // Find the first idx in string with the previous math.\n        while ((!d[pIdx - 1][sIdx - 1]) && (sIdx < sLen + 1)) sIdx++;\n        // If (string) matches (pattern),\n        // when (string) matches (pattern)* as well\n        d[pIdx][sIdx - 1] = d[pIdx - 1][sIdx - 1];\n        // If (string) matches (pattern),\n        // when (string)(whatever_characters) matches (pattern)* as well\n        while (sIdx < sLen + 1) d[pIdx][sIdx++] = true;\n      }\n      // the current character in the pattern is '?'\n      else if (p.charAt(pIdx - 1) == '?') {\n        for(int sIdx = 1; sIdx < sLen + 1; sIdx++)\n          d[pIdx][sIdx] = d[pIdx - 1][sIdx - 1];\n      }\n      // the current character in the pattern is not '*' or '?'\n      else {\n        for(int sIdx = 1; sIdx < sLen + 1; sIdx++) {\n          // Match is possible if there is a previous match\n          // and current characters are the same\n          d[pIdx][sIdx] = d[pIdx - 1][sIdx - 1] &&\n                  (p.charAt(pIdx - 1) == s.charAt(sIdx - 1));\n        }\n      }\n    }\n    return d[pLen][sLen];\n  }\n}\n", "class Solution {\n  public boolean isMatch(String s, String p) {\n    int sLen = s.length(), pLen = p.length();\n    int sIdx = 0, pIdx = 0;\n    int starIdx = -1, sTmpIdx = -1;\n    while (sIdx < sLen) {\n      // If the pattern caracter = string character\n      // or pattern character = '?'\n      if (pIdx < pLen && (p.charAt(pIdx) == '?' || p.charAt(pIdx) == s.charAt(sIdx))){\n        ++sIdx;\n        ++pIdx;\n      }\n      // If pattern character = '*'\n      else if (pIdx < pLen && p.charAt(pIdx) == '*') {\n        // Check the situation\n        // when '*' matches no characters\n        starIdx = pIdx;\n        sTmpIdx = sIdx;\n        ++pIdx;\n      }\n      // If pattern character != string character\n      // or pattern is used up\n      // and there was no '*' character in pattern \n      else if (starIdx == -1) {\n        return false;\n      }\n      // If pattern character != string character\n      // or pattern is used up\n      // and there was '*' character in pattern before\n      else {\n        // Backtrack: check the situation\n        // when '*' matches one more character\n        pIdx = starIdx + 1;\n        sIdx = sTmpIdx + 1;\n        sTmpIdx = sIdx;\n      }\n    }\n    // The remaining characters in the pattern should all be '*' characters\n    for(int i = pIdx; i < pLen; i++)\n      if (p.charAt(i) != '*') return false;\n    return true;\n  }\n}\n"]}
{"number": 45, "statement": "Given an array of non-negative integers, you are initially positioned at the first index of the array.\nEach element in the array represents your maximum jump length at that position.\nYour goal is to reach the last index in the minimum number of jumps.\n", "solutions": ["class Solution {\n  public:\n  bool canJump(vector<int>& nums) {\n    int n = nums.size();\n    // max position one could reach \n    // starting from index <= i\n    int maxPos = nums[0];\n    for (int i = 1; i < n; ++i) {\n      // if one could't reach this point\n      if (maxPos < i) {\n        return false;\n      }\n      maxPos = max(maxPos, nums[i] + i);\n    }\n    return true;\n  }\n};\n", "class Solution {\n  public:\n  int jump(vector<int>& nums) {\n    int n = nums.size();\n    if (n < 2) return 0;\n    // max position one could reach \n    // starting from index <= i \n    int maxPos = nums[0];\n    // max number of steps one could do\n    // inside this jump\n    int maxSteps = nums[0];\n    \n    int jumps = 1;\n    for (int i = 1; i < n; ++i) {\n      // if to reach this point \n      // one needs one more jump\n      if (maxSteps < i) {\n        ++jumps;\n        maxSteps = maxPos;\n      }\n      maxPos = max(maxPos, nums[i] + i);\n    }\n    return jumps;\n  }\n};\n"]}
{"number": 46, "statement": "Given a collection of distinct integers, return all possible permutations.\n", "solutions": ["class Solution {\n  public void backtrack(int n,\n                        ArrayList<Integer> nums,\n                        List<List<Integer>> output,\n                        int first) {\n    // if all integers are used up\n    if (first == n)\n      output.add(new ArrayList<Integer>(nums));\n    for (int i = first; i < n; i++) {\n      // place i-th integer first \n      // in the current permutation\n      Collections.swap(nums, first, i);\n      // use next integers to complete the permutations\n      backtrack(n, nums, output, first + 1);\n      // backtrack\n      Collections.swap(nums, first, i);\n    }\n  }\n  public List<List<Integer>> permute(int[] nums) {\n    // init output list\n    List<List<Integer>> output = new LinkedList();\n    // convert nums into list since the output is a list of lists\n    ArrayList<Integer> nums_lst = new ArrayList<Integer>();\n    for (int num : nums)\n      nums_lst.add(num);\n    int n = nums.length;\n    backtrack(n, nums_lst, output, 0);\n    return output;\n  }\n}\n"]}
{"number": 48, "statement": "You are given an n x n 2D matrix representing an image.\nRotate the image by 90 degrees (clockwise).\nNote:\nYou have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.\n", "solutions": ["class Solution {\n  public void rotate(int[][] matrix) {\n    int n = matrix.length;\n    // transpose matrix\n    for (int i = 0; i < n; i++) {\n      for (int j = i; j < n; j++) {\n        int tmp = matrix[j][i];\n        matrix[j][i] = matrix[i][j];\n        matrix[i][j] = tmp;\n      }\n    }\n    // reverse each row\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < n / 2; j++) {\n        int tmp = matrix[i][j];\n        matrix[i][j] = matrix[i][n - j - 1];\n        matrix[i][n - j - 1] = tmp;\n      }\n    }\n  }\n}\n", "class Solution {\n  public void rotate(int[][] matrix) {\n    int n = matrix.length;\n    for (int i = 0; i < n / 2 + n % 2; i++) {\n      for (int j = 0; j < n / 2; j++) {\n        int[] tmp = new int[4];\n        int row = i;\n        int col = j;\n        for (int k = 0; k < 4; k++) {\n          tmp[k] = matrix[row][col];\n          int x = row;\n          row = col;\n          col = n - 1 - x;\n        }\n        for (int k = 0; k < 4; k++) {\n          matrix[row][col] = tmp[(k + 3) % 4];\n          int x = row;\n          row = col;\n          col = n - 1 - x;\n        }\n      }\n    }\n  }\n}\n", "class Solution {\n  public void rotate(int[][] matrix) {\n    int n = matrix.length;\n    for (int i = 0; i < (n + 1) / 2; i ++) {\n      for (int j = 0; j < n / 2; j++) {\n        int temp = matrix[n - 1 - j][i];\n        matrix[n - 1 - j][i] = matrix[n - 1 - i][n - j - 1];\n        matrix[n - 1 - i][n - j - 1] = matrix[j][n - 1 -i];\n        matrix[j][n - 1 - i] = matrix[i][j];\n        matrix[i][j] = temp;\n      }\n    }\n  }\n}\n"]}
{"number": 49, "statement": "Given an array of strings, group anagrams together.\n", "solutions": ["class Solution {\n    public List<List<String>> groupAnagrams(String[] strs) {\n        if (strs.length == 0) return new ArrayList();\n        Map<String, List> ans = new HashMap<String, List>();\n        for (String s : strs) {\n            char[] ca = s.toCharArray();\n            Arrays.sort(ca);\n            String key = String.valueOf(ca);\n            if (!ans.containsKey(key)) ans.put(key, new ArrayList());\n            ans.get(key).add(s);\n        }\n        return new ArrayList(ans.values());\n    }\n}\n", "class Solution {\n    public List<List<String>> groupAnagrams(String[] strs) {\n        if (strs.length == 0) return new ArrayList();\n        Map<String, List> ans = new HashMap<String, List>();\n        int[] count = new int[26];\n        for (String s : strs) {\n            Arrays.fill(count, 0);\n            for (char c : s.toCharArray()) count[c - 'a']++;\n            StringBuilder sb = new StringBuilder(\"\");\n            for (int i = 0; i < 26; i++) {\n                sb.append('#');\n                sb.append(count[i]);\n            }\n            String key = sb.toString();\n            if (!ans.containsKey(key)) ans.put(key, new ArrayList());\n            ans.get(key).add(s);\n        }\n        return new ArrayList(ans.values());\n    }\n}\n"]}
{"number": 50, "statement": "Implement pow(x, n), which calculatesx raised to the power n (xn).\n", "solutions": ["class Solution {\npublic:\n    double myPow(double x, int n) {\n        long long N = n;\n        if (N < 0) {\n            x = 1 / x;\n            N = -N;\n        }\n        double ans = 1;\n        for (long long i = 0; i < N; i++)\n            ans = ans * x;\n        return ans;\n    }\n};\n", "class Solution {\npublic:\n    double fastPow(double x, long long n) {\n        if (n == 0) {\n            return 1.0;\n        }\n        double half = fastPow(x, n / 2);\n        if (n % 2 == 0) {\n            return half * half;\n        } else {\n            return half * half * x;\n        }\n    }\n    double myPow(double x, int n) {\n        long long N = n;\n        if (N < 0) {\n            x = 1 / x;\n            N = -N;\n        }\n        return fastPow(x, N);\n    }\n};\n", "class Solution {\npublic:\n    double myPow(double x, int n) {\n        long long N = n;\n        if (N < 0) {\n            x = 1 / x;\n            N = -N;\n        }\n        double ans = 1;\n        double current_product = x;\n        for (long long i = N; i ; i /= 2) {\n            if ((i % 2) == 1) {\n                ans = ans * current_product;\n            }\n            current_product = current_product * current_product;\n        }\n        return ans;\n    }\n};\n"]}
{"number": 51, "statement": "The n-queens puzzle is the problem of placing n queens on an n\u00d7n chessboard such that no two queens attack each other.\nGiven an integer n, return all distinct solutions to the n-queens puzzle.\nEach solution contains a distinct board configuration of the n-queens' placement, where 'Q' and '.' both indicate a queen and an empty space respectively.\n", "solutions": ["class Solution {\n  int rows[];\n  // \"hill\" diagonals\n  int hills[];\n  // \"dale\" diagonals\n  int dales[];\n  int n;\n  // output\n  List<List<String>> output = new ArrayList();\n  // queens positions\n  int queens[];\n  public boolean isNotUnderAttack(int row, int col) {\n    int res = rows[col] + hills[row - col + 2 * n] + dales[row + col];\n    return (res == 0) ? true : false;\n  }\n  public void placeQueen(int row, int col) {\n    queens[row] = col;\n    rows[col] = 1;\n    hills[row - col + 2 * n] = 1;  // \"hill\" diagonals\n    dales[row + col] = 1;   //\"dale\" diagonals\n  }\n  public void removeQueen(int row, int col) {\n    queens[row] = 0;\n    rows[col] = 0;\n    hills[row - col + 2 * n] = 0;\n    dales[row + col] = 0;\n  }\n  public void addSolution() {\n    List<String> solution = new ArrayList<String>();\n    for (int i = 0; i < n; ++i) {\n      int col = queens[i];\n      StringBuilder sb = new StringBuilder();\n      for(int j = 0; j < col; ++j) sb.append(\".\");\n      sb.append(\"Q\");\n      for(int j = 0; j < n - col - 1; ++j) sb.append(\".\");\n      solution.add(sb.toString());\n    }\n    output.add(solution);\n  }\n  public void backtrack(int row) {\n    for (int col = 0; col < n; col++) {\n      if (isNotUnderAttack(row, col)) {\n        placeQueen(row, col);\n        // if n queens are already placed\n        if (row + 1 == n) addSolution();\n          // if not proceed to place the rest\n        else backtrack(row + 1);\n        // backtrack\n        removeQueen(row, col);\n      }\n    }\n  }\n  public List<List<String>> solveNQueens(int n) {\n    this.n = n;\n    rows = new int[n];\n    hills = new int[4 * n - 1];\n    dales = new int[2 * n - 1];\n    queens = new int[n];\n    backtrack(0);\n    return output;\n  }\n}\n"]}
{"number": 52, "statement": "The n-queens puzzle is the problem of placing n queens on an n\u00d7n chessboard such that no two queens attack each other.\nGiven an integern, return the number ofdistinct solutions to then-queens puzzle.\n", "solutions": ["class Solution {\n  public boolean is_not_under_attack(int row, int col, int n,\n                                     int [] rows,\n                                     int [] hills,\n                                     int [] dales) {\n    int res = rows[col] + hills[row - col + 2 * n] + dales[row + col];\n    return (res == 0) ? true : false;\n  }\n  public int backtrack(int row, int count, int n,\n                       int [] rows,\n                       int [] hills,\n                       int [] dales) {\n    for (int col = 0; col < n; col++) {\n      if (is_not_under_attack(row, col, n, rows, hills, dales)) {\n        // place_queen\n        rows[col] = 1;\n        hills[row - col + 2 * n] = 1;  // \"hill\" diagonals\n        dales[row + col] = 1;   //\"dale\" diagonals    \n        // if n queens are already placed\n        if (row + 1 == n) count++;\n        // if not proceed to place the rest\n        else count = backtrack(row + 1, count, n,\n                rows, hills, dales);\n        // remove queen\n        rows[col] = 0;\n        hills[row - col + 2 * n] = 0;\n        dales[row + col] = 0;\n      }\n    }\n    return count;\n  }\n  public int totalNQueens(int n) {\n    int rows[] = new int[n];\n    // \"hill\" diagonals\n    int hills[] = new int[4 * n - 1];\n    // \"dale\" diagonals\n    int dales[] = new int[2 * n - 1];\n    return backtrack(0, 0, n, rows, hills, dales);\n  }\n}\n", "class Solution {\n  public int backtrack(int row, int hills, int next_row, int dales, int count, int n) {\n    /** \n     row: current row to place the queen\n     hills: \"hill\" diagonals occupation [1 = taken, 0 = free]\n     next_row: free and taken slots for the next row [1 = taken, 0 = free]\n     dales: \"dale\" diagonals occupation [1 = taken, 0 = free]\n     count: number of all possible solutions\n     */\n    // all columns available for this board, \n    // i.e. n times '1' in binary representation\n    // bin(cols) = 0b1111 for n = 4, bin(cols) = 0b111 for n = 3\n    // [1 = available]\n    int columns = (1 << n) - 1;\n    if (row == n)   // if all n queens are already placed\n      count++;  // we found one more solution\n    else {\n      // free columns in the current row\n      // ! 0 and 1 are inversed with respect to hills, next_row and dales\n      // [0 = taken, 1 = free]\n      int free_columns = columns & ~(hills | next_row | dales);\n      // while there's still a column to place next queen\n      while (free_columns != 0) {\n        // the first bit '1' in a binary form of free_columns\n        // on this column we will place the current queen\n        int curr_column = - free_columns & free_columns;\n        // place the queen \n        // and exclude the column where the queen is placed\n        free_columns ^= curr_column;\n        count = backtrack(row + 1,\n                (hills | curr_column) << 1,\n                next_row | curr_column,\n                (dales | curr_column) >> 1,\n                count, n);\n      }\n    }\n    return count;\n  }\n  public int totalNQueens(int n) {\n    return backtrack(0, 0, 0, 0, 0, n);\n  }\n}\n"]}
{"number": 53, "statement": "Given an integer array nums, find the contiguous subarray(containing at least one number) which has the largest sum and return its sum.\n", "solutions": ["class Solution {\n  public int crossSum(int[] nums, int left, int right, int p) {\n    if (left == right) return nums[left];\n    int leftSubsum = Integer.MIN_VALUE;\n    int currSum = 0;\n    for(int i = p; i > left - 1; --i) {\n      currSum += nums[i];\n      leftSubsum = Math.max(leftSubsum, currSum);\n    }\n    int rightSubsum = Integer.MIN_VALUE;\n    currSum = 0;\n    for(int i = p + 1; i < right + 1; ++i) {\n      currSum += nums[i];\n      rightSubsum = Math.max(rightSubsum, currSum);\n    }\n    return leftSubsum + rightSubsum;\n  }\n  public int helper(int[] nums, int left, int right) {\n    if (left == right) return nums[left];\n    int p = (left + right) / 2;\n    int leftSum = helper(nums, left, p);\n    int rightSum = helper(nums, p + 1, right);\n    int crossSum = crossSum(nums, left, right, p);\n    return Math.max(Math.max(leftSum, rightSum), crossSum);\n  }\n  public int maxSubArray(int[] nums) {\n    return helper(nums, 0, nums.length - 1);\n  }\n}\n", "class Solution {\n  public int maxSubArray(int[] nums) {\n    int n = nums.length;\n    int currSum = nums[0], maxSum = nums[0];\n    for(int i = 1; i < n; ++i) {\n      currSum = Math.max(nums[i], currSum + nums[i]);\n      maxSum = Math.max(maxSum, currSum);\n    }\n    return maxSum;\n  }\n}\n", "class Solution {\n  public int maxSubArray(int[] nums) {\n    int n = nums.length, maxSum = nums[0];\n    for(int i = 1; i < n; ++i) {\n      if (nums[i - 1] > 0) nums[i] += nums[i - 1];\n      maxSum = Math.max(nums[i], maxSum);\n    }\n    return maxSum;\n  }\n}\n"]}
{"number": 54, "statement": "Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.\n", "solutions": ["class Solution {\n    public List<Integer> spiralOrder(int[][] matrix) {\n        List ans = new ArrayList();\n        if (matrix.length == 0) return ans;\n        int R = matrix.length, C = matrix[0].length;\n        boolean[][] seen = new boolean[R][C];\n        int[] dr = {0, 1, 0, -1};\n        int[] dc = {1, 0, -1, 0};\n        int r = 0, c = 0, di = 0;\n        for (int i = 0; i < R * C; i++) {\n            ans.add(matrix[r][c]);\n            seen[r][c] = true;\n            int cr = r + dr[di];\n            int cc = c + dc[di];\n            if (0 <= cr && cr < R && 0 <= cc && cc < C && !seen[cr][cc]){\n                r = cr;\n                c = cc;\n            } else {\n                di = (di + 1) % 4;\n                r += dr[di];\n                c += dc[di];\n            }\n        }\n        return ans;\n    }\n}\n", "class Solution {\n    public List < Integer > spiralOrder(int[][] matrix) {\n        List ans = new ArrayList();\n        if (matrix.length == 0)\n            return ans;\n        int r1 = 0, r2 = matrix.length - 1;\n        int c1 = 0, c2 = matrix[0].length - 1;\n        while (r1 <= r2 && c1 <= c2) {\n            for (int c = c1; c <= c2; c++) ans.add(matrix[r1][c]);\n            for (int r = r1 + 1; r <= r2; r++) ans.add(matrix[r][c2]);\n            if (r1 < r2 && c1 < c2) {\n                for (int c = c2 - 1; c > c1; c--) ans.add(matrix[r2][c]);\n                for (int r = r2; r > r1; r--) ans.add(matrix[r][c1]);\n            }\n            r1++;\n            r2--;\n            c1++;\n            c2--;\n        }\n        return ans;\n    }\n}\n"]}
{"number": 55, "statement": "Given an array of non-negative integers, you are initially positioned at the first index of the array.\nEach element in the array represents your maximum jump length at that position.\nDetermine if you are able to reach the last index.\n", "solutions": ["public class Solution {\n    public boolean canJumpFromPosition(int position, int[] nums) {\n        if (position == nums.length - 1) {\n            return true;\n        }\n        int furthestJump = Math.min(position + nums[position], nums.length - 1);\n        for (int nextPosition = position + 1; nextPosition <= furthestJump; nextPosition++) {\n            if (canJumpFromPosition(nextPosition, nums)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    public boolean canJump(int[] nums) {\n        return canJumpFromPosition(0, nums);\n    }\n}\n", "// Old\nfor (int nextPosition = position + 1; nextPosition <= furthestJump; nextPosition++)\n// New\nfor (int nextPosition = furthestJump; nextPosition > position; nextPosition--)\n", "enum Index {\n    GOOD, BAD, UNKNOWN\n}\npublic class Solution {\n    Index[] memo;\n    public boolean canJumpFromPosition(int position, int[] nums) {\n        if (memo[position] != Index.UNKNOWN) {\n            return memo[position] == Index.GOOD ? true : false;\n        }\n        int furthestJump = Math.min(position + nums[position], nums.length - 1);\n        for (int nextPosition = position + 1; nextPosition <= furthestJump; nextPosition++) {\n            if (canJumpFromPosition(nextPosition, nums)) {\n                memo[position] = Index.GOOD;\n                return true;\n            }\n        }\n        memo[position] = Index.BAD;\n        return false;\n    }\n    public boolean canJump(int[] nums) {\n        memo = new Index[nums.length];\n        for (int i = 0; i < memo.length; i++) {\n            memo[i] = Index.UNKNOWN;\n        }\n        memo[memo.length - 1] = Index.GOOD;\n        return canJumpFromPosition(0, nums);\n    }\n}\n", "enum Index {\n    GOOD, BAD, UNKNOWN\n}\npublic class Solution {\n    public boolean canJump(int[] nums) {\n        Index[] memo = new Index[nums.length];\n        for (int i = 0; i < memo.length; i++) {\n            memo[i] = Index.UNKNOWN;\n        }\n        memo[memo.length - 1] = Index.GOOD;\n        for (int i = nums.length - 2; i >= 0; i--) {\n            int furthestJump = Math.min(i + nums[i], nums.length - 1);\n            for (int j = i + 1; j <= furthestJump; j++) {\n                if (memo[j] == Index.GOOD) {\n                    memo[i] = Index.GOOD;\n                    break;\n                }\n            }\n        }\n        return memo[0] == Index.GOOD;\n    }\n}\n", "public class Solution {\n    public boolean canJump(int[] nums) {\n        int lastPos = nums.length - 1;\n        for (int i = nums.length - 1; i >= 0; i--) {\n            if (i + nums[i] >= lastPos) {\n                lastPos = i;\n            }\n        }\n        return lastPos == 0;\n    }\n}\n"]}
{"number": 56, "statement": "Given a collection of intervals, merge all overlapping intervals.\n", "solutions": ["class Solution {\n  private Map<int[], List<int[]>> graph;\n  private Map<Integer, List<int[]>> nodesInComp;\n  private Set<int[]> visited;\n  // return whether two intervals overlap (inclusive)\n  private boolean overlap(int[] a, int[] b) {\n    return a[0] <= b[1] && b[0] <= a[1];\n  }\n  // build a graph where an undirected edge between intervals u and v exists\n  // iff u and v overlap.\n  private void buildGraph(int[][] intervals) {\n    graph = new HashMap<>();\n    for (int[] interval : intervals) {\n      graph.put(interval, new LinkedList<>());\n    }\n    for (int[] interval1 : intervals) {\n      for (int[] interval2 : intervals) {\n        if (overlap(interval1, interval2)) {\n          graph.get(interval1).add(interval2);\n          graph.get(interval2).add(interval1);\n        }\n      }\n    }\n  }\n  // merges all of the nodes in this connected component into one interval.\n  private int[] mergeNodes(List<int[]> nodes) {\n    int minStart = nodes.get(0)[0];\n    for (int[] node : nodes) {\n      minStart = Math.min(minStart, node[0]);\n    }\n    int maxEnd = nodes.get(0)[1];\n    for (int[] node : nodes) {\n      maxEnd = Math.max(maxEnd, node[1]);\n    }\n    return new int[] {minStart, maxEnd};\n  }\n  // use depth-first search to mark all nodes in the same connected component\n  // with the same integer.\n  private void markComponentDFS(int[] start, int compNumber) {\n    Stack<int[]> stack = new Stack<>();\n    stack.add(start);\n    while (!stack.isEmpty()) {\n      int[] node = stack.pop();\n      if (!visited.contains(node)) {\n        visited.add(node);\n        if (nodesInComp.get(compNumber) == null) {\n          nodesInComp.put(compNumber, new LinkedList<>());\n        }\n        nodesInComp.get(compNumber).add(node);\n        for (int[] child : graph.get(node)) {\n          stack.add(child);\n        }\n      }\n    }\n  }\n  // gets the connected components of the interval overlap graph.\n  private void buildComponents(int[][] intervals) {\n    nodesInComp = new HashMap<>();\n    visited = new HashSet<>();\n    int compNumber = 0;\n    for (int[] interval : intervals) {\n      if (!visited.contains(interval)) {\n        markComponentDFS(interval, compNumber);\n        compNumber++;\n      }\n    }\n  }\n  public int[][] merge(int[][] intervals) {\n    buildGraph(intervals);\n    buildComponents(intervals);\n    // for each component, merge all intervals into one interval.\n    List<int[]> merged = new LinkedList<>();\n    for (int comp = 0; comp < nodesInComp.size(); comp++) {\n      merged.add(mergeNodes(nodesInComp.get(comp)));\n    }\n    return merged.toArray(new int[merged.size()][]);\n  }\n}\n", "class Solution {\n  private class IntervalComparator implements Comparator<int[]> {\n    @Override\n    public int compare(int[] a, int[] b) {\n      return a[0] < b[0] ? -1 : a[0] == b[0] ? 0 : 1;\n    }\n  }\n  public int[][] merge(int[][] intervals) {\n    Collections.sort(Arrays.asList(intervals), new IntervalComparator());\n    LinkedList<int[]> merged = new LinkedList<>();\n    for (int[] interval : intervals) {\n      // if the list of merged intervals is empty or if the current\n      // interval does not overlap with the previous, simply append it.\n      if (merged.isEmpty() || merged.getLast()[1] < interval[0]) {\n        merged.add(interval);\n      }\n      // otherwise, there is overlap, so we merge the current and previous\n      // intervals.\n      else {\n        merged.getLast()[1] = Math.max(merged.getLast()[1], interval[1]);\n      }\n    }\n    return merged.toArray(new int[merged.size()][]);\n  }\n}\n"]}
{"number": 57, "statement": "Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary).\nYou may assume that the intervals were initially sorted according to their start times.\n", "solutions": ["class Solution {\n  public int[][] insert(int[][] intervals, int[] newInterval) {\n    // init data\n    int newStart = newInterval[0], newEnd = newInterval[1];\n    int idx = 0, n = intervals.length;\n    LinkedList<int[]> output = new LinkedList<int[]>();\n    // add all intervals starting before newInterval\n    while (idx < n && newStart > intervals[idx][0])\n      output.add(intervals[idx++]);\n    // add newInterval\n    int[] interval = new int[2];\n    // if there is no overlap, just add the interval\n    if (output.isEmpty() || output.getLast()[1] < newStart)\n      output.add(newInterval);\n    // if there is an overlap, merge with the last interval\n    else {\n      interval = output.removeLast();\n      interval[1] = Math.max(interval[1], newEnd);\n      output.add(interval);\n    }\n    // add next intervals, merge with newInterval if needed\n    while (idx < n) {\n      interval = intervals[idx++];\n      int start = interval[0], end = interval[1];\n      // if there is no overlap, just add an interval\n      if (output.getLast()[1] < start) output.add(interval);\n      // if there is an overlap, merge with the last interval\n      else {\n        interval = output.removeLast();\n        interval[1] = Math.max(interval[1], end);\n        output.add(interval);\n      }\n    }\n    return output.toArray(new int[output.size()][2]);\n  }\n}\n"]}
{"number": 58, "statement": "Given a string s consists of upper/lower-case alphabets and empty space characters ' ', return the length of last word (last word means the last appearing word if we loop from left to right) in the string.\nIf the last word does not exist, return 0.\nNote: A word is defined as a maximal substring consistingof non-space characters only.\n", "solutions": ["class Solution {\n    public int lengthOfLastWord(String s) {\n        // trim the trailing spaces\n        int p = s.length() - 1;\n        while (p >= 0 && s.charAt(p) == ' ') {\n            p--;\n        }\n        // compute the length of last word\n        int length = 0;\n        while (p >= 0 && s.charAt(p) != ' ') {\n            p--;\n            length++;\n        }\n        return length;\n    }\n}\n", "class Solution {\n    public int lengthOfLastWord(String s) {\n        int p = s.length(), length = 0;\n        while (p > 0) {\n            p--;\n            // we're in the middle of the last word\n            if (s.charAt(p) != ' ') {\n                length++;\n            }\n            // here is the end of last word\n            else if (length > 0) {\n                return length;\n            }\n        }\n        return length;\n  }\n}\n", "class Solution {\n    public int lengthOfLastWord(String s) {\n        s = s.trim();  // trim the trailing spaces in the string\n        return s.length() - s.lastIndexOf(\" \") - 1;\n    }\n}\n"]}
{"number": 60, "statement": "The set [1,2,3,...,n] contains a total of n! unique permutations.\nBy listing and labeling all of the permutations in order, we get the following sequence for n = 3:\n\"123\"\n\"132\"\n\"213\"\n\"231\"\n\"312\"\n\"321\"\nGiven n and k, return the kth permutation sequence.\nNote:\nGiven n will be between 1 and 9 inclusive.\nGivenkwill be between 1 and n! inclusive.\n", "solutions": ["class Solution {\n  public String getPermutation(int n, int k) {\n    int[] factorials = new int[n];\n    List<Integer> nums = new ArrayList() {{add(1);}};\n    factorials[0] = 1;\n    for(int i = 1; i < n; ++i) {\n      // generate factorial system bases 0!, 1!, ..., (n - 1)!\n      factorials[i] = factorials[i - 1] * i;\n      // generate nums 1, 2, ..., n\n      nums.add(i + 1);\n    }\n    // fit k in the interval 0 ... (n! - 1)\n    --k;\n    // compute factorial representation of k\n    StringBuilder sb = new StringBuilder();\n    for (int i = n - 1; i > -1; --i) {\n      int idx = k / factorials[i];\n      k -= idx * factorials[i];\n      sb.append(nums.get(idx));\n      nums.remove(idx);\n    }\n    return sb.toString();\n  }\n}\n"]}
{"number": 61, "statement": "Given a linkedlist, rotate the list to the right by k places, where k is non-negative.\n", "solutions": ["class Solution {\n  public ListNode rotateRight(ListNode head, int k) {\n    // base cases\n    if (head == null) return null;\n    if (head.next == null) return head;\n    // close the linked list into the ring\n    ListNode old_tail = head;\n    int n;\n    for(n = 1; old_tail.next != null; n++)\n      old_tail = old_tail.next;\n    old_tail.next = head;\n    // find new tail : (n - k % n - 1)th node\n    // and new head : (n - k % n)th node\n    ListNode new_tail = head;\n    for (int i = 0; i < n - k % n - 1; i++)\n      new_tail = new_tail.next;\n    ListNode new_head = new_tail.next;\n    // break the ring\n    new_tail.next = null;\n    return new_head;\n  }\n}\n"]}
{"number": 62, "statement": "A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below).\nThe robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).\nHow many possible unique paths are there?\nAbove is a 7 x 3 grid. How many possible unique paths are there?\n", "solutions": ["class Solution {\n  public int uniquePaths(int m, int n) {\n    if (m == 1 || n == 1) {\n      return 1;\n    }\n    return uniquePaths(m - 1, n) + uniquePaths(m, n - 1);\n  }\n}\n", "class Solution {\n  public int uniquePaths(int m, int n) {\n    int[][] d = new int[m][n];\n    for(int[] arr : d) {\n      Arrays.fill(arr, 1);\n    }\n    for(int col = 1; col < m; ++col) {\n      for(int row = 1; row < n; ++row) {\n        d[col][row] = d[col - 1][row] + d[col][row - 1];\n      }\n    }\n    return d[m - 1][n - 1];\n  }\n}\n", "from math import factorial\nclass Solution:\n    def uniquePaths(self, m: int, n: int) -> int:\n        return factorial(m + n - 2) // factorial(n - 1) // factorial(m - 1)\n"]}
{"number": 63, "statement": "A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below).\nThe robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).\nNow consider if some obstacles are added to the grids. How many unique paths would there be?\nAn obstacle and empty space is marked as 1 and 0 respectively in the grid.\nNote: m and n will be at most 100.\n", "solutions": ["class Solution {\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\n        int R = obstacleGrid.length;\n        int C = obstacleGrid[0].length;\n        // If the starting cell has an obstacle, then simply return as there would be\n        // no paths to the destination.\n        if (obstacleGrid[0][0] == 1) {\n            return 0;\n        }\n        // Number of ways of reaching the starting cell = 1.\n        obstacleGrid[0][0] = 1;\n        // Filling the values for the first column\n        for (int i = 1; i < R; i++) {\n            obstacleGrid[i][0] = (obstacleGrid[i][0] == 0 && obstacleGrid[i - 1][0] == 1) ? 1 : 0;\n        }\n        // Filling the values for the first row\n        for (int i = 1; i < C; i++) {\n            obstacleGrid[0][i] = (obstacleGrid[0][i] == 0 && obstacleGrid[0][i - 1] == 1) ? 1 : 0;\n        }\n        // Starting from cell(1,1) fill up the values\n        // No. of ways of reaching cell[i][j] = cell[i - 1][j] + cell[i][j - 1]\n        // i.e. From above and left.\n        for (int i = 1; i < R; i++) {\n            for (int j = 1; j < C; j++) {\n                if (obstacleGrid[i][j] == 0) {\n                    obstacleGrid[i][j] = obstacleGrid[i - 1][j] + obstacleGrid[i][j - 1];\n                } else {\n                    obstacleGrid[i][j] = 0;\n                }\n            }\n        }\n        // Return value stored in rightmost bottommost cell. That is the destination.\n        return obstacleGrid[R - 1][C - 1];\n    }\n}\n"]}
{"number": 64, "statement": "Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.\nNote: You can only move either down or right at any point in time.\n", "solutions": ["public class Solution {\n    public int calculate(int[][] grid, int i, int j) {\n        if (i == grid.length || j == grid[0].length) return Integer.MAX_VALUE;\n        if (i == grid.length - 1 && j == grid[0].length - 1) return grid[i][j];\n        return grid[i][j] + Math.min(calculate(grid, i + 1, j), calculate(grid, i, j + 1));\n    }\n    public int minPathSum(int[][] grid) {\n        return calculate(grid, 0, 0);\n    }\n}\n", "public class Solution {\n    public int minPathSum(int[][] grid) {\n        int[][] dp = new int[grid.length][grid[0].length];\n        for (int i = grid.length - 1; i >= 0; i--) {\n            for (int j = grid[0].length - 1; j >= 0; j--) {\n                if(i == grid.length - 1 && j != grid[0].length - 1)\n                    dp[i][j] = grid[i][j] +  dp[i][j + 1];\n                else if(j == grid[0].length - 1 && i != grid.length - 1)\n                    dp[i][j] = grid[i][j] + dp[i + 1][j];\n                else if(j != grid[0].length - 1 && i != grid.length - 1)\n                    dp[i][j] = grid[i][j] + Math.min(dp[i + 1][j], dp[i][j + 1]);\n                else\n                    dp[i][j] = grid[i][j];\n            }\n        }\n        return dp[0][0];\n    }\n}\n"]}
{"number": 66, "statement": "Given a non-empty array of digitsrepresenting a non-negative integer, plus one to the integer.\nThe digits are stored such that the most significant digit is at the head of the list, and each element in the array contain a single digit.\nYou may assume the integer does not contain any leading zero, except the number 0 itself.\n", "solutions": ["class Solution {\n  public int[] plusOne(int[] digits) {\n    int n = digits.length;\n    // move along the input array starting from the end\n    for (int idx = n - 1; idx >= 0; --idx) {\n      // set all the nines at the end of array to zeros\n      if (digits[idx] == 9) {\n        digits[idx] = 0;\n      }\n      // here we have the rightmost not-nine\n      else {\n        // increase this rightmost not-nine by 1 \n        digits[idx]++;\n        // and the job is done\n        return digits;\n      }\n    }\n    // we're here because all the digits are nines\n    digits = new int[n + 1];\n    digits[0] = 1;\n    return digits;\n  }\n}\n"]}
{"number": 67, "statement": "Given two binary strings, return their sum (also a binary string).\nThe input strings are both non-empty and contains only characters 1 or0.\n", "solutions": ["class Solution {\n  public String addBinary(String a, String b) {\n    return Integer.toBinaryString(Integer.parseInt(a, 2) + Integer.parseInt(b, 2));\n  }\n}\n", "class Solution {\n  public String addBinary(String a, String b) {\n    int n = a.length(), m = b.length();\n    if (n < m) return addBinary(b, a);\n    int L = Math.max(n, m);\n    StringBuilder sb = new StringBuilder();\n    int carry = 0, j = m - 1;\n    for(int i = L - 1; i > -1; --i) {\n      if (a.charAt(i) == '1') ++carry;\n      if (j > -1 && b.charAt(j--) == '1') ++carry;\n      if (carry % 2 == 1) sb.append('1');\n      else sb.append('0');\n      carry /= 2;\n    }\n    if (carry == 1) sb.append('1');\n    sb.reverse();\n    return sb.toString();\n  }\n}\n"]}
{"number": 69, "statement": "Implement int sqrt(int x).\nCompute and return the square root of x, wherexis guaranteed to be a non-negative integer.\nSince the return typeis an integer, the decimal digits are truncated and only the integer part of the resultis returned.\n", "solutions": ["class Solution {\n  public int mySqrt(int x) {\n    if (x < 2) return x;\n    int left = (int)Math.pow(Math.E, 0.5 * Math.log(x));\n    int right = left + 1;\n    return (long)right * right > x ? left : right;\n  }\n}\n", "class Solution {\n  public int mySqrt(int x) {\n    if (x < 2) return x;\n    long num;\n    int pivot, left = 2, right = x / 2;\n    while (left <= right) {\n      pivot = left + (right - left) / 2;\n      num = (long)pivot * pivot;\n      if (num > x) right = pivot - 1;\n      else if (num < x) left = pivot + 1;\n      else return pivot;\n    }\n    return right;\n  }\n}\n"]}
{"number": 70, "statement": "You are climbing a stair case. It takes n steps to reach to the top.\nEach time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?\nNote: Given n will be a positive integer.\n", "solutions": ["public class Solution {\n    public int climbStairs(int n) {\n        return climb_Stairs(0, n);\n    }\n    public int climb_Stairs(int i, int n) {\n        if (i > n) {\n            return 0;\n        }\n        if (i == n) {\n            return 1;\n        }\n        return climb_Stairs(i + 1, n) + climb_Stairs(i + 2, n);\n    }\n}\n", "public class Solution {\n    public int climbStairs(int n) {\n        int memo[] = new int[n + 1];\n        return climb_Stairs(0, n, memo);\n    }\n    public int climb_Stairs(int i, int n, int memo[]) {\n        if (i > n) {\n            return 0;\n        }\n        if (i == n) {\n            return 1;\n        }\n        if (memo[i] > 0) {\n            return memo[i];\n        }\n        memo[i] = climb_Stairs(i + 1, n, memo) + climb_Stairs(i + 2, n, memo);\n        return memo[i];\n    }\n}\n"]}
{"number": 71, "statement": "Given an absolute path for a file (Unix-style), simplify it. Or in other words, convert it to the canonical path.\nIn a UNIX-style file system, a period .refers to the current directory. Furthermore, a double period ..moves the directory up a level.\nNote that the returned canonical path must always beginwith a slash /, and there must be only a single slash /between two directory names.The last directory name (if it exists) must notend with a trailing /. Also, the canonical path must be the shortest stringrepresenting the absolute path.\n", "solutions": ["class Solution {\n    public String simplifyPath(String path) {\n        \n        // Handle empty string\n        if (path.isEmpty()) {\n            return path;\n        }\n        \n        // Initialize a stack\n        Stack<String> stack = new Stack<String>();\n        String[] components = path.split(\"/\");\n        \n        // Split the input string on \"/\" as the delimiter\n        // and process each portion one by one\n        for (String directory : components) {\n            \n            // A no-op for a \".\" or an empty string\n            if (directory.equals(\".\") || directory.isEmpty()) {\n                continue;\n            } else if (directory.equals(\"..\")) {\n                \n                // If the current component is a \"..\", then\n                // we pop an entry from the stack if it's non-empty\n                if (!stack.isEmpty()) {\n                    stack.pop();\n                }\n            } else {\n                \n                // Finally, a legitimate directory name, so we add it\n                // to our stack\n                stack.add(directory);\n            }\n        }\n        \n        // Stich together all the directory names together    \n        StringBuilder result = new StringBuilder();\n        for (String dir : stack) {\n            result.append(\"/\");\n            result.append(dir);\n        }\n        \n        return result.length() > 0 ? result.toString() : \"/\" ;\n    }\n}\n"]}
{"number": 72, "statement": "Given two words word1 and word2, find the minimum number of operations required to convert word1 to word2.\nYou have the following 3 operations permitted on a word:\nInsert a character\nDelete a character\nReplace a character\n", "solutions": ["class Solution {\n  public int minDistance(String word1, String word2) {\n    int n = word1.length();\n    int m = word2.length();\n    // if one of the strings is empty\n    if (n * m == 0)\n      return n + m;\n    // array to store the convertion history\n    int [][] d = new int[n + 1][m + 1];\n    // init boundaries\n    for (int i = 0; i < n + 1; i++) {\n      d[i][0] = i;\n    }\n    for (int j = 0; j < m + 1; j++) {\n      d[0][j] = j;\n    }\n    // DP compute \n    for (int i = 1; i < n + 1; i++) {\n      for (int j = 1; j < m + 1; j++) {\n        int left = d[i - 1][j] + 1;\n        int down = d[i][j - 1] + 1;\n        int left_down = d[i - 1][j - 1];\n        if (word1.charAt(i - 1) != word2.charAt(j - 1))\n          left_down += 1;\n        d[i][j] = Math.min(left, Math.min(down, left_down));\n      }\n    }\n    return d[n][m];\n  }\n}\n"]}
{"number": 73, "statement": "Given a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in-place.\n", "solutions": ["class Solution {\n  public void setZeroes(int[][] matrix) {\n    int R = matrix.length;\n    int C = matrix[0].length;\n    Set<Integer> rows = new HashSet<Integer>();\n    Set<Integer> cols = new HashSet<Integer>();\n    // Essentially, we mark the rows and columns that are to be made zero\n    for (int i = 0; i < R; i++) {\n      for (int j = 0; j < C; j++) {\n        if (matrix[i][j] == 0) {\n          rows.add(i);\n          cols.add(j);\n        }\n      }\n    }\n    // Iterate over the array once again and using the rows and cols sets, update the elements.\n    for (int i = 0; i < R; i++) {\n      for (int j = 0; j < C; j++) {\n        if (rows.contains(i) || cols.contains(j)) {\n          matrix[i][j] = 0;\n        }\n      }\n    }\n  }\n}\n", "class Solution {\n  public void setZeroes(int[][] matrix) {\n    int MODIFIED = -1000000;\n    int R = matrix.length;\n    int C = matrix[0].length;\n    for (int r = 0; r < R; r++) {\n      for (int c = 0; c < C; c++) {\n        if (matrix[r][c] == 0) {\n          // We modify the corresponding rows and column elements in place.\n          // Note, we only change the non zeroes to MODIFIED\n          for (int k = 0; k < C; k++) {\n            if (matrix[r][k] != 0) {\n              matrix[r][k] = MODIFIED;\n            }\n          }\n          for (int k = 0; k < R; k++) {\n            if (matrix[k][c] != 0) {\n              matrix[k][c] = MODIFIED;\n            }\n          }\n        }\n      }\n    }\n    for (int r = 0; r < R; r++) {\n      for (int c = 0; c < C; c++) {\n        // Make a second pass and change all MODIFIED elements to 0 \"\"\"\n        if (matrix[r][c] == MODIFIED) {\n          matrix[r][c] = 0;\n        }\n      }\n    }\n  }\n}\n"]}
{"number": 74, "statement": "Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:\nIntegers in each row are sorted from left to right.\nThe first integer of each row is greater than the last integer of the previous row.\n", "solutions": ["class Solution {\n  public:\n  bool searchMatrix(vector<vector<int>>& matrix, int target) {\n    int m = matrix.size();\n    if (m == 0) return false;\n    int n = matrix[0].size();\n    // binary search\n    int left = 0, right = m * n - 1;\n    int pivotIdx, pivotElement;\n    while (left <= right) {\n      pivotIdx = (left + right) / 2;\n      pivotElement = matrix[pivotIdx / n][pivotIdx % n];\n      if (target == pivotElement) return true;\n      else {\n        if (target < pivotElement) right = pivotIdx - 1;\n        else left = pivotIdx + 1;\n      }\n    }\n    return false;\n  }\n};\n"]}
{"number": 75, "statement": "Given an array with n objects colored red, white or blue, sort them in-placeso that objects of the same color are adjacent, with the colors in the order red, white and blue.\nHere, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.\nNote:You are not suppose to use the library's sort function for this problem.\n", "solutions": ["class Solution {\n  public:\n  /*\n  Dutch National Flag problem solution.\n  */\n  void sortColors(vector<int>& nums) {\n    // for all idx < p0 : nums[idx < p0] = 0\n    // curr is an index of element under consideration\n    int p0 = 0, curr = 0;\n    // for all idx > p2 : nums[idx > p2] = 2\n    int p2 = nums.size() - 1;\n    while (curr <= p2) {\n      if (nums[curr] == 0) {\n        swap(nums[curr++], nums[p0++]);\n      }\n      else if (nums[curr] == 2) {\n        swap(nums[curr], nums[p2--]);\n      }\n      else curr++;\n    }\n  }\n};\n"]}
{"number": 76, "statement": "Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n).\n", "solutions": ["class Solution {\n    public String minWindow(String s, String t) {\n        if (s.length() == 0 || t.length() == 0) {\n            return \"\";\n        }\n        Map<Character, Integer> dictT = new HashMap<Character, Integer>();\n        for (int i = 0; i < t.length(); i++) {\n            int count = dictT.getOrDefault(t.charAt(i), 0);\n            dictT.put(t.charAt(i), count + 1);\n        }\n        int required = dictT.size();\n        // Filter all the characters from s into a new list along with their index.\n        // The filtering criteria is that the character should be present in t.\n        List<Pair<Integer, Character>> filteredS = new ArrayList<Pair<Integer, Character>>();\n        for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n            if (dictT.containsKey(c)) {\n                filteredS.add(new Pair<Integer, Character>(i, c));\n            }\n        }\n        int l = 0, r = 0, formed = 0;\n        Map<Character, Integer> windowCounts = new HashMap<Character, Integer>();  \n        int[] ans = {-1, 0, 0};\n        // Look for the characters only in the filtered list instead of entire s.\n        // This helps to reduce our search.\n        // Hence, we follow the sliding window approach on as small list.\n        while (r < filteredS.size()) {\n            char c = filteredS.get(r).getValue();\n            int count = windowCounts.getOrDefault(c, 0);\n            windowCounts.put(c, count + 1);\n            if (dictT.containsKey(c) && windowCounts.get(c).intValue() == dictT.get(c).intValue()) {\n                formed++;\n            }\n            // Try and contract the window till the point where it ceases to be 'desirable'.\n            while (l <= r && formed == required) {\n                c = filteredS.get(l).getValue();\n                // Save the smallest window until now.\n                int end = filteredS.get(r).getKey();\n                int start = filteredS.get(l).getKey();\n                if (ans[0] == -1 || end - start + 1 < ans[0]) {\n                    ans[0] = end - start + 1;\n                    ans[1] = start;\n                    ans[2] = end;\n                }\n                windowCounts.put(c, windowCounts.get(c) - 1);\n                if (dictT.containsKey(c) && windowCounts.get(c).intValue() < dictT.get(c).intValue()) {\n                    formed--;\n                }\n                l++;\n            }\n            r++;   \n        }\n        return ans[0] == -1 ? \"\" : s.substring(ans[1], ans[2] + 1);\n    }\n}\n"]}
{"number": 77, "statement": "Given two integers n and k, return all possible combinations of k numbers out of 1 ... n.\n", "solutions": ["class Solution {\n  List<List<Integer>> output = new LinkedList();\n  int n;\n  int k;\n  public void backtrack(int first, LinkedList<Integer> curr) {\n    // if the combination is done\n    if (curr.size() == k)\n      output.add(new LinkedList(curr));\n    for (int i = first; i < n + 1; ++i) {\n      // add i into the current combination\n      curr.add(i);\n      // use next integers to complete the combination\n      backtrack(i + 1, curr);\n      // backtrack\n      curr.removeLast();\n    }\n  }\n  public List<List<Integer>> combine(int n, int k) {\n    this.n = n;\n    this.k = k;\n    backtrack(1, new LinkedList<Integer>());\n    return output;\n  }\n}\n", "class Solution {\n  public List<List<Integer>> combine(int n, int k) {\n    // init first combination\n    LinkedList<Integer> nums = new LinkedList<Integer>();\n    for(int i = 1; i < k + 1; ++i)\n      nums.add(i);\n    nums.add(n + 1);\n    List<List<Integer>> output = new ArrayList<List<Integer>>();\n    int j = 0;\n    while (j < k) {\n      // add current combination\n      output.add(new LinkedList(nums.subList(0, k)));\n      // increase first nums[j] by one\n      // if nums[j] + 1 != nums[j + 1]\n      j = 0;\n      while ((j < k) && (nums.get(j + 1) == nums.get(j) + 1))\n        nums.set(j, j++ + 1);\n      nums.set(j, nums.get(j) + 1);\n    }\n    return output;\n  }\n}\n"]}
{"number": 78, "statement": "Given a set of distinct integers, nums, return all possible subsets (the power set).\nNote: The solution set must not contain duplicate subsets.\n", "solutions": ["class Solution {\n  public List<List<Integer>> subsets(int[] nums) {\n    List<List<Integer>> output = new ArrayList();\n    output.add(new ArrayList<Integer>());\n    for (int num : nums) {\n      List<List<Integer>> newSubsets = new ArrayList();\n      for (List<Integer> curr : output) {\n        newSubsets.add(new ArrayList<Integer>(curr){{add(num);}});\n      }\n      for (List<Integer> curr : newSubsets) {\n        output.add(curr);\n      }\n    }\n    return output;\n  }\n}\n", "class Solution {\n  List<List<Integer>> output = new ArrayList();\n  int n, k;\n  public void backtrack(int first, ArrayList<Integer> curr, int[] nums) {\n    // if the combination is done\n    if (curr.size() == k)\n      output.add(new ArrayList(curr));\n    for (int i = first; i < n; ++i) {\n      // add i into the current combination\n      curr.add(nums[i]);\n      // use next integers to complete the combination\n      backtrack(i + 1, curr, nums);\n      // backtrack\n      curr.remove(curr.size() - 1);\n    }\n  }\n  public List<List<Integer>> subsets(int[] nums) {\n    n = nums.length;\n    for (k = 0; k < n + 1; ++k) {\n      backtrack(0, new ArrayList<Integer>(), nums);\n    }\n    return output;\n  }\n}\n"]}
{"number": 79, "statement": "Given a 2D board and a word, find if the word exists in the grid.\nThe word can be constructed from letters of sequentially adjacent cell, where \"adjacent\" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.\n", "solutions": ["class Solution {\n  private char[][] board;\n  private int ROWS;\n  private int COLS;\n  public boolean exist(char[][] board, String word) {\n    this.board = board;\n    this.ROWS = board.length;\n    this.COLS = board[0].length;\n    for (int row = 0; row < this.ROWS; ++row)\n      for (int col = 0; col < this.COLS; ++col)\n        if (this.backtrack(row, col, word, 0))\n          return true;\n    return false;\n  }\n  protected boolean backtrack(int row, int col, String word, int index) {\n    /* Step 1). check the bottom case. */\n    if (index >= word.length())\n      return true;\n    /* Step 2). Check the boundaries. */\n    if (row < 0 || row == this.ROWS || col < 0 || col == this.COLS\n        || this.board[row][col] != word.charAt(index))\n      return false;\n    /* Step 3). explore the neighbors in DFS */\n    boolean ret = false;\n    // mark the path before the next exploration\n    this.board[row][col] = '#';\n    int[] rowOffsets = {0, 1, 0, -1};\n    int[] colOffsets = {1, 0, -1, 0};\n    for (int d = 0; d < 4; ++d) {\n      ret = this.backtrack(row + rowOffsets[d], col + colOffsets[d], word, index + 1);\n      if (ret)\n        break;\n    }\n    /* Step 4). clean up and return the result. */\n    this.board[row][col] = word.charAt(index);\n    return ret;\n  }\n}\n", "  protected boolean backtrack(int row, int col, String word, int index) {\n    /* Step 1). check the bottom case. */\n    if (index >= word.length())\n      return true;\n    /* Step 2). Check the boundaries. */\n    if (row < 0 || row == this.ROWS || col < 0 || col == this.COLS\n        || this.board[row][col] != word.charAt(index))\n      return false;\n    /* Step 3). explore the neighbors in DFS */\n    // mark the path before the next exploration\n    this.board[row][col] = '#';\n    int[] rowOffsets = {0, 1, 0, -1};\n    int[] colOffsets = {1, 0, -1, 0};\n    for (int d = 0; d < 4; ++d) {\n      if (this.backtrack(row + rowOffsets[d], col + colOffsets[d], word, index + 1))\n        // return without cleanup\n        return true;\n    }\n    /* Step 4). clean up and return the result. */\n    this.board[row][col] = word.charAt(index);\n    return false;\n  }\n"]}
{"number": 80, "statement": "Given a sorted array nums, remove the duplicates in-place such that duplicates appeared at mosttwice and return the new length.\nDo not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.\n", "solutions": ["class Solution {\n    \n    public int[] remElement(int[] arr, int index) {\n        \n        //\n        // Overwrite the element at the given index by \n        // moving all the elements to the right of the\n        // index, one position to the left.\n        //\n        for (int i = index + 1; i < arr.length; i++) {\n            arr[i - 1] = arr[i];\n        }\n        \n        return arr;\n    }    \n    \n    public int removeDuplicates(int[] nums) {\n        \n        // Initialize the counter and the array index.\n        int i = 1, count = 1, length = nums.length;\n        \n        //\n        // Start from the second element of the array and process\n        // elements one by one.\n        //\n        while (i < length) {\n            \n            //\n            // If the current element is a duplicate, \n            // increment the count.\n            //\n            if (nums[i] == nums[i - 1]) {\n                \n                count++;\n                \n                //    \n                // If the count is more than 2, this is an unwanted duplicate element\n                // and hence we remove it from the array.\n                //    \n                if (count > 2) {\n                    \n                    this.remElement(nums, i);\n                    \n                    //\n                    // Note that we have to decrement the array index value to\n                    // keep it consistent with the size of the array.\n                    //    \n                    i--;\n                    \n                    //\n                    // Since we have a fixed size array and we can't actually\n                    // remove an element, we reduce the length of the array as\n                    // well.\n                    //\n                    length--;\n                }\n            } else {\n                \n                //\n                // Reset the count since we encountered a different element\n                // than the previous one.\n                //\n                count = 1;\n            }\n                \n            // Move on to the next element in the array\n            i++;\n        }\n            \n        return length;\n    }\n}\n", "class Solution {\n    \n    public int removeDuplicates(int[] nums) {\n        \n        //\n        // Initialize the counter and the second pointer.\n        //\n        int j = 1, count = 1;\n        \n        //\n        // Start from the second element of the array and process\n        // elements one by one.\n        //\n        for (int i = 1; i < nums.length; i++) {\n            \n            //\n            // If the current element is a duplicate, increment the count.\n            //\n            if (nums[i] == nums[i - 1]) {\n                \n                count++;\n                \n            } else {\n                \n                //\n                // Reset the count since we encountered a different element\n                // than the previous one.\n                //\n                count = 1;\n            }\n            \n            //\n            // For a count <= 2, we copy the element over thus\n            // overwriting the element at index \"j\" in the array\n            //\n            if (count <= 2) {\n                nums[j++] = nums[i];\n            }\n        }\n        return j;\n    }\n}\n"]}
{"number": 83, "statement": "Given a sorted linked list, delete all duplicates such that each element appear only once.\n", "solutions": ["public ListNode deleteDuplicates(ListNode head) {\n    ListNode current = head;\n    while (current != null && current.next != null) {\n        if (current.next.val == current.val) {\n            current.next = current.next.next;\n        } else {\n            current = current.next;\n        }\n    }\n    return head;\n}\n"]}
{"number": 84, "statement": "Given n non-negative integers representing the histogram's bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.\nAbove is a histogram where width of each bar is 1, given height = [2,1,5,6,2,3].\nThe largest rectangle is shown in the shaded area, which has area = 10 unit.\n", "solutions": [" public class Solution {\n    public int largestRectangleArea(int[] heights) {\n        int maxarea = 0;\n        for (int i = 0; i < heights.length; i++) {\n            int minheight = Integer.MAX_VALUE;\n            for (int j = i; j < heights.length; j++) {\n                minheight = Math.min(minheight, heights[j]);\n                maxarea = Math.max(maxarea, minheight * (j - i + 1));\n            }\n        }\n        return maxarea;\n    }\n}\n"]}
{"number": 85, "statement": "Given a 2D binary matrix filled with 0's and 1's, find the largest rectangle containing only 1's and return its area.\n", "solutions": ["class Solution {\n    public int maximalRectangle(char[][] matrix) {\n        if (matrix.length == 0) return 0;\n        int maxarea = 0;\n        int[][] dp = new int[matrix.length][matrix[0].length];\n        for(int i = 0; i < matrix.length; i++){\n            for(int j = 0; j < matrix[0].length; j++){\n                if (matrix[i][j] == '1'){\n                    // compute the maximum width and update dp with it\n                    dp[i][j] = j == 0? 1 : dp[i][j-1] + 1;\n                    int width = dp[i][j];\n                    // compute the maximum area rectangle with a lower right corner at [i, j]\n                    for(int k = i; k >= 0; k--){\n                        width = Math.min(width, dp[k][j]);\n                        maxarea = Math.max(maxarea, width * (i - k + 1));\n                    }\n                }\n            }\n        } return maxarea;\n    }\n}\n", "class Solution {\n    // Get the maximum area in a histogram given its heights\n    public int leetcode84(int[] heights) {\n        Stack < Integer > stack = new Stack < > ();\n        stack.push(-1);\n        int maxarea = 0;\n        for (int i = 0; i < heights.length; ++i) {\n            while (stack.peek() != -1 && heights[stack.peek()] >= heights[i])\n                maxarea = Math.max(maxarea, heights[stack.pop()] * (i - stack.peek() - 1));\n            stack.push(i);\n        }\n        while (stack.peek() != -1)\n            maxarea = Math.max(maxarea, heights[stack.pop()] * (heights.length - stack.peek() -1));\n        return maxarea;\n    }\n    public int maximalRectangle(char[][] matrix) {\n        if (matrix.length == 0) return 0;\n        int maxarea = 0;\n        int[] dp = new int[matrix[0].length];\n        for(int i = 0; i < matrix.length; i++) {\n            for(int j = 0; j < matrix[0].length; j++) {\n                // update the state of this row's histogram using the last row's histogram\n                // by keeping track of the number of consecutive ones\n                dp[j] = matrix[i][j] == '1' ? dp[j] + 1 : 0;\n            }\n            // update maxarea with the maximum area from this row's histogram\n            maxarea = Math.max(maxarea, leetcode84(dp));\n        } return maxarea;\n    }\n}\n"]}
{"number": 86, "statement": "Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.\nYou should preserve the original relative order of the nodes in each of the two partitions.\n", "solutions": ["class Solution {\n    public ListNode partition(ListNode head, int x) {\n        // before and after are the two pointers used to create the two list\n        // before_head and after_head are used to save the heads of the two lists.\n        // All of these are initialized with the dummy nodes created.\n        ListNode before_head = new ListNode(0);\n        ListNode before = before_head;\n        ListNode after_head = new ListNode(0);\n        ListNode after = after_head;\n        while (head != null) {\n            // If the original list node is lesser than the given x,\n            // assign it to the before list.\n            if (head.val < x) {\n                before.next = head;\n                before = before.next;\n            } else {\n                // If the original list node is greater or equal to the given x,\n                // assign it to the after list.\n                after.next = head;\n                after = after.next;\n            }\n            // move ahead in the original list\n            head = head.next;\n        }\n        // Last node of \"after\" list would also be ending node of the reformed list\n        after.next = null;\n        // Once all the nodes are correctly assigned to the two lists,\n        // combine them to form a single list which would be returned.\n        before.next = after_head.next;\n        return before_head.next;\n    }\n}\n"]}
{"number": 88, "statement": "Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.\nNote:\nThe number of elements initialized in nums1 and nums2 are m and n respectively.\nYou may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2.\n", "solutions": ["class Solution {\n  public void merge(int[] nums1, int m, int[] nums2, int n) {\n    System.arraycopy(nums2, 0, nums1, m, n);\n    Arrays.sort(nums1);\n  }\n}\n", "class Solution {\n  public void merge(int[] nums1, int m, int[] nums2, int n) {\n    // Make a copy of nums1.\n    int [] nums1_copy = new int[m];\n    System.arraycopy(nums1, 0, nums1_copy, 0, m);\n    // Two get pointers for nums1_copy and nums2.\n    int p1 = 0;\n    int p2 = 0;\n    // Set pointer for nums1\n    int p = 0;\n    // Compare elements from nums1_copy and nums2\n    // and add the smallest one into nums1.\n    while ((p1 < m) && (p2 < n))\n      nums1[p++] = (nums1_copy[p1] < nums2[p2]) ? nums1_copy[p1++] : nums2[p2++];\n    // if there are still elements to add\n    if (p1 < m)\n      System.arraycopy(nums1_copy, p1, nums1, p1 + p2, m + n - p1 - p2);\n    if (p2 < n)\n      System.arraycopy(nums2, p2, nums1, p1 + p2, m + n - p1 - p2);\n  }\n}\n", "class Solution {\n  public void merge(int[] nums1, int m, int[] nums2, int n) {\n    // two get pointers for nums1 and nums2\n    int p1 = m - 1;\n    int p2 = n - 1;\n    // set pointer for nums1\n    int p = m + n - 1;\n    // while there are still elements to compare\n    while ((p1 >= 0) && (p2 >= 0))\n      // compare two elements from nums1 and nums2 \n      // and add the largest one in nums1 \n      nums1[p--] = (nums1[p1] < nums2[p2]) ? nums2[p2--] : nums1[p1--];\n    // add missing elements from nums2\n    System.arraycopy(nums2, 0, nums1, 0, p2 + 1);\n  }\n}\n"]}
{"number": 91, "statement": "A message containing letters from A-Z is being encoded to numbers using the following mapping:\n'A' - 1\n'B' - 2\n...\n'Z' - 26\nGiven a non-empty string containing only digits, determine the total number of ways to decode it.\n", "solutions": ["class Solution {\n    HashMap<Integer, Integer> memo = new HashMap<>();\n    private int recursiveWithMemo(int index, String str) {\n        // If you reach the end of the string\n        // Return 1 for success.\n        if (index == str.length()) {\n            return 1;\n        }\n        // If the string starts with a zero, it can't be decoded\n        if (str.charAt(index) == '0') {\n            return 0;\n        }\n        if (index == str.length()-1) {\n            return 1;\n        }\n        // Memoization is needed since we might encounter the same sub-string.\n        if (memo.containsKey(index)) {\n            return memo.get(index);\n        }\n        int ans = recursiveWithMemo(index+1, str);\n        if (Integer.parseInt(str.substring(index, index+2)) <= 26) {\n             ans += recursiveWithMemo(index+2, str);\n         }\n        // Save for memoization\n        memo.put(index, ans);\n        return ans;\n    }\n    public int numDecodings(String s) {\n        if (s == null || s.length() == 0) {\n            return 0;\n        }\n        return recursiveWithMemo(0, s);\n    }\n}\n", "class Solution {\n    public int numDecodings(String s) {\n        if(s == null || s.length() == 0) {\n            return 0;\n        }\n        // DP array to store the subproblem results\n        int[] dp = new int[s.length() + 1];\n        dp[0] = 1;\n        // Ways to decode a string of size 1 is 1. Unless the string is '0'.\n        // '0' doesn't have a single digit decode.\n        dp[1] = s.charAt(0) == '0' ? 0 : 1;\n        for(int i = 2; i < dp.length; i += 1) {\n            // Check if successful single digit decode is possible.\n            if(s.charAt(i-1) != '0') {\n               dp[i] += dp[i-1];  \n            }\n            // Check if successful two digit decode is possible.\n            int twoDigit = Integer.valueOf(s.substring(i-2, i));\n            if(twoDigit >= 10 && twoDigit <= 26) {\n                dp[i] += dp[i-2];\n            }\n        }\n        return dp[s.length()];\n    }\n}\n"]}
{"number": 92, "statement": "Reverse a linked list from position m to n. Do it in one-pass.\nNote:1 \u2264 m \u2264 n \u2264 length of list.\n", "solutions": ["class Solution {\n    // Object level variables since we need the changes\n    // to persist across recursive calls and Java is pass by value.\n    private boolean stop;\n    private ListNode left;\n    public void recurseAndReverse(ListNode right, int m, int n) {\n        // base case. Don't proceed any further\n        if (n == 1) {\n            return;\n        }\n        // Keep moving the right pointer one step forward until (n == 1)\n        right = right.next;\n        // Keep moving left pointer to the right until we reach the proper node\n        // from where the reversal is to start.\n        if (m > 1) {\n            this.left = this.left.next;\n        }\n        // Recurse with m and n reduced.\n        this.recurseAndReverse(right, m - 1, n - 1);\n        // In case both the pointers cross each other or become equal, we\n        // stop i.e. don't swap data any further. We are done reversing at this\n        // point.\n        if (this.left == right || right.next == this.left) {\n            this.stop = true;            \n        }\n        // Until the boolean stop is false, swap data between the two pointers\n        if (!this.stop) {\n            int t = this.left.val;\n            this.left.val = right.val;\n            right.val = t;\n            // Move left one step to the right.\n            // The right pointer moves one step back via backtracking.\n            this.left = this.left.next;\n        }\n    }\n    public ListNode reverseBetween(ListNode head, int m, int n) {\n        this.left = head;\n        this.stop = false;\n        this.recurseAndReverse(head, m, n);\n        return head;\n    }\n}\n", "class Solution {\n    public ListNode reverseBetween(ListNode head, int m, int n) {\n        // Empty list\n        if (head == null) {\n            return null;\n        }\n        // Move the two pointers until they reach the proper starting point\n        // in the list.\n        ListNode cur = head, prev = null;\n        while (m > 1) {\n            prev = cur;\n            cur = cur.next;\n            m--;\n            n--;\n        }\n        // The two pointers that will fix the final connections.\n        ListNode con = prev, tail = cur;\n        // Iteratively reverse the nodes until n becomes 0.\n        ListNode third = null;\n        while (n > 0) {\n            third = cur.next;\n            cur.next = prev;\n            prev = cur;\n            cur = third;\n            n--;\n        }\n        // Adjust the final connections as explained in the algorithm\n        if (con != null) {\n            con.next = prev;\n        } else {\n            head = prev;\n        }\n        tail.next = cur;\n        return head;\n    }\n}\n"]}
{"number": 93, "statement": "Given a string containing only digits, restore it by returning all possible valid IP address combinations.\nA valid IP address consists of exactly four integers(each integer is between 0 and 255) separated by single points.\n", "solutions": ["class Solution {\n  int n;\n  String s;\n  LinkedList<String> segments = new LinkedList<String>();\n  ArrayList<String> output = new ArrayList<String>();\n  public boolean valid(String segment) {\n    /*\n    Check if the current segment is valid :\n    1. less or equal to 255      \n    2. the first character could be '0' \n    only if the segment is equal to '0'\n    */\n    int m = segment.length();\n    if (m > 3)\n      return false;\n    return (segment.charAt(0) != '0') ? (Integer.valueOf(segment) <= 255) : (m == 1);\n  }\n  public void update_output(int curr_pos) {\n    /*\n    Append the current list of segments \n    to the list of solutions\n    */\n    String segment = s.substring(curr_pos + 1, n);\n    if (valid(segment)) {\n      segments.add(segment);\n      output.add(String.join(\".\", segments));\n      segments.removeLast();\n    }\n  }\n  public void backtrack(int prev_pos, int dots) {\n    /*\n    prev_pos : the position of the previously placed dot\n    dots : number of dots to place\n    */\n    // The current dot curr_pos could be placed \n    // in a range from prev_pos + 1 to prev_pos + 4.\n    // The dot couldn't be placed \n    // after the last character in the string.\n    int max_pos = Math.min(n - 1, prev_pos + 4);\n    for (int curr_pos = prev_pos + 1; curr_pos < max_pos; curr_pos++) {\n      String segment = s.substring(prev_pos + 1, curr_pos + 1);\n      if (valid(segment)) {\n        segments.add(segment);  // place dot\n        if (dots - 1 == 0)      // if all 3 dots are placed\n          update_output(curr_pos);  // add the solution to output\n        else\n          backtrack(curr_pos, dots - 1);  // continue to place dots\n        segments.removeLast();  // remove the last placed dot \n      }\n    }\n  }\n  public List<String> restoreIpAddresses(String s) {\n    n = s.length();\n    this.s = s;\n    backtrack(-1, 3);\n    return output;\n  }\n}\n"]}
{"number": 94, "statement": "Given a binary tree, return the inorder traversal of its nodes' values.\n", "solutions": ["class Solution {\n    public List < Integer > inorderTraversal(TreeNode root) {\n        List < Integer > res = new ArrayList < > ();\n        helper(root, res);\n        return res;\n    }\n    public void helper(TreeNode root, List < Integer > res) {\n        if (root != null) {\n            if (root.left != null) {\n                helper(root.left, res);\n            }\n            res.add(root.val);\n            if (root.right != null) {\n                helper(root.right, res);\n            }\n        }\n    }\n}\n", "public class Solution {\n    public List < Integer > inorderTraversal(TreeNode root) {\n        List < Integer > res = new ArrayList < > ();\n        Stack < TreeNode > stack = new Stack < > ();\n        TreeNode curr = root;\n        while (curr != null || !stack.isEmpty()) {\n            while (curr != null) {\n                stack.push(curr);\n                curr = curr.left;\n            }\n            curr = stack.pop();\n            res.add(curr.val);\n            curr = curr.right;\n        }\n        return res;\n    }\n}\n", "class Solution {\n    public List < Integer > inorderTraversal(TreeNode root) {\n        List < Integer > res = new ArrayList < > ();\n        TreeNode curr = root;\n        TreeNode pre;\n        while (curr != null) {\n            if (curr.left == null) {\n                res.add(curr.val);\n                curr = curr.right; // move to next right node\n            } else { // has a left subtree\n                pre = curr.left;\n                while (pre.right != null) { // find rightmost\n                    pre = pre.right;\n                }\n                pre.right = curr; // put cur after the pre node\n                TreeNode temp = curr; // store cur node\n                curr = curr.left; // move cur to the top of the new tree\n                temp.left = null; // original cur left be null, avoid infinite loops\n            }\n        }\n        return res;\n    }\n}\n"]}
{"number": 95, "statement": "Given an integer n, generate all structurally unique BST's (binary search trees) that store values 1 ...n.\n", "solutions": ["// Definition for a binary tree node.\npublic class TreeNode {\n  int val;\n  TreeNode left;\n  TreeNode right;\n  TreeNode(int x) {\n    val = x;\n  }\n}\n", "class Solution {\n  public LinkedList<TreeNode> generate_trees(int start, int end) {\n    LinkedList<TreeNode> all_trees = new LinkedList<TreeNode>();\n    if (start > end) {\n      all_trees.add(null);\n      return all_trees;\n    }\n    // pick up a root\n    for (int i = start; i <= end; i++) {\n      // all possible left subtrees if i is choosen to be a root\n      LinkedList<TreeNode> left_trees = generate_trees(start, i - 1);\n      // all possible right subtrees if i is choosen to be a root\n      LinkedList<TreeNode> right_trees = generate_trees(i + 1, end);\n      // connect left and right trees to the root i\n      for (TreeNode l : left_trees) {\n        for (TreeNode r : right_trees) {\n          TreeNode current_tree = new TreeNode(i);\n          current_tree.left = l;\n          current_tree.right = r;\n          all_trees.add(current_tree);\n        }\n      }\n    }\n    return all_trees;\n  }\n  public List<TreeNode> generateTrees(int n) {\n    if (n == 0) {\n      return new LinkedList<TreeNode>();\n    }\n    return generate_trees(1, n);\n  }\n}\n"]}
{"number": 96, "statement": "Given n, how many structurally unique BST's (binary search trees) that store values 1 ...n?\n", "solutions": ["public class Solution {\n  public int numTrees(int n) {\n    int[] G = new int[n + 1];\n    G[0] = 1;\n    G[1] = 1;\n    for (int i = 2; i <= n; ++i) {\n      for (int j = 1; j <= i; ++j) {\n        G[i] += G[j - 1] * G[i - j];\n      }\n    }\n    return G[n];\n  }\n}\n", "class Solution {\n  public int numTrees(int n) {\n    // Note: we should use long here instead of int, otherwise overflow\n    long C = 1;\n    for (int i = 0; i < n; ++i) {\n      C = C * 2 * (2 * i + 1) / (i + 2);\n    }\n    return (int) C;\n  }\n}\n"]}
{"number": 97, "statement": "Given s1, s2, s3, find whether s3 is formed by the interleaving of s1 and s2.\n", "solutions": ["public class Solution {\n    public boolean is_Interleave(String s1,int i,String s2,int j,String res,String s3)\n    {\n        if(res.equals(s3) && i==s1.length() && j==s2.length())\n            return true;\n        boolean ans=false;\n        if(i<s1.length())\n            ans|=is_Interleave(s1,i+1,s2,j,res+s1.charAt(i),s3);\n        if(j<s2.length())\n            ans|=is_Interleave(s1,i,s2,j+1,res+s2.charAt(j),s3);\n        return ans;\n    }\n    public boolean isInterleave(String s1, String s2, String s3) {\n        return is_Interleave(s1,0,s2,0,\"\",s3);\n    }\n}\n", " public class Solution {\n    public boolean is_Interleave(String s1, int i, String s2, int j, String s3, int k, int[][] memo) {\n        if (i == s1.length()) {\n            return s2.substring(j).equals(s3.substring(k));\n        }\n        if (j == s2.length()) {\n            return s1.substring(i).equals(s3.substring(k));\n        }\n        if (memo[i][j] >= 0) {\n            return memo[i][j] == 1 ? true : false;\n        }\n        boolean ans = false;\n        if (s3.charAt(k) == s1.charAt(i) && is_Interleave(s1, i + 1, s2, j, s3, k + 1, memo)\n                || s3.charAt(k) == s2.charAt(j) && is_Interleave(s1, i, s2, j + 1, s3, k + 1, memo)) {\n            ans = true;\n        }\n        memo[i][j] = ans ? 1 : 0;\n        return ans;\n    }\n    public boolean isInterleave(String s1, String s2, String s3) {\n        int memo[][] = new int[s1.length()][s2.length()];\n        for (int i = 0; i < s1.length(); i++) {\n            for (int j = 0; j < s2.length(); j++) {\n                memo[i][j] = -1;\n            }\n        }\n        return is_Interleave(s1, 0, s2, 0, s3, 0, memo);\n    }\n}\n", "public class Solution {\n    public boolean isInterleave(String s1, String s2, String s3) {\n        if (s3.length() != s1.length() + s2.length()) {\n            return false;\n        }\n        boolean dp[][] = new boolean[s1.length() + 1][s2.length() + 1];\n        for (int i = 0; i <= s1.length(); i++) {\n            for (int j = 0; j <= s2.length(); j++) {\n                if (i == 0 && j == 0) {\n                    dp[i][j] = true;\n                } else if (i == 0) {\n                    dp[i][j] = dp[i][j - 1] && s2.charAt(j - 1) == s3.charAt(i + j - 1);\n                } else if (j == 0) {\n                    dp[i][j] = dp[i - 1][j] && s1.charAt(i - 1) == s3.charAt(i + j - 1);\n                } else {\n                    dp[i][j] = (dp[i - 1][j] && s1.charAt(i - 1) == s3.charAt(i + j - 1)) || (dp[i][j - 1] && s2.charAt(j - 1) == s3.charAt(i + j - 1));\n                }\n            }\n        }\n        return dp[s1.length()][s2.length()];\n    }\n}\n", "public class Solution {\n    public boolean isInterleave(String s1, String s2, String s3) {\n        if (s3.length() != s1.length() + s2.length()) {\n            return false;\n        }\n        boolean dp[] = new boolean[s2.length() + 1];\n        for (int i = 0; i <= s1.length(); i++) {\n            for (int j = 0; j <= s2.length(); j++) {\n                if (i == 0 && j == 0) {\n                    dp[j] = true;\n                } else if (i == 0) {\n                    dp[j] = dp[j - 1] && s2.charAt(j - 1) == s3.charAt(i + j - 1);\n                } else if (j == 0) {\n                    dp[j] = dp[j] && s1.charAt(i - 1) == s3.charAt(i + j - 1);\n                } else {\n                    dp[j] = (dp[j] && s1.charAt(i - 1) == s3.charAt(i + j - 1)) || (dp[j - 1] && s2.charAt(j - 1) == s3.charAt(i + j - 1));\n                }\n            }\n        }\n        return dp[s2.length()];\n    }\n}\n"]}
{"number": 98, "statement": "Given a binary tree, determine if it is a valid binary search tree (BST).\nAssume a BST is defined as follows:\nThe left subtree of a node contains only nodes with keys less than the node's key.\nThe right subtree of a node contains only nodes with keys greater than the node's key.\nBoth the left and right subtrees must also be binary search trees.\n", "solutions": ["// Definition for a binary tree node.\npublic class TreeNode {\n  int val;\n  TreeNode left;\n  TreeNode right;\n  TreeNode(int x) {\n    val = x;\n  }\n}\n", "class Solution {\n  public boolean helper(TreeNode node, Integer lower, Integer upper) {\n    if (node == null) return true;\n    int val = node.val;\n    if (lower != null && val <= lower) return false;\n    if (upper != null && val >= upper) return false;\n    if (! helper(node.right, val, upper)) return false;\n    if (! helper(node.left, lower, val)) return false;\n    return true;\n  }\n  public boolean isValidBST(TreeNode root) {\n    return helper(root, null, null);\n  }\n}\n", "class Solution {\n  LinkedList<TreeNode> stack = new LinkedList();\n  LinkedList<Integer> uppers = new LinkedList(),\n          lowers = new LinkedList();\n  public void update(TreeNode root, Integer lower, Integer upper) {\n    stack.add(root);\n    lowers.add(lower);\n    uppers.add(upper);\n  }\n  public boolean isValidBST(TreeNode root) {\n    Integer lower = null, upper = null, val;\n    update(root, lower, upper);\n    while (!stack.isEmpty()) {\n      root = stack.poll();\n      lower = lowers.poll();\n      upper = uppers.poll();\n      if (root == null) continue;\n      val = root.val;\n      if (lower != null && val <= lower) return false;\n      if (upper != null && val >= upper) return false;\n      update(root.right, val, upper);\n      update(root.left, lower, val);\n    }\n    return true;\n  }\n}\n", "class Solution {\n  public boolean isValidBST(TreeNode root) {\n    Stack<TreeNode> stack = new Stack();\n    double inorder = - Double.MAX_VALUE;\n    while (!stack.isEmpty() || root != null) {\n      while (root != null) {\n        stack.push(root);\n        root = root.left;\n      }\n      root = stack.pop();\n      // If next element in inorder traversal\n      // is smaller than the previous one\n      // that's not BST.\n      if (root.val <= inorder) return false;\n      inorder = root.val;\n      root = root.right;\n    }\n    return true;\n  }\n}\n"]}
{"number": 99, "statement": "Two elements of a binary search tree (BST) are swapped by mistake.\nRecover the tree without changing its structure.\n", "solutions": ["public void inorder(TreeNode root, List<Integer> nums) {\n  if (root == null) return;\n  inorder(root.left, nums);\n  nums.add(root.val);\n  inorder(root.right, nums);\n}\n", "public int[] findTwoSwapped(List<Integer> nums) {\n  int n = nums.size();\n  int x = -1, y = -1;\n  for(int i = 0; i < n - 1; ++i) {\n    if (nums.get(i + 1) < nums.get(i)) {\n      y = nums.get(i + 1);\n      // first swap occurence\n      if (x == -1) x = nums.get(i);\n      // second swap occurence\n      else break;\n    }\n  }\n  return new int[]{x, y};\n}\n", "class Solution {\n  public void inorder(TreeNode root, List<Integer> nums) {\n    if (root == null) return;\n    inorder(root.left, nums);\n    nums.add(root.val);\n    inorder(root.right, nums);\n  }\n  public int[] findTwoSwapped(List<Integer> nums) {\n    int n = nums.size();\n    int x = -1, y = -1;\n    for(int i = 0; i < n - 1; ++i) {\n      if (nums.get(i + 1) < nums.get(i)) {\n        y = nums.get(i + 1);\n        // first swap occurence\n        if (x == -1) x = nums.get(i);\n        // second swap occurence\n        else break;\n      }\n    }\n    return new int[]{x, y};\n  }\n  public void recover(TreeNode r, int count, int x, int y) {\n    if (r != null) {\n      if (r.val == x || r.val == y) {\n        r.val = r.val == x ? y : x;\n        if (--count == 0) return;\n      }\n      recover(r.left, count, x, y);\n      recover(r.right, count, x, y);\n    }\n  }\n  public void recoverTree(TreeNode root) {\n    List<Integer> nums = new ArrayList();\n    inorder(root, nums);\n    int[] swapped = findTwoSwapped(nums);\n    recover(root, 2, swapped[0], swapped[1]);\n  }\n}\n", "class Solution {\n  public void swap(TreeNode a, TreeNode b) {\n    int tmp = a.val;\n    a.val = b.val;\n    b.val = tmp;\n  }\n  public void recoverTree(TreeNode root) {\n    Deque<TreeNode> stack = new ArrayDeque();\n    TreeNode x = null, y = null, pred = null;\n    while (!stack.isEmpty() || root != null) {\n      while (root != null) {\n        stack.add(root);\n        root = root.left;\n      }\n      root = stack.removeLast();\n      if (pred != null && root.val < pred.val) {\n        y = root;\n        if (x == null) x = pred;\n        else break;\n      }\n      pred = root;\n      root = root.right;\n    }\n    swap(x, y);\n  }\n}\n", "class Solution {\n  TreeNode x = null, y = null, pred = null;\n  public void swap(TreeNode a, TreeNode b) {\n    int tmp = a.val;\n    a.val = b.val;\n    b.val = tmp;\n  }\n  public void findTwoSwapped(TreeNode root) {\n    if (root == null) return;\n    findTwoSwapped(root.left);\n    if (pred != null && root.val < pred.val) {\n      y = root;\n      if (x == null) x = pred;\n      else return;\n    }\n    pred = root;\n    findTwoSwapped(root.right);\n  }\n  public void recoverTree(TreeNode root) {\n    findTwoSwapped(root);\n    swap(x, y);\n  }\n}\n", "class Solution {\n  public void swap(TreeNode a, TreeNode b) {\n    int tmp = a.val;\n    a.val = b.val;\n    b.val = tmp;\n  }\n  public void recoverTree(TreeNode root) {\n    // predecessor is a Morris predecessor. \n    // In the 'loop' cases it could be equal to the node itself predecessor == root.\n    // pred is a 'true' predecessor, \n    // the previous node in the inorder traversal.\n    TreeNode x = null, y = null, pred = null, predecessor = null;\n    while (root != null) {\n      // If there is a left child\n      // then compute the predecessor.\n      // If there is no link predecessor.right = root --> set it.\n      // If there is a link predecessor.right = root --> break it.\n      if (root.left != null) {\n        // Predecessor node is one step left \n        // and then right till you can.\n        predecessor = root.left;\n        while (predecessor.right != null && predecessor.right != root)\n          predecessor = predecessor.right;\n        // set link predecessor.right = root\n        // and go to explore left subtree\n        if (predecessor.right == null) {\n          predecessor.right = root;\n          root = root.left;\n        }\n        // break link predecessor.right = root\n        // link is broken : time to change subtree and go right\n        else {\n          // check for the swapped nodes\n          if (pred != null && root.val < pred.val) {\n            y = root;\n            if (x == null) x = pred;\n          }\n          pred = root;\n          predecessor.right = null;\n          root = root.right;\n        }\n      }\n      // If there is no left child\n      // then just go right.\n      else {\n        // check for the swapped nodes\n        if (pred != null && root.val < pred.val) {\n          y = root;\n          if (x == null) x = pred;\n        }\n        pred = root;\n        root = root.right;\n      }\n    }\n    swap(x, y);\n  }\n}\n"]}
{"number": 100, "statement": "Given two binary trees, write a function to check if they are the same or not.\nTwo binary trees are considered the same if they are structurally identical and the nodes have the same value.\n", "solutions": ["/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n  public boolean isSameTree(TreeNode p, TreeNode q) {\n    // p and q are both null\n    if (p == null && q == null) return true;\n    // one of p and q is null\n    if (q == null || p == null) return false;\n    if (p.val != q.val) return false;\n    return isSameTree(p.right, q.right) &&\n            isSameTree(p.left, q.left);\n  }\n}\n", "class Solution {\n  public boolean check(TreeNode p, TreeNode q) {\n    // p and q are null\n    if (p == null && q == null) return true;\n    // one of p and q is null\n    if (q == null || p == null) return false;\n    if (p.val != q.val) return false;\n    return true;\n  }\n  public boolean isSameTree(TreeNode p, TreeNode q) {\n    if (p == null && q == null) return true;\n    if (!check(p, q)) return false;\n    // init deques\n    ArrayDeque<TreeNode> deqP = new ArrayDeque<TreeNode>();\n    ArrayDeque<TreeNode> deqQ = new ArrayDeque<TreeNode>();\n    deqP.addLast(p);\n    deqQ.addLast(q);\n    while (!deqP.isEmpty()) {\n      p = deqP.removeFirst();\n      q = deqQ.removeFirst();\n      if (!check(p, q)) return false;\n      if (p != null) {\n        // in Java nulls are not allowed in Deque\n        if (!check(p.left, q.left)) return false;\n        if (p.left != null) {\n          deqP.addLast(p.left);\n          deqQ.addLast(q.left);\n        }\n        if (!check(p.right, q.right)) return false;\n        if (p.right != null) {\n          deqP.addLast(p.right);\n          deqQ.addLast(q.right);\n        }\n      }\n    }\n    return true;\n  }\n}\n"]}
{"number": 101, "statement": "Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).\nFor example, this binary tree [1,2,2,3,4,4,3] is symmetric:\n    1\n   / \\\n  2   2\n / \\ / \\\n3  4 4  3\nBut the following [1,2,2,null,3,null,3] is not:\n    1\n   / \\\n  2   2\n   \\   \\\n   3    3\nFollow up: Solve it both recursively and iteratively.\n", "solutions": ["public boolean isSymmetric(TreeNode root) {\n    return isMirror(root, root);\n}\npublic boolean isMirror(TreeNode t1, TreeNode t2) {\n    if (t1 == null && t2 == null) return true;\n    if (t1 == null || t2 == null) return false;\n    return (t1.val == t2.val)\n        && isMirror(t1.right, t2.left)\n        && isMirror(t1.left, t2.right);\n}\n", "public boolean isSymmetric(TreeNode root) {\n    Queue<TreeNode> q = new LinkedList<>();\n    q.add(root);\n    q.add(root);\n    while (!q.isEmpty()) {\n        TreeNode t1 = q.poll();\n        TreeNode t2 = q.poll();\n        if (t1 == null && t2 == null) continue;\n        if (t1 == null || t2 == null) return false;\n        if (t1.val != t2.val) return false;\n        q.add(t1.left);\n        q.add(t2.right);\n        q.add(t1.right);\n        q.add(t2.left);\n    }\n    return true;\n}\n"]}
{"number": 102, "statement": "Given a binary tree, return the level order traversal of its nodes' values. (ie, from left to right, level by level).\nFor example:\nGiven binary tree [3,9,20,null,null,15,7],\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\nreturn its level order traversal as:\n[\n  [3],\n  [9,20],\n  [15,7]\n]\n", "solutions": ["class Solution {\n    List<List<Integer>> levels = new ArrayList<List<Integer>>();\n    public void helper(TreeNode node, int level) {\n        // start the current level\n        if (levels.size() == level)\n            levels.add(new ArrayList<Integer>());\n         // fulfil the current level\n         levels.get(level).add(node.val);\n         // process child nodes for the next level\n         if (node.left != null)\n            helper(node.left, level + 1);\n         if (node.right != null)\n            helper(node.right, level + 1);\n    }\n    \n    public List<List<Integer>> levelOrder(TreeNode root) {\n        if (root == null) return levels;\n        helper(root, 0);\n        return levels;\n    }\n}\n", "class Solution {\n  public List<List<Integer>> levelOrder(TreeNode root) {\n    List<List<Integer>> levels = new ArrayList<List<Integer>>();\n    if (root == null) return levels;\n    Queue<TreeNode> queue = new LinkedList<TreeNode>();\n    queue.add(root);\n    int level = 0;\n    while ( !queue.isEmpty() ) {\n      // start the current level\n      levels.add(new ArrayList<Integer>());\n      // number of elements in the current level\n      int level_length = queue.size();\n      for(int i = 0; i < level_length; ++i) {\n        TreeNode node = queue.remove();\n        // fulfill the current level\n        levels.get(level).add(node.val);\n        // add child nodes of the current level\n        // in the queue for the next level\n        if (node.left != null) queue.add(node.left);\n        if (node.right != null) queue.add(node.right);\n      }\n      // go to next level\n      level++;\n    }\n    return levels;\n  }\n}\n"]}
{"number": 103, "statement": "Given a binary tree, return the zigzag level order traversal of its nodes' values. (ie, from left to right, then right to left for the next level and alternate between).\nFor example:\nGiven binary tree [3,9,20,null,null,15,7],\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\nreturn its zigzag level order traversal as:\n[\n  [3],\n  [20,9],\n  [15,7]\n]\n", "solutions": ["/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n  public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\n    if (root == null) {\n      return new ArrayList<List<Integer>>();\n    }\n    List<List<Integer>> results = new ArrayList<List<Integer>>();\n    // add the root element with a delimiter to kick off the BFS loop\n    LinkedList<TreeNode> node_queue = new LinkedList<TreeNode>();\n    node_queue.addLast(root);\n    node_queue.addLast(null);\n    LinkedList<Integer> level_list = new LinkedList<Integer>();\n    boolean is_order_left = true;\n    while (node_queue.size() > 0) {\n      TreeNode curr_node = node_queue.pollFirst();\n      if (curr_node != null) {\n        if (is_order_left)\n          level_list.addLast(curr_node.val);\n        else\n          level_list.addFirst(curr_node.val);\n        if (curr_node.left != null)\n          node_queue.addLast(curr_node.left);\n        if (curr_node.right != null)\n          node_queue.addLast(curr_node.right);\n      } else {\n        // we finish the scan of one level\n        results.add(level_list);\n        level_list = new LinkedList<Integer>();\n        // prepare for the next level\n        if (node_queue.size() > 0)\n          node_queue.addLast(null);\n        is_order_left = !is_order_left;\n      }\n    }\n    return results;\n  }\n}\n", "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n  protected void DFS(TreeNode node, int level, List<List<Integer>> results) {\n    if (level >= results.size()) {\n      LinkedList<Integer> newLevel = new LinkedList<Integer>();\n      newLevel.add(node.val);\n      results.add(newLevel);\n    } else {\n      if (level % 2 == 0)\n        results.get(level).add(node.val);\n      else\n        results.get(level).add(0, node.val);\n    }\n    if (node.left != null) DFS(node.left, level + 1, results);\n    if (node.right != null) DFS(node.right, level + 1, results);\n  }\n  public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\n    if (root == null) {\n      return new ArrayList<List<Integer>>();\n    }\n    List<List<Integer>> results = new ArrayList<List<Integer>>();\n    DFS(root, 0, results);\n    return results;\n  }\n}\n"]}
{"number": 104, "statement": "Given a binary tree, find its maximum depth.\nThe maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.\nNote:A leaf is a node with no children.\n", "solutions": ["/* Definition for a binary tree node. */\nstruct TreeNode {\n  int val;\n  TreeNode *left;\n  TreeNode *right;\n  TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n", "class Solution {\n  public:\n    int maxDepth(TreeNode *root) {\n      if (root == NULL) {\n        return 0;\n      }\n      return max(1 + maxDepth(root -> left), 1 + maxDepth(root -> right));\n    }\n};\n", "class Solution {\n  private:\n    // The queue that contains the next nodes to visit, \n    //   along with the level/depth that each node is located.\n    queue<pair<TreeNode*, int>> next_items;\n    int max_depth = 0;\n    \n    /**\n     * A tail recursion function to calculate the max depth\n     *   of the binary tree.\n     */\n    int next_maxDepth() {\n    \n      if (next_items.size() == 0) {\n        return max_depth;\n      }\n        \n      auto next_item = next_items.front();\n      next_items.pop();\n      auto next_node = next_item.first;\n      auto next_level = next_item.second + 1;\n      \n      max_depth = max(max_depth, next_level);\n      // Add the nodes to visit in the following recursive calls.\n      if (next_node->left != NULL) {\n        next_items.push(make_pair(next_node->left, next_level));\n      }\n      if (next_node->right != NULL) {\n        next_items.push(make_pair(next_node->right, next_level));\n      }\n    \n      // The last action should be the ONLY recursive call\n      //   in the tail-recursion function.\n      return next_maxDepth();\n    }\n    \n  public:\n    int maxDepth(TreeNode* root) {\n      if (root == NULL) return 0;\n        \n      // clear the previous queue.\n      std::queue<pair<TreeNode*, int>> empty;\n      std::swap(next_items, empty);\n      max_depth = 0;\n        \n      // push the root node into the queue to kick off the next visit.\n      next_items.push(make_pair(root, 0));\n        \n      return next_maxDepth();\n    }\n};\n", "class Solution {\n  public:\n  int maxDepth(TreeNode* root) {\n    if (root == NULL) {\n      return 0;\n    }\n    vector<pair<int, TreeNode*>> my_stack;\n    my_stack.push_back(pair<int, TreeNode*>(1, root));\n    int max_depth = 0;\n    while (!my_stack.empty()) {\n      pair<int, TreeNode*> my_pair = my_stack.back();\n      int c_depth = get<0>(my_pair);\n      TreeNode* c_node = get<1>(my_pair);\n      max_depth = max(max_depth, c_depth);\n      my_stack.pop_back();\n      if (c_node->left != NULL) {\n        my_stack.push_back(pair<int, TreeNode*>(c_depth + 1, c_node->left));\n      }\n      if (c_node->right != NULL) {\n        my_stack.push_back(pair<int, TreeNode*>(c_depth + 1, c_node->right));\n      }\n    }\n    return max_depth;\n  }\n};\n"]}
{"number": 105, "statement": "Given preorder and inorder traversal of a tree, construct the binary tree.\nNote:\nYou may assume that duplicates do not exist in the tree.\nFor example, given\npreorder =[3,9,20,15,7]\ninorder = [9,3,15,20,7]\nReturn the following binary tree:\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n", "solutions": ["// Definition for a binary tree node.\npublic class TreeNode {\n  int val;\n  TreeNode left;\n  TreeNode right;\n  TreeNode(int x) {\n    val = x;\n  }\n}\n", "class Solution {\n  // start from first preorder element\n  int pre_idx = 0;\n  int[] preorder;\n  int[] inorder;\n  HashMap<Integer, Integer> idx_map = new HashMap<Integer, Integer>();\n  public TreeNode helper(int in_left, int in_right) {\n    // if there is no elements to construct subtrees\n    if (in_left == in_right)\n      return null;\n    // pick up pre_idx element as a root\n    int root_val = preorder[pre_idx];\n    TreeNode root = new TreeNode(root_val);\n    // root splits inorder list\n    // into left and right subtrees\n    int index = idx_map.get(root_val);\n    // recursion \n    pre_idx++;\n    // build left subtree\n    root.left = helper(in_left, index);\n    // build right subtree\n    root.right = helper(index + 1, in_right);\n    return root;\n  }\n  public TreeNode buildTree(int[] preorder, int[] inorder) {\n    this.preorder = preorder;\n    this.inorder = inorder;\n    // build a hashmap value -> its index\n    int idx = 0;\n    for (Integer val : inorder)\n      idx_map.put(val, idx++);\n    return helper(0, inorder.length);\n  }\n}\n"]}
{"number": 106, "statement": "Given inorder and postorder traversal of a tree, construct the binary tree.\nNote:\nYou may assume that duplicates do not exist in the tree.\nFor example, given\ninorder =[9,3,15,20,7]\npostorder = [9,15,7,20,3]\nReturn the following binary tree:\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n", "solutions": ["class Solution {\n  int post_idx;\n  int[] postorder;\n  int[] inorder;\n  HashMap<Integer, Integer> idx_map = new HashMap<Integer, Integer>();\n  public TreeNode helper(int in_left, int in_right) {\n    // if there is no elements to construct subtrees\n    if (in_left > in_right)\n      return null;\n    // pick up post_idx element as a root\n    int root_val = postorder[post_idx];\n    TreeNode root = new TreeNode(root_val);\n    // root splits inorder list\n    // into left and right subtrees\n    int index = idx_map.get(root_val);\n    // recursion \n    post_idx--;\n    // build right subtree\n    root.right = helper(index + 1, in_right);\n    // build left subtree\n    root.left = helper(in_left, index - 1);\n    return root;\n  }\n  public TreeNode buildTree(int[] inorder, int[] postorder) {\n    this.postorder = postorder;\n    this.inorder = inorder;\n    // start from the last postorder element\n    post_idx = postorder.length - 1;\n    // build a hashmap value -> its index\n    int idx = 0;\n    for (Integer val : inorder)\n      idx_map.put(val, idx++);\n    return helper(0, inorder.length - 1);\n  }\n}\n"]}
{"number": 108, "statement": "Given an array where elements are sorted in ascending order, convert it to a height balanced BST.\nFor this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.\n", "solutions": ["class Solution {\n  int[] nums;\n  public TreeNode helper(int left, int right) {\n    if (left > right) return null;\n    // always choose left middle node as a root\n    int p = (left + right) / 2;\n    // inorder traversal: left -> node -> right\n    TreeNode root = new TreeNode(nums[p]);\n    root.left = helper(left, p - 1);\n    root.right = helper(p + 1, right);\n    return root;\n  }\n  public TreeNode sortedArrayToBST(int[] nums) {\n    this.nums = nums;\n    return helper(0, nums.length - 1);\n  }\n}\n", "class Solution {\n  int[] nums;\n  public TreeNode helper(int left, int right) {\n    if (left > right) return null;\n    // always choose right middle node as a root\n    int p = (left + right) / 2;\n    if ((left + right) % 2 == 1) ++p;\n    // inorder traversal: left -> node -> right\n    TreeNode root = new TreeNode(nums[p]);\n    root.left = helper(left, p - 1);\n    root.right = helper(p + 1, right);\n    return root;\n  }\n  public TreeNode sortedArrayToBST(int[] nums) {\n    this.nums = nums;\n    return helper(0, nums.length - 1);\n  }\n}\n", "class Solution {\n    int[] nums;\n    Random rand = new Random();\n    \n    public TreeNode helper(int left, int right) {\n        if (left > right) return null;\n        \n        // choose random middle node as a root\n        int p = (left + right) / 2; \n        if ((left + right) % 2 == 1) p += rand.nextInt(2);\n        // inorder traversal: left -> node -> right\n        TreeNode root = new TreeNode(nums[p]);\n        root.left = helper(left, p - 1);\n        root.right = helper(p + 1, right);\n        return root;\n    }\n    \n    public TreeNode sortedArrayToBST(int[] nums) {\n        this.nums = nums;\n        return helper(0, nums.length - 1);    \n    }\n}\n"]}
{"number": 109, "statement": "Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.\nFor this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.\n", "solutions": ["/**\n * Definition for singly-linked list. public class ListNode { int val; ListNode next; ListNode(int\n * x) { val = x; } }\n */\n/**\n * Definition for a binary tree node. public class TreeNode { int val; TreeNode left; TreeNode\n * right; TreeNode(int x) { val = x; } }\n */\nclass Solution {\n  private ListNode findMiddleElement(ListNode head) {\n    // The pointer used to disconnect the left half from the mid node.\n    ListNode prevPtr = null;\n    ListNode slowPtr = head;\n    ListNode fastPtr = head;\n    // Iterate until fastPr doesn't reach the end of the linked list.\n    while (fastPtr != null && fastPtr.next != null) {\n      prevPtr = slowPtr;\n      slowPtr = slowPtr.next;\n      fastPtr = fastPtr.next.next;\n    }\n    // Handling the case when slowPtr was equal to head.\n    if (prevPtr != null) {\n      prevPtr.next = null;\n    }\n    return slowPtr;\n  }\n  public TreeNode sortedListToBST(ListNode head) {\n    // If the head doesn't exist, then the linked list is empty\n    if (head == null) {\n      return null;\n    }\n    // Find the middle element for the list.\n    ListNode mid = this.findMiddleElement(head);\n    // The mid becomes the root of the BST.\n    TreeNode node = new TreeNode(mid.val);\n    // Base case when there is just one element in the linked list\n    if (head == mid) {\n      return node;\n    }\n    // Recursively form balanced BSTs using the left and right halves of the original list.\n    node.left = this.sortedListToBST(head);\n    node.right = this.sortedListToBST(mid.next);\n    return node;\n  }\n}\n", "/**\n * Definition for singly-linked list. public class ListNode { int val; ListNode next; ListNode(int\n * x) { val = x; } }\n */\n/**\n * Definition for a binary tree node. public class TreeNode { int val; TreeNode left; TreeNode\n * right; TreeNode(int x) { val = x; } }\n */\nclass Solution {\n  private List<Integer> values;\n  public Solution() {\n    this.values = new ArrayList<Integer>();\n  }\n  private void mapListToValues(ListNode head) {\n    while (head != null) {\n      this.values.add(head.val);\n      head = head.next;\n    }\n  }\n  private TreeNode convertListToBST(int left, int right) {\n    // Invalid case\n    if (left > right) {\n      return null;\n    }\n    // Middle element forms the root.\n    int mid = (left + right) / 2;\n    TreeNode node = new TreeNode(this.values.get(mid));\n    // Base case for when there is only one element left in the array\n    if (left == right) {\n      return node;\n    }\n    // Recursively form BST on the two halves\n    node.left = convertListToBST(left, mid - 1);\n    node.right = convertListToBST(mid + 1, right);\n    return node;\n  }\n  public TreeNode sortedListToBST(ListNode head) {\n    // Form an array out of the given linked list and then\n    // use the array to form the BST.\n    this.mapListToValues(head);\n    // Convert the array to\n    return convertListToBST(0, this.values.size() - 1);\n  }\n}\n", "/**\n * Definition for singly-linked list. public class ListNode { int val; ListNode next; ListNode(int\n * x) { val = x; } }\n */\n/**\n * Definition for a binary tree node. public class TreeNode { int val; TreeNode left; TreeNode\n * right; TreeNode(int x) { val = x; } }\n */\nclass Solution {\n  private ListNode head;\n  private int findSize(ListNode head) {\n    ListNode ptr = head;\n    int c = 0;\n    while (ptr != null) {\n      ptr = ptr.next;  \n      c += 1;\n    }\n    return c;\n  }\n  private TreeNode convertListToBST(int l, int r) {\n    // Invalid case\n    if (l > r) {\n      return null;\n    }\n    int mid = (l + r) / 2;\n    // First step of simulated inorder traversal. Recursively form\n    // the left half\n    TreeNode left = this.convertListToBST(l, mid - 1);\n    // Once left half is traversed, process the current node\n    TreeNode node = new TreeNode(this.head.val);\n    node.left = left;\n    // Maintain the invariance mentioned in the algorithm\n    this.head = this.head.next;\n    // Recurse on the right hand side and form BST out of them\n    node.right = this.convertListToBST(mid + 1, r);\n    return node;\n  }\n  public TreeNode sortedListToBST(ListNode head) {\n    // Get the size of the linked list first\n    int size = this.findSize(head);\n    this.head = head;\n    // Form the BST now that we know the size\n    return convertListToBST(0, size - 1);\n  }\n}\n"]}
{"number": 110, "statement": "Given a binary tree, determine if it is height-balanced.\nFor this problem, a height-balanced binary tree is defined as:\na binary tree in which the left and right subtrees of every node differ in height by no more than 1.\n", "solutions": ["class Solution {\nprivate:\n  // Recursively obtain the height of a tree. An empty tree has -1 height\n  int height(TreeNode* root) { \n    // An empty tree has height -1\n    if (root == NULL) {\n      return -1;\n    }\n    return 1 + max(height(root->left), height(root->right));\n  }\npublic:\n  bool isBalanced(TreeNode* root) {\n    // An empty tree satisfies the definition of a balanced tree\n    if (root == NULL) {\n      return true;\n    }\n    // Check if subtrees have height within 1. If they do, check if the\n    // subtrees are balanced\n    return abs(height(root->left) - height(root->right)) < 2 &&\n      isBalanced(root->left) &&\n      isBalanced(root->right);\n  }\n};\n", "class Solution {\nprivate:\n  // Return whether or not the tree at root is balanced while also storing\n  // the tree's height in a reference variable. \n  bool isBalancedTreeHelper(TreeNode* root, int& height) {\n    // An empty tree is balanced and has height = -1\n    if (root == NULL) {\n      height = -1;\n      return true;\n    }\n    // Check subtrees to see if they are balanced. If they are, check if the \n    // current node is also balanced using the heights obtained from the \n    // recursive calls.\n    int left, right;\n    if (isBalancedTreeHelper(root->left, left)  &&\n        isBalancedTreeHelper(root->right, right) &&\n        abs(left - right) < 2) {\n      // Store the current tree's height\n      height = max(left, right) + 1;\n      return true;\n    }\n    return false;\n  }\npublic:\n  bool isBalanced(TreeNode* root) {\n    int height;\n    return isBalancedTreeHelper(root, height);\n  }\n};\n"]}
{"number": 111, "statement": "Given a binary tree, find its minimum depth.\nThe minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.\nNote:A leaf is a node with no children.\n", "solutions": ["// Definition for a binary tree node.\npublic class TreeNode {\n  int val;\n  TreeNode left;\n  TreeNode right;\n  TreeNode(int x) {\n    val = x;\n  }\n}\n", "class Solution {\n  public int minDepth(TreeNode root) {\n    if (root == null) {\n      return 0;\n    }\n    if ((root.left == null) && (root.right == null)) {\n      return 1;\n    }\n    int min_depth = Integer.MAX_VALUE;\n    if (root.left != null) {\n      min_depth = Math.min(minDepth(root.left), min_depth);\n    }\n    if (root.right != null) {\n      min_depth = Math.min(minDepth(root.right), min_depth);\n    }\n    return min_depth + 1;\n  }\n}\n", "class Solution {\n  public int minDepth(TreeNode root) {\n    LinkedList<Pair<TreeNode, Integer>> stack = new LinkedList<>();\n    if (root == null) {\n      return 0;\n    }\n    else {\n      stack.add(new Pair(root, 1));\n    }\n    int min_depth = Integer.MAX_VALUE;\n    while (!stack.isEmpty()) {\n      Pair<TreeNode, Integer> current = stack.pollLast();\n      root = current.getKey();\n      int current_depth = current.getValue();\n      if ((root.left == null) && (root.right == null)) {\n        min_depth = Math.min(min_depth, current_depth);\n      }\n      if (root.left != null) {\n        stack.add(new Pair(root.left, current_depth + 1));\n      }\n      if (root.right != null) {\n        stack.add(new Pair(root.right, current_depth + 1));\n      }\n    }\n    return min_depth;\n  }\n}\n", "class Solution {\n  public int minDepth(TreeNode root) {\n    LinkedList<Pair<TreeNode, Integer>> stack = new LinkedList<>();\n    if (root == null) {\n      return 0;\n    }\n    else {\n      stack.add(new Pair(root, 1));\n    }\n    int current_depth = 0;\n    while (!stack.isEmpty()) {\n      Pair<TreeNode, Integer> current = stack.poll();\n      root = current.getKey();\n      current_depth = current.getValue();\n      if ((root.left == null) && (root.right == null)) {\n        break;\n      }\n      if (root.left != null) {\n        stack.add(new Pair(root.left, current_depth + 1));\n      }\n      if (root.right != null) {\n        stack.add(new Pair(root.right, current_depth + 1));\n      }\n    }\n    return current_depth;\n  }\n}\n"]}
{"number": 112, "statement": "Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.\nNote:A leaf is a node with no children.\n", "solutions": ["/* Definition for a binary tree node. */\npublic class TreeNode {\n  int val;\n  TreeNode left;\n  TreeNode right;\n  TreeNode(int x) {\n    val = x;\n  }\n}\n", "class Solution {\n  public boolean hasPathSum(TreeNode root, int sum) {\n    if (root == null)\n      return false;\n    sum -= root.val;\n    if ((root.left == null) && (root.right == null))\n      return (sum == 0);\n    return hasPathSum(root.left, sum) || hasPathSum(root.right, sum);\n  }\n}\n", "class Solution {\n  public boolean hasPathSum(TreeNode root, int sum) {\n    if (root == null)\n      return false;\n    LinkedList<TreeNode> node_stack = new LinkedList();\n    LinkedList<Integer> sum_stack = new LinkedList();\n    node_stack.add(root);\n    sum_stack.add(sum - root.val);\n    TreeNode node;\n    int curr_sum;\n    while ( !node_stack.isEmpty() ) {\n      node = node_stack.pollLast();\n      curr_sum = sum_stack.pollLast();\n      if ((node.right == null) && (node.left == null) && (curr_sum == 0))\n        return true;\n      if (node.right != null) {\n        node_stack.add(node.right);\n        sum_stack.add(curr_sum - node.right.val);\n      }\n      if (node.left != null) {\n        node_stack.add(node.left);\n        sum_stack.add(curr_sum - node.left.val);\n      }\n    }\n    return false;\n  }\n}\n"]}
{"number": 113, "statement": "Given a binary tree and a sum, find all root-to-leaf paths where each path's sum equals the given sum.\nNote:A leaf is a node with no children.\n", "solutions": ["/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    \n    private void recurseTree(TreeNode node, int remainingSum, List<Integer> pathNodes, List<List<Integer>> pathsList) {\n        \n        if (node == null) {\n            return;\n        }\n        \n        // Add the current node to the path's list\n        pathNodes.add(node.val);\n        \n        // Check if the current node is a leaf and also, if it\n        // equals our remaining sum. If it does, we add the path to\n        // our list of paths\n        if (remainingSum == node.val && node.left == null && node.right == null) {\n            pathsList.add(new ArrayList<>(pathNodes));\n        } else {\n            \n            // Else, we will recurse on the left and the right children\n            this.recurseTree(node.left, remainingSum - node.val, pathNodes, pathsList);\n            this.recurseTree(node.right, remainingSum - node.val, pathNodes, pathsList);\n        }\n        \n        // We need to pop the node once we are done processing ALL of it's\n        // subtrees.\n        pathNodes.remove(pathNodes.size() - 1);\n    }\n    \n    public List<List<Integer>> pathSum(TreeNode root, int sum) {\n        List<List<Integer>> pathsList = new ArrayList<List<Integer>>();\n        List<Integer> pathNodes = new ArrayList<Integer>();\n        this.recurseTree(root, sum, pathNodes, pathsList);\n        return pathsList;        \n    }\n}\n"]}
{"number": 114, "statement": "Given a binary tree, flatten it to a linked list in-place.\nFor example, given the following tree:\n    1\n   / \\\n  2   5\n / \\   \\\n3   4   6\nThe flattened tree should look like:\n1\n \\\n  2\n   \\\n    3\n     \\\n      4\n       \\\n        5\n         \\\n          6\n", "solutions": ["/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    \n    private TreeNode flattenTree(TreeNode node) {\n        \n        // Handle the null scenario\n        if (node == null) {\n            return null;\n        }\n            \n        // For a leaf node, we simply return the\n        // node as is.\n        if (node.left == null && node.right == null) {\n            return node;\n        }\n        \n        //Recursively flatten the left subtree\n        TreeNode leftTail = this.flattenTree(node.left);\n        \n        // Recursively flatten the right subtree\n        TreeNode rightTail = this.flattenTree(node.right);\n        \n        // If there was a left subtree, we shuffle the connections\n        // around so that there is nothing on the left side\n        // anymore.\n        if (leftTail != null) {\n            leftTail.right = node.right;\n            node.right = node.left;\n            node.left = null;\n        }\n        \n        // We need to return the \"rightmost\" node after we are\n        // done wiring the new connections. \n        return rightTail == null ? leftTail : rightTail;\n    }\n    \n    public void flatten(TreeNode root) {\n        \n        this.flattenTree(root);\n    }\n}\n", "class Pair<K, V> {\n    K key;\n    V value;\n    Pair(K a, V b) {\n        this.key = a;\n        this.value = b;\n    }\n    public K getKey() {\n        return this.key;\n    }\n    public V getValue() {\n        return this.value;\n    }\n}\nclass Solution {\n   \n    public void flatten(TreeNode root) {\n        \n        // Handle the null scenario\n        if (root == null) {\n            return;\n        }\n            \n        int START = 1, END = 2;\n        \n        TreeNode tailNode = null;\n        Stack<Pair<TreeNode, Integer>> stack = new Stack<Pair<TreeNode, Integer>>();\n        stack.push(new Pair<TreeNode, Integer>(root, START));\n        \n        while (!stack.isEmpty()) {\n            \n            Pair<TreeNode, Integer> nodeData = stack.pop();\n            TreeNode currentNode = nodeData.getKey();\n            int recursionState = nodeData.getValue();\n            \n            // We reached a leaf node. Record this as a tail\n            // node and move on.\n            if (currentNode.left == null && currentNode.right == null) {\n                tailNode = currentNode;\n                continue;\n            }\n            \n            // If the node is in the START state, it means we still\n            // haven't processed it's left child yet.\n            if (recursionState == START) {\n                \n                // If the current node has a left child, we add it\n                // to the stack AFTER adding the current node again\n                // to the stack with the END recursion state. \n                if (currentNode.left != null) {\n                    \n                    stack.push(new Pair<TreeNode, Integer>(currentNode, END));\n                    stack.push(new Pair<TreeNode, Integer>(currentNode.left, START));\n                    \n                } else if (currentNode.right != null) {\n                    \n                    // In case the current node didn't have a left child\n                    // we will add it's right child\n                    stack.push(new Pair<TreeNode, Integer>(currentNode.right, START));\n                }\n                   \n            } else {\n                \n                // If the current node is in the END recursion state,\n                // that means we did process one of it's children. Left\n                // if it existed, else right.\n                TreeNode rightNode = currentNode.right;\n                \n                // If there was a left child, there must have been a leaf\n                // node and so, we would have set the tailNode\n                if (tailNode != null) {\n                    \n                    // Establish the proper connections. \n                    tailNode.right = currentNode.right;\n                    currentNode.right = currentNode.left;\n                    currentNode.left = null;\n                    rightNode = tailNode.right;\n                \n                }\n                    \n                if (rightNode != null) {\n                    stack.push(new Pair<TreeNode, Integer>(rightNode, START));\n                }\n            }\n        }\n    }\n}\n", "class Solution {\n   \n    public void flatten(TreeNode root) {\n        \n        // Handle the null scenario\n        if (root == null) {\n            return;\n        }\n        \n        TreeNode node = root;\n        \n        while (node != null) {\n            \n            // If the node has a left child\n            if (node.left != null) {\n                \n                // Find the rightmost node\n                TreeNode rightmost = node.left;\n                while (rightmost.right != null) {\n                    rightmost = rightmost.right;\n                }\n                \n                // rewire the connections\n                rightmost.right = node.right;\n                node.right = node.left;\n                node.left = null;\n            }\n            \n            // move on to the right side of the tree\n            node = node.right;\n        }\n    }\n}\n"]}
{"number": 115, "statement": "Given a string S and a string T, count the number of distinct subsequences of S which equals T.\nA subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, \"ACE\" is a subsequence of \"ABCDE\" while \"AEC\" is not).\nIt's guaranteed the answer fits on a 32-bit signed integer.\n", "solutions": ["class Solution {\n    \n    // Dictionary that we will use for memoization\n    private HashMap<Pair<Integer, Integer>, Integer> memo;\n    \n    private int recurse(String s, String t, int i, int j) {\n        \n        int M = s.length();\n        int N = t.length();\n        \n        // Base case\n        if (i == M || j == N || M - i < N - j) {\n            return j == t.length() ? 1 : 0;\n        }\n        \n        Pair<Integer, Integer> key = new Pair<Integer, Integer>(i, j);\n        \n        // Check to see if the result for this recursive\n        // call is already cached\n        if (this.memo.containsKey(key)) {\n            return this.memo.get(key);\n        }\n        \n        // Always calculate this result since it's\n        // required for both the cases\n        int ans = this.recurse(s, t, i + 1, j);\n        \n        // If the characters match, then we make another\n        // recursion call and add the result to \"ans\"\n        if (s.charAt(i) == t.charAt(j)) {\n            ans += this.recurse(s, t, i + 1, j + 1);\n        }\n        \n        // Cache the result\n        this.memo.put(key, ans);\n        return ans;\n    }\n    \n    public int numDistinct(String s, String t) {\n        \n        this.memo = new HashMap<Pair<Integer, Integer>, Integer>();        \n        return this.recurse(s, t, 0, 0);\n    }\n}\n", "class Solution {\n    \n    public int numDistinct(String s, String t) {\n        int M = s.length();\n        int N = t.length();\n        \n        int[][] dp = new int[M + 1][N + 1];\n        \n        // Base case initialization\n        for (int j = 0; j <= N; j++) {\n            dp[M][j] = 0;\n        }\n        \n        // Base case initialization\n        for (int i = 0; i <= M; i++) {\n            dp[i][N] = 1;\n        }\n        \n        // Iterate over the strings in reverse so as to\n        // satisfy the way we've modeled our recursive solution\n        for (int i = M - 1; i >= 0; i--) {\n            for (int j = N - 1; j >= 0; j--) {\n                \n                // Remember, we always need this result\n                dp[i][j] = dp[i + 1][j];\n                // If the characters match, we add the\n                // result of the next recursion call (in this\n                // case, the value of a cell in the dp table\n                if (s.charAt(i) == t.charAt(j)) {\n                    dp[i][j] += dp[i + 1][j + 1];\n                }\n            }\n        }\n        \n        return dp[0][0];\n    }\n}\n", "class Solution {\n    \n    public int numDistinct(String s, String t) {\n        int M = s.length();\n        int N = t.length();\n        \n        int[] dp = new int[N];\n        \n        int prev = 1;\n        \n        // Iterate over the strings in reverse so as to\n        // satisfy the way we've modeled our recursive solution\n        for (int i = M - 1; i >= 0; i--) {\n                \n                // At each step we start with the last value in\n                // the row which is always 1. Notice how we are\n                // starting the loop from N - 1 instead of N like\n                // in the previous solution.\n                prev = 1;\n                for (int j = N - 1; j >= 0; j--) {\n                    // Record the current value in this cell so that\n                    // we can use it to calculate the value of dp[j - 1]\n                    int old_dpj = dp[j];\n                    // If the characters match, we add the\n                    // result of the next recursion call (in this\n                    // case, the value of a cell in the dp table\n                    if (s.charAt(i) == t.charAt(j)) {\n                        dp[j] += prev;\n                    }\n                    // Update the prev variable\n                    prev = old_dpj;    \n            }\n        }\n        \n        return dp[0];\n    }\n}\n"]}
{"number": 116, "statement": "You are given a perfect binary treewhereall leaves are on the same level, and every parent has two children. The binary tree has the following definition:\nstruct Node {\n  int val;\n  Node *left;\n  Node *right;\n  Node *next;\n}\nPopulate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.\nInitially, all next pointers are set to NULL.\nFollow up:\nYou may only use constant extra space.\nRecursive approach is fine, you may assume implicit stack space does not count as extra space for this problem.\n", "solutions": ["class Solution {\n    public Node connect(Node root) {\n        \n        if (root == null) {\n            return root;\n        }\n        \n        // Initialize a queue data structure which contains\n        // just the root of the tree\n        Queue<Node> Q = new LinkedList<Node>(); \n        Q.add(root);\n        \n        // Outer while loop which iterates over \n        // each level\n        while (Q.size() > 0) {\n            \n            // Note the size of the queue\n            int size = Q.size();\n            \n            // Iterate over all the nodes on the current level\n            for(int i = 0; i < size; i++) {\n                \n                // Pop a node from the front of the queue\n                Node node = Q.poll();\n                \n                // This check is important. We don't want to\n                // establish any wrong connections. The queue will\n                // contain nodes from 2 levels at most at any\n                // point in time. This check ensures we only \n                // don't establish next pointers beyond the end\n                // of a level\n                if (i < size - 1) {\n                    node.next = Q.peek();\n                }\n                \n                // Add the children, if any, to the back of\n                // the queue\n                if (node.left != null) {\n                    Q.add(node.left);\n                }\n                if (node.right != null) {\n                    Q.add(node.right);\n                }\n            }\n        }\n        \n        // Since the tree has now been modified, return the root node\n        return root;\n    }\n}\n", "class Solution {\n    public Node connect(Node root) {\n        \n        if (root == null) {\n            return root;\n        }\n        \n        // Start with the root node. There are no next pointers\n        // that need to be set up on the first level\n        Node leftmost = root;\n        \n        // Once we reach the final level, we are done\n        while (leftmost.left != null) {\n            \n            // Iterate the \"linked list\" starting from the head\n            // node and using the next pointers, establish the \n            // corresponding links for the next level\n            Node head = leftmost;\n            \n            while (head != null) {\n                \n                // CONNECTION 1\n                head.left.next = head.right;\n                \n                // CONNECTION 2\n                if (head.next != null) {\n                    head.right.next = head.next.left;\n                }\n                \n                // Progress along the list (nodes on the current level)\n                head = head.next;\n            }\n            \n            // Move onto the next level\n            leftmost = leftmost.left;\n        }\n        \n        return root;\n    }\n}\n"]}
{"number": 117, "statement": "Given a binary tree\nstruct Node {\n  int val;\n  Node *left;\n  Node *right;\n  Node *next;\n}\nPopulate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.\nInitially, all next pointers are set to NULL.\nFollow up:\nYou may only use constant extra space.\nRecursive approach is fine, you may assume implicit stack space does not count as extra space for this problem.\n", "solutions": ["class Solution {\n    public Node connect(Node root) {\n        \n        if (root == null) {\n            return root;\n        }\n        \n        // Initialize a queue data structure which contains\n        // just the root of the tree\n        Queue<Node> Q = new LinkedList<Node>(); \n        Q.add(root);\n        \n        // Outer while loop which iterates over \n        // each level\n        while (Q.size() > 0) {\n            \n            // Note the size of the queue\n            int size = Q.size();\n            \n            // Iterate over all the nodes on the current level\n            for(int i = 0; i < size; i++) {\n                \n                // Pop a node from the front of the queue\n                Node node = Q.poll();\n                \n                // This check is important. We don't want to\n                // establish any wrong connections. The queue will\n                // contain nodes from 2 levels at most at any\n                // point in time. This check ensures we only \n                // don't establish next pointers beyond the end\n                // of a level\n                if (i < size - 1) {\n                    node.next = Q.peek();\n                }\n                \n                // Add the children, if any, to the back of\n                // the queue\n                if (node.left != null) {\n                    Q.add(node.left);\n                }\n                if (node.right != null) {\n                    Q.add(node.right);\n                }\n            }\n        }\n        \n        // Since the tree has now been modified, return the root node\n        return root;\n    }\n}\n", "class Solution {\n    \n    Node prev, leftmost;\n    \n    public void processChild(Node childNode) {\n        \n        if (childNode != null) {\n            \n            // If the \"prev\" pointer is alread set i.e. if we\n            // already found atleast one node on the next level,\n            // setup its next pointer\n            if (this.prev != null) {\n                this.prev.next = childNode;\n                    \n            } else {\n                \n                // Else it means this child node is the first node\n                // we have encountered on the next level, so, we\n                // set the leftmost pointer\n                this.leftmost = childNode;\n            }    \n                \n            this.prev = childNode; \n        }\n    }\n        \n    public Node connect(Node root) {\n        \n        if (root == null) {\n            return root;\n        }\n        \n        // The root node is the only node on the first level\n        // and hence its the leftmost node for that level\n        this.leftmost = root;\n        \n        // Variable to keep track of leading node on the \"current\" level\n        Node curr = leftmost;\n        \n        // We have no idea about the structure of the tree,\n        // so, we keep going until we do find the last level.\n        // the nodes on the last level won't have any children\n        while (this.leftmost != null) {\n            \n            // \"prev\" tracks the latest node on the \"next\" level\n            // while \"curr\" tracks the latest node on the current\n            // level.\n            this.prev = null;\n            curr = this.leftmost;\n            \n            // We reset this so that we can re-assign it to the leftmost\n            // node of the next level. Also, if there isn't one, this\n            // would help break us out of the outermost loop.\n            this.leftmost = null;\n            \n            // Iterate on the nodes in the current level using\n            // the next pointers already established.\n            while (curr != null) {\n                \n                // Process both the children and update the prev\n                // and leftmost pointers as necessary.\n                this.processChild(curr.left);\n                this.processChild(curr.right);\n                \n                // Move onto the next node.\n                curr = curr.next;\n            }\n        }\n                \n        return root ;\n    }\n}\n"]}
{"number": 118, "statement": "Given a non-negative integernumRows, generate the first numRows of Pascal's triangle.\nIn Pascal's triangle, each number is the sum of the two numbers directly above it.\n", "solutions": ["class Solution {\n    public List<List<Integer>> generate(int numRows) {\n        List<List<Integer>> triangle = new ArrayList<List<Integer>>();\n        // First base case; if user requests zero rows, they get zero rows.\n        if (numRows == 0) {\n            return triangle;\n        }\n        // Second base case; first row is always [1].\n        triangle.add(new ArrayList<>());\n        triangle.get(0).add(1);\n        for (int rowNum = 1; rowNum < numRows; rowNum++) {\n            List<Integer> row = new ArrayList<>();\n            List<Integer> prevRow = triangle.get(rowNum-1);\n            // The first row element is always 1.\n            row.add(1);\n            // Each triangle element (other than the first and last of each row)\n            // is equal to the sum of the elements above-and-to-the-left and\n            // above-and-to-the-right.\n            for (int j = 1; j < rowNum; j++) {\n                row.add(prevRow.get(j-1) + prevRow.get(j));\n            }\n            // The last row element is always 1.\n            row.add(1);\n            triangle.add(row);\n        }\n        return triangle;\n    }\n}\n"]}
{"number": 119, "statement": "Given a non-negativeindex kwhere k \u226433, return the kthindex row of the Pascal's triangle.\nNote that the row index starts from0.\nIn Pascal's triangle, each number is the sum of the two numbers directly above it.\n", "solutions": ["class Solution {\n public:\n  int getNum(int row, int col) {\n    if (row == 0 || col == 0 || row == col)\n      return 1;\n    return getNum(row - 1, col - 1) + getNum(row - 1, col);\n  }\n  vector<int> getRow(int rowIndex) {\n    vector<int> ans;\n    for (int i = 0; i <= rowIndex; i++)\n      ans.push_back(getNum(rowIndex, i));\n    return ans;\n  }\n};\n", "class Solution {\n  unordered_map<size_t, int> cache;\n  // use a better hashing function like `boost::hash_combine` in the real world.\n  int key(int i, int j) const {\n    size_t hash_i = hash<int>{}(i), hash_j = hash<int>{}(j);\n    int hashed = (int)(hash_i ^ (hash_i >> 32));\n    return (hashed << 5) - 1 + (int)(hash_j ^ (hash_j >> 32));\n  }\n public:\n  int getNum(int row, int col) {\n    auto rowCol = key(row, col);\n    if (cache.count(rowCol) > 0)\n      return cache[rowCol];\n    if (row == 0 || col == 0 || row == col)\n      return (cache[rowCol] = 1);\n    return (cache[rowCol] = getNum(row - 1, col - 1) + getNum(row - 1, col));\n  }\n  vector<int> getRow(int rowIndex) {\n    vector<int> ans;\n    for (int i = 0; i <= rowIndex; i++)\n      ans.push_back(getNum(rowIndex, i));\n    return ans;\n  }\n};\n", "class Solution {\n public:\n  vector<int> getRow(int rowIndex) {\n    vector<int> curr, prev = {1};\n    for (int i = 1; i <= rowIndex; i++) {\n      curr.assign(i + 1, 1);\n      for (int j = 1; j < i; j++)\n        curr[j] = prev[j - 1] + prev[j];\n      prev = move(curr);  // This is O(1)\n    }\n    return prev;\n  }\n};\n", "class Solution {\n public:\n  vector<int> getRow(int rowIndex) {\n    vector<int> ans = vector<int>(rowIndex + 1, 1);\n    for (int i = 1; i < rowIndex; i++)\n      for (int j = i; j > 0; j--)\n        ans[j] += ans[j - 1];  // ans[j] = ans[j-1] + ans[j]\n    return ans;\n  }\n};\n", "class Solution {\n public:\n  vector<int> getRow(int n) {\n    vector<int> ans = {1};\n    for (int k = 1; k <= n; k++)\n      ans.push_back((int)((ans.back() * (long long)(n - k + 1)) / k));\n    return ans;\n  }\n};\n"]}
{"number": 121, "statement": "Say you have an array for which the ith element is the price of a given stock on day i.\nIf you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit.\nNote that you cannot sell a stock before you buy one.\n", "solutions": ["public class Solution {\n    public int maxProfit(int prices[]) {\n        int maxprofit = 0;\n        for (int i = 0; i < prices.length - 1; i++) {\n            for (int j = i + 1; j < prices.length; j++) {\n                int profit = prices[j] - prices[i];\n                if (profit > maxprofit)\n                    maxprofit = profit;\n            }\n        }\n        return maxprofit;\n    }\n}\n", "public class Solution {\n    public int maxProfit(int prices[]) {\n        int minprice = Integer.MAX_VALUE;\n        int maxprofit = 0;\n        for (int i = 0; i < prices.length; i++) {\n            if (prices[i] < minprice)\n                minprice = prices[i];\n            else if (prices[i] - minprice > maxprofit)\n                maxprofit = prices[i] - minprice;\n        }\n        return maxprofit;\n    }\n}\n"]}
{"number": 122, "statement": "Say you have an array prices for which the ith element is the price of a given stock on day i.\nDesign an algorithm to find the maximum profit. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times).\nNote: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).\n", "solutions": ["class Solution {\n    public int maxProfit(int[] prices) {\n        return calculate(prices, 0);\n    }\n    public int calculate(int prices[], int s) {\n        if (s >= prices.length)\n            return 0;\n        int max = 0;\n        for (int start = s; start < prices.length; start++) {\n            int maxprofit = 0;\n            for (int i = start + 1; i < prices.length; i++) {\n                if (prices[start] < prices[i]) {\n                    int profit = calculate(prices, i + 1) + prices[i] - prices[start];\n                    if (profit > maxprofit)\n                        maxprofit = profit;\n                }\n            }\n            if (maxprofit > max)\n                max = maxprofit;\n        }\n        return max;\n    }\n}\n", "class Solution {\n    public int maxProfit(int[] prices) {\n        int i = 0;\n        int valley = prices[0];\n        int peak = prices[0];\n        int maxprofit = 0;\n        while (i < prices.length - 1) {\n            while (i < prices.length - 1 && prices[i] >= prices[i + 1])\n                i++;\n            valley = prices[i];\n            while (i < prices.length - 1 && prices[i] <= prices[i + 1])\n                i++;\n            peak = prices[i];\n            maxprofit += peak - valley;\n        }\n        return maxprofit;\n    }\n}\n", "class Solution {\n    public int maxProfit(int[] prices) {\n        int maxprofit = 0;\n        for (int i = 1; i < prices.length; i++) {\n            if (prices[i] > prices[i - 1])\n                maxprofit += prices[i] - prices[i - 1];\n        }\n        return maxprofit;\n    }\n}\n"]}
{"number": 123, "statement": "Say you have an array for which the ith element is the price of a given stock on day i.\nDesign an algorithm to find the maximum profit. You may complete at most two transactions.\nNote:You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).\n", "solutions": ["class Solution {\n  public:\n  int maxProfit(vector<int>& prices) {\n    int length = prices.size();\n    if (length <= 1) return 0;\n    int leftMin = prices[0];\n    int rightMax = prices[length - 1];\n    vector<int> leftProfits(length, 0);\n    // pad the right DP array with an additional zero for convenience.\n    vector<int> rightProfits(length + 1, 0);\n    // construct the bidirectional DP array\n    for (int l = 1; l < length; ++l) {\n      leftProfits[l] = max(leftProfits[l - 1], prices[l] - leftMin);\n      leftMin = min(leftMin, prices[l]);\n      int r = length - 1 - l;\n      rightProfits[r] = max(rightProfits[r + 1], rightMax - prices[r]);\n      rightMax = max(rightMax, prices[r]);\n    }\n    int maxProfit = 0;\n    for (int i = 0; i < length; ++i) {\n      maxProfit = max(maxProfit, leftProfits[i] + rightProfits[i + 1]);\n    }\n    return maxProfit;\n  }\n};\n", "class Solution {\n  public:\n  int maxProfit(vector<int>& prices) {\n    int t1Cost = INT_MAX, \n        t2Cost = INT_MAX;\n    int t1Profit = 0,\n        t2Profit = 0;\n    for (int price : prices) {\n        // the maximum profit if only one transaction is allowed\n        t1Cost = min(t1Cost, price);\n        t1Profit = max(t1Profit, price - t1Cost);\n        // re-invest the gained profit in the second transaction\n        t2Cost = min(t2Cost, price - t1Profit);\n        t2Profit = max(t2Profit, price - t2Cost);\n    }\n    return t2Profit;\n  }\n};\n"]}
{"number": 124, "statement": "Given a non-empty binary tree, find the maximum path sum.\nFor this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root.\n", "solutions": ["/* Definition for a binary tree node. */\npublic class TreeNode {\n  int val;\n  TreeNode left;\n  TreeNode right;\n  TreeNode(int x) {\n    val = x;\n  }\n}\n", "class Solution {\n  int max_sum = Integer.MIN_VALUE;\n  public int max_gain(TreeNode node) {\n    if (node == null) return 0;\n    // max sum on the left and right sub-trees of node\n    int left_gain = Math.max(max_gain(node.left), 0);\n    int right_gain = Math.max(max_gain(node.right), 0);\n    // the price to start a new path where `node` is a highest node\n    int price_newpath = node.val + left_gain + right_gain;\n    // update max_sum if it's better to start a new path\n    max_sum = Math.max(max_sum, price_newpath);\n    // for recursion :\n    // return the max gain if continue the same path\n    return node.val + Math.max(left_gain, right_gain);\n  }\n  public int maxPathSum(TreeNode root) {\n    max_gain(root);\n    return max_sum;\n  }\n}\n"]}
{"number": 125, "statement": "Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.\nNote:For the purpose of this problem, we define empty string as valid palindrome.\n", "solutions": ["class Solution {\n public:\n  bool isPalindrome(string s) {\n    string filtered_string, reversed_string;\n    for (auto ch : s) {\n      if (isalnum(ch))\n        filtered_string += tolower(ch);\n    }\n    reversed_string.resize(filtered_string.size());\n    reverse_copy(filtered_string.begin(), filtered_string.end(),\n                 reversed_string.begin());\n    return filtered_string == reversed_string;\n  }\n};\n", "class Solution {\n public:\n  bool isPalindrome(string s) {\n    for (int i = 0, j = s.size() - 1; i < j; i++, j--) {\n      while (i < j && !isalnum(s[i]))\n        i++;\n      while (i < j && !isalnum(s[j]))\n        j--;\n      if (i < j && tolower(s[i]) != tolower(s[j]))\n        return false;\n    }\n    return true;\n  }\n};\n"]}
{"number": 127, "statement": "Given two words (beginWord and endWord), and a dictionary's word list, find the length of shortest transformation sequence from beginWord to endWord, such that:\nOnly one letter can be changed at a time.\nEach transformed word must exist in the word list.\nNote:\nReturn 0 if there is no such transformation sequence.\nAll words have the same length.\nAll words contain only lowercase alphabetic characters.\nYou may assume no duplicates in the word list.\nYou may assume beginWord and endWord are non-empty and are not the same.\n", "solutions": ["class Solution {\n  public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n    // Since all words are of same length.\n    int L = beginWord.length();\n    // Dictionary to hold combination of words that can be formed,\n    // from any given word. By changing one letter at a time.\n    Map<String, List<String>> allComboDict = new HashMap<>();\n    wordList.forEach(\n        word -> {\n          for (int i = 0; i < L; i++) {\n            // Key is the generic word\n            // Value is a list of words which have the same intermediate generic word.\n            String newWord = word.substring(0, i) + '*' + word.substring(i + 1, L);\n            List<String> transformations = allComboDict.getOrDefault(newWord, new ArrayList<>());\n            transformations.add(word);\n            allComboDict.put(newWord, transformations);\n          }\n        });\n    // Queue for BFS\n    Queue<Pair<String, Integer>> Q = new LinkedList<>();\n    Q.add(new Pair(beginWord, 1));\n    // Visited to make sure we don't repeat processing same word.\n    Map<String, Boolean> visited = new HashMap<>();\n    visited.put(beginWord, true);\n    while (!Q.isEmpty()) {\n      Pair<String, Integer> node = Q.remove();\n      String word = node.getKey();\n      int level = node.getValue();\n      for (int i = 0; i < L; i++) {\n        // Intermediate words for current word\n        String newWord = word.substring(0, i) + '*' + word.substring(i + 1, L);\n        // Next states are all the words which share the same intermediate state.\n        for (String adjacentWord : allComboDict.getOrDefault(newWord, new ArrayList<>())) {\n          // If at any point if we find what we are looking for\n          // i.e. the end word - we can return with the answer.\n          if (adjacentWord.equals(endWord)) {\n            return level + 1;\n          }\n          // Otherwise, add it to the BFS Queue. Also mark it visited\n          if (!visited.containsKey(adjacentWord)) {\n            visited.put(adjacentWord, true);\n            Q.add(new Pair(adjacentWord, level + 1));\n          }\n        }\n      }\n    }\n    return 0;\n  }\n}\n", "class Solution {\n  private int L;\n  private Map<String, List<String>> allComboDict;\n  Solution() {\n    this.L = 0;\n    // Dictionary to hold combination of words that can be formed,\n    // from any given word. By changing one letter at a time.\n    this.allComboDict = new HashMap<>();\n  }\n  private int visitWordNode(\n      Queue<Pair<String, Integer>> Q,\n      Map<String, Integer> visited,\n      Map<String, Integer> othersVisited) {\n    Pair<String, Integer> node = Q.remove();\n    String word = node.getKey();\n    int level = node.getValue();\n    for (int i = 0; i < this.L; i++) {\n      // Intermediate words for current word\n      String newWord = word.substring(0, i) + '*' + word.substring(i + 1, L);\n      // Next states are all the words which share the same intermediate state.\n      for (String adjacentWord : this.allComboDict.getOrDefault(newWord, new ArrayList<>())) {\n        // If at any point if we find what we are looking for\n        // i.e. the end word - we can return with the answer.\n        if (othersVisited.containsKey(adjacentWord)) {\n          return level + othersVisited.get(adjacentWord);\n        }\n        if (!visited.containsKey(adjacentWord)) {\n          // Save the level as the value of the dictionary, to save number of hops.\n          visited.put(adjacentWord, level + 1);\n          Q.add(new Pair(adjacentWord, level + 1));\n        }\n      }\n    }\n    return -1;\n  }\n  public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n    if (!wordList.contains(endWord)) {\n      return 0;\n    }\n    // Since all words are of same length.\n    this.L = beginWord.length();\n    wordList.forEach(\n        word -> {\n          for (int i = 0; i < L; i++) {\n            // Key is the generic word\n            // Value is a list of words which have the same intermediate generic word.\n            String newWord = word.substring(0, i) + '*' + word.substring(i + 1, L);\n            List<String> transformations =\n                this.allComboDict.getOrDefault(newWord, new ArrayList<>());\n            transformations.add(word);\n            this.allComboDict.put(newWord, transformations);\n          }\n        });\n    // Queues for birdirectional BFS\n    // BFS starting from beginWord\n    Queue<Pair<String, Integer>> Q_begin = new LinkedList<>();\n    // BFS starting from endWord\n    Queue<Pair<String, Integer>> Q_end = new LinkedList<>();\n    Q_begin.add(new Pair(beginWord, 1));\n    Q_end.add(new Pair(endWord, 1));\n    // Visited to make sure we don't repeat processing same word.\n    Map<String, Integer> visitedBegin = new HashMap<>();\n    Map<String, Integer> visitedEnd = new HashMap<>();\n    visitedBegin.put(beginWord, 1);\n    visitedEnd.put(endWord, 1);\n    while (!Q_begin.isEmpty() && !Q_end.isEmpty()) {\n      // One hop from begin word\n      int ans = visitWordNode(Q_begin, visitedBegin, visitedEnd);\n      if (ans > -1) {\n        return ans;\n      }\n      // One hop from end word\n      ans = visitWordNode(Q_end, visitedEnd, visitedBegin);\n      if (ans > -1) {\n        return ans;\n      }\n    }\n    return 0;\n  }\n}\n"]}
{"number": 128, "statement": "Given an unsorted array of integers, find the length of the longest consecutive elements sequence.\nYour algorithm should run in O(n) complexity.\n", "solutions": ["class Solution {\n    private boolean arrayContains(int[] arr, int num) {\n        for (int i = 0; i < arr.length; i++) {\n            if (arr[i] == num) {\n                return true;\n            }\n        }\n        return false;\n    }\n    public int longestConsecutive(int[] nums) {\n        int longestStreak = 0;\n        for (int num : nums) {\n            int currentNum = num;\n            int currentStreak = 1;\n            while (arrayContains(nums, currentNum + 1)) {\n                currentNum += 1;\n                currentStreak += 1;\n            }\n            longestStreak = Math.max(longestStreak, currentStreak);\n        }\n        return longestStreak;\n    }\n}\n", "class Solution {\n    public int longestConsecutive(int[] nums) {\n        if (nums.length == 0) {\n            return 0;\n        }\n        Arrays.sort(nums);\n        int longestStreak = 1;\n        int currentStreak = 1;\n        for (int i = 1; i < nums.length; i++) {\n            if (nums[i] != nums[i-1]) {\n                if (nums[i] == nums[i-1]+1) {\n                    currentStreak += 1;\n                }\n                else {\n                    longestStreak = Math.max(longestStreak, currentStreak);\n                    currentStreak = 1;\n                }\n            }\n        }\n        return Math.max(longestStreak, currentStreak);\n    }\n}\n", "class Solution {\n    public int longestConsecutive(int[] nums) {\n        Set<Integer> num_set = new HashSet<Integer>();\n        for (int num : nums) {\n            num_set.add(num);\n        }\n        int longestStreak = 0;\n        for (int num : num_set) {\n            if (!num_set.contains(num-1)) {\n                int currentNum = num;\n                int currentStreak = 1;\n                while (num_set.contains(currentNum+1)) {\n                    currentNum += 1;\n                    currentStreak += 1;\n                }\n                longestStreak = Math.max(longestStreak, currentStreak);\n            }\n        }\n        return longestStreak;\n    }\n}\n"]}
{"number": 129, "statement": "Given a binary tree containing digits from 0-9 only, each root-to-leaf path could represent a number.\nAn example is the root-to-leaf path 1-2-3 which represents the number 123.\nFind the total sum of all root-to-leaf numbers.\nNote:A leaf is a node with no children.\n", "solutions": ["class Solution {\n  public int sumNumbers(TreeNode root) {\n    int rootToLeaf = 0, currNumber = 0;\n    Deque<Pair<TreeNode, Integer>> stack = new ArrayDeque();\n    stack.push(new Pair(root, 0));\n    while (!stack.isEmpty()) {\n      Pair<TreeNode, Integer> p = stack.pop();\n      root = p.getKey();\n      currNumber = p.getValue();\n      if (root != null) {\n        currNumber = currNumber * 10 + root.val;\n        // if it's a leaf, update root-to-leaf sum\n        if (root.left == null && root.right == null) {\n          rootToLeaf += currNumber;\n        } else {\n          stack.push(new Pair(root.right, currNumber));\n          stack.push(new Pair(root.left, currNumber));\n        }\n      }\n    }\n    return rootToLeaf;\n  }\n}\n", "class Solution {\n  int rootToLeaf = 0;\n  public void preorder(TreeNode r, int currNumber) {\n    if (r != null) {\n      currNumber = currNumber * 10 + r.val;\n      // if it's a leaf, update root-to-leaf sum\n      if (r.left == null && r.right == null) {\n        rootToLeaf += currNumber;\n      }\n      preorder(r.left, currNumber);\n      preorder(r.right, currNumber) ;\n    }\n  }\n  public int sumNumbers(TreeNode root) {\n    preorder(root, 0);\n    return rootToLeaf;\n  }\n}\n", "class Solution {\n  public int sumNumbers(TreeNode root) {\n    int rootToLeaf = 0, currNumber = 0;\n    int steps;\n    TreeNode predecessor;\n    while (root != null) {\n      // If there is a left child,\n      // then compute the predecessor.\n      // If there is no link predecessor.right = root --> set it.\n      // If there is a link predecessor.right = root --> break it.\n      if (root.left != null) {\n        // Predecessor node is one step to the left\n        // and then to the right till you can.\n        predecessor = root.left;\n        steps = 1;\n        while (predecessor.right != null && predecessor.right != root) {\n          predecessor = predecessor.right;\n          ++steps;\n        }\n        // Set link predecessor.right = root\n        // and go to explore the left subtree\n        if (predecessor.right == null) {\n          currNumber = currNumber * 10 + root.val;\n          predecessor.right = root;\n          root = root.left;\n        }\n        // Break the link predecessor.right = root\n        // Once the link is broken,\n        // it's time to change subtree and go to the right\n        else {\n          // If you're on the leaf, update the sum\n          if (predecessor.left == null) {\n            rootToLeaf += currNumber;\n          }\n          // This part of tree is explored, backtrack\n          for(int i = 0; i < steps; ++i) {\n            currNumber /= 10;\n          }\n          predecessor.right = null;\n          root = root.right;\n        }\n      }\n      // If there is no left child\n      // then just go right.\n      else {\n        currNumber = currNumber * 10 + root.val;\n        // if you're on the leaf, update the sum\n        if (root.right == null) {\n          rootToLeaf += currNumber;\n        }\n        root = root.right;\n      }\n    }\n    return rootToLeaf;\n  }\n}\n"]}
{"number": 130, "statement": "Given a 2D board containing 'X' and 'O' (the letter O), capture all regions surrounded by 'X'.\nA region is captured by flipping all 'O's into 'X's in that surrounded region.\n", "solutions": ["public class Solution {\n  protected Integer ROWS = 0;\n  protected Integer COLS = 0;\n  public void solve(char[][] board) {\n    if (board == null || board.length == 0) {\n      return;\n    }\n    this.ROWS = board.length;\n    this.COLS = board[0].length;\n    List<Pair<Integer, Integer>> borders = new LinkedList<Pair<Integer, Integer>>();\n    // Step 1). construct the list of border cells\n    for (int r = 0; r < this.ROWS; ++r) {\n      borders.add(new Pair(r, 0));\n      borders.add(new Pair(r, this.COLS - 1));\n    }\n    for (int c = 0; c < this.COLS; ++c) {\n      borders.add(new Pair(0, c));\n      borders.add(new Pair(this.ROWS - 1, c));\n    }\n    // Step 2). mark the escaped cells\n    for (Pair<Integer, Integer> pair : borders) {\n      this.DFS(board, pair.first, pair.second);\n    }\n    // Step 3). flip the cells to their correct final states\n    for (int r = 0; r < this.ROWS; ++r) {\n      for (int c = 0; c < this.COLS; ++c) {\n        if (board[r][c] == 'O')\n          board[r][c] = 'X';\n        if (board[r][c] == 'E')\n          board[r][c] = 'O';\n      }\n    }\n  }\n  protected void DFS(char[][] board, int row, int col) {\n    if (board[row][col] != 'O')\n      return;\n    board[row][col] = 'E';\n    if (col < this.COLS - 1)\n      this.DFS(board, row, col + 1);\n    if (row < this.ROWS - 1)\n      this.DFS(board, row + 1, col);\n    if (col > 0)\n      this.DFS(board, row, col - 1);\n    if (row > 0)\n      this.DFS(board, row - 1, col);\n  }\n}\nclass Pair<U, V> {\n  public U first;\n  public V second;\n  public Pair(U first, V second) {\n    this.first = first;\n    this.second = second;\n  }\n}\n", "def DFS(self, board, row, col):\n    if row < 0 or row >= self.ROWS or col < 0 or col >= self.COLS:\n        return\n    if board[row][col] != 'O':\n        return\n    board[row][col] = 'E'\n    # jump to the neighbors without boundary checks\n    for ro, co in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n        self.DFS(board, row+ro, col+co)\n", "public class Solution {\n  protected Integer ROWS = 0;\n  protected Integer COLS = 0;\n  public void solve(char[][] board) {\n    if (board == null || board.length == 0) {\n      return;\n    }\n    this.ROWS = board.length;\n    this.COLS = board[0].length;\n    List<Pair<Integer, Integer>> borders = new LinkedList<Pair<Integer, Integer>>();\n    // Step 1). construct the list of border cells\n    for (int r = 0; r < this.ROWS; ++r) {\n      borders.add(new Pair(r, 0));\n      borders.add(new Pair(r, this.COLS - 1));\n    }\n    for (int c = 0; c < this.COLS; ++c) {\n      borders.add(new Pair(0, c));\n      borders.add(new Pair(this.ROWS - 1, c));\n    }\n    // Step 2). mark the escaped cells\n    for (Pair<Integer, Integer> pair : borders) {\n      this.BFS(board, pair.first, pair.second);\n    }\n    // Step 3). flip the cells to their correct final states\n    for (int r = 0; r < this.ROWS; ++r) {\n      for (int c = 0; c < this.COLS; ++c) {\n        if (board[r][c] == 'O')\n          board[r][c] = 'X';\n        if (board[r][c] == 'E')\n          board[r][c] = 'O';\n      }\n    }\n  }\n  protected void BFS(char[][] board, int r, int c) {\n    LinkedList<Pair<Integer, Integer>> queue = new LinkedList<Pair<Integer, Integer>>();\n    queue.offer(new Pair<>(r, c));\n    while (!queue.isEmpty()) {\n      Pair<Integer, Integer> pair = queue.pollFirst();\n      int row = pair.first, col = pair.second;\n      if (board[row][col] != 'O')\n        continue;\n      board[row][col] = 'E';\n      if (col < this.COLS - 1)\n        queue.offer(new Pair<>(row, col + 1));\n      if (row < this.ROWS - 1)\n        queue.offer(new Pair<>(row + 1, col));\n      if (col > 0)\n        queue.offer(new Pair<>(row, col - 1));\n      if (row > 0)\n        queue.offer(new Pair<>(row - 1, col));\n    }\n  }\n}\nclass Pair<U, V> {\n  public U first;\n  public V second;\n  public Pair(U first, V second) {\n    this.first = first;\n    this.second = second;\n  }\n}\n", "  protected void DFS(char[][] board, int r, int c) {\n    LinkedList<Pair<Integer, Integer>> queue = new LinkedList<Pair<Integer, Integer>>();\n    queue.offer(new Pair<>(r, c));\n    while (!queue.isEmpty()) {\n      // pop out the _tail_ element, rather than the head\n      Pair<Integer, Integer> pair = queue.pollLast();\n      int row = pair.first, col = pair.second;\n      if (board[row][col] != 'O')\n        continue;\n      board[row][col] = 'E';\n      if (col < this.COLS - 1)\n        queue.offer(new Pair<>(row, col + 1));\n      if (row < this.ROWS - 1)\n        queue.offer(new Pair<>(row + 1, col));\n      if (col > 0)\n        queue.offer(new Pair<>(row, col - 1));\n      if (row > 0)\n        queue.offer(new Pair<>(row - 1, col));\n    }\n  }\n"]}
{"number": 133, "statement": "Given a reference of a node in aconnectedundirected graph.\nReturn a deep copy (clone) of the graph.\nEach node in the graph contains a val (int) and a list (List[Node]) of its neighbors.\nclass Node {\n    public int val;\n    public ListNode neighbors;\n}\nTest case format:\nFor simplicity sake, eachnode's value is the same as the node's index (1-indexed). For example, the first node withval = 1, the second node with val = 2, and so on.The graph is represented in the test case using an adjacency list.\nAdjacency listis a collection of unorderedlistsused to represent a finite graph. Eachlistdescribes the set of neighbors of a node in the graph.\nThe given node willalways be the first nodewithval = 1. You must return the copy of the given node as a reference to the cloned graph.\n", "solutions": ["/*\n// Definition for a Node.\nclass Node {\n    public int val;\n    public List<Node> neighbors;\n    public Node() {}\n    public Node(int _val,List<Node> _neighbors) {\n        val = _val;\n        neighbors = _neighbors;\n    }\n};\n*/\nclass Solution {\n    private HashMap <Node, Node> visited = new HashMap <> ();\n    public Node cloneGraph(Node node) {\n        if (node == null) {\n            return node;\n        }\n        // If the node was already visited before.\n        // Return the clone from the visited dictionary.\n        if (visited.containsKey(node)) {\n            return visited.get(node);\n        }\n        // Create a clone for the given node.\n        // Note that we don't have cloned neighbors as of now, hence [].\n        Node cloneNode = new Node(node.val, new ArrayList());\n        // The key is original node and value being the clone node.\n        visited.put(node, cloneNode);\n        // Iterate through the neighbors to generate their clones\n        // and prepare a list of cloned neighbors to be added to the cloned node.\n        for (Node neighbor: node.neighbors) {\n            cloneNode.neighbors.add(cloneGraph(neighbor));\n        }\n        return cloneNode;\n    }\n}\n", "/*\n// Definition for a Node.\nclass Node {\n    public int val;\n    public List<Node> neighbors;\n    public Node() {}\n    public Node(int _val,List<Node> _neighbors) {\n        val = _val;\n        neighbors = _neighbors;\n    }\n};\n*/\nclass Solution {\n    public Node cloneGraph(Node node) {\n        if (node == null) {\n            return node;\n        }\n        // Hash map to save the visited node and it's respective clone\n        // as key and value respectively. This helps to avoid cycles.\n        HashMap<Node, Node> visited = new HashMap();\n        // Put the first node in the queue\n        LinkedList<Node> queue = new LinkedList<Node> ();\n        queue.add(node);\n        // Clone the node and put it in the visited dictionary.\n        visited.put(node, new Node(node.val, new ArrayList()));\n        // Start BFS traversal\n        while (!queue.isEmpty()) {\n            // Pop a node say \"n\" from the from the front of the queue.\n            Node n = queue.remove();\n            // Iterate through all the neighbors of the node \"n\"\n            for (Node neighbor: n.neighbors) {\n                if (!visited.containsKey(neighbor)) {\n                    // Clone the neighbor and put in the visited, if not present already\n                    visited.put(neighbor, new Node(neighbor.val, new ArrayList()));\n                    // Add the newly encountered node to the queue.\n                    queue.add(neighbor);\n                }\n                // Add the clone of the neighbor to the neighbors of the clone node \"n\".\n                visited.get(n).neighbors.add(visited.get(neighbor));\n            }\n        }\n        // Return the clone of the node from visited.\n        return visited.get(node);\n    }\n}\n"]}
{"number": 134, "statement": "There are N gas stations along a circular route, where the amount of gas at station i is gas[i].\nYou have a car with an unlimited gas tank and it costs cost[i] of gas to travel from station i to its next station (i+1). You begin the journey with an empty tank at one of the gas stations.\nReturn the starting gas station's index if you can travel around the circuit once in the clockwise direction, otherwise return -1.\nNote:\nIf there exists asolution, it is guaranteed to be unique.\nBoth input arrays are non-empty and have the same length.\nEach element in the input arrays is a non-negative integer.\n", "solutions": ["class Solution {\n  public:\n  int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\n    int n = gas.size();\n    int total_tank = 0;\n    int curr_tank = 0;\n    int starting_station = 0;\n    for (int i = 0; i < n; ++i) {\n      total_tank += gas[i] - cost[i];\n      curr_tank += gas[i] - cost[i];\n      // If one couldn't get here,\n      if (curr_tank < 0) {\n        // Pick up the next station as the starting one.\n        starting_station = i + 1;\n        // Start with an empty tank.\n        curr_tank = 0;\n      }\n    }\n    return total_tank >= 0 ? starting_station : -1;\n  }\n};\n"]}
{"number": 135, "statement": "There are N children standing in a line. Each child is assigned a rating value.\nYou are giving candies to these children subjected to the following requirements:\nEach child must have at least one candy.\nChildren with a higher rating get more candies than their neighbors.\nWhat is the minimum candies you must give?\n", "solutions": ["public class Solution {\n    public int candy(int[] ratings) {\n        int[] candies = new int[ratings.length];\n        Arrays.fill(candies, 1);\n        boolean flag = true;\n        int sum = 0;\n        while (flag) {\n            flag = false;\n            for (int i = 0; i < ratings.length; i++) {\n                if (i != ratings.length - 1 && ratings[i] > ratings[i + 1] && candies[i] <= candies[i + 1]) {\n                    candies[i] = candies[i + 1] + 1;\n                    flag = true;\n                }\n                if (i > 0 && ratings[i] > ratings[i - 1] && candies[i] <= candies[i - 1]) {\n                    candies[i] = candies[i - 1] + 1;\n                    flag = true;\n                }\n            }\n        }\n        for (int candy : candies) {\n            sum += candy;\n        }\n        return sum;\n    }\n}\n", "public class Solution {\n    public int candy(int[] ratings) {\n        int sum = 0;\n        int[] left2right = new int[ratings.length];\n        int[] right2left = new int[ratings.length];\n        Arrays.fill(left2right, 1);\n        Arrays.fill(right2left, 1);\n        for (int i = 1; i < ratings.length; i++) {\n            if (ratings[i] > ratings[i - 1]) {\n                left2right[i] = left2right[i - 1] + 1;\n            }\n        }\n        for (int i = ratings.length - 2; i >= 0; i--) {\n            if (ratings[i] > ratings[i + 1]) {\n                right2left[i] = right2left[i + 1] + 1;\n            }\n        }\n        for (int i = 0; i < ratings.length; i++) {\n            sum += Math.max(left2right[i], right2left[i]);\n        }\n        return sum;\n    }\n}\n", "public class Solution {\n    public int candy(int[] ratings) {\n        int[] candies = new int[ratings.length];\n        Arrays.fill(candies, 1);\n        for (int i = 1; i < ratings.length; i++) {\n            if (ratings[i] > ratings[i - 1]) {\n                candies[i] = candies[i - 1] + 1;\n            }\n        }\n        int sum = candies[ratings.length - 1];\n        for (int i = ratings.length - 2; i >= 0; i--) {\n            if (ratings[i] > ratings[i + 1]) {\n                candies[i] = Math.max(candies[i], candies[i + 1] + 1);\n            }\n            sum += candies[i];\n        }\n        return sum;\n    }\n}\n", "public class Solution {\n    public int count(int n) {\n        return (n * (n + 1)) / 2;\n    }\n    public int candy(int[] ratings) {\n        if (ratings.length <= 1) {\n            return ratings.length;\n        }\n        int candies = 0;\n        int up = 0;\n        int down = 0;\n        int old_slope = 0;\n        for (int i = 1; i < ratings.length; i++) {\n            int new_slope = (ratings[i] > ratings[i - 1]) ? 1 : (ratings[i] < ratings[i - 1] ? -1 : 0);\n            if ((old_slope > 0 && new_slope == 0) || (old_slope < 0 && new_slope >= 0)) {\n                candies += count(up) + count(down) + Math.max(up, down);\n                up = 0;\n                down = 0;\n            }\n            if (new_slope > 0)\n                up++;\n            if (new_slope < 0)\n                down++;\n            if (new_slope == 0)\n                candies++;\n            old_slope = new_slope;\n        }\n        candies += count(up) + count(down) + Math.max(up, down) + 1;\n        return candies;\n    }\n}\n"]}
{"number": 136, "statement": "Given a non-emptyarray of integers, every element appears twice except for one. Find that single one.\nNote:\nYour algorithm should have a linear runtime complexity. Could you implement it without using extra memory?\n", "solutions": ["class Solution {\n  public int singleNumber(int[] nums) {\n    List<Integer> no_duplicate_list = new ArrayList<>();\n    for (int i : nums) {\n      if (!no_duplicate_list.contains(i)) {\n        no_duplicate_list.add(i);\n      } else {\n        no_duplicate_list.remove(new Integer(i));\n      }\n    }\n    return no_duplicate_list.get(0);\n  }\n}\n", "class Solution {\n  public int singleNumber(int[] nums) {\n    HashMap<Integer, Integer> hash_table = new HashMap<>();\n    for (int i : nums) {\n      hash_table.put(i, hash_table.getOrDefault(i, 0) + 1);\n    }\n    for (int i : nums) {\n      if (hash_table.get(i) == 1) {\n        return i;\n      }\n    }\n    return 0;\n  }\n}\n", "class Solution {\n  public int singleNumber(int[] nums) {\n    int sumOfSet = 0, sumOfNums = 0;\n    Set<Integer> set = new HashSet();\n    for (int num : nums) {\n      if (!set.contains(num)) {\n        set.add(num);\n        sumOfSet += num;\n      }\n      sumOfNums += num;\n    }\n    return 2 * sumOfSet - sumOfNums;\n  }\n}\n", "class Solution {\n  public int singleNumber(int[] nums) {\n    int a = 0;\n    for (int i : nums) {\n      a ^= i;\n    }\n    return a;\n  }\n}\n"]}
{"number": 137, "statement": "Given a non-emptyarray of integers, every element appears three times except for one, which appears exactly once. Find that single one.\nNote:\nYour algorithm should have a linear runtime complexity. Could you implement it without using extra memory?\n", "solutions": ["class Solution {\n  public int singleNumber(int[] nums) {\n    Set<Long> set = new HashSet<>();\n    long sumSet = 0, sumArray = 0;\n    for(int n : nums) {\n      sumArray += n;\n      set.add((long)n);\n    }\n    for(Long s : set) sumSet += s;\n    return (int)((3 * sumSet - sumArray) / 2);\n  }\n}\n", "class Solution {\n  public int singleNumber(int[] nums) {\n    HashMap<Integer, Integer> hashmap = new HashMap<>();\n    for (int num : nums)\n      hashmap.put(num, hashmap.getOrDefault(num, 0) + 1);\n    for (int k : hashmap.keySet())\n      if (hashmap.get(k) == 1) return k;\n    return -1;\n  }\n}\n", "class Solution {\n  public int singleNumber(int[] nums) {\n    int seenOnce = 0, seenTwice = 0;\n    for (int num : nums) {\n      // first appearence: \n      // add num to seen_once \n      // don't add to seen_twice because of presence in seen_once\n      // second appearance: \n      // remove num from seen_once \n      // add num to seen_twice\n      // third appearance: \n      // don't add to seen_once because of presence in seen_twice\n      // remove num from seen_twice\n      seenOnce = ~seenTwice & (seenOnce ^ num);\n      seenTwice = ~seenOnce & (seenTwice ^ num);\n    }\n    return seenOnce;\n  }\n}\n"]}
{"number": 138, "statement": "A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.\nReturn a deep copy of the list.\nThe Linked List is represented in the input/output as a list of n nodes. Each node is represented as a pair of [val, random_index] where:\nval: an integer representing Node.val\nrandom_index: the index of the node (range from 0 to n-1) where random pointer points to, or null if it does not point to any node.\n", "solutions": ["/*\n// Definition for a Node.\nclass Node {\n    public int val;\n    public Node next;\n    public Node random;\n    public Node() {}\n    public Node(int _val,Node _next,Node _random) {\n        val = _val;\n        next = _next;\n        random = _random;\n    }\n};\n*/\npublic class Solution {\n  // HashMap which holds old nodes as keys and new nodes as its values.\n  HashMap<Node, Node> visitedHash = new HashMap<Node, Node>();\n  public Node copyRandomList(Node head) {\n    if (head == null) {\n      return null;\n    }\n    // If we have already processed the current node, then we simply return the cloned version of\n    // it.\n    if (this.visitedHash.containsKey(head)) {\n      return this.visitedHash.get(head);\n    }\n    // Create a new node with the value same as old node. (i.e. copy the node)\n    Node node = new Node(head.val, null, null);\n    // Save this value in the hash map. This is needed since there might be\n    // loops during traversal due to randomness of random pointers and this would help us avoid\n    // them.\n    this.visitedHash.put(head, node);\n    // Recursively copy the remaining linked list starting once from the next pointer and then from\n    // the random pointer.\n    // Thus we have two independent recursive calls.\n    // Finally we update the next and random pointers for the new node created.\n    node.next = this.copyRandomList(head.next);\n    node.random = this.copyRandomList(head.random);\n    return node;\n  }\n}\n", "/*\n// Definition for a Node.\nclass Node {\n    public int val;\n    public Node next;\n    public Node random;\n    public Node() {}\n    public Node(int _val,Node _next,Node _random) {\n        val = _val;\n        next = _next;\n        random = _random;\n    }\n};\n*/\npublic class Solution {\n  // Visited dictionary to hold old node reference as \"key\" and new node reference as the \"value\"\n  HashMap<Node, Node> visited = new HashMap<Node, Node>();\n  public Node getClonedNode(Node node) {\n    // If the node exists then\n    if (node != null) {\n      // Check if the node is in the visited dictionary\n      if (this.visited.containsKey(node)) {\n        // If its in the visited dictionary then return the new node reference from the dictionary\n        return this.visited.get(node);\n      } else {\n        // Otherwise create a new node, add to the dictionary and return it\n        this.visited.put(node, new Node(node.val, null, null));\n        return this.visited.get(node);\n      }\n    }\n    return null;\n  }\n  public Node copyRandomList(Node head) {\n    if (head == null) {\n      return null;\n    }\n    Node oldNode = head;\n    // Creating the new head node.\n    Node newNode = new Node(oldNode.val);\n    this.visited.put(oldNode, newNode);\n    // Iterate on the linked list until all nodes are cloned.\n    while (oldNode != null) {\n      // Get the clones of the nodes referenced by random and next pointers.\n      newNode.random = this.getClonedNode(oldNode.random);\n      newNode.next = this.getClonedNode(oldNode.next);\n      // Move one step ahead in the linked list.\n      oldNode = oldNode.next;\n      newNode = newNode.next;\n    }\n    return this.visited.get(head);\n  }\n}\n", "/*\n// Definition for a Node.\nclass Node {\n    public int val;\n    public Node next;\n    public Node random;\n    public Node() {}\n    public Node(int _val,Node _next,Node _random) {\n        val = _val;\n        next = _next;\n        random = _random;\n    }\n};\n*/\npublic class Solution {\n  public Node copyRandomList(Node head) {\n    if (head == null) {\n      return null;\n    }\n    // Creating a new weaved list of original and copied nodes.\n    Node ptr = head;\n    while (ptr != null) {\n      // Cloned node\n      Node newNode = new Node(ptr.val);\n      // Inserting the cloned node just next to the original node.\n      // If A->B->C is the original linked list,\n      // Linked list after weaving cloned nodes would be A->A'->B->B'->C->C'\n      newNode.next = ptr.next;\n      ptr.next = newNode;\n      ptr = newNode.next;\n    }\n    ptr = head;\n    // Now link the random pointers of the new nodes created.\n    // Iterate the newly created list and use the original nodes' random pointers,\n    // to assign references to random pointers for cloned nodes.\n    while (ptr != null) {\n      ptr.next.random = (ptr.random != null) ? ptr.random.next : null;\n      ptr = ptr.next.next;\n    }\n    // Unweave the linked list to get back the original linked list and the cloned list.\n    // i.e. A->A'->B->B'->C->C' would be broken to A->B->C and A'->B'->C'\n    Node ptr_old_list = head; // A->B->C\n    Node ptr_new_list = head.next; // A'->B'->C'\n    Node head_old = head.next;\n    while (ptr_old_list != null) {\n      ptr_old_list.next = ptr_old_list.next.next;\n      ptr_new_list.next = (ptr_new_list.next != null) ? ptr_new_list.next.next : null;\n      ptr_old_list = ptr_old_list.next;\n      ptr_new_list = ptr_new_list.next;\n    }\n    return head_old;\n  }\n}\n"]}
{"number": 139, "statement": "Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, determine if s can be segmented into a space-separated sequence of one or more dictionary words.\nNote:\nThe same word in the dictionary may be reused multiple times in the segmentation.\nYou may assume the dictionary does not contain duplicate words.\n", "solutions": ["public class Solution {\n    public boolean wordBreak(String s, List<String> wordDict) {\n        return word_Break(s, new HashSet(wordDict), 0);\n    }\n    public boolean word_Break(String s, Set<String> wordDict, int start) {\n        if (start == s.length()) {\n            return true;\n        }\n        for (int end = start + 1; end <= s.length(); end++) {\n            if (wordDict.contains(s.substring(start, end)) && word_Break(s, wordDict, end)) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n", "public class Solution {\n    public boolean wordBreak(String s, List<String> wordDict) {\n        return word_Break(s, new HashSet(wordDict), 0, new Boolean[s.length()]);\n    }\n    public boolean word_Break(String s, Set<String> wordDict, int start, Boolean[] memo) {\n        if (start == s.length()) {\n            return true;\n        }\n        if (memo[start] != null) {\n            return memo[start];\n        }\n        for (int end = start + 1; end <= s.length(); end++) {\n            if (wordDict.contains(s.substring(start, end)) && word_Break(s, wordDict, end, memo)) {\n                return memo[start] = true;\n            }\n        }\n        return memo[start] = false;\n    }\n}\n", "public class Solution {\n    public boolean wordBreak(String s, List<String> wordDict) {\n        Set<String> wordDictSet=new HashSet(wordDict);\n        Queue<Integer> queue = new LinkedList<>();\n        int[] visited = new int[s.length()];\n        queue.add(0);\n        while (!queue.isEmpty()) {\n            int start = queue.remove();\n            if (visited[start] == 0) {\n                for (int end = start + 1; end <= s.length(); end++) {\n                    if (wordDictSet.contains(s.substring(start, end))) {\n                        queue.add(end);\n                        if (end == s.length()) {\n                            return true;\n                        }\n                    }\n                }\n                visited[start] = 1;\n            }\n        }\n        return false;\n    }\n}\n", "public class Solution {\n    public boolean wordBreak(String s, List<String> wordDict) {\n        Set<String> wordDictSet=new HashSet(wordDict);\n        boolean[] dp = new boolean[s.length() + 1];\n        dp[0] = true;\n        for (int i = 1; i <= s.length(); i++) {\n            for (int j = 0; j < i; j++) {\n                if (dp[j] && wordDictSet.contains(s.substring(j, i))) {\n                    dp[i] = true;\n                    break;\n                }\n            }\n        }\n        return dp[s.length()];\n    }\n}\n"]}
{"number": 140, "statement": "Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, add spaces in s to construct a sentence where each word is a valid dictionary word.Return all such possible sentences.\nNote:\nThe same word in the dictionary may be reused multiple times in the segmentation.\nYou may assume the dictionary does not contain duplicate words.\n", "solutions": ["public class Solution {\n    public List<String> wordBreak(String s, Set<String> wordDict) {\n        return word_Break(s, wordDict, 0);\n    }\n    public List<String> word_Break(String s, Set<String> wordDict, int start) {\n        LinkedList<String> res = new LinkedList<>();\n        if (start == s.length()) {\n            res.add(\"\");\n        }\n        for (int end = start + 1; end <= s.length(); end++) {\n            if (wordDict.contains(s.substring(start, end))) {\n                List<String> list = word_Break(s, wordDict, end);\n                for (String l : list) {\n                    res.add(s.substring(start, end) + (l.equals(\"\") ? \"\" : \" \") + l);\n                }\n            }\n        }\n        return res;\n    }\n}\n", "public class Solution {\n    public List<String> wordBreak(String s, Set<String> wordDict) {\n        return word_Break(s, wordDict, 0);\n    }\n    HashMap<Integer, List<String>> map = new HashMap<>();\n    public List<String> word_Break(String s, Set<String> wordDict, int start) {\n        if (map.containsKey(start)) {\n            return map.get(start);\n        }\n        LinkedList<String> res = new LinkedList<>();\n        if (start == s.length()) {\n            res.add(\"\");\n        }\n        for (int end = start + 1; end <= s.length(); end++) {\n            if (wordDict.contains(s.substring(start, end))) {\n                List<String> list = word_Break(s, wordDict, end);\n                for (String l : list) {\n                    res.add(s.substring(start, end) + (l.equals(\"\") ? \"\" : \" \") + l);\n                }\n            }\n        }\n        map.put(start, res);\n        return res;\n    }\n}\n", " public class Solution {\n    public List<String> wordBreak(String s, Set<String> wordDict) {\n        LinkedList<String>[] dp = new LinkedList[s.length() + 1];\n        LinkedList<String> initial = new LinkedList<>();\n        initial.add(\"\");\n        dp[0] = initial;\n        for (int i = 1; i <= s.length(); i++) {\n            LinkedList<String> list = new LinkedList<>();\n            for (int j = 0; j < i; j++) {\n                if (dp[j].size() > 0 && wordDict.contains(s.substring(j, i))) {\n                    for (String l : dp[j]) {\n                        list.add(l + (l.equals(\"\") ? \"\" : \" \") + s.substring(j, i));\n                    }\n                }\n            }\n            dp[i] = list;\n        }\n        return dp[s.length()];\n    }\n}\n"]}
{"number": 141, "statement": "Given a linked list, determine if it has a cycle in it.\nTo represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed)in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list.\n", "solutions": ["public boolean hasCycle(ListNode head) {\n    Set<ListNode> nodesSeen = new HashSet<>();\n    while (head != null) {\n        if (nodesSeen.contains(head)) {\n            return true;\n        } else {\n            nodesSeen.add(head);\n        }\n        head = head.next;\n    }\n    return false;\n}\n", "public boolean hasCycle(ListNode head) {\n    if (head == null || head.next == null) {\n        return false;\n    }\n    ListNode slow = head;\n    ListNode fast = head.next;\n    while (slow != fast) {\n        if (fast == null || fast.next == null) {\n            return false;\n        }\n        slow = slow.next;\n        fast = fast.next.next;\n    }\n    return true;\n}\n"]}
{"number": 142, "statement": "Given a linked list, return the node where the cycle begins. If there is no cycle, return null.\nTo represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed)in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list.\nNote: Do not modify the linked list.\n", "solutions": ["public class Solution {\n    public ListNode detectCycle(ListNode head) {\n        Set<ListNode> visited = new HashSet<ListNode>();\n        ListNode node = head;\n        while (node != null) {\n            if (visited.contains(node)) {\n                return node;\n            }\n            visited.add(node);\n            node = node.next;\n        }\n        return null;\n    }\n}\n", "public class Solution {\n    private ListNode getIntersect(ListNode head) {\n        ListNode tortoise = head;\n        ListNode hare = head;\n        // A fast pointer will either loop around a cycle and meet the slow\n        // pointer or reach the `null` at the end of a non-cyclic list.\n        while (hare != null && hare.next != null) {\n            tortoise = tortoise.next;\n            hare = hare.next.next;\n            if (tortoise == hare) {\n                return tortoise;\n            }\n        }\n        return null;\n}\n    public ListNode detectCycle(ListNode head) {\n        if (head == null) {\n            return null;\n        }\n        // If there is a cycle, the fast/slow pointers will intersect at some\n        // node. Otherwise, there is no cycle, so we cannot find an entrance to\n        // a cycle.\n        ListNode intersect = getIntersect(head);\n        if (intersect == null) {\n            return null;\n        }\n        // To find the entrance to the cycle, we have two pointers traverse at\n        // the same speed -- one from the front of the list, and the other from\n        // the point of intersection.\n        ListNode ptr1 = head;\n        ListNode ptr2 = intersect;\n        while (ptr1 != ptr2) {\n            ptr1 = ptr1.next;\n            ptr2 = ptr2.next;\n        }\n        return ptr1;\n    }\n}\n"]}
{"number": 143, "statement": "Given a singly linked list L: L0\u2192L1\u2192\u2026\u2192Ln-1\u2192Ln,\nreorder it to: L0\u2192Ln\u2192L1\u2192Ln-1\u2192L2\u2192Ln-2\u2192\u2026\nYou may not modify the values in the list's nodes, only nodes itself may be changed.\n", "solutions": ["// find the middle of linked list [Problem 876]\n// in 1->2->3->4->5->6 find 4 \nListNode slow = head, fast = head;\nwhile (fast != null && fast.next != null) {\n  slow = slow.next;\n  fast = fast.next.next;\n}\n", "// reverse the second part of the list [Problem 206]\n// convert 1->2->3->4->5->6 into 1->2->3->4 and 6->5->4\n// reverse the second half in-place\nListNode prev = null, curr = slow, tmp;\nwhile (curr != null) {\n  tmp = curr.next;\n  curr.next = prev;\n  prev = curr;\n  curr = tmp;\n}\n", "# reverse the second part of the list [Problem 206]\n# convert 1->2->3->4->5->6 into 1->2->3->4 and 6->5->4\n# reverse the second half in-place\nprev, curr = None, slow\nwhile curr:\n    curr.next, prev, curr = prev, curr, curr.next      \n", "// merge two sorted linked lists [Problem 21]\n// merge 1->2->3->4 and 6->5->4 into 1->6->2->5->3->4\nListNode first = head, second = prev;\nwhile (second.next != null) {\n  tmp = first.next;\n  first.next = second;\n  first = tmp;\n  tmp = second.next;\n  second.next = first;\n  second = tmp;\n}\n", "# merge two sorted linked lists [Problem 21]\n# merge 1->2->3->4 and 6->5->4 into 1->6->2->5->3->4\nfirst, second = head, prev\nwhile second.next:\n    first.next, first = second, first.next\n    second.next, second = first, second.next\n", "class Solution {\n  public void reorderList(ListNode head) {\n    if (head == null) return;\n    // find the middle of linked list [Problem 876]\n    // in 1->2->3->4->5->6 find 4 \n    ListNode slow = head, fast = head;\n    while (fast != null && fast.next != null) {\n      slow = slow.next;\n      fast = fast.next.next;\n    }\n    // reverse the second part of the list [Problem 206]\n    // convert 1->2->3->4->5->6 into 1->2->3->4 and 6->5->4\n    // reverse the second half in-place\n    ListNode prev = null, curr = slow, tmp;\n    while (curr != null) {\n      tmp = curr.next;\n      curr.next = prev;\n      prev = curr;\n      curr = tmp;\n    }\n    // merge two sorted linked lists [Problem 21]\n    // merge 1->2->3->4 and 6->5->4 into 1->6->2->5->3->4\n    ListNode first = head, second = prev;\n    while (second.next != null) {\n      tmp = first.next;\n      first.next = second;\n      first = tmp;\n      tmp = second.next;\n      second.next = first;\n      second = tmp;\n    }\n  }\n}\n"]}
{"number": 144, "statement": "Given a binary tree, return the preorder traversal of its nodes' values.\n", "solutions": ["/* Definition for a binary tree node. */\npublic class TreeNode {\n  int val;\n  TreeNode left;\n  TreeNode right;\n  TreeNode(int x) {\n    val = x;\n  }\n}\n", "class Solution {\n  public List<Integer> preorderTraversal(TreeNode root) {\n    LinkedList<TreeNode> stack = new LinkedList<>();\n    LinkedList<Integer> output = new LinkedList<>();\n    if (root == null) {\n      return output;\n    }\n    stack.add(root);\n    while (!stack.isEmpty()) {\n      TreeNode node = stack.pollLast();\n      output.add(node.val);\n      if (node.right != null) {\n        stack.add(node.right);\n      }\n      if (node.left != null) {\n        stack.add(node.left);\n      }\n    }\n    return output;\n  }\n}\n", "class Solution {\n  public List<Integer> preorderTraversal(TreeNode root) {\n    LinkedList<Integer> output = new LinkedList<>();\n    TreeNode node = root;\n    while (node != null) {\n      if (node.left == null) {\n        output.add(node.val);\n        node = node.right;\n      }\n      else {\n        TreeNode predecessor = node.left;\n        while ((predecessor.right != null) && (predecessor.right != node)) {\n          predecessor = predecessor.right;\n        }\n        if (predecessor.right == null) {\n          output.add(node.val);\n          predecessor.right = node;\n          node = node.left;\n        }\n        else{\n          predecessor.right = null;\n          node = node.right;\n        }\n      }\n    }\n    return output;\n  }\n}\n"]}
{"number": 145, "statement": "Given a binary tree, return the postorder traversal of its nodes' values.\n", "solutions": ["/* Definition for a binary tree node. */\npublic class TreeNode {\n  int val;\n  TreeNode left;\n  TreeNode right;\n  TreeNode(int x) {\n    val = x;\n  }\n}\n", "class Solution {\n  public List<Integer> postorderTraversal(TreeNode root) {\n    LinkedList<TreeNode> stack = new LinkedList<>();\n    LinkedList<Integer> output = new LinkedList<>();\n    if (root == null) {\n      return output;\n    }\n    stack.add(root);\n    while (!stack.isEmpty()) {\n      TreeNode node = stack.pollLast();\n      output.addFirst(node.val);\n      if (node.left != null) {\n        stack.add(node.left);\n      }\n      if (node.right != null) {\n        stack.add(node.right);\n      }\n    }\n    return output;\n  }\n}\n"]}
{"number": 146, "statement": "Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put.\nget(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.\nput(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.\nThe cache is initialized with a positive capacity.\nFollow up:\nCould you do both operations in O(1) time complexity?\n", "solutions": ["class LRUCache extends LinkedHashMap<Integer, Integer>{\n    private int capacity;\n    \n    public LRUCache(int capacity) {\n        super(capacity, 0.75F, true);\n        this.capacity = capacity;\n    }\n    public int get(int key) {\n        return super.getOrDefault(key, -1);\n    }\n    public void put(int key, int value) {\n        super.put(key, value);\n    }\n    @Override\n    protected boolean removeEldestEntry(Map.Entry<Integer, Integer> eldest) {\n        return size() > capacity; \n    }\n}\n/**\n * Your LRUCache object will be instantiated and called as such:\n * LRUCache obj = new LRUCache(capacity);\n * int param_1 = obj.get(key);\n * obj.put(key,value);\n */\n", "public class LRUCache {\n  class DLinkedNode {\n    int key;\n    int value;\n    DLinkedNode prev;\n    DLinkedNode next;\n  }\n  private void addNode(DLinkedNode node) {\n    /**\n     * Always add the new node right after head.\n     */\n    node.prev = head;\n    node.next = head.next;\n    head.next.prev = node;\n    head.next = node;\n  }\n  private void removeNode(DLinkedNode node){\n    /**\n     * Remove an existing node from the linked list.\n     */\n    DLinkedNode prev = node.prev;\n    DLinkedNode next = node.next;\n    prev.next = next;\n    next.prev = prev;\n  }\n  private void moveToHead(DLinkedNode node){\n    /**\n     * Move certain node in between to the head.\n     */\n    removeNode(node);\n    addNode(node);\n  }\n  private DLinkedNode popTail() {\n    /**\n     * Pop the current tail.\n     */\n    DLinkedNode res = tail.prev;\n    removeNode(res);\n    return res;\n  }\n  private Map<Integer, DLinkedNode> cache = new HashMap<>();\n  private int size;\n  private int capacity;\n  private DLinkedNode head, tail;\n  public LRUCache(int capacity) {\n    this.size = 0;\n    this.capacity = capacity;\n    head = new DLinkedNode();\n    // head.prev = null;\n    tail = new DLinkedNode();\n    // tail.next = null;\n    head.next = tail;\n    tail.prev = head;\n  }\n  public int get(int key) {\n    DLinkedNode node = cache.get(key);\n    if (node == null) return -1;\n    // move the accessed node to the head;\n    moveToHead(node);\n    return node.value;\n  }\n  public void put(int key, int value) {\n    DLinkedNode node = cache.get(key);\n    if(node == null) {\n      DLinkedNode newNode = new DLinkedNode();\n      newNode.key = key;\n      newNode.value = value;\n      cache.put(key, newNode);\n      addNode(newNode);\n      ++size;\n      if(size > capacity) {\n        // pop the tail\n        DLinkedNode tail = popTail();\n        cache.remove(tail.key);\n        --size;\n      }\n    } else {\n      // update the value.\n      node.value = value;\n      moveToHead(node);\n    }\n  }\n}\n"]}
{"number": 149, "statement": "Given n points on a 2D plane, find the maximum number of points that lie on the same straight line.\n", "solutions": ["class Solution {\n  int[][] points;\n  int n;\n  HashMap<Double, Integer> lines = new HashMap<Double, Integer>();\n  int horisontal_lines;\n  public Pair<Integer, Integer> add_line(int i, int j, int count, int duplicates) {\n    /*\n    Add a line passing through i and j points.\n    Update max number of points on a line containing point i.\n    Update a number of duplicates of i point.\n    */\n    // rewrite points as coordinates\n    int x1 = points[i][0];\n    int y1 = points[i][1];\n    int x2 = points[j][0];\n    int y2 = points[j][1];\n    // add a duplicate point\n    if ((x1 == x2) && (y1 == y2))\n      duplicates++;\n    // add a horisontal line : y = const\n    else if (y1 == y2) {\n      horisontal_lines += 1;\n      count = Math.max(horisontal_lines, count);\n    }\n    // add a line : x = slope * y + c\n    // only slope is needed for a hash-map\n    // since we always start from the same point\n    else {\n      double slope = 1.0 * (x1 - x2) / (y1 - y2) + 0.0;\n      lines.put(slope, lines.getOrDefault(slope, 1) + 1);\n      count = Math.max(lines.get(slope), count);\n    }\n    return new Pair(count, duplicates);\n  }\n  public int max_points_on_a_line_containing_point_i(int i) {\n    /*\n    Compute the max number of points\n    for a line containing point i.\n    */\n    // init lines passing through point i\n    lines.clear();\n    horisontal_lines = 1;\n    // One starts with just one point on a line : point i.\n    int count = 1;\n    // There is no duplicates of a point i so far.\n    int duplicates = 0;\n    // Compute lines passing through point i (fixed)\n    // and point j (interation).\n    // Update in a loop the number of points on a line\n    // and the number of duplicates of point i.\n    for (int j = i + 1; j < n; j++) {\n      Pair<Integer, Integer> p = add_line(i, j, count, duplicates);\n      count = p.getKey();\n      duplicates = p.getValue();\n    }\n    return count + duplicates;\n  }\n  public int maxPoints(int[][] points) {\n    this.points = points;\n    // If the number of points is less than 3\n    // they are all on the same line.\n    n = points.length;\n    if (n < 3)\n      return n;\n    int max_count = 1;\n    // Compute in a loop a max number of points \n    // on a line containing point i.\n    for (int i = 0; i < n - 1; i++)\n      max_count = Math.max(max_points_on_a_line_containing_point_i(i), max_count);\n    return max_count;\n  }\n}\n"]}
{"number": 150, "statement": "Evaluate the value of an arithmetic expression in Reverse Polish Notation.\nValid operators are +, -, *, /. Each operand may be an integer or another expression.\nNote:\nDivision between two integers should truncate toward zero.\nThe given RPN expression is always valid. That means the expression would always evaluate to a result and there won'tbe anydivideby zero operation.\n", "solutions": ["class Solution {\n    \n    private static final Map<String, BiFunction<Integer, Integer, Integer>> OPERATIONS = new HashMap<>();\n    \n    // Ensure this only gets done once for ALL test cases.\n    static {\n        OPERATIONS.put(\"+\", (a, b) -> a + b);\n        OPERATIONS.put(\"-\", (a, b) -> a - b);\n        OPERATIONS.put(\"*\", (a, b) -> a * b);\n        OPERATIONS.put(\"/\", (a, b) -> a / b);\n    }\n    \n    public int evalRPN(String[] tokens) {\n        \n        int currentPosition = 0;\n        int length = tokens.length; // We need to keep track of this ourselves.\n        \n        while (length > 1) {\n            \n            // Move the position pointer to the next operator token.\n            while (!OPERATIONS.containsKey(tokens[currentPosition])) {\n                currentPosition++;\n            }\n            \n            // Extract the operation and numbers to apply operation too.\n            String operation = tokens[currentPosition];\n            int number1 = Integer.parseInt(tokens[currentPosition - 2]);\n            int number2 = Integer.parseInt(tokens[currentPosition - 1]);\n            \n            // Calculate the result to overwrite the operator with.\n            BiFunction<Integer, Integer, Integer> operator = OPERATIONS.get(operation);\n            int value = operator.apply(number1, number2);\n            tokens[currentPosition] = Integer.toString(value);\n            \n            // Delete numbers and point pointers correctly.\n            delete2AtIndex(tokens, currentPosition - 2, length);\n            currentPosition--;\n            length -= 2;\n        } \n        \n        return Integer.parseInt(tokens[0]);\n    }\n    \n    private void delete2AtIndex(String[] tokens, int d, int length) {\n        for (int i = d; i < length - 2; i++) {\n            tokens[i] = tokens[i + 2];\n        }\n    }\n}\n", "class Solution {\n    public int evalRPN(String[] tokens) {\n        \n        int currentPosition = 0;\n        int length = tokens.length; // We will need to keep track of this ourselves.\n        \n        while (length > 1) {\n            \n            // Move the position pointer to the next operator token.\n            while (!\"+-*/\".contains(tokens[currentPosition])) {\n                currentPosition++;\n            }\n            \n            // Extract the numbers.\n            int number1 = Integer.parseInt(tokens[currentPosition - 2]);\n            int number2 = Integer.parseInt(tokens[currentPosition  - 1]);\n            \n            // Calculate the result to overwrite the operator with.\n            int newValue = 0;\n            switch (tokens[currentPosition]) {\n                case \"+\":\n                    newValue = number1 + number2;\n                    break;\n                case \"-\":\n                    newValue = number1 - number2;\n                    break;\n                case \"*\":\n                    newValue = number1 * number2;\n                    break;\n                case \"/\":\n                    newValue = number1 / number2;\n                    break;\n            }\n            tokens[currentPosition] = Integer.toString(newValue);\n            \n            // Delete numbers and point pointers correctly.\n            delete2AtIndex(tokens, currentPosition - 2, length);\n            currentPosition--;\n            length -= 2;\n        }\n        \n        return Integer.parseInt(tokens[0]);\n    }\n    \n    private void delete2AtIndex(String[] tokens, int d, int length) {\n        for (int i = d; i < length - 2; i++) {\n            tokens[i] = tokens[i + 2];\n        }\n    }\n}\n", "class Solution {\n    \n    private static final Map<String, BiFunction<Integer, Integer, Integer>> OPERATIONS = new HashMap<>();\n    \n    // Ensure this only gets done once for ALL test cases.\n    static {\n        OPERATIONS.put(\"+\", (a, b) -> a + b);\n        OPERATIONS.put(\"-\", (a, b) -> a - b);\n        OPERATIONS.put(\"*\", (a, b) -> a * b);\n        OPERATIONS.put(\"/\", (a, b) -> a / b);\n    }\n    \n    public int evalRPN(String[] tokens) {\n        Stack<Integer> stack = new Stack<>();\n        for (String token : tokens) {\n            \n            if (!OPERATIONS.containsKey(token)) {\n                stack.push(Integer.valueOf(token));\n                continue;\n            }\n            \n            int number2 = stack.pop();\n            int number1 = stack.pop();\n            BiFunction<Integer, Integer, Integer> operation;\n            operation = OPERATIONS.get(token);\n            int result = operation.apply(number1, number2);\n            stack.push(result);\n        }\n        \n        return stack.pop();\n        \n    }\n}\n", "class Solution {\n    \n    public int evalRPN(String[] tokens) {\n        \n        Stack<Integer> stack = new Stack<>();\n        \n        for (String token : tokens) {\n            \n            if (!\"+-*/\".contains(token)) {\n                stack.push(Integer.valueOf(token));\n                continue;\n            }\n            \n            int number2 = stack.pop();\n            int number1 = stack.pop();\n            \n            int result = 0;\n            \n            switch (token) {\n                case \"+\":\n                    result = number1 + number2;\n                    break;\n                case \"-\":\n                    result = number1 - number2;\n                    break;\n                case \"*\":\n                    result = number1 * number2;\n                    break;\n                case \"/\":\n                    result = number1 / number2;\n                    break;\n            }\n            \n            stack.push(result);\n            \n        }\n        \n        return stack.pop();\n    }\n}\n"]}
{"number": 151, "statement": "Given an input string, reverse the string word by word.\n", "solutions": ["class Solution {\n  public String reverseWords(String s) {\n    // remove leading spaces\n    s = s.trim();\n    // split by multiple spaces\n    List<String> wordList = Arrays.asList(s.split(\"\\\\s+\"));\n    Collections.reverse(wordList);\n    return String.join(\" \", wordList);\n  }\n}\n", "class Solution {\n  public:\n  string reverseWords(string s) {\n    // reverse the whole string\n    reverse(s.begin(), s.end());\n    int n = s.size();\n    int idx = 0;\n    for (int start = 0; start < n; ++start) {\n      if (s[start] != ' ') {\n        // go to the beginning of the word\n        if (idx != 0) s[idx++] = ' ';\n        // go to the end of the word\n        int end = start;\n        while (end < n && s[end] != ' ') s[idx++] = s[end++];\n        // reverse the word\n        reverse(s.begin() + idx - (end - start), s.begin() + idx);\n        // move to the next word\n        start = end;\n      }\n    }\n    s.erase(s.begin() + idx, s.end());\n    return s;\n  }\n};\n", "class Solution {\n  public String reverseWords(String s) {\n    int left = 0, right = s.length() - 1;\n    // remove leading spaces\n    while (left <= right && s.charAt(left) == ' ') ++left;\n    // remove trailing spaces\n    while (left <= right && s.charAt(right) == ' ') --right;\n    Deque<String> d = new ArrayDeque();\n    StringBuilder word = new StringBuilder();\n    // push word by word in front of deque\n    while (left <= right) {\n      char c = s.charAt(left);\n      if ((word.length() != 0) && (c == ' ')) {\n        d.offerFirst(word.toString());\n        word.setLength(0);\n      } else if (c != ' ') {\n        word.append(c);\n      }\n      ++left;\n    }\n    d.offerFirst(word.toString());\n    return String.join(\" \", d);\n  }\n}\n"]}
{"number": 153, "statement": "Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.\n(i.e., [0,1,2,4,5,6,7]might become [4,5,6,7,0,1,2]).\nFind the minimum element.\nYou may assume no duplicate exists in the array.\n", "solutions": ["class Solution {\n  public int findMin(int[] nums) {\n    // If the list has just one element then return that element.\n    if (nums.length == 1) {\n      return nums[0];\n    }\n    // initializing left and right pointers.\n    int left = 0, right = nums.length - 1;\n    // if the last element is greater than the first element then there is no rotation.\n    // e.g. 1 < 2 < 3 < 4 < 5 < 7. Already sorted array.\n    // Hence the smallest element is first element. A[0]\n    if (nums[right] > nums[0]) {\n      return nums[0];\n    }\n    \n    // Binary search way\n    while (right >= left) {\n      // Find the mid element\n      int mid = left + (right - left) / 2;\n      // if the mid element is greater than its next element then mid+1 element is the smallest\n      // This point would be the point of change. From higher to lower value.\n      if (nums[mid] > nums[mid + 1]) {\n        return nums[mid + 1];\n      }\n      // if the mid element is lesser than its previous element then mid element is the smallest\n      if (nums[mid - 1] > nums[mid]) {\n        return nums[mid];\n      }\n      // if the mid elements value is greater than the 0th element this means\n      // the least value is still somewhere to the right as we are still dealing with elements\n      // greater than nums[0]\n      if (nums[mid] > nums[0]) {\n        left = mid + 1;\n      } else {\n        // if nums[0] is greater than the mid value then this means the smallest value is somewhere to\n        // the left\n        right = mid - 1;\n      }\n    }\n    return -1;\n  }\n}\n"]}
{"number": 154, "statement": "Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.\n(i.e., [0,1,2,4,5,6,7]might become [4,5,6,7,0,1,2]).\nFind the minimum element.\nThe array may contain duplicates.\n", "solutions": ["class Solution {\n  public int findMin(int[] nums) {\n    int low = 0, high = nums.length - 1;\n    while (low < high) {\n      int pivot = low + (high - low) / 2;\n      if (nums[pivot] < nums[high])\n        high = pivot;\n      else if (nums[pivot] > nums[high])\n        low = pivot + 1;\n      else\n        high -= 1;\n    }\n    return nums[low];\n  }\n}\n"]}
{"number": 155, "statement": "Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.\npush(x) -- Push element x onto stack.\npop() -- Removes the element on top of the stack.\ntop() -- Get the top element.\ngetMin() -- Retrieve the minimum element in the stack.\n", "solutions": ["class MinStack {\n    private Stack<Integer> stack = new Stack<>();\n    private Stack<Integer> minStack = new Stack<>();\n    \n    \n    public MinStack() { }\n    \n    \n    public void push(int x) {\n        stack.push(x);\n        if (minStack.isEmpty() || x <= minStack.peek()) {\n            minStack.push(x);\n        }\n    }\n    \n    \n    public void pop() {\n        if (stack.peek().equals(minStack.peek())) {\n            minStack.pop();\n        }\n        stack.pop();\n    }\n    \n    \n    public int top() {\n        return stack.peek();\n    }\n    \n    public int getMin() {\n        return minStack.peek();\n    }\n}\n"]}
{"number": 161, "statement": "Given two strings sand t, determine if they are both one edit distance apart.\nNote:\nThere are 3 possiblities to satisify one edit distance apart:\nInsert acharacter into sto gett\nDelete acharacter fromsto gett\nReplace a character ofsto gett\n", "solutions": ["class Solution {\n  public boolean isOneEditDistance(String s, String t) {\n    int ns = s.length();\n    int nt = t.length();\n    // Ensure that s is shorter than t.\n    if (ns > nt)\n      return isOneEditDistance(t, s);\n    // The strings are NOT one edit away distance  \n    // if the length diff is more than 1.\n    if (nt - ns > 1)\n      return false;\n    for (int i = 0; i < ns; i++)\n      if (s.charAt(i) != t.charAt(i))\n        // if strings have the same length\n        if (ns == nt)\n          return s.substring(i + 1).equals(t.substring(i + 1));\n        // if strings have different lengths\n        else\n          return s.substring(i).equals(t.substring(i + 1));\n    // If there is no diffs on ns distance\n    // the strings are one edit away only if\n    // t has one more character. \n    return (ns + 1 == nt);\n  }\n}\n"]}
{"number": 162, "statement": "A peak element is an element that is greater than its neighbors.\nGiven an input array nums, where nums[i] \u2260 nums[i+1], find a peak element and return its index.\nThe array may contain multiple peaks, in that case return the index to any one of the peaks is fine.\nYou may imagine that nums[-1] = nums[n] = -\u221e.\n", "solutions": ["public class Solution {\n    public int findPeakElement(int[] nums) {\n        for (int i = 0; i < nums.length - 1; i++) {\n            if (nums[i] > nums[i + 1])\n                return i;\n        }\n        return nums.length - 1;\n    }\n}\n", "public class Solution {\n    public int findPeakElement(int[] nums) {\n        return search(nums, 0, nums.length - 1);\n    }\n    public int search(int[] nums, int l, int r) {\n        if (l == r)\n            return l;\n        int mid = (l + r) / 2;\n        if (nums[mid] > nums[mid + 1])\n            return search(nums, l, mid);\n        return search(nums, mid + 1, r);\n    }\n}\n", "public class Solution {\n    public int findPeakElement(int[] nums) {\n        int l = 0, r = nums.length - 1;\n        while (l < r) {\n            int mid = (l + r) / 2;\n            if (nums[mid] > nums[mid + 1])\n                r = mid;\n            else\n                l = mid + 1;\n        }\n        return l;\n    }\n}\n"]}
{"number": 164, "statement": "Given an unsorted array, find the maximum difference between the successive elements in its sorted form.\nReturn 0 if the array contains less than 2 elements.\n", "solutions": ["int maximumGap(vector<int>& nums)\n{\n    if (nums.empty() || nums.size() < 2)            // check if array is empty or small sized\n        return 0;\n    sort(nums.begin(), nums.end());                 // sort the array\n    int maxGap = 0;\n    for (int i = 0; i < nums.size() - 1; i++)\n        maxGap = max(nums[i + 1] - nums[i], maxGap);\n    return maxGap;\n}\n", "int maximumGap(vector<int>& nums)\n{\n    if (nums.empty() || nums.size() < 2)\n        return 0;\n    int maxVal = *max_element(nums.begin(), nums.end());\n    int exp = 1;                                 // 1, 10, 100, 1000 ...\n    int radix = 10;                              // base 10 system\n    vector<int> aux(nums.size());\n    /* LSD Radix Sort */\n    while (maxVal / exp > 0) {                   // Go through all digits from LSD to MSD\n        vector<int> count(radix, 0);\n        for (int i = 0; i < nums.size(); i++)    // Counting sort\n            count[(nums[i] / exp) % 10]++;\n        for (int i = 1; i < count.size(); i++)   // you could also use partial_sum()\n            count[i] += count[i - 1];\n        for (int i = nums.size() - 1; i >= 0; i--)\n            aux[--count[(nums[i] / exp) % 10]] = nums[i];\n        for (int i = 0; i < nums.size(); i++)\n            nums[i] = aux[i];\n        exp *= 10;\n    }\n    int maxGap = 0;\n    for (int i = 0; i < nums.size() - 1; i++)\n        maxGap = max(nums[i + 1] - nums[i], maxGap);\n    return maxGap;\n}\n", "class Bucket {\npublic:\n    bool used = false;\n    int minval = numeric_limits<int>::max();        // same as INT_MAX\n    int maxval = numeric_limits<int>::min();        // same as INT_MIN\n};\nint maximumGap(vector<int>& nums)\n{\n    if (nums.empty() || nums.size() < 2)\n        return 0;\n    int mini = *min_element(nums.begin(), nums.end()),\n        maxi = *max_element(nums.begin(), nums.end());\n    int bucketSize = max(1, (maxi - mini) / ((int)nums.size() - 1));        // bucket size or capacity\n    int bucketNum = (maxi - mini) / bucketSize + 1;                         // number of buckets\n    vector<Bucket> buckets(bucketNum);\n    for (auto&& num : nums) {\n        int bucketIdx = (num - mini) / bucketSize;                          // locating correct bucket\n        buckets[bucketIdx].used = true;\n        buckets[bucketIdx].minval = min(num, buckets[bucketIdx].minval);\n        buckets[bucketIdx].maxval = max(num, buckets[bucketIdx].maxval);\n    }\n    int prevBucketMax = mini, maxGap = 0;\n    for (auto&& bucket : buckets) {\n        if (!bucket.used)\n            continue;\n        maxGap = max(maxGap, bucket.minval - prevBucketMax);\n        prevBucketMax = bucket.maxval;\n    }\n    return maxGap;\n}\n"]}
{"number": 165, "statement": "Compare two version numbers version1 and version2.\nIf version1  version2 return 1;if version1  version2 return -1;otherwise return 0.\nYou may assume that the version strings are non-empty and contain only digits and the . character.\nThe . character does not represent a decimal point and is used to separate number sequences.\nFor instance, 2.5 is not \"two and a half\" or \"half way to version three\", it is the fifth second-level revision of the second first-level revision.\nYou may assume the default revision number for each level of a version number to be 0. For example, version number 3.4 has a revision number of 3 and 4 for its first and second level revision number. Its third and fourth level revision number are both 0.\n", "solutions": ["class Solution {\n  public int compareVersion(String version1, String version2) {\n    String[] nums1 = version1.split(\"\\\\.\");\n    String[] nums2 = version2.split(\"\\\\.\");\n    int n1 = nums1.length, n2 = nums2.length;\n    // compare versions\n    int i1, i2;\n    for (int i = 0; i < Math.max(n1, n2); ++i) {\n      i1 = i < n1 ? Integer.parseInt(nums1[i]) : 0;\n      i2 = i < n2 ? Integer.parseInt(nums2[i]) : 0;\n      if (i1 != i2) {\n        return i1 > i2 ? 1 : -1;\n      }\n    }\n    // the versions are equal\n    return 0;\n  }\n}\n", "class Solution {\n  public Pair<Integer, Integer> getNextChunk(String version, int n, int p) {\n    // if pointer is set to the end of string\n    // return 0\n    if (p > n - 1) {\n      return new Pair(0, p);\n    }\n    // find the end of chunk\n    int i, pEnd = p;\n    while (pEnd < n && version.charAt(pEnd) != '.') {\n      ++pEnd;\n    }\n    // retrieve the chunk\n    if (pEnd != n - 1) {\n      i = Integer.parseInt(version.substring(p, pEnd));\n    } else {\n      i = Integer.parseInt(version.substring(p, n));\n    }\n    // find the beginning of next chunk\n    p = pEnd + 1;\n    return new Pair(i, p);\n  }\n  public int compareVersion(String version1, String version2) {\n    int p1 = 0, p2 = 0;\n    int n1 = version1.length(), n2 = version2.length();\n    // compare versions\n    int i1, i2;\n    Pair<Integer, Integer> pair;\n    while (p1 < n1 || p2 < n2) {\n      pair = getNextChunk(version1, n1, p1);\n      i1 = pair.getKey();\n      p1 = pair.getValue();\n      pair = getNextChunk(version2, n2, p2);\n      i2 = pair.getKey();\n      p2 = pair.getValue();\n      if (i1 != i2) {\n        return i1 > i2 ? 1 : -1;\n      }\n    }\n    // the versions are equal\n    return 0;\n  }\n}\n"]}
{"number": 166, "statement": "Given two integers representing the numerator and denominator of a fraction, return the fraction in string format.\nIf the fractional part is repeating, enclose the repeating part in parentheses.\n", "solutions": ["public String fractionToDecimal(int numerator, int denominator) {\n    if (numerator == 0) {\n        return \"0\";\n    }\n    StringBuilder fraction = new StringBuilder();\n    // If either one is negative (not both)\n    if (numerator < 0 ^ denominator < 0) {\n        fraction.append(\"-\");\n    }\n    // Convert to Long or else abs(-2147483648) overflows\n    long dividend = Math.abs(Long.valueOf(numerator));\n    long divisor = Math.abs(Long.valueOf(denominator));\n    fraction.append(String.valueOf(dividend / divisor));\n    long remainder = dividend % divisor;\n    if (remainder == 0) {\n        return fraction.toString();\n    }\n    fraction.append(\".\");\n    Map<Long, Integer> map = new HashMap<>();\n    while (remainder != 0) {\n        if (map.containsKey(remainder)) {\n            fraction.insert(map.get(remainder), \"(\");\n            fraction.append(\")\");\n            break;\n        }\n        map.put(remainder, fraction.length());\n        remainder *= 10;\n        fraction.append(String.valueOf(remainder / divisor));\n        remainder %= divisor;\n    }\n    return fraction.toString();\n}\n"]}
{"number": 167, "statement": "Given an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number.\nThe function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2.\nNote:\nYour returned answers (both index1 and index2) are not zero-based.\nYou may assume that each input would have exactly one solution and you may not use the same element twice.\n", "solutions": ["class Solution {\npublic:\n    vector<int> twoSum(vector<int>& numbers, int target) {\n        int low = 0, high = numbers.size() - 1;\n        while (low < high) {\n            int sum = numbers[low] + numbers[high];\n            if (sum == target)\n                return {low + 1, high + 1};\n            else if (sum < target)\n                ++low;\n            else\n                --high;\n        }\n        return {-1, -1};\n    }\n};\n"]}
{"number": 169, "statement": "Given an array of size n, find the majority element. The majority element is the element that appears more than \u230a n/2 \u230b times.\nYou may assume that the array is non-empty and the majority element always exist in the array.\n", "solutions": ["class Solution {\n    public int majorityElement(int[] nums) {\n        int majorityCount = nums.length/2;\n        for (int num : nums) {\n            int count = 0;\n            for (int elem : nums) {\n                if (elem == num) {\n                    count += 1;\n                }\n            }\n            if (count > majorityCount) {\n                return num;\n            }\n        }\n        return -1;    \n    }\n}\n", "class Solution {\n    private Map<Integer, Integer> countNums(int[] nums) {\n        Map<Integer, Integer> counts = new HashMap<Integer, Integer>();\n        for (int num : nums) {\n            if (!counts.containsKey(num)) {\n                counts.put(num, 1);\n            }\n            else {\n                counts.put(num, counts.get(num)+1);\n            }\n        }\n        return counts;\n    }\n    public int majorityElement(int[] nums) {\n        Map<Integer, Integer> counts = countNums(nums);\n        Map.Entry<Integer, Integer> majorityEntry = null;\n        for (Map.Entry<Integer, Integer> entry : counts.entrySet()) {\n            if (majorityEntry == null || entry.getValue() > majorityEntry.getValue()) {\n                majorityEntry = entry;\n            }\n        }\n        return majorityEntry.getKey();\n    }\n}\n", "class Solution {\n    public int majorityElement(int[] nums) {\n        Arrays.sort(nums);\n        return nums[nums.length/2];\n    }\n}\n", "class Solution {\n    private int randRange(Random rand, int min, int max) {\n        return rand.nextInt(max - min) + min;\n    }\n    private int countOccurences(int[] nums, int num) {\n        int count = 0;\n        for (int i = 0; i < nums.length; i++) {\n            if (nums[i] == num) {\n                count++;\n            }\n        }\n        return count;\n    }\n    public int majorityElement(int[] nums) {\n        Random rand = new Random();\n        int majorityCount = nums.length/2;\n        while (true) {\n            int candidate = nums[randRange(rand, 0, nums.length)];\n            if (countOccurences(nums, candidate) > majorityCount) {\n                return candidate;\n            }\n        }\n    }\n}\n", "class Solution {\n    private int countInRange(int[] nums, int num, int lo, int hi) {\n        int count = 0;\n        for (int i = lo; i <= hi; i++) {\n            if (nums[i] == num) {\n                count++;\n            }\n        }\n        return count;\n    }\n    private int majorityElementRec(int[] nums, int lo, int hi) {\n        // base case; the only element in an array of size 1 is the majority\n        // element.\n        if (lo == hi) {\n            return nums[lo];\n        }\n        // recurse on left and right halves of this slice.\n        int mid = (hi-lo)/2 + lo;\n        int left = majorityElementRec(nums, lo, mid);\n        int right = majorityElementRec(nums, mid+1, hi);\n        // if the two halves agree on the majority element, return it.\n        if (left == right) {\n            return left;\n        }\n        // otherwise, count each element and return the \"winner\".\n        int leftCount = countInRange(nums, left, lo, hi);\n        int rightCount = countInRange(nums, right, lo, hi);\n        return leftCount > rightCount ? left : right;\n    }\n    public int majorityElement(int[] nums) {\n        return majorityElementRec(nums, 0, nums.length-1);\n    }\n}\n", "class Solution {\n    public int majorityElement(int[] nums) {\n        int count = 0;\n        Integer candidate = null;\n        for (int num : nums) {\n            if (count == 0) {\n                candidate = num;\n            }\n            count += (num == candidate) ? 1 : -1;\n        }\n        return candidate;\n    }\n}\n"]}
{"number": 170, "statement": "Design and implement a TwoSum class. It should support the following operations: add and find.\nadd - Add the number to an internal data structure.\nfind - Find if there exists any pair of numbers which sum is equal to the value.\n", "solutions": ["import java.util.Collections;\nclass TwoSum {\n  private ArrayList<Integer> nums;\n  private boolean is_sorted;\n  /** Initialize your data structure here. */\n  public TwoSum() {\n    this.nums = new ArrayList<Integer>();\n    this.is_sorted = false;\n  }\n  /** Add the number to an internal data structure.. */\n  public void add(int number) {\n    this.nums.add(number);\n    this.is_sorted = false;\n  }\n  /** Find if there exists any pair of numbers which sum is equal to the value. */\n  public boolean find(int value) {\n    if (!this.is_sorted) {\n      Collections.sort(this.nums);\n    }\n    int low = 0, high = this.nums.size() - 1;\n    while (low < high) {\n      int twosum = this.nums.get(low) + this.nums.get(high);\n      if (twosum < value)\n        low += 1;\n      else if (twosum > value)\n        high -= 1;\n      else\n        return true;\n    }\n    return false;\n  }\n}\n", "import java.util.HashMap;\nclass TwoSum {\n  private HashMap<Integer, Integer> num_counts;\n  /** Initialize your data structure here. */\n  public TwoSum() {\n    this.num_counts = new HashMap<Integer, Integer>();\n  }\n  /** Add the number to an internal data structure.. */\n  public void add(int number) {\n    if (this.num_counts.containsKey(number))\n      this.num_counts.replace(number, this.num_counts.get(number) + 1);\n    else\n      this.num_counts.put(number, 1);\n  }\n  /** Find if there exists any pair of numbers which sum is equal to the value. */\n  public boolean find(int value) {\n    for (Map.Entry<Integer, Integer> entry : this.num_counts.entrySet()) {\n      int complement = value - entry.getKey();\n      if (complement != entry.getKey()) {\n        if (this.num_counts.containsKey(complement))\n          return true;\n      } else {\n        if (entry.getValue() > 1)\n          return true;\n      }\n    }\n    return false;\n  }\n}\n"]}
{"number": 172, "statement": "Given an integer n, return the number of trailing zeroes in n!.\n", "solutions": ["import java.math.BigInteger;\npublic int trailingZeroes(int n) {\n    \n    // Calculate n!\n    BigInteger nFactorial = BigInteger.ONE;\n    for (int i = 2; i <= n; i++) {\n        nFactorial = nFactorial.multiply(BigInteger.valueOf(i));\n    }\n                    \n    // Count how many 0's are on the end.\n    int zeroCount = 0;\n    \n    while (nFactorial.mod(BigInteger.TEN).equals(BigInteger.ZERO)) {\n        nFactorial = nFactorial.divide(BigInteger.TEN);\n        zeroCount++;\n    }\n    \n    return zeroCount;\n}\n", "public int trailingZeroes(int n) {\n        \n    int zeroCount = 0;\n    for (int i = 5; i <= n; i += 5) {\n        int currentFactor = i;\n        while (currentFactor % 5 == 0) {\n            zeroCount++;\n            currentFactor /= 5;\n        }\n    }\n    return zeroCount;\n}\n", "public int trailingZeroes(int n) {\n    \n    int zeroCount = 0;\n    for (int i = 5; i <= n; i += 5) {\n        int powerOf5 = 5;\n        while (i % powerOf5 == 0) {\n            zeroCount += 1;\n            powerOf5 *= 5;\n        }\n    }\n    return zeroCount;\n}\n", "public int trailingZeroes(int n) {\n    int zeroCount = 0;\n    // We need to use long because currentMultiple can potentially become\n    // larger than an int.\n    long currentMultiple = 5;\n    while (n >= currentMultiple) {\n        zeroCount += (n / currentMultiple);\n        currentMultiple *= 5;\n    }\n    return zeroCount;\n}\n", "public int trailingZeroes(int n) {\n    int zeroCount = 0;\n    long currentMultiple = 5;\n    while (n > 0) {\n        n /= 5;\n        zeroCount += n;\n    }\n    return zeroCount;\n}\n"]}
{"number": 173, "statement": "Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST.\nCalling next() will return the next smallest number in the BST.\n", "solutions": ["/**\n * Definition for a binary tree node.\n * public class TreeNode {\n * int val;\n * TreeNode left;\n * TreeNode right;\n * TreeNode(int x) { val = x; }\n * }\n */\nclass BSTIterator {\n    ArrayList<Integer> nodesSorted;\n    int index;\n    public BSTIterator(TreeNode root) {\n        // Array containing all the nodes in the sorted order\n        this.nodesSorted = new ArrayList<Integer>();\n        \n        // Pointer to the next smallest element in the BST\n        this.index = -1;\n        \n        // Call to flatten the input binary search tree\n        this._inorder(root);\n    }\n    private void _inorder(TreeNode root) {\n        if (root == null) {\n            return;\n        }\n        this._inorder(root.left);\n        this.nodesSorted.add(root.val);\n        this._inorder(root.right);\n    }\n    /**\n     * @return the next smallest number\n     */\n    public int next() {\n        return this.nodesSorted.get(++this.index);\n    }\n    /**\n     * @return whether we have a next smallest number\n     */\n    public boolean hasNext() {\n        return this.index + 1 < this.nodesSorted.size();\n    }\n}\n", "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n * int val;\n * TreeNode left;\n * TreeNode right;\n * TreeNode(int x) { val = x; }\n * }\n */\nclass BSTIterator {\n    Stack<TreeNode> stack;\n    public BSTIterator(TreeNode root) {\n        \n        // Stack for the recursion simulation\n        this.stack = new Stack<TreeNode>();\n        \n        // Remember that the algorithm starts with a call to the helper function\n        // with the root node as the input\n        this._leftmostInorder(root);\n    }\n    private void _leftmostInorder(TreeNode root) {\n      \n        // For a given node, add all the elements in the leftmost branch of the tree\n        // under it to the stack.\n        while (root != null) {\n            this.stack.push(root);\n            root = root.left;\n        }\n    }\n    /**\n     * @return the next smallest number\n     */\n    public int next() {\n        // Node at the top of the stack is the next smallest element\n        TreeNode topmostNode = this.stack.pop();\n        // Need to maintain the invariant. If the node has a right child, call the \n        // helper function for the right child\n        if (topmostNode.right != null) {\n            this._leftmostInorder(topmostNode.right);\n        }\n        return topmostNode.val;\n    }\n    /**\n     * @return whether we have a next smallest number\n     */\n    public boolean hasNext() {\n        return this.stack.size() > 0;\n    }\n}\n"]}
{"number": 174, "statement": "table.dungeon, .dungeon th, .dungeon td {\n  border:3px solid black;\n}\n .dungeon th, .dungeon td {\n    text-align: center;\n    height: 70px;\n    width: 70px;\n}\nThe demons had captured the princess (P) and imprisoned her in the bottom-right corner of a dungeon. The dungeon consists of M x N rooms laid out in a 2D grid. Our valiant knight (K) was initially positioned in the top-left room and must fight his way through the dungeon to rescue the princess.\nThe knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately.\nSome of the rooms are guarded by demons, so the knight loses health (negative integers) upon entering these rooms; other rooms are either empty (0's) or contain magic orbs that increase the knight's health (positive integers).\nIn order to reach the princess as quickly as possible, the knight decides to move only rightward or downward in each step.\nWrite a function to determine the knight's minimum initial health so that he is able to rescue the princess.\nFor example, given the dungeon below, the initial health of the knight must be at least 7 if he follows the optimal path RIGHT- RIGHT - DOWN - DOWN.\n-2 (K)\n-3\n3\n-5\n-10\n1\n10\n30\n-5 (P)\nNote:\nThe knight's health has no upper bound.\nAny room can contain threats or power-ups, even the first room the knight enters and the bottom-right room where the princess is imprisoned.\n", "solutions": ["class Solution {\n  int inf = Integer.MAX_VALUE;\n  int[][] dp;\n  int rows, cols;\n  public int getMinHealth(int currCell, int nextRow, int nextCol) {\n    if (nextRow >= this.rows || nextCol >= this.cols)\n      return inf;\n    int nextCell = this.dp[nextRow][nextCol];\n    // hero needs at least 1 point to survive\n    return Math.max(1, nextCell - currCell);\n  }\n  public int calculateMinimumHP(int[][] dungeon) {\n    this.rows = dungeon.length;\n    this.cols = dungeon[0].length;\n    this.dp = new int[rows][cols];\n    for (int[] arr : this.dp) {\n      Arrays.fill(arr, this.inf);\n    }\n    int currCell, rightHealth, downHealth, nextHealth, minHealth;\n    for (int row = this.rows - 1; row >= 0; --row) {\n      for (int col = this.cols - 1; col >= 0; --col) {\n        currCell = dungeon[row][col];\n        rightHealth = getMinHealth(currCell, row, col + 1);\n        downHealth = getMinHealth(currCell, row + 1, col);\n        nextHealth = Math.min(rightHealth, downHealth);\n        if (nextHealth != inf) {\n          minHealth = nextHealth;\n        } else {\n          minHealth = currCell >= 0 ? 1 : 1 - currCell;\n        }\n        this.dp[row][col] = minHealth;\n      }\n    }\n    return this.dp[0][0];\n  }\n}\n", "class MyCircularQueue {\n  protected int capacity;\n  protected int tailIndex;\n  public int[] queue;\n  public MyCircularQueue(int capacity) {\n    this.queue = new int[capacity];\n    this.tailIndex = 0;\n    this.capacity = capacity;\n  }\n  public void enQueue(int value) {\n    this.queue[this.tailIndex] = value;\n    this.tailIndex = (this.tailIndex + 1) % this.capacity;\n  }\n  public int get(int index) {\n    return this.queue[index % this.capacity];\n  }\n}\nclass Solution {\n  int inf = Integer.MAX_VALUE;\n  MyCircularQueue dp;\n  int rows, cols;\n  public int getMinHealth(int currCell, int nextRow, int nextCol) {\n    if (nextRow < 0 || nextCol < 0)\n      return inf;\n    int index = cols * nextRow + nextCol;\n    int nextCell = this.dp.get(index);\n    // hero needs at least 1 point to survive\n    return Math.max(1, nextCell - currCell);\n  }\n  public int calculateMinimumHP(int[][] dungeon) {\n    this.rows = dungeon.length;\n    this.cols = dungeon[0].length;\n    this.dp = new MyCircularQueue(this.cols);\n    int currCell, rightHealth, downHealth, nextHealth, minHealth;\n    for (int row = 0; row < this.rows; ++row) {\n      for (int col = 0; col < this.cols; ++col) {\n        currCell = dungeon[rows - row - 1][cols - col - 1];\n        rightHealth = getMinHealth(currCell, row, col - 1);\n        downHealth = getMinHealth(currCell, row - 1, col);\n        nextHealth = Math.min(rightHealth, downHealth);\n        if (nextHealth != inf) {\n          minHealth = nextHealth;\n        } else {\n          minHealth = currCell >= 0 ? 1 : 1 - currCell;\n        }\n        this.dp.enQueue(minHealth);\n      }\n    }\n    // retrieve the last element in the queue\n    return this.dp.get(this.cols - 1);\n  }\n}\n"]}
{"number": 179, "statement": "Given a list of non negative integers, arrange them such that they form the largest number.\n", "solutions": ["class Solution {\n    private class LargerNumberComparator implements Comparator<String> {\n        @Override\n        public int compare(String a, String b) {\n            String order1 = a + b;\n            String order2 = b + a;\n           return order2.compareTo(order1);\n        }\n    }\n    public String largestNumber(int[] nums) {\n        // Get input integers as strings.\n        String[] asStrs = new String[nums.length];\n        for (int i = 0; i < nums.length; i++) {\n            asStrs[i] = String.valueOf(nums[i]);\n        }\n        // Sort strings according to custom comparator.\n        Arrays.sort(asStrs, new LargerNumberComparator());\n        // If, after being sorted, the largest number is `0`, the entire number\n        // is zero.\n        if (asStrs[0].equals(\"0\")) {\n            return \"0\";\n        }\n        // Build largest number from sorted array.\n        String largestNumberStr = new String();\n        for (String numAsStr : asStrs) {\n            largestNumberStr += numAsStr;\n        }\n        return largestNumberStr;\n    }\n}\n"]}
{"number": 186, "statement": "Given an input string, reverse the string word by word.\n", "solutions": ["class Solution {\n  public:\n  void reverseWords(vector<char>& s) {\n    // reverse the whole string\n    reverse(s.begin(), s.end());\n    int n = s.size();\n    int idx = 0;\n    for (int start = 0; start < n; ++start) {\n      if (s[start] != ' ') {\n        // go to the beginning of the word\n        if (idx != 0) s[idx++] = ' ';\n        // go to the end of the word\n        int end = start;\n        while (end < n && s[end] != ' ') s[idx++] = s[end++];\n        // reverse the word\n        reverse(s.begin() + idx - (end - start), s.begin() + idx);\n        // move to the next word\n        start = end;\n      }\n    }\n  }\n};\n"]}
{"number": 187, "statement": "All DNA is composed of a series of nucleotides abbreviated as A, C, G, and T, for example: \"ACGAATTCCG\". When studying DNA, it is sometimes useful to identify repeated sequences within the DNA.\nWrite a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule.\n", "solutions": ["class Solution {\n  public List<String> findRepeatedDnaSequences(String s) {\n    int L = 10, n = s.length();\n    HashSet<String> seen = new HashSet(), output = new HashSet();\n    // iterate over all sequences of length L\n    for (int start = 0; start < n - L + 1; ++start) {\n      String tmp = s.substring(start, start + L);\n      if (seen.contains(tmp)) output.add(tmp);\n      seen.add(tmp);\n    }\n    return new ArrayList<String>(output);\n  }\n}\n", "class Solution {\n  public List<String> findRepeatedDnaSequences(String s) {\n    int L = 10, n = s.length();\n    if (n <= L) return new ArrayList();\n    // rolling hash parameters: base a\n    int a = 4, aL = (int)Math.pow(a, L);\n    // convert string to array of integers\n    Map<Character, Integer> toInt = new\n            HashMap() {{put('A', 0); put('C', 1); put('G', 2); put('T', 3); }};\n    int[] nums = new int[n];\n    for(int i = 0; i < n; ++i) nums[i] = toInt.get(s.charAt(i));\n    int h = 0;\n    Set<Integer> seen = new HashSet();\n    Set<String> output = new HashSet();\n    // iterate over all sequences of length L\n    for (int start = 0; start < n - L + 1; ++start) {\n      // compute hash of the current sequence in O(1) time\n      if (start != 0)\n        h = h * a - nums[start - 1] * aL + nums[start + L - 1];\n      // compute hash of the first sequence in O(L) time\n      else\n        for(int i = 0; i < L; ++i) h = h * a + nums[i];\n      // update output and hashset of seen sequences\n      if (seen.contains(h)) output.add(s.substring(start, start + L));\n      seen.add(h);\n    }\n    return new ArrayList<String>(output);\n  }\n}\n", "class Solution {\n  public List<String> findRepeatedDnaSequences(String s) {\n    int L = 10, n = s.length();\n    if (n <= L) return new ArrayList();\n    // rolling hash parameters: base a\n    int a = 4, aL = (int)Math.pow(a, L);\n    // convert string to array of integers\n    Map<Character, Integer> toInt = new\n            HashMap() {{put('A', 0); put('C', 1); put('G', 2); put('T', 3); }};\n    int[] nums = new int[n];\n    for(int i = 0; i < n; ++i) nums[i] = toInt.get(s.charAt(i));\n    int bitmask = 0;\n    Set<Integer> seen = new HashSet();\n    Set<String> output = new HashSet();\n    // iterate over all sequences of length L\n    for (int start = 0; start < n - L + 1; ++start) {\n      // compute bitmask of the current sequence in O(1) time\n      if (start != 0) {\n        // left shift to free the last 2 bit\n        bitmask <<= 2;\n        // add a new 2-bits number in the last two bits\n        bitmask |= nums[start + L - 1];\n        // unset first two bits: 2L-bit and (2L + 1)-bit\n        bitmask &= ~(3 << 2 * L);\n      }\n      // compute hash of the first sequence in O(L) time\n      else {\n        for(int i = 0; i < L; ++i) {\n          bitmask <<= 2;\n          bitmask |= nums[i];\n        }\n      }\n      // update output and hashset of seen sequences\n      if (seen.contains(bitmask)) output.add(s.substring(start, start + L));\n      seen.add(bitmask);\n    }\n    return new ArrayList<String>(output);\n  }\n}\n"]}
{"number": 189, "statement": "Given an array, rotate the array to the right by k steps, wherekis non-negative.\nFollow up:\nTry to come up as many solutions as you can, there are at least 3 different ways to solve this problem.\nCould you do it in-place with O(1) extra space?\n", "solutions": ["class Solution {\n  public void rotate(int[] nums, int k) {\n    int temp, previous;\n    for (int i = 0; i < k; i++) {\n      previous = nums[nums.length - 1];\n      for (int j = 0; j < nums.length; j++) {\n        temp = nums[j];\n        nums[j] = previous;\n        previous = temp;\n      }\n    }\n  }\n}\n", "class Solution {\n  public void rotate(int[] nums, int k) {\n    int[] a = new int[nums.length];\n    for (int i = 0; i < nums.length; i++) {\n      a[(i + k) % nums.length] = nums[i];\n    }\n    for (int i = 0; i < nums.length; i++) {\n      nums[i] = a[i];\n    }\n  }\n}\n", "class Solution {\n  public void rotate(int[] nums, int k) {\n    k = k % nums.length;\n    int count = 0;\n    for (int start = 0; count < nums.length; start++) {\n      int current = start;\n      int prev = nums[start];\n      do {\n        int next = (current + k) % nums.length;\n        int temp = nums[next];\n        nums[next] = prev;\n        prev = temp;\n        current = next;\n        count++;\n      } while (start != current);\n    }\n  }\n}\n", "class Solution {\n  public void rotate(int[] nums, int k) {\n    k %= nums.length;\n    reverse(nums, 0, nums.length - 1);\n    reverse(nums, 0, k - 1);\n    reverse(nums, k, nums.length - 1);\n  }\n  public void reverse(int[] nums, int start, int end) {\n    while (start < end) {\n      int temp = nums[start];\n      nums[start] = nums[end];\n      nums[end] = temp;\n      start++;\n      end--;\n    }\n  }\n}\n"]}
{"number": 190, "statement": "Reverse bits of a given 32 bits unsigned integer.\n", "solutions": ["class Solution {\n  public:\n  uint32_t reverseBits(uint32_t n) {\n    uint32_t ret = 0, power = 31;\n    while (n != 0) {\n      ret += (n & 1) << power;\n      n = n >> 1;\n      power -= 1;\n    }\n    return ret;\n  }\n};\n", "class Solution {\npublic:\n    uint32_t reverseByte(uint32_t byte, map<uint32_t, uint32_t> cache) {\n        if (cache.find(byte) != cache.end()) {\n            return cache[byte];\n        }\n        uint32_t value = (byte * 0x0202020202 & 0x010884422010) % 1023;\n        cache.emplace(byte, value);\n        return value;\n    }\n    uint32_t reverseBits(uint32_t n) {\n        uint32_t ret = 0, power = 24;\n        map<uint32_t, uint32_t> cache;\n        while (n != 0) {\n            ret += reverseByte(n & 0xff, cache) << power;\n            n = n >> 8;\n            power -= 8;\n        }\n        return ret;\n    }\n};\n", "class Solution {\npublic:\n    uint32_t reverseBits(uint32_t n) {\n        n = (n >> 16) | (n << 16);\n        n = ((n & 0xff00ff00) >> 8) | ((n & 0x00ff00ff) << 8);\n        n = ((n & 0xf0f0f0f0) >> 4) | ((n & 0x0f0f0f0f) << 4);\n        n = ((n & 0xcccccccc) >> 2) | ((n & 0x33333333) << 2);\n        n = ((n & 0xaaaaaaaa) >> 1) | ((n & 0x55555555) << 1);\n        return n;\n    }\n};\n"]}
{"number": 199, "statement": "Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.\n", "solutions": ["class Solution {\n    public List<Integer> rightSideView(TreeNode root) {\n        Map<Integer, Integer> rightmostValueAtDepth = new HashMap<Integer, Integer>();\n        int max_depth = -1;\n        /* These two stacks are always synchronized, providing an implicit\n         * association values with the same offset on each stack. */\n        Stack<TreeNode> nodeStack = new Stack<TreeNode>();\n        Stack<Integer> depthStack = new Stack<Integer>();\n        nodeStack.push(root);\n        depthStack.push(0);\n        while (!nodeStack.isEmpty()) {\n            TreeNode node = nodeStack.pop();\n            int depth = depthStack.pop();\n            if (node != null) {\n                max_depth = Math.max(max_depth, depth);\n                /* The first node that we encounter at a particular depth contains\n                * the correct value. */\n                if (!rightmostValueAtDepth.containsKey(depth)) {\n                    rightmostValueAtDepth.put(depth, node.val);\n                }\n                nodeStack.push(node.left);\n                nodeStack.push(node.right);\n                depthStack.push(depth+1);\n                depthStack.push(depth+1);\n            }\n        }\n        /* Construct the solution based on the values that we end up with at the\n         * end. */\n        List<Integer> rightView = new ArrayList<Integer>();\n        for (int depth = 0; depth <= max_depth; depth++) {\n            rightView.add(rightmostValueAtDepth.get(depth));\n        }\n        return rightView;\n    }\n}\n", "class Solution {\n    public List<Integer> rightSideView(TreeNode root) {\n        Map<Integer, Integer> rightmostValueAtDepth = new HashMap<Integer, Integer>();\n        int max_depth = -1;\n        /* These two Queues are always synchronized, providing an implicit\n         * association values with the same offset on each Queue. */\n        Queue<TreeNode> nodeQueue = new LinkedList<TreeNode>();\n        Queue<Integer> depthQueue = new LinkedList<Integer>();\n        nodeQueue.add(root);\n        depthQueue.add(0);\n        while (!nodeQueue.isEmpty()) {\n            TreeNode node = nodeQueue.remove();\n            int depth = depthQueue.remove();\n            if (node != null) {\n                max_depth = Math.max(max_depth, depth);\n                /* The last node that we encounter at a particular depth contains\n                * the correct value, so the correct value is never overwritten. */\n                rightmostValueAtDepth.put(depth, node.val);\n                nodeQueue.add(node.left);\n                nodeQueue.add(node.right);\n                depthQueue.add(depth+1);\n                depthQueue.add(depth+1);\n            }\n        }\n        /* Construct the solution based on the values that we end up with at the\n         * end. */\n        List<Integer> rightView = new ArrayList<Integer>();\n        for (int depth = 0; depth <= max_depth; depth++) {\n            rightView.add(rightmostValueAtDepth.get(depth));\n        }\n        return rightView;\n    }\n}\n"]}
{"number": 200, "statement": "Given a 2d grid map of '1's (land) and '0's (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.\n", "solutions": ["class Solution {\nprivate:\n  void dfs(vector<vector<char>>& grid, int r, int c) {\n    int nr = grid.size();\n    int nc = grid[0].size();\n    grid[r][c] = '0';\n    if (r - 1 >= 0 && grid[r-1][c] == '1') dfs(grid, r - 1, c);\n    if (r + 1 < nr && grid[r+1][c] == '1') dfs(grid, r + 1, c);\n    if (c - 1 >= 0 && grid[r][c-1] == '1') dfs(grid, r, c - 1);\n    if (c + 1 < nc && grid[r][c+1] == '1') dfs(grid, r, c + 1);\n  }\npublic:\n  int numIslands(vector<vector<char>>& grid) {\n    int nr = grid.size();\n    if (!nr) return 0;\n    int nc = grid[0].size();\n    int num_islands = 0;\n    for (int r = 0; r < nr; ++r) {\n      for (int c = 0; c < nc; ++c) {\n        if (grid[r][c] == '1') {\n          ++num_islands;\n          dfs(grid, r, c);\n        }\n      }\n    }\n    return num_islands;\n  }\n};\n", "class Solution {\npublic:\n  int numIslands(vector<vector<char>>& grid) {\n    int nr = grid.size();\n    if (!nr) return 0;\n    int nc = grid[0].size();\n    int num_islands = 0;\n    for (int r = 0; r < nr; ++r) {\n      for (int c = 0; c < nc; ++c) {\n        if (grid[r][c] == '1') {\n          ++num_islands;\n          grid[r][c] = '0'; // mark as visited\n          queue<pair<int, int>> neighbors;\n          neighbors.push({r, c});\n          while (!neighbors.empty()) {\n            auto rc = neighbors.front();\n            neighbors.pop();\n            int row = rc.first, col = rc.second;\n            if (row - 1 >= 0 && grid[row-1][col] == '1') {\n              neighbors.push({row-1, col}); grid[row-1][col] = '0';\n            }\n            if (row + 1 < nr && grid[row+1][col] == '1') {\n              neighbors.push({row+1, col}); grid[row+1][col] = '0';\n            }\n            if (col - 1 >= 0 && grid[row][col-1] == '1') {\n              neighbors.push({row, col-1}); grid[row][col-1] = '0';\n            }\n            if (col + 1 < nc && grid[row][col+1] == '1') {\n              neighbors.push({row, col+1}); grid[row][col+1] = '0';\n            }\n          }\n        }\n      }\n    }\n    return num_islands;\n  }\n};\n", "class UnionFind {\npublic:\n  UnionFind(vector<vector<char>>& grid) {\n    count = 0;\n    int m = grid.size();\n    int n = grid[0].size();\n      for (int i = 0; i < m; ++i) {\n        for (int j = 0; j < n; ++j) {\n          if (grid[i][j] == '1') {\n            parent.push_back(i * n + j);\n            ++count;\n          }\n          else parent.push_back(-1);\n          rank.push_back(0);\n        }\n    }\n  }\n  int find(int i) { // path compression\n    if (parent[i] != i) parent[i] = find(parent[i]);\n    return parent[i];\n  }\n  void Union(int x, int y) { // union with rank\n    int rootx = find(x);\n    int rooty = find(y);\n    if (rootx != rooty) {\n      if (rank[rootx] > rank[rooty]) parent[rooty] = rootx;\n      else if (rank[rootx] < rank[rooty]) parent[rootx] = rooty;\n      else {\n        parent[rooty] = rootx; rank[rootx] += 1;\n      }\n      --count;\n    }\n  }\n  int getCount() const {\n    return count;\n  }\nprivate:\n  vector<int> parent;\n  vector<int> rank;\n  int count; // # of connected components\n};\nclass Solution {\npublic:\n  int numIslands(vector<vector<char>>& grid) {\n    int nr = grid.size();\n    if (!nr) return 0;\n    int nc = grid[0].size();\n    UnionFind uf (grid);\n    int num_islands = 0;\n    for (int r = 0; r < nr; ++r) {\n      for (int c = 0; c < nc; ++c) {\n        if (grid[r][c] == '1') {\n          grid[r][c] = '0';\n          if (r - 1 >= 0 && grid[r-1][c] == '1') uf.Union(r * nc + c, (r-1) * nc + c);\n          if (r + 1 < nr && grid[r+1][c] == '1') uf.Union(r * nc + c, (r+1) * nc + c);\n          if (c - 1 >= 0 && grid[r][c-1] == '1') uf.Union(r * nc + c, r * nc + c - 1);\n          if (c + 1 < nc && grid[r][c+1] == '1') uf.Union(r * nc + c, r * nc + c + 1);\n        }\n      }\n    }\n    return uf.getCount();\n  }\n};\n"]}
{"number": 201, "statement": "Given a range [m, n] where 0 = m = n = 2147483647, return the bitwise AND of all numbers in this range, inclusive.\n", "solutions": ["class Solution {\n  public int rangeBitwiseAnd(int m, int n) {\n    int shift = 0;\n    // find the common 1-bits\n    while (m < n) {\n      m >>= 1;\n      n >>= 1;\n      ++shift;\n    }\n    return m << shift;\n  }\n}\n", "class Solution {\n  public int rangeBitwiseAnd(int m, int n) {\n    while (m < n) {\n      // turn off rightmost 1-bit\n      n = n & (n - 1);\n    }\n    return m & n;\n  }\n}\n"]}
{"number": 202, "statement": "Write an algorithm to determine if a number n is \"happy\".\nA happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers.\nReturn True if n is a happy number, and False if not.\n", "solutions": ["class Solution {\n    private int getNext(int n) {\n        int totalSum = 0;\n        while (n > 0) {\n            int d = n % 10;\n            n = n / 10;\n            totalSum += d * d;\n        }\n        return totalSum;\n    }\n    public boolean isHappy(int n) {\n        Set<Integer> seen = new HashSet<>();\n        while (n != 1 && !seen.contains(n)) {\n            seen.add(n);\n            n = getNext(n);\n        }\n        return n == 1;\n    }\n}\n", "class Solution {\n     public int getNext(int n) {\n        int totalSum = 0;\n        while (n > 0) {\n            int d = n % 10;\n            n = n / 10;\n            totalSum += d * d;\n        }\n        return totalSum;\n    }\n    public boolean isHappy(int n) {\n        int slowRunner = n;\n        int fastRunner = getNext(n);\n        while (fastRunner != 1 && slowRunner != fastRunner) {\n            slowRunner = getNext(slowRunner);\n            fastRunner = getNext(getNext(fastRunner));\n        }\n        return fastRunner == 1;\n    }\n}\n", "class Solution {\n    private static Set<Integer> cycleMembers =\n        new HashSet<>(Arrays.asList(4, 16, 37, 58, 89, 145, 42, 20));\n    public int getNext(int n) {\n        int totalSum = 0;\n        while (n > 0) {\n            int d = n % 10;\n            n = n / 10;\n            totalSum += d * d;\n        }\n        return totalSum;\n    }\n    public boolean isHappy(int n) {\n        while (n != 1 && !cycleMembers.contains(n)) {\n            n = getNext(n);\n        }\n        return n == 1;\n    }\n}\n", "class Solution {\n    \n    public int getNext(int n) {\n        int totalSum = 0;\n        while (n > 0) {\n            int d = n % 10;\n            n = n / 10;\n            totalSum += d * d;\n        }\n        return totalSum;\n    }\n    \n    public boolean isHappy(int n) {\n        while (n != 1 && n != 4) {\n            n = getNext(n);\n        }\n        return n == 1;\n    }\n}\n"]}
{"number": 203, "statement": "Remove all elements from a linked list of integers that have value val.\n", "solutions": ["class Solution {\n  public:\n  ListNode* removeElements(ListNode* head, int val) {\n    ListNode* sentinel = new ListNode(0);\n    sentinel->next = head;\n    ListNode *prev = sentinel, *curr = head, *toDelete = nullptr;\n    while (curr != nullptr) {\n      if (curr->val == val) {\n        prev->next = curr->next;\n        toDelete = curr;\n      } else prev = curr;\n      curr = curr->next;\n      if (toDelete != nullptr) {\n        delete toDelete;\n        toDelete = nullptr;\n      }\n    }\n    ListNode *ret = sentinel->next;\n    delete sentinel;\n    return ret;\n  }\n};\n"]}
{"number": 207, "statement": "There are a total of numCourses courses you have to take, labeled from 0 to numCourses-1.\nSome courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]\nGiven the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses?\n", "solutions": ["class Solution {\n  public boolean canFinish(int numCourses, int[][] prerequisites) {\n    // course -> list of next courses\n    HashMap<Integer, List<Integer>> courseDict = new HashMap<>();\n    // build the graph first\n    for (int[] relation : prerequisites) {\n      // relation[0] depends on relation[1]\n      if (courseDict.containsKey(relation[1])) {\n        courseDict.get(relation[1]).add(relation[0]);\n      } else {\n        List<Integer> nextCourses = new LinkedList<>();\n        nextCourses.add(relation[0]);\n        courseDict.put(relation[1], nextCourses);\n      }\n    }\n    boolean[] path = new boolean[numCourses];\n    for (int currCourse = 0; currCourse < numCourses; ++currCourse) {\n      if (this.isCyclic(currCourse, courseDict, path)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  /*\n   * backtracking method to check that no cycle would be formed starting from currCourse\n   */\n  protected boolean isCyclic(\n      Integer currCourse,\n      HashMap<Integer, List<Integer>> courseDict,\n      boolean[] path) {\n    if (path[currCourse]) {\n      // come across a previously visited node, i.e. detect the cycle\n      return true;\n    }\n    // no following courses, no loop.\n    if (!courseDict.containsKey(currCourse))\n      return false;\n    // before backtracking, mark the node in the path\n    path[currCourse] = true;\n    // backtracking\n    boolean ret = false;\n    for (Integer nextCourse : courseDict.get(currCourse)) {\n      ret = this.isCyclic(nextCourse, courseDict, path);\n      if (ret)\n        break;\n    }\n    // after backtracking, remove the node from the path\n    path[currCourse] = false;\n    return ret;\n  }\n}\n", "class Solution {\n  public boolean canFinish(int numCourses, int[][] prerequisites) {\n    // course -> list of next courses\n    HashMap<Integer, List<Integer>> courseDict = new HashMap<>();\n    // build the graph first\n    for (int[] relation : prerequisites) {\n      // relation[0] depends on relation[1]\n      if (courseDict.containsKey(relation[1])) {\n        courseDict.get(relation[1]).add(relation[0]);\n      } else {\n        List<Integer> nextCourses = new LinkedList<>();\n        nextCourses.add(relation[0]);\n        courseDict.put(relation[1], nextCourses);\n      }\n    }\n    boolean[] checked = new boolean[numCourses];\n    boolean[] path = new boolean[numCourses];\n    for (int currCourse = 0; currCourse < numCourses; ++currCourse) {\n      if (this.isCyclic(currCourse, courseDict, checked, path))\n        return false;\n    }\n    return true;\n  }\n  /*\n   * postorder DFS check that no cycle would be formed starting from currCourse\n   */\n  protected boolean isCyclic(\n      Integer currCourse, HashMap<Integer, List<Integer>> courseDict,\n      boolean[] checked, boolean[] path) {\n    // bottom cases\n    if (checked[currCourse])\n      // this node has been checked, no cycle would be formed with this node.\n      return false;\n    if (path[currCourse])\n      // come across a previously visited node, i.e. detect the cycle\n      return true;\n    // no following courses, no loop.\n    if (!courseDict.containsKey(currCourse))\n      return false;\n    // before backtracking, mark the node in the path\n    path[currCourse] = true;\n    boolean ret = false;\n    // postorder DFS, to visit all its children first.\n    for (Integer child : courseDict.get(currCourse)) {\n      ret = this.isCyclic(child, courseDict, checked, path);\n      if (ret)\n        break;\n    }\n    // after the visits of children, we come back to process the node itself\n    // remove the node from the path\n    path[currCourse] = false;\n    // Now that we've visited the nodes in the downstream,\n    // we complete the check of this node.\n    checked[currCourse] = true;\n    return ret;\n  }\n}\n", "class GNode {\n  public Integer inDegrees = 0;\n  public List<Integer> outNodes = new LinkedList<Integer>();\n}\nclass Solution {\n  public boolean canFinish(int numCourses, int[][] prerequisites) {\n    if (prerequisites.length == 0)\n      return true; // no cycle could be formed in empty graph.\n    // course -> list of next courses\n    HashMap<Integer, GNode> graph = new HashMap<>();\n    // build the graph first\n    for (int[] relation : prerequisites) {\n      // relation[1] -> relation[0]\n      GNode prevCourse = this.getCreateGNode(graph, relation[1]);\n      GNode nextCourse = this.getCreateGNode(graph, relation[0]);\n      prevCourse.outNodes.add(relation[0]);\n      nextCourse.inDegrees += 1;\n    }\n    // We start from courses that have no prerequisites.\n    int totalDeps = prerequisites.length;\n    LinkedList<Integer> nodepCourses = new LinkedList<Integer>();\n    for (Map.Entry<Integer, GNode> entry : graph.entrySet()) {\n      GNode node = entry.getValue();\n      if (node.inDegrees == 0)\n        nodepCourses.add(entry.getKey());\n    }\n    int removedEdges = 0;\n    while (nodepCourses.size() > 0) {\n      Integer course = nodepCourses.pop();\n      for (Integer nextCourse : graph.get(course).outNodes) {\n        GNode childNode = graph.get(nextCourse);\n        childNode.inDegrees -= 1;\n        removedEdges += 1;\n        if (childNode.inDegrees == 0)\n          nodepCourses.add(nextCourse);\n      }\n    }\n    if (removedEdges != totalDeps)\n      // if there are still some edges left, then there exist some cycles\n      // Due to the dead-lock (dependencies), we cannot remove the cyclic edges\n      return false;\n    else\n      return true;\n  }\n  /**\n   * Retrieve the existing <key, value> from graph, otherwise create a new one.\n   */\n  protected GNode getCreateGNode(HashMap<Integer, GNode> graph, Integer course) {\n    GNode node = null;\n    if (graph.containsKey(course)) {\n      node = graph.get(course);\n    } else {\n      node = new GNode();\n      graph.put(course, node);\n    }\n    return node;\n  }\n}\n"]}
{"number": 209, "statement": "Given an array of n positive integers and a positive integer s, find the minimal length of a contiguous subarray of which the sum \u2265 s. If there isn't one, return 0 instead.\n", "solutions": ["int minSubArrayLen(int s, vector<int>& nums)\n{\n    int n = nums.size();\n    int ans = INT_MAX;\n    for (int i = 0; i < n; i++) {\n        for (int j = i; j < n; j++) {\n            int sum = 0;\n            for (int k = i; k <= j; k++) {\n                sum += nums[k];\n            }\n            if (sum >= s) {\n                ans = min(ans, (j - i + 1));\n                break; //Found the smallest subarray with sum>=s starting with index i, hence move to next index\n            }\n        }\n    }\n    return (ans != INT_MAX) ? ans : 0;\n}\n", "int minSubArrayLen(int s, vector<int>& nums)\n{\n    int n = nums.size();\n    if (n == 0)\n        return 0;\n    int ans = INT_MAX;\n    vector<int> sums(n);\n    sums[0] = nums[0];\n    for (int i = 1; i < n; i++)\n        sums[i] = sums[i - 1] + nums[i];\n    for (int i = 0; i < n; i++) {\n        for (int j = i; j < n; j++) {\n            int sum = sums[j] - sums[i] + nums[i];\n            if (sum >= s) {\n                ans = min(ans, (j - i + 1));\n                break; //Found the smallest subarray with sum>=s starting with index i, hence move to next index\n            }\n        }\n    }\n    return (ans != INT_MAX) ? ans : 0;\n}\n", "int minSubArrayLen(int s, vector<int>& nums)\n{\n    int n = nums.size();\n    if (n == 0)\n        return 0;\n    int ans = INT_MAX;\n    vector<int> sums(n + 1, 0); //size = n+1 for easier calculations\n    //sums[0]=0 : Meaning that it is the sum of first 0 elements\n    //sums[1]=A[0] : Sum of first 1 elements\n    //ans so on...\n    for (int i = 1; i <= n; i++)\n        sums[i] = sums[i - 1] + nums[i - 1];\n    for (int i = 1; i <= n; i++) {\n        int to_find = s + sums[i - 1];\n        auto bound = lower_bound(sums.begin(), sums.end(), to_find);\n        if (bound != sums.end()) {\n            ans = min(ans, static_cast<int>(bound - (sums.begin() + i - 1)));\n        }\n    }\n    return (ans != INT_MAX) ? ans : 0;\n}\n", "int minSubArrayLen(int s, vector<int>& nums)\n{\n    int n = nums.size();\n    int ans = INT_MAX;\n    int left = 0;\n    int sum = 0;\n    for (int i = 0; i < n; i++) {\n        sum += nums[i];\n        while (sum >= s) {\n            ans = min(ans, i + 1 - left);\n            sum -= nums[left++];\n        }\n    }\n    return (ans != INT_MAX) ? ans : 0;\n}\n"]}
{"number": 210, "statement": "There are a total of n courses you have to take, labeled from 0 to n-1.\nSome courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]\nGiven the total number of courses and a list of prerequisite pairs, return the ordering of courses you should take to finish all courses.\nThere may be multiple correct orders, you just need to return one of them. If it is impossible to finish all courses, return an empty array.\n", "solutions": ["int minSubArrayLen(int s, vector<int>& nums)\n{\n    int n = nums.size();\n    int ans = INT_MAX;\n    int left = 0;\n    int sum = 0;\n    for (int i = 0; i < n; i++) {\n        sum += nums[i];\n        while (sum >= s) {\n            ans = min(ans, i + 1 - left);\n            sum -= nums[left++];\n        }\n    }\n    return (ans != INT_MAX) ? ans : 0;\n}\n", "class Solution {\n  public int[] findOrder(int numCourses, int[][] prerequisites) {\n    boolean isPossible = true;\n    Map<Integer, List<Integer>> adjList = new HashMap<Integer, List<Integer>>();\n    int[] indegree = new int[numCourses];\n    int[] topologicalOrder = new int[numCourses];\n    // Create the adjacency list representation of the graph\n    for (int i = 0; i < prerequisites.length; i++) {\n      int dest = prerequisites[i][0];\n      int src = prerequisites[i][1];\n      List<Integer> lst = adjList.getOrDefault(src, new ArrayList<Integer>());\n      lst.add(dest);\n      adjList.put(src, lst);\n      // Record in-degree of each vertex\n      indegree[dest] += 1;\n    }\n    // Add all vertices with 0 in-degree to the queue\n    Queue<Integer> q = new LinkedList<Integer>();\n    for (int i = 0; i < numCourses; i++) {\n      if (indegree[i] == 0) {\n        q.add(i);\n      }\n    }\n    int i = 0;\n    // Process until the Q becomes empty\n    while (!q.isEmpty()) {\n      int node = q.remove();\n      topologicalOrder[i++] = node;\n      // Reduce the in-degree of each neighbor by 1\n      if (adjList.containsKey(node)) {\n        for (Integer neighbor : adjList.get(node)) {\n          indegree[neighbor]--;\n          // If in-degree of a neighbor becomes 0, add it to the Q\n          if (indegree[neighbor] == 0) {\n            q.add(neighbor);\n          }\n        }\n      }\n    }\n    // Check to see if topological sort is possible or not.\n    if (i == numCourses) {\n      return topologicalOrder;\n    }\n    return new int[0];\n  }\n}\n"]}
{"number": 212, "statement": "Given a 2D board and a list of words from the dictionary, find all words in the board.\nEach word must be constructed from letters of sequentially adjacent cell, where \"adjacent\" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.\n", "solutions": ["class TrieNode {\n  HashMap<Character, TrieNode> children = new HashMap<Character, TrieNode>();\n  String word = null;\n  public TrieNode() {}\n}\nclass Solution {\n  char[][] _board = null;\n  ArrayList<String> _result = new ArrayList<String>();\n  public List<String> findWords(char[][] board, String[] words) {\n    // Step 1). Construct the Trie\n    TrieNode root = new TrieNode();\n    for (String word : words) {\n      TrieNode node = root;\n      for (Character letter : word.toCharArray()) {\n        if (node.children.containsKey(letter)) {\n          node = node.children.get(letter);\n        } else {\n          TrieNode newNode = new TrieNode();\n          node.children.put(letter, newNode);\n          node = newNode;\n        }\n      }\n      node.word = word;  // store words in Trie\n    }\n    this._board = board;\n    // Step 2). Backtracking starting for each cell in the board\n    for (int row = 0; row < board.length; ++row) {\n      for (int col = 0; col < board[row].length; ++col) {\n        if (root.children.containsKey(board[row][col])) {\n          backtracking(row, col, root);\n        }\n      }\n    }\n    return this._result;\n  }\n  \n  private void backtracking(int row, int col, TrieNode parent) {\n    Character letter = this._board[row][col];\n    TrieNode currNode = parent.children.get(letter);\n    // check if there is any match\n    if (currNode.word != null) {\n      this._result.add(currNode.word);\n      currNode.word = null;\n    }\n    // mark the current letter before the EXPLORATION\n    this._board[row][col] = '#';\n    // explore neighbor cells in around-clock directions: up, right, down, left\n    int[] rowOffset = {-1, 0, 1, 0};\n    int[] colOffset = {0, 1, 0, -1};\n    for (int i = 0; i < 4; ++i) {\n      int newRow = row + rowOffset[i];\n      int newCol = col + colOffset[i];\n      if (newRow < 0 || newRow >= this._board.length || newCol < 0\n          || newCol >= this._board[0].length) {\n        continue;\n      }\n      if (currNode.children.containsKey(this._board[newRow][newCol])) {\n        backtracking(newRow, newCol, currNode);\n      }\n    }\n    // End of EXPLORATION, restore the original letter in the board.\n    this._board[row][col] = letter;\n    // Optimization: incrementally remove the leaf nodes\n    if (currNode.children.isEmpty()) {\n      parent.children.remove(letter);\n    }\n  }\n}\n"]}
{"number": 214, "statement": "Given a string s, you are allowed to convert it to a palindrome by adding characters in front of it. Find and return the shortest palindrome you can find by performing this transformation.\n", "solutions": ["string shortestPalindrome(string s)\n{\n    int n = s.size();\n    string rev(s);\n    reverse(rev.begin(), rev.end());\n    int j = 0;\n    for (int i = 0; i < n; i++) {\n        if (s.substr(0, n - i) == rev.substr(i))\n            return rev.substr(0, i) + s;\n    }\n    return \"\";\n}\n", "string shortestPalindrome(string s)\n{\n    int n = s.size();\n    int i = 0;\n    for (int j = n - 1; j >= 0; j--) {\n        if (s[i] == s[j])\n            i++;\n    }\n    if (i == n)\n        return s;\n    string remain_rev = s.substr(i, n);\n    reverse(remain_rev.begin(), remain_rev.end());\n    return remain_rev + shortestPalindrome(s.substr(0, i)) + s.substr(i);\n}\n", "string shortestPalindrome(string s)\n{\n    int n = s.size();\n    string rev(s);\n    reverse(rev.begin(), rev.end());\n    string s_new = s + \"#\" + rev;\n    int n_new = s_new.size();\n    vector<int> f(n_new, 0);\n    for (int i = 1; i < n_new; i++) {\n        int t = f[i - 1];\n        while (t > 0 && s_new[i] != s_new[t])\n            t = f[t - 1];\n        if (s_new[i] == s_new[t])\n            ++t;\n        f[i] = t;\n    }\n    return rev.substr(0, n - f[n_new - 1]) + s;\n}\n"]}
{"number": 215, "statement": "Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.\n", "solutions": ["class Solution {\n    public int findKthLargest(int[] nums, int k) {\n        // init heap 'the smallest element first'\n        PriorityQueue<Integer> heap =\n            new PriorityQueue<Integer>((n1, n2) -> n1 - n2);\n        // keep k largest elements in the heap\n        for (int n: nums) {\n          heap.add(n);\n          if (heap.size() > k)\n            heap.poll();\n        }\n        // output\n        return heap.poll();        \n  }\n}\n", "import java.util.Random;\nclass Solution {\n  int [] nums;\n  public void swap(int a, int b) {\n    int tmp = this.nums[a];\n    this.nums[a] = this.nums[b];\n    this.nums[b] = tmp;\n  }\n  public int partition(int left, int right, int pivot_index) {\n    int pivot = this.nums[pivot_index];\n    // 1. move pivot to end\n    swap(pivot_index, right);\n    int store_index = left;\n    // 2. move all smaller elements to the left\n    for (int i = left; i <= right; i++) {\n      if (this.nums[i] < pivot) {\n        swap(store_index, i);\n        store_index++;\n      }\n    }\n    // 3. move pivot to its final place\n    swap(store_index, right);\n    return store_index;\n  }\n  public int quickselect(int left, int right, int k_smallest) {\n    /*\n    Returns the k-th smallest element of list within left..right.\n    */\n    if (left == right) // If the list contains only one element,\n      return this.nums[left];  // return that element\n    // select a random pivot_index\n    Random random_num = new Random();\n    int pivot_index = left + random_num.nextInt(right - left); \n    \n    pivot_index = partition(left, right, pivot_index);\n    // the pivot is on (N - k)th smallest position\n    if (k_smallest == pivot_index)\n      return this.nums[k_smallest];\n    // go left side\n    else if (k_smallest < pivot_index)\n      return quickselect(left, pivot_index - 1, k_smallest);\n    // go right side\n    return quickselect(pivot_index + 1, right, k_smallest);\n  }\n  public int findKthLargest(int[] nums, int k) {\n    this.nums = nums;\n    int size = nums.length;\n    // kth largest is (N - k)th smallest\n    return quickselect(0, size - 1, size - k);\n  }\n}\n"]}
{"number": 218, "statement": "A city's skyline is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance. Now suppose you are given the locations and height of all the buildings as shown on a cityscape photo (Figure A), write a program to output the skyline formed by these buildings collectively (Figure B).\nThe geometric information of each building is represented by a triplet of integers [Li, Ri, Hi], where Li and Ri are the x coordinates of the left and right edge of the ith building, respectively, and Hi is its height. It is guaranteed that 0 \u2264 Li, Ri \u2264 INT_MAX, 0  Hi \u2264 INT_MAX, and Ri - Li  0. You may assume all buildings are perfect rectangles grounded on an absolutely flat surface at height 0.\nFor instance, the dimensions of all buildings in Figure A are recorded as: [ [2 9 10], [3 7 15], [5 12 12], [15 20 10], [19 24 8] ] .\nThe output is a list of \"key points\" (red dots in Figure B) in the format of [ [x1,y1], [x2, y2], [x3, y3], ... ] that uniquely defines a skyline. A key point is the left endpoint of a horizontal line segment. Note that the last key point, where the rightmost building ends, is merely used to mark the termination of the skyline, and always has zero height. Also, the ground in between any two adjacent buildings should be considered part of the skyline contour.\nFor instance, the skyline in Figure B should be represented as:[ [2 10], [3 15], [7 12], [12 0], [15 10], [20 8], [24, 0] ].\nNotes:\nThe number of buildings in any input list is guaranteed to be in the range [0, 10000].\nThe input list is already sorted in ascending order by the left x position Li.\nThe output list must be sorted by the x position.\nThere must be no consecutive horizontal lines of equal height in the output skyline. For instance, [...[2 3], [4 5], [7 5], [11 5], [12 7]...] is not acceptable; the three lines of height 5 should be merged into one in the final output as such: [...[2 3], [4 5], [12 7], ...]\n", "solutions": ["class Solution {\n  /**\n   *  Divide-and-conquer algorithm to solve skyline problem, \n   *  which is similar with the merge sort algorithm.\n   */\n  public List<List<Integer>> getSkyline(int[][] buildings) {\n    int n = buildings.length;\n    List<List<Integer>> output = new ArrayList<List<Integer>>();\n    // The base cases \n    if (n == 0) return output;\n    if (n == 1) {\n      int xStart = buildings[0][0];\n      int xEnd = buildings[0][1];\n      int y = buildings[0][2];\n      output.add(new ArrayList<Integer>() {{add(xStart); add(y); }});\n      output.add(new ArrayList<Integer>() {{add(xEnd); add(0); }});\n      // output.add(new int[]{xStart, y});\n      // output.add(new int[]{xEnd, 0});\n      return output;\n    }\n    // If there is more than one building, \n    // recursively divide the input into two subproblems.\n    List<List<Integer>> leftSkyline, rightSkyline;\n    leftSkyline = getSkyline(Arrays.copyOfRange(buildings, 0, n / 2));\n    rightSkyline = getSkyline(Arrays.copyOfRange(buildings, n / 2, n));\n    // Merge the results of subproblem together.\n    return mergeSkylines(leftSkyline, rightSkyline);\n  }\n  /**\n   *  Merge two skylines together.\n   */\n  public List<List<Integer>> mergeSkylines(List<List<Integer>> left, List<List<Integer>> right) {\n    int nL = left.size(), nR = right.size();\n    int pL = 0, pR = 0;\n    int currY = 0, leftY = 0, rightY = 0;\n    int x, maxY;\n    List<List<Integer>> output = new ArrayList<List<Integer>>();\n    // while we're in the region where both skylines are present\n    while ((pL < nL) && (pR < nR)) {\n      List<Integer> pointL = left.get(pL);\n      List<Integer> pointR = right.get(pR);\n      // pick up the smallest x\n      if (pointL.get(0) < pointR.get(0)) {\n        x = pointL.get(0);\n        leftY = pointL.get(1);\n        pL++;\n      }\n      else {\n        x = pointR.get(0);\n        rightY = pointR.get(1);\n        pR++;\n      }\n      // max height (i.e. y) between both skylines\n      maxY = Math.max(leftY, rightY);\n      // update output if there is a skyline change\n      if (currY != maxY) {\n        updateOutput(output, x, maxY);\n        currY = maxY;\n      }\n    }\n    // there is only left skyline\n    appendSkyline(output, left, pL, nL, currY);\n    // there is only right skyline\n    appendSkyline(output, right, pR, nR, currY);\n    return output;\n  }\n  /**\n   * Update the final output with the new element.\n   */\n  public void updateOutput(List<List<Integer>> output, int x, int y) {\n    // if skyline change is not vertical - \n    // add the new point\n    if (output.isEmpty() || output.get(output.size() - 1).get(0) != x)\n      output.add(new ArrayList<Integer>() {{add(x); add(y); }});\n      // if skyline change is vertical - \n      // update the last point\n    else {\n      output.get(output.size() - 1).set(1, y);\n    }\n  }\n  /**\n   *  Append the rest of the skyline elements with indice (p, n)\n   *  to the final output.\n   */\n  public void appendSkyline(List<List<Integer>> output, List<List<Integer>> skyline,\n                            int p, int n, int currY) {\n    while (p < n) {\n      List<Integer> point = skyline.get(p);\n      int x = point.get(0);\n      int y = point.get(1);\n      p++;\n      // update output\n      // if there is a skyline change\n      if (currY != y) {\n        updateOutput(output, x, y);\n        currY = y;\n      }\n    }\n  }\n}\n"]}
{"number": 222, "statement": "Given a complete binary tree, count the number of nodes.\nNote: \nDefinition of a complete binary tree from Wikipedia:\nIn a complete binary tree every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h.\n", "solutions": ["class Solution {\n  public int countNodes(TreeNode root) {\n    return root != null ? 1 + countNodes(root.right) + countNodes(root.left) : 0;\n  }\n}\n", "class Solution {\n  // Return tree depth in O(d) time.\n  public int computeDepth(TreeNode node) {\n    int d = 0;\n    while (node.left != null) {\n      node = node.left;\n      ++d;\n    }\n    return d;\n  }\n  // Last level nodes are enumerated from 0 to 2**d - 1 (left -> right).\n  // Return True if last level node idx exists. \n  // Binary search with O(d) complexity.\n  public boolean exists(int idx, int d, TreeNode node) {\n    int left = 0, right = (int)Math.pow(2, d) - 1;\n    int pivot;\n    for(int i = 0; i < d; ++i) {\n      pivot = left + (right - left) / 2;\n      if (idx <= pivot) {\n        node = node.left;\n        right = pivot;\n      }\n      else {\n        node = node.right;\n        left = pivot + 1;\n      }\n    }\n    return node != null;\n  }\n  public int countNodes(TreeNode root) {\n    // if the tree is empty\n    if (root == null) return 0;\n    int d = computeDepth(root);\n    // if the tree contains 1 node\n    if (d == 0) return 1;\n    // Last level nodes are enumerated from 0 to 2**d - 1 (left -> right).\n    // Perform binary search to check how many nodes exist.\n    int left = 1, right = (int)Math.pow(2, d) - 1;\n    int pivot;\n    while (left <= right) {\n      pivot = left + (right - left) / 2;\n      if (exists(pivot, d, root)) left = pivot + 1;\n      else right = pivot - 1;\n    }\n    // The tree contains 2**d - 1 nodes on the first (d - 1) levels\n    // and left nodes on the last level.\n    return (int)Math.pow(2, d) - 1 + left;\n  }\n}\n"]}
{"number": 224, "statement": "Implement a basic calculator to evaluate a simple expression string.\nThe expression string may contain open ( and closing parentheses ), the plus + or minus sign -, non-negative integers and empty spaces  .\n", "solutions": ["class Solution {\n    public int evaluateExpr(Stack<Object> stack) {\n        int res = 0;\n        if (!stack.empty()) {\n            res = (int) stack.pop();\n        }\n        // Evaluate the expression till we get corresponding ')'\n        while (!stack.empty() && !((char) stack.peek() == ')')) {\n            char sign = (char) stack.pop();\n            if (sign == '+') {\n                res += (int) stack.pop();\n            } else {\n                res -= (int) stack.pop();\n            }\n        }\n        return res;\n    }\n    public int calculate(String s) {\n        int operand = 0;\n        int n = 0;\n        Stack<Object> stack = new Stack<Object>();\n        for (int i = s.length() - 1; i >= 0; i--) {\n            char ch = s.charAt(i);\n            if (Character.isDigit(ch)) {\n                // Forming the operand - in reverse order.\n                operand = (int) Math.pow(10, n) * (int) (ch - '0') + operand;\n                n += 1;\n            } else if (ch != ' ') {\n                if (n != 0) {\n                    // Save the operand on the stack\n                    // As we encounter some non-digit.\n                    stack.push(operand);\n                    n = 0;\n                    operand = 0;\n                }\n                if (ch == '(') {\n                    int res = evaluateExpr(stack);\n                    stack.pop();\n                    // Append the evaluated result to the stack.\n                    // This result could be of a sub-expression within the parenthesis.\n                    stack.push(res);\n                } else {\n                    // For other non-digits just push onto the stack.\n                    stack.push(ch);\n                }\n            }\n        }\n        //Push the last operand to stack, if any.\n        if (n != 0) {\n            stack.push(operand);\n        }\n        // Evaluate any left overs in the stack.\n        return evaluateExpr(stack);\n    }\n}\n", "class Solution {\n    public int calculate(String s) {\n        Stack<Integer> stack = new Stack<Integer>();\n        int operand = 0;\n        int result = 0; // For the on-going result\n        int sign = 1;  // 1 means positive, -1 means negative\n        for (int i = 0; i < s.length(); i++) {\n            char ch = s.charAt(i);\n            if (Character.isDigit(ch)) {\n                // Forming operand, since it could be more than one digit\n                operand = 10 * operand + (int) (ch - '0');\n            } else if (ch == '+') {\n                // Evaluate the expression to the left,\n                // with result, sign, operand\n                result += sign * operand;\n                // Save the recently encountered '+' sign\n                sign = 1;\n                // Reset operand\n                operand = 0;\n            } else if (ch == '-') {\n                result += sign * operand;\n                sign = -1;\n                operand = 0;\n            } else if (ch == '(') {\n                // Push the result and sign on to the stack, for later\n                // We push the result first, then sign\n                stack.push(result);\n                stack.push(sign);\n                // Reset operand and result, as if new evaluation begins for the new sub-expression\n                sign = 1;\n                result = 0;\n            } else if (ch == ')') {\n                // Evaluate the expression to the left\n                // with result, sign and operand\n                result += sign * operand;\n                // ')' marks end of expression within a set of parenthesis\n                // Its result is multiplied with sign on top of stack\n                // as stack.pop() is the sign before the parenthesis\n                result *= stack.pop();\n                // Then add to the next operand on the top.\n                // as stack.pop() is the result calculated before this parenthesis\n                // (operand on stack) + (sign on stack * (result from parenthesis))\n                result += stack.pop();\n                // Reset the operand\n                operand = 0;\n            }\n        }\n        return result + (sign * operand);\n    }\n}\n"]}
{"number": 230, "statement": "Given a binary search tree, write a function kthSmallest to find the kth smallest element in it.\nNote: \nYou may assume k is always valid, 1 \u2264 k \u2264 BST's total elements.\n", "solutions": ["class Solution {\n  public int kthSmallest(TreeNode root, int k) {\n    LinkedList<TreeNode> stack = new LinkedList<TreeNode>();\n    while (true) {\n      while (root != null) {\n        stack.add(root);\n        root = root.left;\n      }\n      root = stack.removeLast();\n      if (--k == 0) return root.val;\n      root = root.right;\n    }\n  }\n}\n"]}
{"number": 231, "statement": "Given an integer, write a function to determine if it is a power of two.\n", "solutions": ["class Solution {\n  public:\n  bool isPowerOfTwo(int n) {\n    if (n == 0) return false;\n    long x = n;\n    return (x & (-x)) == x;\n  }\n};\n"]}
{"number": 233, "statement": "Given an integer n, count the total number of digit 1 appearing in all non-negative integers less than or equal to n.\n", "solutions": ["int countDigitOne(int n)\n{\n    int countr = 0;\n    for (int i = 1; i <= n; i++) {\n        string str = to_string(i);\n        countr += count(str.begin(), str.end(), '1');\n    }\n    return countr;\n}\n", "int countDigitOne(int n)\n{\n    int countr = 0;\n    for (long long i = 1; i <= n; i *= 10) {\n        long long divider = i * 10;\n        countr += (n / divider) * i + min(max(n % divider - i + 1, 0LL), i);\n    }\n    return countr;\n}\n"]}
{"number": 234, "statement": "Given a singly linked list, determine if it is a palindrome.\n", "solutions": ["class Solution {\n    public boolean isPalindrome(ListNode head) {\n        List<Integer> vals = new ArrayList<>();\n        // Convert LinkedList into ArrayList.\n        ListNode currentNode = head;\n        while (currentNode != null) {\n            vals.add(currentNode.val);\n            currentNode = currentNode.next;\n        }\n        // Use two-pointer technique to check for palindrome.\n        int front = 0;\n        int back = vals.size() - 1;\n        while (front < back) {\n            // Note that we must use ! .equals instead of !=\n            // because we are comparing Integer, not int.\n            if (!vals.get(front).equals(vals.get(back))) {\n                return false;\n            }\n            front++;\n            back--;\n        }\n        return true;\n    }\n}\n", "class Solution {\n    private ListNode frontPointer;\n    private boolean recursivelyCheck(ListNode currentNode) {\n        if (currentNode != null) {\n            if (!recursivelyCheck(currentNode.next)) return false;\n            if (currentNode.val != frontPointer.val) return false;\n            frontPointer = frontPointer.next;\n        }\n        return true;\n    }\n    public boolean isPalindrome(ListNode head) {\n        frontPointer = head;\n        return recursivelyCheck(head);\n    }\n}\n", "class Solution {\n    public boolean isPalindrome(ListNode head) {\n        if (head == null) return true;\n        // Find the end of first half and reverse second half.\n        ListNode firstHalfEnd = endOfFirstHalf(head);\n        ListNode secondHalfStart = reverseList(firstHalfEnd.next);\n        // Check whether or not there is a palindrome.\n        ListNode p1 = head;\n        ListNode p2 = secondHalfStart;\n        boolean result = true;\n        while (result && p2 != null) {\n            if (p1.val != p2.val) result = false;\n            p1 = p1.next;\n            p2 = p2.next;\n        }        \n        // Restore the list and return the result.\n        firstHalfEnd.next = reverseList(secondHalfStart);\n        return result;\n    }\n    // Taken from https://leetcode.com/problems/reverse-linked-list/solution/\n    private ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n    private ListNode endOfFirstHalf(ListNode head) {\n        ListNode fast = head;\n        ListNode slow = head;\n        while (fast.next != null && fast.next.next != null) {\n            fast = fast.next.next;\n            slow = slow.next;\n        }\n        return slow;\n    }\n}\n"]}
{"number": 235, "statement": "Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.\nAccording to the definition of LCA on Wikipedia: \u201cThe lowest common ancestor is defined between two nodes p and qas the lowest node in T that has both p and qas descendants (where we allow a node to be a descendant of itself).\u201d\nGiven binary search tree: root =[6,2,8,0,4,7,9,null,null,3,5]\n", "solutions": ["class Solution {\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        // Value of current node or parent node.\n        int parentVal = root.val;\n        // Value of p\n        int pVal = p.val;\n        // Value of q;\n        int qVal = q.val;\n        if (pVal > parentVal && qVal > parentVal) {\n            // If both p and q are greater than parent\n            return lowestCommonAncestor(root.right, p, q);\n        } else if (pVal < parentVal && qVal < parentVal) {\n            // If both p and q are lesser than parent\n            return lowestCommonAncestor(root.left, p, q);\n        } else {\n            // We have found the split point, i.e. the LCA node.\n            return root;\n        }\n    }\n}\n", "class Solution {\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        // Value of p\n        int pVal = p.val;\n        // Value of q;\n        int qVal = q.val;\n        // Start from the root node of the tree\n        TreeNode node = root;\n        // Traverse the tree\n        while (node != null) {\n            // Value of ancestor/parent node.\n            int parentVal = node.val;\n            if (pVal > parentVal && qVal > parentVal) {\n                // If both p and q are greater than parent\n                node = node.right;\n            } else if (pVal < parentVal && qVal < parentVal) {\n                // If both p and q are lesser than parent\n                node = node.left;\n            } else {\n                // We have found the split point, i.e. the LCA node.\n                return node;\n            }\n        }\n        return null;\n    }\n}\n"]}
{"number": 236, "statement": "Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.\nAccording to the definition of LCA on Wikipedia: \u201cThe lowest common ancestor is defined between two nodes pand qas the lowest node in T that has both pand qas descendants (where we allow a node to be a descendant of itself).\u201d\nGiven the following binary tree: root =[3,5,1,6,2,0,8,null,null,7,4]\n", "solutions": ["class Solution {\n    private TreeNode ans;\n    public Solution() {\n        // Variable to store LCA node.\n        this.ans = null;\n    }\n    private boolean recurseTree(TreeNode currentNode, TreeNode p, TreeNode q) {\n        // If reached the end of a branch, return false.\n        if (currentNode == null) {\n            return false;\n        }\n        // Left Recursion. If left recursion returns true, set left = 1 else 0\n        int left = this.recurseTree(currentNode.left, p, q) ? 1 : 0;\n        // Right Recursion\n        int right = this.recurseTree(currentNode.right, p, q) ? 1 : 0;\n        // If the current node is one of p or q\n        int mid = (currentNode == p || currentNode == q) ? 1 : 0;\n        // If any two of the flags left, right or mid become True\n        if (mid + left + right >= 2) {\n            this.ans = currentNode;\n        }\n        // Return true if any one of the three bool values is True.\n        return (mid + left + right > 0);\n    }\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        // Traverse the tree\n        this.recurseTree(root, p, q);\n        return this.ans;\n    }\n}\n", "class Solution {\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        // Stack for tree traversal\n        Deque<TreeNode> stack = new ArrayDeque<>();\n        // HashMap for parent pointers\n        Map<TreeNode, TreeNode> parent = new HashMap<>();\n        parent.put(root, null);\n        stack.push(root);\n        // Iterate until we find both the nodes p and q\n        while (!parent.containsKey(p) || !parent.containsKey(q)) {\n            TreeNode node = stack.pop();\n            // While traversing the tree, keep saving the parent pointers.\n            if (node.left != null) {\n                parent.put(node.left, node);\n                stack.push(node.left);\n            }\n            if (node.right != null) {\n                parent.put(node.right, node);\n                stack.push(node.right);\n            }\n        }\n        // Ancestors set() for node p.\n        Set<TreeNode> ancestors = new HashSet<>();\n        // Process all ancestors for node p using parent pointers.\n        while (p != null) {\n            ancestors.add(p);\n            p = parent.get(p);\n        }\n        // The first ancestor of q which appears in\n        // p's ancestor set() is their lowest common ancestor.\n        while (!ancestors.contains(q))\n            q = parent.get(q);\n        return q;\n    }\n}\n", "class Solution {\n    // Three static flags to keep track of post-order traversal.\n    // Both left and right traversal pending for a node.\n    // Indicates the nodes children are yet to be traversed.\n    private static int BOTH_PENDING = 2;\n    // Left traversal done.\n    private static int LEFT_DONE = 1;\n    // Both left and right traversal done for a node.\n    // Indicates the node can be popped off the stack.\n    private static int BOTH_DONE = 0;\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        Stack<Pair<TreeNode, Integer>> stack = new Stack<Pair<TreeNode, Integer>>();\n        // Initialize the stack with the root node.\n        stack.push(new Pair<TreeNode, Integer>(root, Solution.BOTH_PENDING));\n        // This flag is set when either one of p or q is found.\n        boolean one_node_found = false;\n        // This is used to keep track of the LCA.\n        TreeNode LCA = null;\n        // Child node\n        TreeNode child_node = null;\n        // We do a post order traversal of the binary tree using stack\n        while (!stack.isEmpty()) {\n            Pair<TreeNode, Integer> top = stack.peek();\n            TreeNode parent_node = top.getKey();\n            int parent_state = top.getValue();\n            // If the parent_state is not equal to BOTH_DONE,\n            // this means the parent_node can't be popped off yet.\n            if (parent_state != Solution.BOTH_DONE) {\n                // If both child traversals are pending\n                if (parent_state == Solution.BOTH_PENDING) {\n                    // Check if the current parent_node is either p or q.\n                    if (parent_node == p || parent_node == q) {\n                        // If one_node_found was set already, this means we have found\n                        // both the nodes.\n                        if (one_node_found) {\n                            return LCA;\n                        } else {\n                            // Otherwise, set one_node_found to True,\n                            // to mark one of p and q is found.\n                            one_node_found = true;\n                            // Save the current top element of stack as the LCA.\n                            LCA = stack.peek().getKey();\n                        }\n                    }\n                    // If both pending, traverse the left child first\n                    child_node = parent_node.left;\n                } else {\n                    // traverse right child\n                    child_node = parent_node.right;\n                }\n                // Update the node state at the top of the stack\n                // Since we have visited one more child.\n                stack.pop();\n                stack.push(new Pair<TreeNode, Integer>(parent_node, parent_state - 1));\n                // Add the child node to the stack for traversal.\n                if (child_node != null) {\n                    stack.push(new Pair<TreeNode, Integer>(child_node, Solution.BOTH_PENDING));\n                }\n            } else {\n                // If the parent_state of the node is both done,\n                // the top node could be popped off the stack.\n                // Update the LCA node to be the next top node.\n                if (LCA == stack.pop().getKey() && one_node_found) {\n                    LCA = stack.peek().getKey();\n                }\n            }\n        }\n        return null;\n    }\n}\n"]}
{"number": 238, "statement": "Given an array nums of n integers where n  1, return an array output such that output[i] is equal to the product of all the elements of nums except nums[i].\n", "solutions": ["class Solution {\n    public int[] productExceptSelf(int[] nums) {\n        // The length of the input array\n        int length = nums.length;\n        // The left and right arrays as described in the algorithm\n        int[] L = new int[length];\n        int[] R = new int[length];\n        // Final answer array to be returned\n        int[] answer = new int[length];\n        // L[i] contains the product of all the elements to the left\n        // Note: for the element at index '0', there are no elements to the left,\n        // so L[0] would be 1\n        L[0] = 1;\n        for (int i = 1; i < length; i++) {\n            // L[i - 1] already contains the product of elements to the left of 'i - 1'\n            // Simply multiplying it with nums[i - 1] would give the product of all\n            // elements to the left of index 'i'\n            L[i] = nums[i - 1] * L[i - 1];\n        }\n        // R[i] contains the product of all the elements to the right\n        // Note: for the element at index 'length - 1', there are no elements to the right,\n        // so the R[length - 1] would be 1\n        R[length - 1] = 1;\n        for (int i = length - 2; i >= 0; i--) {\n            // R[i + 1] already contains the product of elements to the right of 'i + 1'\n            // Simply multiplying it with nums[i + 1] would give the product of all\n            // elements to the right of index 'i'\n            R[i] = nums[i + 1] * R[i + 1];\n        }\n        // Constructing the answer array\n        for (int i = 0; i < length; i++) {\n            // For the first element, R[i] would be product except self\n            // For the last element of the array, product except self would be L[i]\n            // Else, multiple product of all elements to the left and to the right\n            answer[i] = L[i] * R[i];\n        }\n        return answer;\n    }\n}\n", "class Solution {\n    public int[] productExceptSelf(int[] nums) {\n        // The length of the input array \n        int length = nums.length;\n        // Final answer array to be returned\n        int[] answer = new int[length];\n        // answer[i] contains the product of all the elements to the left\n        // Note: for the element at index '0', there are no elements to the left,\n        // so the answer[0] would be 1\n        answer[0] = 1;\n        for (int i = 1; i < length; i++) {\n            // answer[i - 1] already contains the product of elements to the left of 'i - 1'\n            // Simply multiplying it with nums[i - 1] would give the product of all \n            // elements to the left of index 'i'\n            answer[i] = nums[i - 1] * answer[i - 1];\n        }\n        // R contains the product of all the elements to the right\n        // Note: for the element at index 'length - 1', there are no elements to the right,\n        // so the R would be 1\n        int R = 1;\n        for (int i = length - 1; i >= 0; i--) {\n            // For the index 'i', R would contain the \n            // product of all elements to the right. We update R accordingly\n            answer[i] = answer[i] * R;\n            R *= nums[i];\n        }\n        return answer;\n    }\n}\n"]}
{"number": 239, "statement": "Given an array nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position. Return the max sliding window.\nFollow up:\nCould you solve it in linear time?\n", "solutions": ["class Solution {\n    public int[] maxSlidingWindow(int[] nums, int k) {\n        int n = nums.length;\n        if (n * k == 0) return new int[0];\n        \n        int [] output = new int[n - k + 1];\n        for (int i = 0; i < n - k + 1; i++) {\n            int max = Integer.MIN_VALUE;\n            for(int j = i; j < i + k; j++) \n                max = Math.max(max, nums[j]);\n            output[i] = max;\n        }\n        return output;\n    }\n}\n", "class Solution {\n  ArrayDeque<Integer> deq = new ArrayDeque<Integer>();\n  int [] nums;\n  public void clean_deque(int i, int k) {\n    // remove indexes of elements not from sliding window\n    if (!deq.isEmpty() && deq.getFirst() == i - k)\n      deq.removeFirst();\n    // remove from deq indexes of all elements \n    // which are smaller than current element nums[i]\n    while (!deq.isEmpty() && nums[i] > nums[deq.getLast()])                           deq.removeLast();\n  }\n  public int[] maxSlidingWindow(int[] nums, int k) {\n    int n = nums.length;\n    if (n * k == 0) return new int[0];\n    if (k == 1) return nums;\n    // init deque and output\n    this.nums = nums;\n    int max_idx = 0;\n    for (int i = 0; i < k; i++) {\n      clean_deque(i, k);\n      deq.addLast(i);\n      // compute max in nums[:k]\n      if (nums[i] > nums[max_idx]) max_idx = i;\n    }\n    int [] output = new int[n - k + 1];\n    output[0] = nums[max_idx];\n    // build output\n    for (int i  = k; i < n; i++) {\n      clean_deque(i, k);\n      deq.addLast(i);\n      output[i - k + 1] = nums[deq.getFirst()];\n    }\n    return output;\n  }\n}\n", "class Solution {\n  public int[] maxSlidingWindow(int[] nums, int k) {\n    int n = nums.length;\n    if (n * k == 0) return new int[0];\n    if (k == 1) return nums;\n    int [] left = new int[n];\n    left[0] = nums[0];\n    int [] right = new int[n];\n    right[n - 1] = nums[n - 1];\n    for (int i = 1; i < n; i++) {\n      // from left to right\n      if (i % k == 0) left[i] = nums[i];  // block_start\n      else left[i] = Math.max(left[i - 1], nums[i]);\n      // from right to left\n      int j = n - i - 1;\n      if ((j + 1) % k == 0) right[j] = nums[j];  // block_end\n      else right[j] = Math.max(right[j + 1], nums[j]);\n    }\n    int [] output = new int[n - k + 1];\n    for (int i = 0; i < n - k + 1; i++)\n      output[i] = Math.max(left[i + k - 1], right[i]);\n    return output;\n  }\n}\n"]}
{"number": 240, "statement": "Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:\nIntegers in each row are sorted in ascending from left to right.\nIntegers in each column are sorted in ascending from top to bottom.\n", "solutions": ["class Solution {\n    public boolean searchMatrix(int[][] matrix, int target) {\n        for (int i = 0; i < matrix.length; i++) {\n            for (int j = 0; j < matrix[0].length; j++) {\n                if (matrix[i][j] == target) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n}\n", "class Solution {\n    private boolean binarySearch(int[][] matrix, int target, int start, boolean vertical) {\n        int lo = start;\n        int hi = vertical ? matrix[0].length-1 : matrix.length-1;\n        while (hi >= lo) {\n            int mid = (lo + hi)/2;\n            if (vertical) { // searching a column\n                if (matrix[start][mid] < target) {\n                    lo = mid + 1;\n                } else if (matrix[start][mid] > target) {\n                    hi = mid - 1;\n                } else {\n                    return true;\n                }\n            } else { // searching a row\n                if (matrix[mid][start] < target) {\n                    lo = mid + 1;\n                } else if (matrix[mid][start] > target) {\n                    hi = mid - 1;\n                } else {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    public boolean searchMatrix(int[][] matrix, int target) {\n        // an empty matrix obviously does not contain `target`\n        if (matrix == null || matrix.length == 0) {\n            return false;\n        }\n        // iterate over matrix diagonals\n        int shorterDim = Math.min(matrix.length, matrix[0].length);\n        for (int i = 0; i < shorterDim; i++) {\n            boolean verticalFound = binarySearch(matrix, target, i, true);\n            boolean horizontalFound = binarySearch(matrix, target, i, false);\n            if (verticalFound || horizontalFound) {\n                return true;\n            }\n        }\n        \n        return false; \n    }\n}\n", "class Solution {\n    private int[][] matrix;\n    private int target;\n    private boolean searchRec(int left, int up, int right, int down) {\n        // this submatrix has no height or no width.\n        if (left > right || up > down) {\n            return false;\n        // `target` is already larger than the largest element or smaller\n        // than the smallest element in this submatrix.\n        } else if (target < matrix[up][left] || target > matrix[down][right]) {\n            return false;\n        }\n        int mid = left + (right-left)/2;\n        // Locate `row` such that matrix[row-1][mid] < target < matrix[row][mid]\n        int row = up;\n        while (row <= down && matrix[row][mid] <= target) {\n            if (matrix[row][mid] == target) {\n                return true;\n            }\n            row++;\n        }\n        return searchRec(left, row, mid-1, down) || searchRec(mid+1, up, right, row-1);\n    }\n    public boolean searchMatrix(int[][] mat, int targ) {\n        // cache input values in object to avoid passing them unnecessarily\n        // to `searchRec`\n        matrix = mat;\n        target = targ;\n        // an empty matrix obviously does not contain `target`\n        if (matrix == null || matrix.length == 0) {\n            return false;\n        }\n        return searchRec(0, 0, matrix[0].length-1, matrix.length-1);\n    }\n}\n", "class Solution {\n    public boolean searchMatrix(int[][] matrix, int target) {\n        // start our \"pointer\" in the bottom-left\n        int row = matrix.length-1;\n        int col = 0;\n        while (row >= 0 && col < matrix[0].length) {\n            if (matrix[row][col] > target) {\n                row--;\n            } else if (matrix[row][col] < target) {\n                col++;\n            } else { // found it\n                return true;\n            }\n        }\n        return false;\n    }\n}\n"]}
{"number": 244, "statement": "Design a class which receives a list of words in the constructor, and implements a method that takes two words word1 and word2 and return the shortest distance between these two words in the list. Your method will be called repeatedly many times with different parameters.\n", "solutions": ["class WordDistance {\n    HashMap<String, ArrayList<Integer>> locations;\n    public WordDistance(String[] words) {\n        this.locations = new HashMap<String, ArrayList<Integer>>();\n        // Prepare a mapping from a word to all it's locations (indices).\n        for (int i = 0; i < words.length; i++) {\n            ArrayList<Integer> loc = this.locations.getOrDefault(words[i], new ArrayList<Integer>());\n            loc.add(i);\n            this.locations.put(words[i], loc);\n        }\n    }\n    public int shortest(String word1, String word2) {\n        ArrayList<Integer> loc1, loc2;\n        // Location lists for both the words\n        // the indices will be in SORTED order by default\n        loc1 = this.locations.get(word1);\n        loc2 = this.locations.get(word2);\n        int l1 = 0, l2 = 0, minDiff = Integer.MAX_VALUE;\n        while (l1 < loc1.size() && l2 < loc2.size()) {\n            minDiff = Math.min(minDiff, Math.abs(loc1.get(l1) - loc2.get(l2)));\n            if (loc1.get(l1) < loc2.get(l2)) {\n                l1++;\n            } else {\n                l2++;\n            }\n        }\n        return minDiff;\n    }\n}\n"]}
{"number": 250, "statement": "Given a binary tree, count the number of uni-value subtrees.\nA Uni-value subtree means all nodes of the subtree have the same value.\n", "solutions": ["public class Solution {\n    int count = 0;\n    boolean is_uni(TreeNode node) {\n        //base case - if the node has no children this is a univalue subtree\n        if (node.left == null && node.right == null) {\n            // found a univalue subtree - increment\n            count++;\n            return true;   \n        }\n        boolean is_unival = true;\n        // check if all of the node's children are univalue subtrees and if they have the same value\n        // also recursively call is_uni for children\n        if (node.left != null) {\n            is_unival = is_uni(node.left) && is_unival && node.left.val == node.val;\n         }\n        if (node.right != null) {\n            is_unival = is_uni(node.right) && is_unival && node.right.val == node.val;\n        }\n        // return if a univalue tree exists here and increment if it does\n        if (!is_unival) return false;\n        count++;\n        return true;\n    }\n    public int countUnivalSubtrees(TreeNode root) {\n        if (root == null) return 0;\n        is_uni(root);\n        return count;\n    }\n}\n", "public class Solution {\n    int count = 0;\n    boolean is_valid_part(TreeNode node, int val) {\n        // considered a valid subtree\n        if (node == null) return true;\n        // check if node.left and node.right are univalue subtrees of value node.val\n        // note that || short circuits but | does not - both sides of the or get evaluated with | so we explore all possible routes\n        if (!is_valid_part(node.left, node.val) | !is_valid_part(node.right, node.val)) return false;\n        // if it passed the last step then this a valid subtree - increment\n        count++;\n        // at this point we know that this node is a univalue subtree of value node.val\n        // pass a boolean indicating if this is a valid subtree for the parent node\n        return node.val == val;\n    }\n    public int countUnivalSubtrees(TreeNode root) {\n        is_valid_part(root, 0);\n        return count;\n    }\n}\n"]}
{"number": 251, "statement": "Design and implement an iterator to flatten a 2d vector. It should support the following operations: next and hasNext.\n", "solutions": ["import java.util.NoSuchElementException;\nclass Vector2D {\n    \n    // Constructor will put all the nums into this list.\n    private List<Integer> nums = new ArrayList<>();\n    // Keep track of where the Iterator is up to.\n    private int position = 0;\n    \n    public Vector2D(int[][] v) {\n        // We need to iterate over the 2D vector, getting all the integers\n        // out of it and putting them into nums (a field).\n        for (int[] innerVector : v) {\n            for (int num : innerVector) {\n                nums.add(num);\n            }\n        }\n    }\n    \n    public int next() {\n        // In Java, we throw a NoSuchElementException when next() is called\n        // on an exhausted Iterator.\n        if (!hasNext()) throw new NoSuchElementException();\n        // Store the number we need to return, as we still need to move position forward.\n        int result = nums.get(position);\n        // Move the position pointer forward by 1, so that it's ready for\n        // the next call to next, and gives a correct hasNext result.\n        position++;\n        return result;\n    }\n    \n    public boolean hasNext() {\n        // There's nums left as long as position is a valid index of the list. \n        return position < nums.size();\n    }\n}\n", "import java.util.NoSuchElementException;\nclass Vector2D {\n    \n    private int[][] vector;\n    private int inner = 0;\n    private int outer = 0;\n    \n    public Vector2D(int[][] v) {\n        // We need to store a *reference* to the input vector. \n        vector = v;\n    }\n    // If the current outer and inner point to an integer, this method does nothing.\n    // Otherwise, inner and outer are advanced until they point to an integer.\n    // If there are no more integers, then outer will be equal to vector.length\n    // when this method terminates.\n    private void advanceToNext() {\n        // While outer is still within the vector, but inner is over the \n        // end of the inner list pointed to by outer, we want to move\n        // forward to the start of the next inner vector.\n        while (outer < vector.length && inner == vector[outer].length) {\n            inner = 0;\n            outer++;\n        }\n    }\n    \n    public int next() {\n        // As per Java specs, throw an exception if there's no next.\n        // This will also ensure the pointers point to an integer otherwise.\n        if (!hasNext()) throw new NoSuchElementException();\n        // Return current element and move inner so that is after the current\n        // element.\n        return vector[outer][inner++];\n    }\n    \n    public boolean hasNext() {\n        // Ensure the position pointers are moved such they point to an integer,\n        // or put outer = vector.length.\n        advanceToNext();\n        // If outer = vector.length then there are no integers left, otherwise\n        // we've stopped at an integer and so there's an integer left.\n        return outer < vector.length;\n    }\n}\n"]}
{"number": 252, "statement": "Given an array of meeting time intervals consisting of start and end times [[s1,e1],[s2,e2],...] (si  ei), determine if a person could attend all meetings.\n", "solutions": ["class Solution {\n  public boolean canAttendMeetings(int[][] intervals) {\n    for (int i = 0; i < intervals.length; i++) {\n      for (int j = i + 1; j < intervals.length; j++) {\n        if (overlap(intervals[i], intervals[j]))\n          return false;\n      }\n    }\n    return true;\n  }\n  public static boolean overlap(int[] i1, int[] i2) {\n    return ((i1[0] >= i2[0] && i1[0] < i2[1]) || (i2[0] >= i1[0] && i2[0] < i1[1]));\n  }\n}\n", "public static boolean overlap(int[] i1, int[] i2) {\n    return (Math.min(i1[1], i2[1]) >\n            Math.max(i1[0], i2[0]));\n}\n", "class Solution {\n  public boolean canAttendMeetings(int[][] intervals) {\n    Arrays.sort(intervals, new Comparator<int[]>() {\n      public int compare(int[] i1, int[] i2) {\n        return i1[0] - i2[0];\n      }\n    });\n    for (int i = 0; i < intervals.length - 1; i++) {\n      if (intervals[i][1] > intervals[i + 1][0])\n        return false;\n    }\n    return true;\n  }\n}\n"]}
{"number": 253, "statement": "Given an array of meeting time intervals consisting of start and end times [[s1,e1],[s2,e2],...] (si  ei), find the minimum number of conference rooms required.\n", "solutions": ["class Solution {\n    public int minMeetingRooms(int[][] intervals) {\n        \n    // Check for the base case. If there are no intervals, return 0\n    if (intervals.length == 0) {\n      return 0;\n    }\n    Integer[] start = new Integer[intervals.length];\n    Integer[] end = new Integer[intervals.length];\n    for (int i = 0; i < intervals.length; i++) {\n      start[i] = intervals[i][0];\n      end[i] = intervals[i][1];\n    }\n    // Sort the intervals by end time\n    Arrays.sort(\n        end,\n        new Comparator<Integer>() {\n          public int compare(Integer a, Integer b) {\n            return a - b;\n          }\n        });\n    // Sort the intervals by start time\n    Arrays.sort(\n        start,\n        new Comparator<Integer>() {\n          public int compare(Integer a, Integer b) {\n            return a - b;\n          }\n        });\n    // The two pointers in the algorithm: e_ptr and s_ptr.\n    int startPointer = 0, endPointer = 0;\n    // Variables to keep track of maximum number of rooms used.\n    int usedRooms = 0;\n    // Iterate over intervals.\n    while (startPointer < intervals.length) {\n      // If there is a meeting that has ended by the time the meeting at `start_pointer` starts\n      if (start[startPointer] >= end[endPointer]) {\n        usedRooms -= 1;\n        endPointer += 1;\n      }\n      // We do this irrespective of whether a room frees up or not.\n      // If a room got free, then this used_rooms += 1 wouldn't have any effect. used_rooms would\n      // remain the same in that case. If no room was free, then this would increase used_rooms\n      usedRooms += 1;\n      startPointer += 1;\n    }\n    return usedRooms;\n  }\n}\n"]}
{"number": 256, "statement": "There are a row of n houses, each house can be painted with one of the three colors: red, blue or green. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color.\nThe cost of painting each house with a certain color is represented by a n x 3 cost matrix. For example, costs[0][0] is the cost of painting house 0 with color red; costs[1][2] is the cost of painting house 1 with color green, and so on... Find the minimum cost to paint all houses.\nNote:\nAll costs are positive integers.\n", "solutions": ["class Solution {\n    private int[][] costs;\n    private Map<String, Integer> memo;\n    public int minCost(int[][] costs) {\n        if (costs.length == 0) {\n            return 0;\n        }\n        this.costs = costs;\n        this.memo = new HashMap<>();\n        return Math.min(paintCost(0, 0), Math.min(paintCost(0, 1), paintCost(0, 2)));\n    }\n    private int paintCost(int n, int color) {\n        if (memo.containsKey(getKey(n, color))) {\n            return memo.get(getKey(n, color));   \n        }\n        int totalCost = costs[n][color];\n        if (n == costs.length - 1) {\n        } else if (color == 0) { // Red\n            totalCost += Math.min(paintCost(n + 1, 1), paintCost(n + 1, 2));\n        } else if (color == 1) { // Green\n            totalCost += Math.min(paintCost(n + 1, 0), paintCost(n + 1, 2));\n        } else { // Blue\n            totalCost += Math.min(paintCost(n + 1, 0), paintCost(n + 1, 1));\n        }        \n        memo.put(getKey(n, color), totalCost);\n        return totalCost;\n    }\n    private String getKey(int n, int color) {\n        return String.valueOf(n) + \" \" + String.valueOf(color);\n    }\n}\n"]}
{"number": 257, "statement": "Given a binary tree, return all root-to-leaf paths.\nNote:A leaf is a node with no children.\n", "solutions": ["/* Definition for a binary tree node. */\npublic class TreeNode {\n  int val;\n  TreeNode left;\n  TreeNode right;\n  TreeNode(int x) {\n    val = x;\n  }\n}\n", "class Solution {\n  public void construct_paths(TreeNode root, String path, LinkedList<String> paths) {\n    if (root != null) {\n      path += Integer.toString(root.val);\n      if ((root.left == null) && (root.right == null))  // if reach a leaf\n        paths.add(path);  // update paths\n      else {\n        path += \"->\";  // extend the current path\n        construct_paths(root.left, path, paths);\n        construct_paths(root.right, path, paths);\n      }\n    }\n  }\n  public List<String> binaryTreePaths(TreeNode root) {\n    LinkedList<String> paths = new LinkedList();\n    construct_paths(root, \"\", paths);\n    return paths;\n  }\n}\n", "class Solution {\n  public List<String> binaryTreePaths(TreeNode root) {\n    LinkedList<String> paths = new LinkedList();\n    if (root == null)\n      return paths;\n    LinkedList<TreeNode> node_stack = new LinkedList();\n    LinkedList<String> path_stack = new LinkedList();\n    node_stack.add(root);\n    path_stack.add(Integer.toString(root.val));\n    TreeNode node;\n    String path;\n    while ( !node_stack.isEmpty() ) {\n      node = node_stack.pollLast();\n      path = path_stack.pollLast();\n      if ((node.left == null) && (node.right == null))\n        paths.add(path);\n      if (node.left != null) {\n        node_stack.add(node.left);\n        path_stack.add(path + \"->\" + Integer.toString(node.left.val));\n      }\n      if (node.right != null) {\n        node_stack.add(node.right);\n        path_stack.add(path + \"->\" + Integer.toString(node.right.val));\n      }\n    }\n    return paths;\n  }\n}\n"]}
{"number": 260, "statement": "Given an array of numbers nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once.\n", "solutions": ["class Solution {\n  public int[] singleNumber(int[] nums) {\n    Map<Integer, Integer> hashmap = new HashMap();\n    for (int n : nums)\n      hashmap.put(n, hashmap.getOrDefault(n, 0) + 1);\n    int[] output = new int[2];\n    int idx = 0;\n    for (Map.Entry<Integer, Integer> item : hashmap.entrySet())\n      if (item.getValue() == 1) output[idx++] = item.getKey();\n    return output;\n  }\n}\n", "class Solution {\n  public int[] singleNumber(int[] nums) {\n    // difference between two numbers (x and y) which were seen only once\n    int bitmask = 0;\n    for (int num : nums) bitmask ^= num;\n    // rightmost 1-bit diff between x and y\n    int diff = bitmask & (-bitmask);\n    int x = 0;\n    // bitmask which will contain only x\n    for (int num : nums) if ((num & diff) != 0) x ^= num;\n    return new int[]{x, bitmask^x};\n  }\n}\n"]}
{"number": 261, "statement": "Given n nodes labeled from 0 to n-1 and a list of undirected edges (each edge is a pair of nodes), write a function to check whether these edges make up a valid tree.\n", "solutions": ["// Create a new list of lists.\nList<List<Integer>> adjacencyList = new ArrayList<>();\n// Initialise an empty list for each node.\nfor (int i = 0; i < n; i++) {\n    adjacencyList.add(new ArrayList<>());\n}\n// Go through the edge list, populating the adjacency list.\nfor (int[] edge : edges) {\n    adjacencyList.get(edge[0]).add(edge[1]);\n    adjacencyList.get(edge[1]).add(edge[0]);\n}\n", "// Use a stack to keep track of unexplored nodes.\nStack<Integer> stack = new Stack<>();\nstack.push(0);\n// Use a set to keep track of already seen nodes to\n// avoid infinite looping. \nSet<Integer> seen = new HashSet<>();\nseen.add(0);\n// While there are nodes remaining on the stack...\nwhile (!stack.isEmpty()) {\n    int node = stack.pop(); // Take one off to visit.\n    // Check for unseen neighbours of this node:\n    for (int neighbour : adjacencyList.get(node)) {\n        if (seen.contains(neighbour)) {\n            continue; // Already seen this node.\n        }\n        // Otherwise, put this neighbour onto stack\n        // and record that it has been seen.\n        stack.push(neighbour);\n        seen.add(neighbour);\n    }\n}\n"]}
{"number": 264, "statement": "Write a program to find the n-th ugly number.\nUgly numbers are positive numbers whose prime factors only include 2, 3, 5.\n", "solutions": ["class Ugly {\n  public int[] nums = new int[1690];\n  Ugly() {\n    HashSet<Long> seen = new HashSet();\n    PriorityQueue<Long> heap = new PriorityQueue<Long>();\n    seen.add(1L);\n    heap.add(1L);\n    long currUgly, newUgly;\n    int[] primes = new int[]{2, 3, 5};\n    for(int i = 0; i < 1690; ++i) {\n      currUgly = heap.poll();\n      nums[i] = (int)currUgly;\n      for(int j : primes) {\n        newUgly = currUgly * j;\n        if (!seen.contains(newUgly)) {\n          seen.add(newUgly);\n          heap.add(newUgly);\n        }\n      }\n    }\n  }\n}\nclass Solution {\n  public static Ugly u = new Ugly();\n  public int nthUglyNumber(int n) {\n    return u.nums[n - 1];\n  }\n}\n", "class Ugly {\n  public int[] nums = new int[1690];\n  Ugly() {\n    nums[0] = 1;\n    int ugly, i2 = 0, i3 = 0, i5 = 0;\n    for(int i = 1; i < 1690; ++i) {\n      ugly = Math.min(Math.min(nums[i2] * 2, nums[i3] * 3), nums[i5] * 5);\n      nums[i] = ugly;\n      if (ugly == nums[i2] * 2) ++i2;\n      if (ugly == nums[i3] * 3) ++i3;\n      if (ugly == nums[i5] * 5) ++i5;\n    }\n  }\n}\nclass Solution {\n  public static Ugly u = new Ugly();\n  public int nthUglyNumber(int n) {\n    return u.nums[n - 1];\n  }\n}\n"]}
{"number": 265, "statement": "There are a row of n houses, each house can be painted with one of the k colors. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color.\nThe cost of painting each house with a certain color is represented by a n x k cost matrix. For example, costs[0][0] is the cost of painting house 0 with color 0; costs[1][2] is the cost of painting house 1 with color 2, and so on... Find the minimum cost to paint all houses.\nNote:\nAll costs are positive integers.\n", "solutions": ["class Solution {\n    private int n;\n    private int k;\n    private int[][] costs;\n    private Map<String, Integer> memo;\n    public int minCostII(int[][] costs) {\n        if (costs.length == 0) return 0;\n        this.k = costs[0].length;\n        this.n = costs.length;\n        this.costs = costs;\n        this.memo = new HashMap<>();\n        int minCost = Integer.MAX_VALUE;\n        for (int color = 0; color < k; color++) {\n            minCost = Math.min(minCost, memoSolve(0, color));\n        }\n        return minCost;\n    }\n    private int memoSolve(int houseNumber, int color) {\n        // Base case: There are no more houses after this one.\n        if (houseNumber == n - 1) {\n            return costs[houseNumber][color];\n        }\n        // Memoization lookup case: Have we already solved this subproblem?\n        if (memo.containsKey(getKey(houseNumber, color))) {\n            return memo.get(getKey(houseNumber, color));\n        }\n        // Recursive case: Determine the minimum cost for the remainder.\n        int minRemainingCost = Integer.MAX_VALUE;\n        for (int nextColor = 0; nextColor < k; nextColor++) {\n            if (color == nextColor) continue;\n            int currentRemainingCost = memoSolve(houseNumber + 1, nextColor);\n            minRemainingCost = Math.min(currentRemainingCost, minRemainingCost);\n        }\n        int totalCost = costs[houseNumber][color] + minRemainingCost;\n        memo.put(getKey(houseNumber, color), totalCost);\n        return totalCost;\n    }\n    // Convert a house number and color into a simple string key for the memo.\n    private String getKey(int n, int color) {\n        return String.valueOf(n) + \" \" + String.valueOf(color);\n    }\n}\n", "class Solution {\n    public int minCostII(int[][] costs) {\n        if (costs.length == 0) return 0;\n        int k = costs[0].length;\n        int n = costs.length;\n        for (int house = 1; house < n; house++) {\n            for (int color = 0; color < k; color++) {\n                int min = Integer.MAX_VALUE;\n                for (int previousColor = 0; previousColor < k; previousColor++) {\n                    if (color == previousColor) continue;\n                    min = Math.min(min, costs[house - 1][previousColor]);\n                }\n                costs[houseNumber][color] += min;\n            }\n        }\n        // Find the minimum in the last row.\n        int min = Integer.MAX_VALUE;\n        for (int c : costs[n - 1]) {\n            min = Math.min(min, c);\n        }\n        return min;\n    }\n}\n", "class Solution {\n    public int minCostII(int[][] costs) {\n        if (costs.length == 0) return 0;\n        int k = costs[0].length;\n        int n = costs.length;\n        int[] previousRow = costs[0];\n        for (int house = 1; house < n; house++) {\n            int[] currentRow = new int[k];\n            for (int color = 0; color < k; color++) {\n                int min = Integer.MAX_VALUE;\n                for (int previousColor = 0; previousColor < k; previousColor++) {\n                    if (color == previousColor) continue;\n                    min = Math.min(min, previousRow[previousColor]);\n                }\n                currentRow[color] += costs[house][color] += min;\n            }\n            previousRow = currentRow;\n        }\n        // Find the minimum in the last row.\n        int min = Integer.MAX_VALUE;\n        for (int c : previousRow) {\n            min = Math.min(min, c);\n        }\n        return min;\n    }\n}\n", "class Solution {\n    public int minCostII(int[][] costs) {\n        if (costs.length == 0) return 0;\n        int k = costs[0].length;\n        int n = costs.length;\n        for (int house = 1; house < n; house++) {\n            // Find the minimum and second minimum color in the PREVIOUS row.\n            int minColor = -1; int secondMinColor = -1;\n            for (int color = 0; color < k; color++) {\n                int cost = costs[house - 1][color];\n                if (minColor == -1 || cost < costs[house - 1][minColor]) {\n                    secondMinColor = minColor;\n                    minColor = color;\n                } else if (secondMinColor == -1 || cost < costs[house - 1][secondMinColor]) {\n                    secondMinColor = color;\n                }\n            }\n            // And now calculate the new costs for the current row.\n            for (int color = 0; color < k; color++) {\n                if (color == minColor) {\n                    costs[house][color] += costs[house - 1][secondMinColor];\n                } else {\n                    costs[house][color] += costs[house - 1][minColor];\n                }\n            }\n        }\n        // Find the minimum in the last row.\n        int min = Integer.MAX_VALUE;\n        for (int c : costs[n - 1]) {\n            min = Math.min(min, c);\n        }\n        return min;\n    }\n}\n", "class Solution {\n    public int minCostII(int[][] costs) {\n        if (costs.length == 0) return 0;\n        int k = costs[0].length;\n        int n = costs.length;\n        /* Firstly, we need to determine the 2 lowest costs of\n         * the first row. We also need to remember the color of\n         * the lowest. */\n        int prevMin = -1; int prevSecondMin = -1; int prevMinColor = -1;\n        for (int color = 0; color < k; color++) {\n            int cost = costs[0][color];\n            if (prevMin == -1 || cost < prevMin) {\n                prevSecondMin = prevMin;\n                prevMinColor = color;\n                prevMin = cost;\n            } else if (prevSecondMin == -1 || cost < prevSecondMin) {\n                prevSecondMin = cost;\n            }\n        }\n        // And now, we need to work our way down, keeping track of the minimums.\n        for (int house = 1; house < n; house++) {\n            int min = -1; int secondMin = -1; int minColor = -1;\n            for (int color = 0; color < k; color++) {\n                // Determine the cost for this cell (without writing it in).\n                int cost = costs[house][color];\n                if (color == prevMinColor) {\n                    cost += prevSecondMin;\n                } else {\n                    cost += prevMin;\n                }\n                // Determine whether or not this current cost is also a minimum.\n                if (min == -1 || cost < min) {\n                    secondMin = min;\n                    minColor = color;\n                    min = cost;\n                } else if (secondMin == -1 || cost < secondMin) {\n                    secondMin = cost;\n                }\n            }\n            // Transfer current mins to be previous mins.\n            prevMin = min;\n            prevSecondMin = secondMin;\n            prevMinColor = minColor;\n        }\n        return prevMin;\n    }\n}\n"]}
{"number": 266, "statement": "Given a string, determine if a permutation of the string could form a palindrome.\n", "solutions": ["public class Solution {\n public boolean canPermutePalindrome(String s) {\n     HashMap < Character, Integer > map = new HashMap < > ();\n     for (int i = 0; i < s.length(); i++) {\n         map.put(s.charAt(i), map.getOrDefault(s.charAt(i), 0) + 1);\n     }\n     int count = 0;\n     for (char key: map.keySet()) {\n         count += map.get(key) % 2;\n     }\n     return count <= 1;\n }\n}\n"]}
{"number": 267, "statement": "Given a string s, return all the palindromic permutations (without duplicates) of it. Return an empty list if no palindromic permutation could be form.\n", "solutions": ["public class Solution {\n    Set < String > set = new HashSet < > ();\n    public List < String > generatePalindromes(String s) {\n        permute(s.toCharArray(), 0);\n        return new ArrayList < String > (set);\n    }\n    public boolean isPalindrome(char[] s) {\n        for (int i = 0; i < s.length; i++) {\n            if (s[i] != s[s.length - 1 - i])\n                return false;\n        }\n        return true;\n    }\n    public void swap(char[] s, int i, int j) {\n        char temp = s[i];\n        s[i] = s[j];\n        s[j] = temp;\n    }\n    void permute(char[] s, int l) {\n        if (l == s.length) {\n            if (isPalindrome(s))\n                set.add(new String(s));\n        } else {\n            for (int i = l; i < s.length; i++) {\n                swap(s, l, i);\n                permute(s, l + 1);\n                swap(s, l, i);\n            }\n        }\n    }\n}\n", "public class Solution {\n    Set < String > set = new HashSet < > ();\n    public List < String > generatePalindromes(String s) {\n        int[] map = new int[128];\n        char[] st = new char[s.length() / 2];\n        if (!canPermutePalindrome(s, map))\n            return new ArrayList < > ();\n        char ch = 0;\n        int k = 0;\n        for (int i = 0; i < map.length; i++) {\n            if (map[i] % 2 == 1)\n                ch = (char) i;\n            for (int j = 0; j < map[i] / 2; j++) {\n                st[k++] = (char) i;\n            }\n        }\n        permute(st, 0, ch);\n        return new ArrayList < String > (set);\n    }\n    public boolean canPermutePalindrome(String s, int[] map) {\n        int count = 0;\n        for (int i = 0; i < s.length(); i++) {\n            map[s.charAt(i)]++;\n            if (map[s.charAt(i)] % 2 == 0)\n                count--;\n            else\n                count++;\n        }\n        return count <= 1;\n    }\n    public void swap(char[] s, int i, int j) {\n        char temp = s[i];\n        s[i] = s[j];\n        s[j] = temp;\n    }\n    void permute(char[] s, int l, char ch) {\n        if (l == s.length) {\n            set.add(new String(s) + (ch == 0 ? \"\" : ch) + new StringBuffer(new String(s)).reverse());\n        } else {\n            for (int i = l; i < s.length; i++) {\n                if (s[l] != s[i] || l == i) {\n                    swap(s, l, i);\n                    permute(s, l + 1, ch);\n                    swap(s, l, i);\n                }\n            }\n        }\n    }\n}\n"]}
{"number": 268, "statement": "Given an array containing n distinct numbers taken from 0, 1, 2, ..., n, find the one that is missing from the array.\n", "solutions": ["class Solution {\n    public int missingNumber(int[] nums) {\n        Arrays.sort(nums);\n        // Ensure that n is at the last index\n        if (nums[nums.length-1] != nums.length) {\n            return nums.length;\n        }\n        // Ensure that 0 is at the first index\n        else if (nums[0] != 0) {\n            return 0;\n        }\n        // If we get here, then the missing number is on the range (0, n)\n        for (int i = 1; i < nums.length; i++) {\n            int expectedNum = nums[i-1] + 1;\n            if (nums[i] != expectedNum) {\n                return expectedNum;\n            }\n        }\n        // Array was not missing any numbers\n        return -1;\n    }\n}\n", "class Solution {\n    public int missingNumber(int[] nums) {\n        Set<Integer> numSet = new HashSet<Integer>();\n        for (int num : nums) numSet.add(num);\n        int expectedNumCount = nums.length + 1;\n        for (int number = 0; number < expectedNumCount; number++) {\n            if (!numSet.contains(number)) {\n                return number;\n            }\n        }\n        return -1;\n    }\n}\n", "class Solution {\n    public int missingNumber(int[] nums) {\n        int missing = nums.length;\n        for (int i = 0; i < nums.length; i++) {\n            missing ^= i ^ nums[i];\n        }\n        return missing;\n    }\n}\n", "class Solution {\n    public int missingNumber(int[] nums) {\n        int expectedSum = nums.length*(nums.length + 1)/2;\n        int actualSum = 0;\n        for (int num : nums) actualSum += num;\n        return expectedSum - actualSum;\n    }\n}\n"]}
{"number": 269, "statement": "There is a new alien language which uses the latin alphabet. However, the order among letters are unknown to you. You receive a list of non-empty words from the dictionary, where words are sorted lexicographically by the rules of this new language. Derive the order of letters in this language.\n", "solutions": ["public String alienOrder(String[] words) {\n    \n    // Step 0: Create data structures and find all unique letters.\n    Map<Character, List<Character>> adjList = new HashMap<>();\n    Map<Character, Integer> counts = new HashMap<>();\n    for (String word : words) {\n        for (char c : word.toCharArray()) {\n            counts.put(c, 0);\n            adjList.put(c, new ArrayList<>());\n        }\n    }\n    \n    // Step 1: Find all edges.\n    for (int i = 0; i < words.length - 1; i++) {\n        String word1 = words[i];\n        String word2 = words[i + 1];\n        // Check that word2 is not a prefix of word1.\n        if (word1.length() > word2.length() && word1.startsWith(word2)) {\n            return \"\";\n        }\n        // Find the first non match and insert the corresponding relation.\n        for (int j = 0; j < Math.min(word1.length(), word2.length()); j++) {\n            if (word1.charAt(j) != word2.charAt(j)) {\n                adjList.get(word1.charAt(j)).add(word2.charAt(j));\n                counts.put(word2.charAt(j), counts.get(word2.charAt(j)) + 1);\n                break;\n            }\n        }\n    }\n    \n    // Step 2: Breadth-first search.\n    StringBuilder sb = new StringBuilder();\n    Queue<Character> queue = new LinkedList<>();\n    for (Character c : counts.keySet()) {\n        if (counts.get(c).equals(0)) {\n            queue.add(c);\n        }\n    }\n    while (!queue.isEmpty()) {\n        Character c = queue.remove();\n        sb.append(c);\n        for (Character next : adjList.get(c)) {\n            counts.put(next, counts.get(next) - 1);\n            if (counts.get(next).equals(0)) {\n                queue.add(next);\n            }\n        }\n    }\n    \n    if (sb.length() < counts.size()) {\n        return \"\";\n    }\n    return sb.toString();\n}\n", "class Solution {\n    \n    private Map<Character, List<Character>> reverseAdjList = new HashMap<>();\n    private Map<Character, Boolean> seen = new HashMap<>();\n    private StringBuilder output = new StringBuilder();\n    \n    public String alienOrder(String[] words) {\n        \n        // Step 0: Put all unique letters into reverseAdjList as keys.\n        for (String word : words) {\n            for (char c : word.toCharArray()) {\n                reverseAdjList.putIfAbsent(c, new ArrayList<>());\n            }\n        }\n        \n        // Step 1: Find all edges and add reverse edges to reverseAdjList.\n        for (int i = 0; i < words.length - 1; i++) {\n            String word1 = words[i];\n            String word2 = words[i + 1];\n            // Check that word2 is not a prefix of word1.\n            if (word1.length() > word2.length() && word1.startsWith(word2)) {\n                return \"\";\n            }\n            // Find the first non match and insert the corresponding relation.\n            for (int j = 0; j < Math.min(word1.length(), word2.length()); j++) {\n                if (word1.charAt(j) != word2.charAt(j)) {\n                    reverseAdjList.get(word2.charAt(j)).add(word1.charAt(j));\n                    break;\n                }\n            }\n        }\n        \n        // Step 2: DFS to build up the output list.\n        for (Character c : reverseAdjList.keySet()) {\n            boolean result = dfs(c);\n            if (!result) return \"\";\n        }\n        \n        \n        if (output.length() < reverseAdjList.size()) {\n            return \"\";\n        }\n        return output.toString();\n    }\n    \n    // Return true iff no cycles detected.\n    private boolean dfs(Character c) {\n        if (seen.containsKey(c)) {\n            return seen.get(c); // If this node was grey (false), a cycle was detected.\n        }\n        seen.put(c, false);\n        for (Character next : reverseAdjList.get(c)) {\n            boolean result = dfs(next);\n            if (!result) return false;\n        }\n        seen.put(c, true);\n        output.append(c);\n        return true;\n    }    \n}\n"]}
{"number": 270, "statement": "Given a non-empty binary search tree and a target value, find the value in the BST that is closest to the target.\nNote:\nGiven target value is a floating point.\nYou are guaranteed to have only one unique value in the BST that is closest to the target.\n", "solutions": ["class Solution {\n  public void inorder(TreeNode root, List<Integer> nums) {\n    if (root == null) return;\n    inorder(root.left, nums);\n    nums.add(root.val);\n    inorder(root.right, nums);\n  }\n  public int closestValue(TreeNode root, double target) {\n    List<Integer> nums = new ArrayList();\n    inorder(root, nums);\n    return Collections.min(nums, new Comparator<Integer>() {\n      @Override\n      public int compare(Integer o1, Integer o2) {\n        return Math.abs(o1 - target) < Math.abs(o2 - target) ? -1 : 1;\n      }\n    });\n  }\n}\n", "class Solution {\n  public int closestValue(TreeNode root, double target) {\n    LinkedList<TreeNode> stack = new LinkedList();\n    long pred = Long.MIN_VALUE;\n    while (!stack.isEmpty() || root != null) {\n      while (root != null) {\n        stack.add(root);\n        root = root.left;\n      }\n      root = stack.removeLast();\n      if (pred <= target && target < root.val)\n        return Math.abs(pred - target) < Math.abs(root.val - target) ? (int)pred : root.val;\n      pred = root.val;\n      root = root.right;\n    }\n    return (int)pred;\n  }\n}\n", "class Solution {\n  public int closestValue(TreeNode root, double target) {\n    int val, closest = root.val;\n    while (root != null) {\n      val = root.val;\n      closest = Math.abs(val - target) < Math.abs(closest - target) ? val : closest;\n      root =  target < root.val ? root.left : root.right;\n    }\n    return closest;\n  }\n}\n"]}
{"number": 271, "statement": "Design an algorithm to encode a list of strings to a string. The encoded string is then sent over the network and is decoded back to the original list of strings.\nMachine 1 (sender) has the function:\nstring encode(vectorstring strs) {\n  // ... your code\n  return encoded_string;\n}\nMachine 2 (receiver) has the function:\nvectorstring decode(string s) {\n  //... your code\n  return strs;\n}\nSo Machine 1 does:\nstring encoded_string = encode(strs);\nand Machine 2 does:\nvectorstring strs2 = decode(encoded_string);\nstrs2 in Machine 2 should be the same as strs in Machine 1.\nImplement the encode and decode methods.\nNote:\nThe string may contain any possible characters out of 256 valid ascii characters. Your algorithm should be generalized enough to work on any possible characters.\nDo not use class member/global/static variables to store states. Your encode and decode algorithms should be stateless.\nDo not rely on any library method such as eval or serialize methods. You should implement your own encode/decode algorithm.\n", "solutions": ["public class Codec {\n  // Encodes a list of strings to a single string.\n  public String encode(List<String> strs) {\n    if (strs.size() == 0) return Character.toString((char)258);\n    String d = Character.toString((char)257);\n    StringBuilder sb = new StringBuilder();\n    for(String s: strs) {\n      sb.append(s);\n      sb.append(d);\n    }\n    sb.deleteCharAt(sb.length() - 1);\n    return sb.toString();\n  }\n  // Decodes a single string to a list of strings.\n  public List<String> decode(String s) {\n    String d = Character.toString((char)258);\n    if (s.equals(d)) return new ArrayList();\n    d = Character.toString((char)257);\n    return Arrays.asList(s.split(d, -1));\n  }\n}\n", "public class Codec {\n  // Encodes string length to bytes string\n  public String intToString(String s) {\n    int x = s.length();\n    char[] bytes = new char[4];\n    for(int i = 3; i > -1; --i) {\n      bytes[3 - i] = (char) (x >> (i * 8) & 0xff);\n    }\n    return new String(bytes);\n  }\n  // Encodes a list of strings to a single string.\n  public String encode(List<String> strs) {\n    StringBuilder sb = new StringBuilder();\n    for(String s: strs) {\n      sb.append(intToString(s));\n      sb.append(s);\n    }\n    return sb.toString();\n  }\n  // Decodes bytes string to integer\n  public int stringToInt(String bytesStr) {\n    int result = 0;\n    for(char b : bytesStr.toCharArray())\n      result = (result << 8) + (int)b;\n    return result;\n  }\n  // Decodes a single string to a list of strings.\n  public List<String> decode(String s) {\n    int i = 0, n = s.length();\n    List<String> output = new ArrayList();\n    while (i < n) {\n      int length = stringToInt(s.substring(i, i + 4));\n      i += 4;\n      output.add(s.substring(i, i + length));\n      i += length;\n    }\n    return output;\n  }\n}\n"]}
{"number": 274, "statement": "Given an array of citations (each citation is a non-negative integer) of a researcher, write a function to compute the researcher's h-index.\nAccording to the definition of h-index on Wikipedia: \"A scientist has index h if h of his/her N papers have at least h citations each, and the other N \u2212 h papers have no more than h citations each.\"\n", "solutions": ["public class Solution {\n    public int hIndex(int[] citations) {\n        // sorting the citations in ascending order\n        Arrays.sort(citations);\n        // finding h-index by linear search\n        int i = 0;\n        while (i < citations.length && citations[citations.length - 1 - i] > i) {\n            i++;\n        }\n        return i; // after the while loop, i = i' + 1\n    }\n}\n", "public class Solution {\n    public int hIndex(int[] citations) {\n        int n = citations.length;\n        int[] papers = new int[n + 1];\n        // counting papers for each citation number\n        for (int c: citations)\n            papers[Math.min(n, c)]++;\n        // finding the h-index\n        int k = n;\n        for (int s = papers[n]; k > s; s += papers[k])\n            k--;\n        return k;\n    }\n}\n"]}
{"number": 275, "statement": "Given an array of citations sortedin ascending order (each citation is a non-negative integer) of a researcher, write a function to compute the researcher's h-index.\nAccording to thedefinition of h-index on Wikipedia: \"A scientist has indexhifhof his/herNpapers haveat leasthcitations each, and the otherN \u2212 hpapers haveno more thanhcitations each.\"\n", "solutions": ["class Solution {\n  public int hIndex(int[] citations) {\n    int idx = 0, n = citations.length;\n    int pivot, left = 0, right = n - 1;\n    while (left <= right) {\n      pivot = left + (right - left) / 2;\n      if (citations[pivot] == n - pivot) return n - pivot;\n      else if (citations[pivot] < n - pivot) left = pivot + 1;\n      else right = pivot - 1;\n    }\n    return n - left;\n  }\n}\n"]}
{"number": 277, "statement": "Suppose you are at a party with n people (labeled from 0 to n - 1) and among them, there may exist one celebrity. The definition of a celebrity is that all the other n - 1 people know him/her but he/she does not know any of them.\nNow you want to find out who the celebrity is or verify that there is not one. The only thing you are allowed to do is to ask questions like: \"Hi, A. Do you know B?\" to get information of whether A knows B. You need to find out the celebrity (or verify there is not one) by asking as few questions as possible (in the asymptotic sense).\nYou are given a helper function bool knows(a, b) which tells you whether A knows B. Implement a function int findCelebrity(n).There will be exactly one celebrity if he/she is in the party. Return the celebrity's label if there is a celebrity in the party. If there is no celebrity, return -1.\n", "solutions": ["public class Solution extends Relation {\n    \n    private int numberOfPeople;\n    \n    public int findCelebrity(int n) {\n        numberOfPeople = n;\n        for (int i = 0; i < n; i++) {\n            if (isCelebrity(i)) {\n                return i;\n            }\n        }\n        return -1;\n    }\n    \n    private boolean isCelebrity(int i) {\n        for (int j = 0; j < numberOfPeople; j++) {\n            if (i == j) continue; // Don't ask if they know themselves.\n            if (knows(i, j) || !knows(j, i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n", "public class Solution extends Relation {\n    \n    private int numberOfPeople;\n    \n    public int findCelebrity(int n) {\n        numberOfPeople = n;\n        int celebrityCandidate = 0;\n        for (int i = 0; i < n; i++) {\n            if (knows(celebrityCandidate, i)) {\n                celebrityCandidate = i;\n            }\n        }\n        if (isCelebrity(celebrityCandidate)) {\n            return celebrityCandidate;\n        }\n        return -1;\n    }\n    \n    private boolean isCelebrity(int i) {\n        for (int j = 0; j < numberOfPeople; j++) {\n            if (i == j) continue; // Don't ask if they know themselves.\n            if (knows(i, j) || !knows(j, i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n", "public class Solution extends Relation {\n    \n    private int numberOfPeople;\n    private Map<Pair<Integer, Integer>, Boolean> cache = new HashMap<>(); \n    \n    @Override\n    public boolean knows(int a, int b) {\n        if (!cache.containsKey(new Pair(a, b))) {\n            cache.put(new Pair(a, b), super.knows(a, b));\n        }\n        return cache.get(new Pair(a, b));\n    }\n    \n    public int findCelebrity(int n) {\n        numberOfPeople = n;\n        int celebrityCandidate = 0;\n        for (int i = 0; i < n; i++) {\n            if (knows(celebrityCandidate, i)) {\n                celebrityCandidate = i;\n            }\n        }\n        if (isCelebrity(celebrityCandidate)) {\n            return celebrityCandidate;\n        }\n        return -1;\n    }\n    \n    private boolean isCelebrity(int i) {\n        for (int j = 0; j < numberOfPeople; j++) {\n            if (i == j) continue; // Don't ask if they know themselves.\n            if (knows(i, j) || !knows(j, i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n"]}
{"number": 278, "statement": "You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.\nSuppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad.\nYou are given an API bool isBadVersion(version) which will return whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.\n", "solutions": ["public int firstBadVersion(int n) {\n    for (int i = 1; i < n; i++) {\n        if (isBadVersion(i)) {\n            return i;\n        }\n    }\n    return n;\n}\n", "public int firstBadVersion(int n) {\n    int left = 1;\n    int right = n;\n    while (left < right) {\n        int mid = left + (right - left) / 2;\n        if (isBadVersion(mid)) {\n            right = mid;\n        } else {\n            left = mid + 1;\n        }\n    }\n    return left;\n}\n"]}
{"number": 279, "statement": "Given a positive integer n, find the least number of perfect square numbers (for example, 1, 4, 9, 16, ...) which sum to n.\n", "solutions": ["class Solution {\n  public int numSquares(int n) {\n    int dp[] = new int[n + 1];\n    Arrays.fill(dp, Integer.MAX_VALUE);\n    // bottom case\n    dp[0] = 0;\n    // pre-calculate the square numbers.\n    int max_square_index = (int) Math.sqrt(n) + 1;\n    int square_nums[] = new int[max_square_index];\n    for (int i = 1; i < max_square_index; ++i) {\n      square_nums[i] = i * i;\n    }\n    for (int i = 1; i <= n; ++i) {\n      for (int s = 1; s < max_square_index; ++s) {\n        if (i < square_nums[s])\n          break;\n        dp[i] = Math.min(dp[i], dp[i - square_nums[s]] + 1);\n      }\n    }\n    return dp[n];\n  }\n}\n"]}
{"number": 282, "statement": "Given a string that contains only digits 0-9 and a target value, return all possibilities to add binary operators (not unary) +, -, or * between the digits so they evaluate to the target value.\n", "solutions": ["class Solution {\n  public ArrayList<String> answer;\n  public String digits;\n  public long target;\n  public void recurse(\n      int index, long previousOperand, long currentOperand, long value, ArrayList<String> ops) {\n    String nums = this.digits;\n    // Done processing all the digits in num\n    if (index == nums.length()) {\n      // If the final value == target expected AND\n      // no operand is left unprocessed\n      if (value == this.target && currentOperand == 0) {\n        StringBuilder sb = new StringBuilder();\n        ops.subList(1, ops.size()).forEach(v -> sb.append(v));\n        this.answer.add(sb.toString());\n      }\n      return;\n    }\n    // Extending the current operand by one digit\n    currentOperand = currentOperand * 10 + Character.getNumericValue(nums.charAt(index));\n    String current_val_rep = Long.toString(currentOperand);\n    int length = nums.length();\n    // To avoid cases where we have 1 + 05 or 1 * 05 since 05 won't be a\n    // valid operand. Hence this check\n    if (currentOperand > 0) {\n      // NO OP recursion\n      recurse(index + 1, previousOperand, currentOperand, value, ops);\n    }\n    // ADDITION\n    ops.add(\"+\");\n    ops.add(current_val_rep);\n    recurse(index + 1, currentOperand, 0, value + currentOperand, ops);\n    ops.remove(ops.size() - 1);\n    ops.remove(ops.size() - 1);\n    if (ops.size() > 0) {\n      // SUBTRACTION\n      ops.add(\"-\");\n      ops.add(current_val_rep);\n      recurse(index + 1, -currentOperand, 0, value - currentOperand, ops);\n      ops.remove(ops.size() - 1);\n      ops.remove(ops.size() - 1);\n      // MULTIPLICATION\n      ops.add(\"*\");\n      ops.add(current_val_rep);\n      recurse(\n          index + 1,\n          currentOperand * previousOperand,\n          0,\n          value - previousOperand + (currentOperand * previousOperand),\n          ops);\n      ops.remove(ops.size() - 1);\n      ops.remove(ops.size() - 1);\n    }\n  }\n  public List<String> addOperators(String num, int target) {\n    if (num.length() == 0) {\n      return new ArrayList<String>();\n    }\n    this.target = target;\n    this.digits = num;\n    this.answer = new ArrayList<String>();\n    this.recurse(0, 0, 0, 0, new ArrayList<String>());\n    return this.answer;\n  }\n}\n"]}
{"number": 284, "statement": "Given an Iterator class interface with methods: next() and hasNext(), design and implement a PeekingIterator that support the peek() operation -- it essentially peek() at the element that will be returned by the next call to next().\n", "solutions": ["import java.util.NoSuchElementException;\nclass PeekingIterator implements Iterator<Integer> {\n    private Iterator<Integer> iter;\n    private Integer peekedValue = null;\n    \n\tpublic PeekingIterator(Iterator<Integer> iterator) {\n        iter = iterator;\n\t}\n\tpublic Integer peek() {\n        /* If there's not already a peeked value, get one out and store\n         * it in the peekedValue variable. We aren't told what to do if\n         * the iterator is actually empty -- here I have thrown an exception\n         * but in an interview you should definitely ask! This is the kind of\n         * thing they expect you to ask about. */\n        if (peekedValue == null) {\n            if (!iter.hasNext()) {\n                throw new NoSuchElementException();\n            }\n            peekedValue = iter.next();\n        }\n        return peekedValue;\n\t}\n\t@Override\n\tpublic Integer next() {\n        /* Firstly, we need to check if we have a value already\n         * stored in the peekedValue variable. If we do, we need to\n         * return it and also set peekedValue to null so that the value\n         * isn't returned again. */\n\t    if (peekedValue != null) {\n            Integer toReturn = peekedValue;\n            peekedValue = null;\n            return toReturn;\n        }\n        /* As per the Java Iterator specs, we should throw a NoSuchElementException\n         * if the next element doesn't exist. */\n        if (!iter.hasNext()) {\n            throw new NoSuchElementException();\n        }\n        /* Otherwise, we need to return a new value. */\n        return iter.next();\n\t}\n\t@Override\n\tpublic boolean hasNext() {\n        /* If there's a value waiting in peekedValue, or if there are values\n         * remaining in the iterator, we should return true. */\n\t    return peekedValue != null || iter.hasNext();\n\t}\n}\n", "import java.util.NoSuchElementException;\nclass PeekingIterator implements Iterator<Integer> {\n    private Iterator<Integer> iter;\n    private Integer next = null;\n    \n\tpublic PeekingIterator(Iterator<Integer> iterator) {\n        // Avoid an exception being thrown in the constructor.\n        if (iterator.hasNext()) {\n            next = iterator.next();\n        }\n        iter = iterator;\n\t}\n\tpublic Integer peek() {\n        return next;\n\t}\n\t@Override\n\tpublic Integer next() {\n        /* As per the Java Iterator specs, we should throw a NoSuchElementException\n         * if the next element doesn't exist. */\n\t    if (next == null) {\n            throw new NoSuchElementException();\n        }\n        Integer toReturn = next;\n        next = null;\n        if (iter.hasNext()) {\n            next = iter.next();\n        }\n        return toReturn;\n\t}\n\t@Override\n\tpublic boolean hasNext() {\n\t    return next != null;\n\t}\n}\n"]}
{"number": 285, "statement": "Given a binary search tree and a node in it, find the in-order successor of that node in the BST.\nThe successor of a nodepis the node with the smallest key greater thanp.val.\n", "solutions": ["class Solution {\n  public TreeNode inorderSuccessor(TreeNode root, TreeNode p) {\n    // the successor is somewhere lower in the right subtree\n    // successor: one step right and then left till you can\n    if (p.right != null) {\n      p = p.right;\n      while (p.left != null) p = p.left;\n      return p;\n    }\n    // the successor is somewhere upper in the tree\n    ArrayDeque<TreeNode> stack = new ArrayDeque<>();\n    int inorder = Integer.MIN_VALUE;\n    // inorder traversal : left -> node -> right\n    while (!stack.isEmpty() || root != null) {\n      // 1. go left till you can\n      while (root != null) {\n        stack.push(root);\n        root = root.left;\n      }\n      // 2. all logic around the node\n      root = stack.pop();\n      // if the previous node was equal to p\n      // then the current node is its successor\n      if (inorder == p.val) return root;\n      inorder = root.val;\n      // 3. go one step right\n      root = root.right;\n    }\n    // there is no successor\n    return null;\n  }\n}\n"]}
{"number": 287, "statement": "Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.\n", "solutions": ["class Solution {\n    public int findDuplicate(int[] nums) {\n        Arrays.sort(nums);\n        for (int i = 1; i < nums.length; i++) {\n            if (nums[i] == nums[i-1]) {\n                return nums[i];\n            }\n        }\n        return -1;\n    }\n}\n", "class Solution {\n    public int findDuplicate(int[] nums) {\n        Set<Integer> seen = new HashSet<Integer>();\n        for (int num : nums) {\n            if (seen.contains(num)) {\n                return num;\n            }\n            seen.add(num);\n        }\n        return -1;\n    }\n}\n", "class Solution {\n  public int findDuplicate(int[] nums) {\n    // Find the intersection point of the two runners.\n    int tortoise = nums[0];\n    int hare = nums[0];\n    do {\n      tortoise = nums[tortoise];\n      hare = nums[nums[hare]];\n    } while (tortoise != hare);\n    // Find the \"entrance\" to the cycle.\n    tortoise = nums[0];\n    while (tortoise != hare) {\n      tortoise = nums[tortoise];\n      hare = nums[hare];\n    }\n    return hare;\n  }\n}\n"]}
{"number": 289, "statement": "According to the Wikipedia's article: \"The Game of Life, also known simply as Life, is a cellular automaton devised by the British mathematician John Horton Conway in 1970.\"\nGiven a board with m by n cells, each cell has an initial state live (1) or dead (0). Each cell interacts with its eight neighbors (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article):\nAny live cell with fewer than two live neighbors dies, as if caused by under-population.\nAny live cell with two or three live neighbors lives on to the next generation.\nAny live cell with more than three live neighbors dies, as if by over-population..\nAny dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.\nWrite a function to compute the next state (after one update) of the board given its current state.The next state is created by applying the above rules simultaneously to every cell in the current state, wherebirths and deaths occur simultaneously.\n", "solutions": ["class Solution {\n    public void gameOfLife(int[][] board) {\n        // Neighbors array to find 8 neighboring cells for a given cell\n        int[] neighbors = {0, 1, -1};\n        int rows = board.length;\n        int cols = board[0].length;\n        // Create a copy of the original board\n        int[][] copyBoard = new int[rows][cols];\n        // Create a copy of the original board\n        for (int row = 0; row < rows; row++) {\n            for (int col = 0; col < cols; col++) {\n                copyBoard[row][col] = board[row][col];\n            }\n        }\n        // Iterate through board cell by cell.\n        for (int row = 0; row < rows; row++) {\n            for (int col = 0; col < cols; col++) {\n                // For each cell count the number of live neighbors.\n                int liveNeighbors = 0;\n                for (int i = 0; i < 3; i++) {\n                    for (int j = 0; j < 3; j++) {\n                        if (!(neighbors[i] == 0 && neighbors[j] == 0)) {\n                            int r = (row + neighbors[i]);\n                            int c = (col + neighbors[j]);\n                            // Check the validity of the neighboring cell.\n                            // and whether it was originally a live cell.\n                            // The evaluation is done against the copy, since that is never updated.\n                            if ((r < rows && r >= 0) && (c < cols && c >= 0) && (copyBoard[r][c] == 1)) {\n                                liveNeighbors += 1;\n                            }\n                        }\n                    }\n                }\n                // Rule 1 or Rule 3\n                if ((copyBoard[row][col] == 1) && (liveNeighbors < 2 || liveNeighbors > 3)) {\n                    board[row][col] = 0;\n                }\n                // Rule 4\n                if (copyBoard[row][col] == 0 && liveNeighbors == 3) {\n                    board[row][col] = 1;\n                }\n            }\n        }\n    }\n}\n", "class Solution {\n    public void gameOfLife(int[][] board) {\n        // Neighbors array to find 8 neighboring cells for a given cell\n        int[] neighbors = {0, 1, -1};\n        int rows = board.length;\n        int cols = board[0].length;\n        // Iterate through board cell by cell.\n        for (int row = 0; row < rows; row++) {\n            for (int col = 0; col < cols; col++) {\n                // For each cell count the number of live neighbors.\n                int liveNeighbors = 0;\n                for (int i = 0; i < 3; i++) {\n                    for (int j = 0; j < 3; j++) {\n                        if (!(neighbors[i] == 0 && neighbors[j] == 0)) {\n                            int r = (row + neighbors[i]);\n                            int c = (col + neighbors[j]);\n                            // Check the validity of the neighboring cell.\n                            // and whether it was originally a live cell.\n                            if ((r < rows && r >= 0) && (c < cols && c >= 0) && (Math.abs(board[r][c]) == 1)) {\n                                liveNeighbors += 1;\n                            }\n                        }\n                    }\n                }\n                // Rule 1 or Rule 3\n                if ((board[row][col] == 1) && (liveNeighbors < 2 || liveNeighbors > 3)) {\n                    // -1 signifies the cell is now dead but originally was live.\n                    board[row][col] = -1;\n                }\n                // Rule 4\n                if (board[row][col] == 0 && liveNeighbors == 3) {\n                    // 2 signifies the cell is now live but was originally dead.\n                    board[row][col] = 2;\n                }\n            }\n        }\n        // Get the final representation for the newly updated board.\n        for (int row = 0; row < rows; row++) {\n            for (int col = 0; col < cols; col++) {\n                if (board[row][col] > 0) {\n                    board[row][col] = 1;\n                } else {\n                    board[row][col] = 0;\n                }\n            }\n        }\n    }\n}\n", "def gameOfLifeInfinite(self, live):\n    ctr = collections.Counter((I, J)\n                              for i, j in live\n                              for I in range(i-1, i+2)\n                              for J in range(j-1, j+2)\n                              if I != i or J != j)\n    return {ij\n            for ij in ctr\n            if ctr[ij] == 3 or ctr[ij] == 2 and ij in live}\ndef gameOfLife(self, board):\n    live = {(i, j) for i, row in enumerate(board) for j, live in enumerate(row) if live}\n    live = self.gameOfLifeInfinite(live)\n    for i, row in enumerate(board):\n        for j in range(len(row)):\n            row[j] = int((i, j) in live)\n"]}
{"number": 295, "statement": "Median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value.\nFor example,\n[2,3,4], the median is 3\n[2,3], the median is (2 + 3) / 2 = 2.5\nDesign a data structure that supports the following two operations:\nvoid addNum(int num) - Add a integer number from the data stream to the data structure.\ndouble findMedian() - Return the median of all elements so far.\n", "solutions": ["class MedianFinder {\n    vector<int> store;\npublic:\n    // Adds a number into the data structure.\n    void addNum(int num)\n    {\n        store.push_back(num);\n    }\n    // Returns the median of current data stream\n    double findMedian()\n    {\n        sort(store.begin(), store.end());\n        int n = store.size();\n        return (n & 1 ? store[n / 2] : ((double) store[n / 2 - 1] + store[n / 2]) * 0.5);\n    }\n};\n", "class MedianFinder {\n    vector<int> store; // resize-able container\npublic:\n    // Adds a number into the data structure.\n    void addNum(int num)\n    {\n        if (store.empty())\n            store.push_back(num);\n        else\n            store.insert(lower_bound(store.begin(), store.end(), num), num);     // binary search and insertion combined\n    }\n    // Returns the median of current data stream\n    double findMedian()\n    {\n        int n = store.size();\n        return n & 1 ? store[n / 2] : ((double) store[n / 2 - 1] + store[n / 2]) * 0.5;\n    }\n};\n", "class MedianFinder {\n    priority_queue<int> lo;                              // max heap\n    priority_queue<int, vector<int>, greater<int>> hi;   // min heap\npublic:\n    // Adds a number into the data structure.\n    void addNum(int num)\n    {\n        lo.push(num);                                    // Add to max heap\n        hi.push(lo.top());                               // balancing step\n        lo.pop();\n        if (lo.size() < hi.size()) {                     // maintain size property\n            lo.push(hi.top());\n            hi.pop();\n        }\n    }\n    // Returns the median of current data stream\n    double findMedian()\n    {\n        return lo.size() > hi.size() ? lo.top() : ((double) lo.top() + hi.top()) * 0.5;\n    }\n};\n", "class MedianFinder {\n    multiset<int> data;\n    multiset<int>::iterator lo_median, hi_median;\npublic:\n    MedianFinder()\n        : lo_median(data.end())\n        , hi_median(data.end())\n    {\n    }\n    void addNum(int num)\n    {\n        const size_t n = data.size();   // store previous size\n        data.insert(num);               // insert into multiset\n        if (!n) {\n            // no elements before, one element now\n            lo_median = hi_median = data.begin();\n        }\n        else if (n & 1) {\n            // odd size before (i.e. lo == hi), even size now (i.e. hi = lo + 1)\n            if (num < *lo_median)       // num < lo\n                lo_median--;\n            else                        // num >= hi\n                hi_median++;            // insertion at end of equal range\n        }\n        else {\n            // even size before (i.e. hi = lo + 1), odd size now (i.e. lo == hi)\n            if (num > *lo_median && num < *hi_median) {\n                lo_median++;                    // num in between lo and hi\n                hi_median--;\n            }\n            else if (num >= *hi_median)         // num inserted after hi\n                lo_median++;\n            else                                // num <= lo < hi\n                lo_median = --hi_median;        // insertion at end of equal range spoils lo\n        }\n    }\n    double findMedian()\n    {\n        return ((double) *lo_median + *hi_median) * 0.5;\n    }\n};\n", "class MedianFinder {\n    multiset<int> data;\n    multiset<int>::iterator mid;\npublic:\n    MedianFinder()\n        : mid(data.end())\n    {\n    }\n    void addNum(int num)\n    {\n        const int n = data.size();\n        data.insert(num);\n        if (!n)                                 // first element inserted\n            mid = data.begin();\n        else if (num < *mid)                    // median is decreased\n            mid = (n & 1 ? mid : prev(mid));\n        else                                    // median is increased\n            mid = (n & 1 ? next(mid) : mid);\n    }\n    double findMedian()\n    {\n        const int n = data.size();\n        return ((double) *mid + *next(mid, n % 2 - 1)) * 0.5;\n    }\n};\n"]}
{"number": 297, "statement": "Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.\nDesign an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.\n", "solutions": ["/* Definition for a binary tree node. */\npublic class TreeNode {\n  int val;\n  TreeNode left;\n  TreeNode right;\n  TreeNode(int x) {\n    val = x;\n  }\n}\n", "// Serialization\npublic class Codec {\n  public String rserialize(TreeNode root, String str) {\n    // Recursive serialization.\n    if (root == null) {\n      str += \"null,\";\n    } else {\n      str += str.valueOf(root.val) + \",\";\n      str = rserialize(root.left, str);\n      str = rserialize(root.right, str);\n    }\n    return str;\n  }\n  // Encodes a tree to a single string.\n  public String serialize(TreeNode root) {\n    return rserialize(root, \"\");\n  }\n};\n", "public class Codec {\n  public TreeNode rdeserialize(List<String> l) {\n    // Recursive deserialization.\n    if (l.get(0).equals(\"null\")) {\n      l.remove(0);\n      return null;\n    }\n    TreeNode root = new TreeNode(Integer.valueOf(l.get(0)));\n    l.remove(0);\n    root.left = rdeserialize(l);\n    root.right = rdeserialize(l);\n    return root;\n  }\n  // Decodes your encoded data to tree.\n  public TreeNode deserialize(String data) {\n    String[] data_array = data.split(\",\");\n    List<String> data_list = new LinkedList<String>(Arrays.asList(data_array));\n    return rdeserialize(data_list);\n  }\n};\n"]}
{"number": 300, "statement": "Given an unsorted array of integers, find the length of longest increasing subsequence.\n", "solutions": ["public class Solution {\n    public int lengthOfLIS(int[] nums) {\n        return lengthofLIS(nums, Integer.MIN_VALUE, 0);\n    }\n    public int lengthofLIS(int[] nums, int prev, int curpos) {\n        if (curpos == nums.length) {\n            return 0;\n        }\n        int taken = 0;\n        if (nums[curpos] > prev) {\n            taken = 1 + lengthofLIS(nums, nums[curpos], curpos + 1);\n        }\n        int nottaken = lengthofLIS(nums, prev, curpos + 1);\n        return Math.max(taken, nottaken);\n    }\n}\n", "public class Solution {\n    public int lengthOfLIS(int[] nums) {\n        int memo[][] = new int[nums.length + 1][nums.length];\n        for (int[] l : memo) {\n            Arrays.fill(l, -1);\n        }\n        return lengthofLIS(nums, -1, 0, memo);\n    }\n    public int lengthofLIS(int[] nums, int previndex, int curpos, int[][] memo) {\n        if (curpos == nums.length) {\n            return 0;\n        }\n        if (memo[previndex + 1][curpos] >= 0) {\n            return memo[previndex + 1][curpos];\n        }\n        int taken = 0;\n        if (previndex < 0 || nums[curpos] > nums[previndex]) {\n            taken = 1 + lengthofLIS(nums, curpos, curpos + 1, memo);\n        }\n        int nottaken = lengthofLIS(nums, previndex, curpos + 1, memo);\n        memo[previndex + 1][curpos] = Math.max(taken, nottaken);\n        return memo[previndex + 1][curpos];\n    }\n}\n", "public class Solution {\n    public int lengthOfLIS(int[] nums) {\n        if (nums.length == 0) {\n            return 0;\n        }\n        int[] dp = new int[nums.length];\n        dp[0] = 1;\n        int maxans = 1;\n        for (int i = 1; i < dp.length; i++) {\n            int maxval = 0;\n            for (int j = 0; j < i; j++) {\n                if (nums[i] > nums[j]) {\n                    maxval = Math.max(maxval, dp[j]);\n                }\n            }\n            dp[i] = maxval + 1;\n            maxans = Math.max(maxans, dp[i]);\n        }\n        return maxans;\n    }\n}\n", "public class Solution {\n    public int lengthOfLIS(int[] nums) {\n        int[] dp = new int[nums.length];\n        int len = 0;\n        for (int num : nums) {\n            int i = Arrays.binarySearch(dp, 0, len, num);\n            if (i < 0) {\n                i = -(i + 1);\n            }\n            dp[i] = num;\n            if (i == len) {\n                len++;\n            }\n        }\n        return len;\n    }\n}\n"]}
{"number": 301, "statement": "Remove the minimum number of invalid parentheses in order to make the input string valid. Return all possible results.\nNote:The input string may contain letters other than the parentheses ( and ).\n", "solutions": ["class Solution {\n  private Set<String> validExpressions = new HashSet<String>();\n  private int minimumRemoved;\n  private void reset() {\n    this.validExpressions.clear();\n    this.minimumRemoved = Integer.MAX_VALUE;\n  }\n  private void recurse(\n      String s,\n      int index,\n      int leftCount,\n      int rightCount,\n      StringBuilder expression,\n      int removedCount) {\n    // If we have reached the end of string.\n    if (index == s.length()) {\n      // If the current expression is valid.\n      if (leftCount == rightCount) {\n        // If the current count of removed parentheses is <= the current minimum count\n        if (removedCount <= this.minimumRemoved) {\n          // Convert StringBuilder to a String. This is an expensive operation.\n          // So we only perform this when needed.\n          String possibleAnswer = expression.toString();\n          // If the current count beats the overall minimum we have till now\n          if (removedCount < this.minimumRemoved) {\n            this.validExpressions.clear();\n            this.minimumRemoved = removedCount;\n          }\n          this.validExpressions.add(possibleAnswer);\n        }\n      }\n    } else {\n      char currentCharacter = s.charAt(index);\n      int length = expression.length();\n      // If the current character is neither an opening bracket nor a closing one,\n      // simply recurse further by adding it to the expression StringBuilder\n      if (currentCharacter != '(' && currentCharacter != ')') {\n        expression.append(currentCharacter);\n        this.recurse(s, index + 1, leftCount, rightCount, expression, removedCount);\n        expression.deleteCharAt(length);\n      } else {\n        // Recursion where we delete the current character and move forward\n        this.recurse(s, index + 1, leftCount, rightCount, expression, removedCount + 1);\n        expression.append(currentCharacter);\n        // If it's an opening parenthesis, consider it and recurse\n        if (currentCharacter == '(') {\n          this.recurse(s, index + 1, leftCount + 1, rightCount, expression, removedCount);\n        } else if (rightCount < leftCount) {\n          // For a closing parenthesis, only recurse if right < left\n          this.recurse(s, index + 1, leftCount, rightCount + 1, expression, removedCount);\n        }\n        // Undoing the append operation for other recursions.\n        expression.deleteCharAt(length);\n      }\n    }\n  }\n  public List<String> removeInvalidParentheses(String s) {\n    this.reset();\n    this.recurse(s, 0, 0, 0, new StringBuilder(), 0);\n    return new ArrayList(this.validExpressions);\n  }\n}\n", "class Solution {\n  private Set<String> validExpressions = new HashSet<String>();\n  private void recurse(\n      String s,\n      int index,\n      int leftCount,\n      int rightCount,\n      int leftRem,\n      int rightRem,\n      StringBuilder expression) {\n    // If we reached the end of the string, just check if the resulting expression is\n    // valid or not and also if we have removed the total number of left and right\n    // parentheses that we should have removed.\n    if (index == s.length()) {\n      if (leftRem == 0 && rightRem == 0) {\n        this.validExpressions.add(expression.toString());\n      }\n    } else {\n      char character = s.charAt(index);\n      int length = expression.length();\n      // The discard case. Note that here we have our pruning condition.\n      // We don't recurse if the remaining count for that parenthesis is == 0.\n      if ((character == '(' && leftRem > 0) || (character == ')' && rightRem > 0)) {\n        this.recurse(\n            s,\n            index + 1,\n            leftCount,\n            rightCount,\n            leftRem - (character == '(' ? 1 : 0),\n            rightRem - (character == ')' ? 1 : 0),\n            expression);\n      }\n      expression.append(character);\n      // Simply recurse one step further if the current character is not a parenthesis.\n      if (character != '(' && character != ')') {\n        this.recurse(s, index + 1, leftCount, rightCount, leftRem, rightRem, expression);\n      } else if (character == '(') {\n        // Consider an opening bracket.\n        this.recurse(s, index + 1, leftCount + 1, rightCount, leftRem, rightRem, expression);\n      } else if (rightCount < leftCount) {\n        // Consider a closing bracket.\n        this.recurse(s, index + 1, leftCount, rightCount + 1, leftRem, rightRem, expression);\n      }\n      // Delete for backtracking.\n      expression.deleteCharAt(length);\n    }\n  }\n  public List<String> removeInvalidParentheses(String s) {\n    int left = 0, right = 0;\n    // First, we find out the number of misplaced left and right parentheses.\n    for (int i = 0; i < s.length(); i++) {\n      // Simply record the left one.\n      if (s.charAt(i) == '(') {\n        left++;\n      } else if (s.charAt(i) == ')') {\n        // If we don't have a matching left, then this is a misplaced right, record it.\n        right = left == 0 ? right + 1 : right;\n        // Decrement count of left parentheses because we have found a right\n        // which CAN be a matching one for a left.\n        left = left > 0 ? left - 1 : left;\n      }\n    }\n    this.recurse(s, 0, 0, 0, left, right, new StringBuilder());\n    return new ArrayList<String>(this.validExpressions);\n  }\n}\n"]}
{"number": 302, "statement": "An image is represented by a binary matrix with 0 as a white pixel and 1 as a black pixel. The black pixels are connected, i.e., there is only one black region. Pixels are connected horizontally and vertically. Given the location (x, y) of one of the black pixels, return the area of the smallest (axis-aligned) rectangle that encloses all black pixels.\n", "solutions": ["public class Solution {\n    private int top, bottom, left, right;\n    public int minArea(char[][] image, int x, int y) {\n        if(image.length == 0 || image[0].length == 0) return 0;\n        top = bottom = x;\n        left = right = y;\n        dfs(image, x, y);\n        return (right - left) * (bottom - top);\n    }\n    private void dfs(char[][] image, int x, int y){\n        if(x < 0 || y < 0 || x >= image.length || y >= image[0].length ||\n          image[x][y] == '0')\n            return;\n        image[x][y] = '0'; // mark visited black pixel as white\n        top = Math.min(top, x);\n        bottom = Math.max(bottom, x + 1);\n        left = Math.min(left, y);\n        right = Math.max(right, y + 1);\n        dfs(image, x + 1, y);\n        dfs(image, x - 1, y);\n        dfs(image, x, y - 1);\n        dfs(image, x, y + 1);\n    }\n}\n"]}
{"number": 305, "statement": "A 2d grid map of m rows and n columns is initially filled with water. We may perform an addLand operation which turns the water at position (row, col) into a land. Given a list of positions to operate, count the number of islands after each addLand operation. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.\n", "solutions": ["class Solution {\nprivate:\n  void dfs(vector<vector<char>>& grid, int r, int c, vector<vector<bool>>& visited) {\n    int nr = grid.size();\n    int nc = grid[0].size();\n    if (r < 0 || c < 0 || r >= nr || c >= nc || grid[r][c] == '0' || visited[r][c]) return;\n    visited[r][c] = true;\n    dfs(grid, r - 1, c, visited);\n    dfs(grid, r + 1, c, visited);\n    dfs(grid, r, c - 1, visited);\n    dfs(grid, r, c + 1, visited);\n  }\n  int numIslands(vector<vector<char>>& grid) {\n    int nr = grid.size();\n    int nc = grid[0].size();\n    vector<vector<bool>> visited (nr, vector<bool>(nc, false));\n    int num_islands = 0;\n    for (int r = 0; r < nr; ++r) {\n      for (int c = 0; c < nc; ++c) {\n        if (grid[r][c] == '1' && !visited[r][c]) {\n          ++num_islands;\n          dfs(grid, r, c, visited);\n        }\n      }\n    }\n    return num_islands;\n  }\npublic:\n  vector<int> numIslands2(int m, int n, vector<pair<int, int>>& positions) {\n    vector<int> ans;\n    vector<vector<char>> grid (m, vector<char>(n, '0'));\n    for (auto pos : positions) {\n      grid[pos.first][pos.second] = '1';\n      ans.push_back(numIslands(grid));\n    }\n    return ans;\n  }\n};\n", "class Solution {\npublic:\n  vector<int> numIslands2(int m, int n, vector<pair<int, int>>& positions) {\n    vector<int> ans;\n    unordered_map<int, int> land2id; // land index : island ID\n    int num_islands = 0;\n    int island_id = 0;\n    for (auto pos : positions) {\n      int r = pos.first;\n      int c = pos.second;\n      // check pos's neighbors to see if they are in the existing islands or not\n      unordered_set<int> overlap; // how many existing islands overlap with 'pos'\n      if (r - 1 >= 0 && land2id.count((r-1) * n + c)) overlap.insert(land2id[(r-1) * n + c]);\n      if (r + 1 < m && land2id.count((r+1) * n + c)) overlap.insert(land2id[(r+1) * n + c]);\n      if (c - 1 >= 0 && land2id.count(r * n + c - 1)) overlap.insert(land2id[r * n + c - 1]);\n      if (c + 1 < n && land2id.count(r * n + c + 1)) overlap.insert(land2id[r * n + c + 1]);\n      if (overlap.empty()) { // no overlap\n        ++num_islands;\n        land2id[r * n + c] = island_id++; // new island\n      } else if (overlap.size() == 1) { // one overlap, just append\n        auto it = overlap.begin();\n        land2id[r * n + c] = *it;\n      } else { // more than 1 overlaps, merge\n        auto it = overlap.begin();\n        int root_id = *it;\n        for (auto& kv : land2id) { // update island id\n          if (overlap.count(kv.second)) kv.second = root_id;\n        }\n        land2id[r * n + c] = root_id;\n        num_islands -= (overlap.size() - 1);\n      }\n      ans.push_back(num_islands);\n    }\n    return ans;\n  }\n};\n", "class UnionFind {\npublic:\n  UnionFind(int N) {\n    count = 0;\n    for (int i = 0; i < N; ++i) {\n      parent.push_back(-1);\n      rank.push_back(0);\n    }\n  }\n  bool isValid(int i) const {\n    return parent[i] >= 0;\n  }\n  void setParent(int i) {\n    parent[i] = i;\n    ++count;\n  }\n  int find(int i) { // path compression\n    if (parent[i] != i) parent[i] = find(parent[i]);\n    return parent[i];\n  }\n  void Union(int x, int y) { // union with rank\n    int rootx = find(x);\n    int rooty = find(y);\n    if (rootx != rooty) {\n      if (rank[rootx] > rank[rooty]) parent[rooty] = rootx;\n      else if (rank[rootx] < rank[rooty]) parent[rootx] = rooty;\n      else {\n        parent[rooty] = rootx; rank[rootx] += 1;\n      }\n      --count;\n    }\n  }\n  int getCount() const {\n    return count;\n  }\nprivate:\n  vector<int> parent;\n  vector<int> rank;\n  int count; // # of connected components\n};\nclass Solution {\npublic:\n  vector<int> numIslands2(int m, int n, vector<pair<int, int>>& positions) {\n    vector<int> ans;\n    UnionFind uf (m * n);\n    for (auto& pos : positions) {\n      int r = pos.first;\n      int c = pos.second;\n      // check pos's neighbors to see if they are in the existing islands or not\n      vector<int> overlap; // how many existing islands overlap with 'pos'\n      if (r - 1 >= 0 && uf.isValid((r-1) * n + c)) overlap.push_back((r-1) * n + c);\n      if (r + 1 < m && uf.isValid((r+1) * n + c)) overlap.push_back((r+1) * n + c);\n      if (c - 1 >= 0 && uf.isValid(r * n + c - 1)) overlap.push_back(r * n + c - 1);\n      if (c + 1 < n && uf.isValid(r * n + c + 1)) overlap.push_back(r * n + c + 1);\n      int index = r * n + c;\n      uf.setParent(index);\n      for (auto i : overlap) uf.Union(i, index);\n      ans.push_back(uf.getCount());\n    }\n    return ans;\n  }\n};\n"]}
{"number": 307, "statement": "Given an integer array nums, find the sum of the elements between indices i and j (i \u2264 j), inclusive.\nThe update(i, val) function modifies nums by updating the element at index i to val.\n", "solutions": ["private int[] nums;\npublic int sumRange(int i, int j) {\n    int sum = 0;\n    for (int l = i; l <= j; l++) {\n        sum += data[l];\n    }\n    return sum;\n}\npublic int update(int i, int val) {\n    nums[i] = val;\n}\n// Time Limit Exceeded\n", "private int[] b;\nprivate int len;\nprivate int[] nums;\npublic NumArray(int[] nums) {\n    this.nums = nums;\n    double l = Math.sqrt(nums.length);\n    len = (int) Math.ceil(nums.length/l);\n    b = new int [len];\n    for (int i = 0; i < nums.length; i++)\n        b[i / len] += nums[i];\n}\npublic int sumRange(int i, int j) {\n    int sum = 0;\n    int startBlock = i / len;\n    int endBlock = j / len;\n    if (startBlock == endBlock) {\n        for (int k = i; k <= j; k++)\n            sum += nums[k];\n    } else {\n        for (int k = i; k <= (startBlock + 1) * len - 1; k++)\n            sum += nums[k];\n        for (int k = startBlock + 1; k <= endBlock - 1; k++)\n            sum += b[k];\n        for (int k = endBlock * len; k <= j; k++)\n            sum += nums[k];\n    }\n    return sum;\n}\npublic void update(int i, int val) {\n    int b_l = i / len;\n    b[b_l] = b[b_l] - nums[i] + val;\n    nums[i] = val;\n}\n// Accepted\n", "int[] tree;\nint n;\npublic NumArray(int[] nums) {\n    if (nums.length > 0) {\n        n = nums.length;\n        tree = new int[n * 2];\n        buildTree(nums);\n    }\n}\nprivate void buildTree(int[] nums) {\n    for (int i = n, j = 0;  i < 2 * n; i++,  j++)\n        tree[i] = nums[j];\n    for (int i = n - 1; i > 0; --i)\n        tree[i] = tree[i * 2] + tree[i * 2 + 1];\n}\n", "void update(int pos, int val) {\n    pos += n;\n    tree[pos] = val;\n    while (pos > 0) {\n        int left = pos;\n        int right = pos;\n        if (pos % 2 == 0) {\n            right = pos + 1;\n        } else {\n            left = pos - 1;\n        }\n        // parent is updated after child is updated\n        tree[pos / 2] = tree[left] + tree[right];\n        pos /= 2;\n    }\n}\n", "public int sumRange(int l, int r) {\n    // get leaf with value 'l'\n    l += n;\n    // get leaf with value 'r'\n    r += n;\n    int sum = 0;\n    while (l <= r) {\n        if ((l % 2) == 1) {\n           sum += tree[l];\n           l++;\n        }\n        if ((r % 2) == 0) {\n           sum += tree[r];\n           r--;\n        }\n        l /= 2;\n        r /= 2;\n    }\n    return sum;\n}\n"]}
{"number": 309, "statement": "Say you have an array for which the ith element is the price of a given stock on day i.\nDesign an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times) with the following restrictions:\nYou may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).\nAfter you sell your stock, you cannot buy stock on next day. (ie, cooldown 1 day)\n", "solutions": ["class Solution {\n  public int maxProfit(int[] prices) {\n    int sold = Integer.MIN_VALUE, held = Integer.MIN_VALUE, reset = 0;\n    for (int price : prices) {\n      int preSold = sold;\n      sold = held + price;\n      held = Math.max(held, reset - price);\n      reset = Math.max(reset, preSold);\n    }\n    return Math.max(sold, reset);\n  }\n}\n", "class Solution {\n  public int maxProfit(int[] prices) {\n    int[] MP = new int[prices.length + 2];\n    for (int i = prices.length - 1; i >= 0; i--) {\n      int C1 = 0;\n      // Case 1). buy and sell the stock\n      for (int sell = i + 1; sell < prices.length; sell++) {\n        int profit = (prices[sell] - prices[i]) + MP[sell + 2];\n        C1 = Math.max(profit, C1);\n      }\n      // Case 2). do no transaction with the stock p[i]\n      int C2 = MP[i + 1];\n      // wrap up the two cases\n      MP[i] = Math.max(C1, C2);\n    }\n    return MP[0];\n  }\n}\n"]}
{"number": 312, "statement": "Given n balloons, indexed from 0 to n-1. Each balloon is painted with a number on it represented by array nums. You are asked to burst all the balloons. If the you burst balloon i you will get nums[left] * nums[i] * nums[right] coins. Here left and right are adjacent indices of i. After the burst, the left and right then becomes adjacent.\nFind the maximum coins you can collect by bursting the balloons wisely.\nNote:\nYou may imagine nums[-1] = nums[n] = 1. They are not real therefore you can not burst them.\n0 \u2264 n \u2264 500, 0 \u2264 nums[i] \u2264 100\n", "solutions": ["class Solution {\n    public int maxCoins(int[] nums) {\n        // reframe the problem\n        int n = nums.length + 2;\n        int[] new_nums = new int[n];\n        for(int i = 0; i < nums.length; i++){\n            new_nums[i+1] = nums[i];\n        }\n        new_nums[0] = new_nums[n - 1] = 1;\n        // cache the results of dp\n        int[][] memo = new int[n][n];\n        // find the maximum number of coins obtained from adding all balloons from (0, len(nums) - 1)\n        return dp(memo, new_nums, 0, n - 1);\n    }\n    public int dp(int[][] memo, int[] nums, int left, int right) {\n        // no more balloons can be added\n        if (left + 1 == right) return 0;\n        // we've already seen this, return from cache\n        if (memo[left][right] > 0) return memo[left][right];\n        // add each balloon on the interval and return the maximum score\n        int ans = 0;\n        for (int i = left + 1; i < right; ++i)\n            ans = Math.max(ans, nums[left] * nums[i] * nums[right]\n            + dp(memo, nums, left, i) + dp(memo, nums, i, right));\n        // add to the cache\n        memo[left][right] = ans;\n        return ans;\n    }\n}\n", "public class Solution{\n    public int maxCoins(int[] nums) {\n        // reframe the problem\n        int n = nums.length + 2;\n        int[] new_nums = new int[n];\n        for(int i = 0; i < nums.length; i++){\n            new_nums[i+1] = nums[i];\n        }\n        new_nums[0] = new_nums[n - 1] = 1;\n        // dp will store the results of our calls\n        int[][] dp = new int[n][n];\n        // iterate over dp and incrementally build up to dp[0][n-1]\n        for (int left = n-2; left > -1; left--)\n            for (int right = left+2; right < n; right++) {\n                for (int i = left + 1; i < right; ++i)\n                    // same formula to get the best score from (left, right) as before\n                    dp[left][right] = Math.max(dp[left][right],\n                    new_nums[left] * new_nums[i] * new_nums[right] + dp[left][i] + dp[i][right]);\n            }\n        return dp[0][n - 1];\n    }\n}\n"]}
{"number": 314, "statement": "Given a binary tree, return the vertical order traversal of its nodes' values. (ie, from top to bottom, column by column).\nIf two nodes are in the same row and column, the order should be from left to right.\n", "solutions": ["class Solution {\n  public List<List<Integer>> verticalOrder(TreeNode root) {\n    List<List<Integer>> output = new ArrayList();\n    if (root == null) {\n      return output;\n    }\n    Map<Integer, ArrayList> columnTable = new HashMap();\n    // Pair of node and its column offset\n    Queue<Pair<TreeNode, Integer>> queue = new ArrayDeque();\n    int column = 0;\n    queue.offer(new Pair(root, column));\n    int minColumn = 0, maxColumn = 0;\n    while (!queue.isEmpty()) {\n      Pair<TreeNode, Integer> p = queue.poll();\n      root = p.getKey();\n      column = p.getValue();\n      if (root != null) {\n        if (!columnTable.containsKey(column)) {\n          columnTable.put(column, new ArrayList<Integer>());\n        }\n        columnTable.get(column).add(root.val);\n        minColumn = Math.min(minColumn, column);\n        maxColumn = Math.max(maxColumn, column);\n        queue.offer(new Pair(root.left, column - 1));\n        queue.offer(new Pair(root.right, column + 1));\n      }\n    }\n    for(int i = minColumn; i < maxColumn + 1; ++i) {\n      output.add(columnTable.get(i));\n    }\n    return output;\n  }\n}\n"]}
{"number": 316, "statement": "Given a string which contains only lowercase letters, remove duplicate letters so that every letter appears once and only once. You must make sure your result is the smallest in lexicographical order among all possible results.\n", "solutions": ["public class Solution {\n    public String removeDuplicateLetters(String s) {\n        // find pos - the index of the leftmost letter in our solution\n        // we create a counter and end the iteration once the suffix doesn't have each unique character\n        // pos will be the index of the smallest character we encounter before the iteration ends\n        int[] cnt = new int[26];\n        int pos = 0;\n        for (int i = 0; i < s.length(); i++) cnt[s.charAt(i) - 'a']++;\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) < s.charAt(pos)) pos = i;\n            if (--cnt[s.charAt(i) - 'a'] == 0) break;\n        }\n        // our answer is the leftmost letter plus the recursive call on the remainder of the string\n        // note that we have to get rid of further occurrences of s[pos] to ensure that there are no duplicates\n        return s.length() == 0 ? \"\" : s.charAt(pos) + removeDuplicateLetters(s.substring(pos + 1).replaceAll(\"\" + s.charAt(pos), \"\"));\n    }\n}\n", "class Solution {\n    public String removeDuplicateLetters(String s) {\n        Stack<Character> stack = new Stack<>();\n        // this lets us keep track of what's in our solution in O(1) time\n        HashSet<Character> seen = new HashSet<>();\n        // this will let us know if there are any more instances of s[i] left in s\n        HashMap<Character, Integer> last_occurrence = new HashMap<>();\n        for(int i = 0; i < s.length(); i++) last_occurrence.put(s.charAt(i), i);\n        for(int i = 0; i < s.length(); i++){\n            char c = s.charAt(i);\n            // we can only try to add c if it's not already in our solution\n            // this is to maintain only one of each character\n            if (!seen.contains(c)){\n                // if the last letter in our solution:\n                //     1. exists\n                //     2. is greater than c so removing it will make the string smaller\n                //     3. it's not the last occurrence\n                // we remove it from the solution to keep the solution optimal\n                while(!stack.isEmpty() && c < stack.peek() && last_occurrence.get(stack.peek()) > i){\n                    seen.remove(stack.pop());\n                }\n                seen.add(c);\n                stack.push(c);\n            }\n        }\n    StringBuilder sb = new StringBuilder(stack.size());\n    for (Character c : stack) sb.append(c.charValue());\n    return sb.toString();\n    }\n}\n"]}
{"number": 318, "statement": "Given a string array words, find the maximum value of length(word[i]) * length(word[j]) where the two words do not share common letters. You may assume that each word will contain only lower case letters. If no such two words exist, return 0.\n", "solutions": ["class Solution {\n  public boolean noCommonLetters(String s1, String s2){\n    // TODO\n  }\n  public int maxProduct(String[] words) {\n    int n = words.length;\n    int maxProd = 0;\n    for (int i = 0; i < n; ++i)\n      for (int j = i + 1; j < n; ++j)\n        if (noCommonLetters(words[i], words[j]))\n          maxProd = Math.max(maxProd, words[i].length() * words[j].length());\n    return maxProd;\n  }\n}\n", "public boolean noCommonLetters(String s1, String s2){\n  for (char ch : s1.toCharArray())\n    if (s2.indexOf(ch) != -1) return false;\n  return true;\n}\n"]}
{"number": 320, "statement": "Write a function to generate the generalized abbreviations of a word.\nNote:The order of the output does not matter.\n", "solutions": ["public class Solution {\n    public List<String> generateAbbreviations(String word){\n        List<String> ans = new ArrayList<String>();\n        backtrack(ans, new StringBuilder(), word, 0, 0);\n        return ans;\n    }\n    // i is the current position\n    // k is the count of consecutive abbreviated characters\n    private void backtrack(List<String> ans, StringBuilder builder, String word, int i, int k){\n        int len = builder.length(); // keep the length of builder\n        if(i == word.length()){\n            if (k != 0) builder.append(k); // append the last k if non zero\n            ans.add(builder.toString());\n        } else {\n            // the branch that word.charAt(i) is abbreviated\n            backtrack(ans, builder, word, i + 1, k + 1);\n            // the branch that word.charAt(i) is kept\n            if (k != 0) builder.append(k);\n            builder.append(word.charAt(i));\n            backtrack(ans, builder, word, i + 1, 0);\n        }\n        builder.setLength(len); // reset builder to the original state\n    }\n}\n", "public class Solution {\n    public List<String> generateAbbreviations(String word) {\n        List<String> ans = new ArrayList<>();\n        for (int x = 0; x < (1 << word.length()); ++x) // loop through all possible x\n            ans.add(abbr(word, x));\n        return ans;\n    }\n    // build the abbreviation for word from number x\n    private String abbr(String word, int x) {\n        StringBuilder builder = new StringBuilder();\n        int k = 0, n = word.length(); // k is the count of consecutive ones in x\n        for (int i = 0; i < n; ++i, x >>= 1) {\n            if ((x & 1) == 0) { // bit is zero, we keep word.charAt(i)\n                if (k != 0) { // we have abbreviated k characters\n                    builder.append(k);\n                    k = 0; // reset the counter k\n                }\n                builder.append(word.charAt(i));\n            }\n            else // bit is one, increase k\n                ++k;\n        }\n        if (k != 0) builder.append(k); //don't forget to append the last k if non zero\n        return builder.toString();\n    }\n}\n"]}
{"number": 322, "statement": "You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.\n", "solutions": ["public class Solution {\n  public int coinChange(int[] coins, int amount) {\n    return coinChange(0, coins, amount);\n  }\n  private int coinChange(int idxCoin, int[] coins, int amount) {\n    if (amount == 0)\n      return 0;\n    if (idxCoin < coins.length && amount > 0) {\n      int maxVal = amount/coins[idxCoin];\n      int minCost = Integer.MAX_VALUE;\n      for (int x = 0; x <= maxVal; x++) {\n        if (amount >= x * coins[idxCoin]) {\n          int res = coinChange(idxCoin + 1, coins, amount - x * coins[idxCoin]);\n          if (res != -1)\n            minCost = Math.min(minCost, res + x);\n        }\n      }\n      return (minCost == Integer.MAX_VALUE)? -1: minCost;\n    }\n    return -1;\n  }\n}\n// Time Limit Exceeded\n", "public class Solution {\n  public int coinChange(int[] coins, int amount) {\n    if (amount < 1) return 0;\n    return coinChange(coins, amount, new int[amount]);\n  }\n  private int coinChange(int[] coins, int rem, int[] count) {\n    if (rem < 0) return -1;\n    if (rem == 0) return 0;\n    if (count[rem - 1] != 0) return count[rem - 1];\n    int min = Integer.MAX_VALUE;\n    for (int coin : coins) {\n      int res = coinChange(coins, rem - coin, count);\n      if (res >= 0 && res < min)\n        min = 1 + res;\n    }\n    count[rem - 1] = (min == Integer.MAX_VALUE) ? -1 : min;\n    return count[rem - 1];\n  }\n}\n"]}
{"number": 326, "statement": "Given an integer, write a function to determine if it is a power of three.\n", "solutions": ["public class Solution {\n    public boolean isPowerOfThree(int n) {\n        if (n < 1) {\n            return false;\n        }\n        while (n % 3 == 0) {\n            n /= 3;\n        }\n        return n == 1;\n    }\n}\n", "String baseChange = Integer.toString(number, base);\n"]}
{"number": 328, "statement": "Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes.\nYou should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity.\n", "solutions": ["public class Solution {\n    public ListNode oddEvenList(ListNode head) {\n        if (head == null) return null;\n        ListNode odd = head, even = head.next, evenHead = even;\n        while (even != null && even.next != null) {\n            odd.next = even.next;\n            odd = odd.next;\n            even.next = odd.next;\n            even = even.next;\n        }\n        odd.next = evenHead;\n        return head;\n    }\n}\n"]}
{"number": 329, "statement": "Given an integer matrix, find the length of the longest increasing path.\nFrom each cell, you can either move to four directions: left, right, up or down. You may NOT move diagonally or move outside of the boundary (i.e. wrap-around is not allowed).\n", "solutions": ["// Naive DFS Solution\n// Time Limit Exceeded\npublic class Solution {\n  private static final int[][] dirs = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n  private int m, n;\n  public int longestIncreasingPath(int[][] matrix) {\n      if (matrix.length == 0) return 0;\n      m = matrix.length;\n      n = matrix[0].length;\n      int ans = 0;\n      for (int i = 0; i < m; ++i)\n          for (int j = 0; j < n; ++j)\n              ans = Math.max(ans, dfs(matrix, i, j));\n      return ans;\n  }\n  private int dfs(int[][] matrix, int i, int j) {\n      int ans = 0;\n      for (int[] d : dirs) {\n          int x = i + d[0], y = j + d[1];\n          if (0 <= x && x < m && 0 <= y && y < n && matrix[x][y] > matrix[i][j])\n              ans = Math.max(ans, dfs(matrix, x, y));\n      }\n      return ++ans;\n  }\n}\n", "1 2 3 . . . n\n2 3 . . .   n+1\n3 . . .     n+2\n.           .\n.           .\n.           .\nm m+1 . . . n+m-1\n"]}
{"number": 330, "statement": "Given a sorted positive integer array nums and an integer n, add/patch elements to the array such that any number in range [1, n] inclusive can be formed by the sum of some elements in the array. Return the minimum number of patches required.\n", "solutions": ["public class Solution {\n    public int minPatches(int[] nums, int n) {\n        int patches = 0, i = 0;\n        long miss = 1; // use long to avoid integer overflow error\n        while (miss <= n) {\n            if (i < nums.length && nums[i] <= miss) // miss is covered\n                miss += nums[i++];\n            else { // patch miss to the array\n                miss += miss;\n                patches++; // increase the answer\n            }\n        }\n        return patches;\n    }\n}\n"]}
{"number": 331, "statement": "One way to serialize a binary tree is to use pre-order traversal. When we encounter a non-null node, we record the node's value. If it is a null node, we record using a sentinel value such as #.\n     _9_\n    /   \\\n   3     2\n  / \\   / \\\n 4   1  #  6\n/ \\ / \\   / \\\n# # # #   # #\nFor example, the above binary tree can be serialized to the string \"9,3,4,#,#,1,#,#,2,#,6,#,#\", where # represents a null node.\nGiven a string of comma separated values, verify whether it is a correct preorder traversal serialization of a binary tree. Find an algorithm without reconstructing the tree.\nEach comma separated value in the string must be either an integer or a character '#' representing null pointer.\nYou may assume that the input format is always valid, for example it could never contain two consecutive commas such as \"1,,3\".\n", "solutions": ["class Solution {\n  public boolean isValidSerialization(String preorder) {\n    // number of available slots\n    int slots = 1;\n    for(String node : preorder.split(\",\")) {\n      // one node takes one slot\n      --slots;\n      // no more slots available\n      if (slots < 0) return false;\n      // non-empty node creates two children slots\n      if (!node.equals(\"#\")) slots += 2;\n    }\n    // all slots should be used up\n    return slots == 0;\n  }\n}\n", "class Solution {\n  public boolean isValidSerialization(String preorder) {\n    // number of available slots\n    int slots = 1;\n    int n = preorder.length();\n    for(int i = 0; i < n; ++i) {\n      if (preorder.charAt(i) == ',') {\n        // one node takes one slot\n        --slots;\n        // no more slots available\n        if (slots < 0) return false;\n        // non-empty node creates two children slots\n        if (preorder.charAt(i - 1) != '#') slots += 2;\n      }\n    }\n    // the last node\n    slots = (preorder.charAt(n - 1) == '#') ? slots - 1 : slots + 1;\n    // all slots should be used up\n    return slots == 0;\n  }\n}\n"]}
{"number": 332, "statement": "Given a list of airline tickets represented by pairs of departure and arrival airports [from, to], reconstruct the itinerary in order. All of the tickets belong to a man who departs from JFK. Thus, the itinerary must begin with JFK.\nNote:\nIf there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string. For example, the itinerary [\"JFK\", \"LGA\"] has a smaller lexical order than [\"JFK\", \"LGB\"].\nAll airports are represented by three capital letters (IATA code).\nYou may assume all tickets form at least one valid itinerary.\n", "solutions": ["class Solution {\n  // origin -> list of destinations\n  HashMap<String, List<String>> flightMap = new HashMap<>();\n  HashMap<String, boolean[]> visitBitmap = new HashMap<>();\n  int flights = 0;\n  List<String> result = null;\n  public List<String> findItinerary(List<List<String>> tickets) {\n    // Step 1). build the graph first\n    for (List<String> ticket : tickets) {\n      String origin = ticket.get(0);\n      String dest = ticket.get(1);\n      if (this.flightMap.containsKey(origin)) {\n        List<String> destList = this.flightMap.get(origin);\n        destList.add(dest);\n      } else {\n        List<String> destList = new LinkedList<String>();\n        destList.add(dest);\n        this.flightMap.put(origin, destList);\n      }\n    }\n    // Step 2). order the destinations and init the visit bitmap\n    for (Map.Entry<String, List<String>> entry : this.flightMap.entrySet()) {\n      Collections.sort(entry.getValue());\n      this.visitBitmap.put(entry.getKey(), new boolean[entry.getValue().size()]);\n    }\n    this.flights = tickets.size();\n    LinkedList<String> route = new LinkedList<String>();\n    route.add(\"JFK\");\n    // Step 3). backtracking\n    this.backtracking(\"JFK\", route);\n    return this.result;\n  }\n  protected boolean backtracking(String origin, LinkedList<String> route) {\n    if (route.size() == this.flights + 1) {\n      this.result = (List<String>) route.clone();\n      return true;\n    }\n    if (!this.flightMap.containsKey(origin))\n      return false;\n    int i = 0;\n    boolean[] bitmap = this.visitBitmap.get(origin);\n    for (String dest : this.flightMap.get(origin)) {\n      if (!bitmap[i]) {\n        bitmap[i] = true;\n        route.add(dest);\n        boolean ret = this.backtracking(dest, route);\n        route.pollLast();\n        bitmap[i] = false;\n        if (ret)\n          return true;\n      }\n      ++i;\n    }\n    return false;\n  }\n}\n", "class Solution {\n  // origin -> list of destinations\n  HashMap<String, LinkedList<String>> flightMap = new HashMap<>();\n  LinkedList<String> result = null;\n  public List<String> findItinerary(List<List<String>> tickets) {\n    // Step 1). build the graph first\n    for(List<String> ticket : tickets) {\n      String origin = ticket.get(0);\n      String dest = ticket.get(1);\n      if (this.flightMap.containsKey(origin)) {\n        LinkedList<String> destList = this.flightMap.get(origin);\n        destList.add(dest);\n      } else {\n        LinkedList<String> destList = new LinkedList<String>();\n        destList.add(dest);\n        this.flightMap.put(origin, destList);\n      }\n    }\n    // Step 2). order the destinations\n    this.flightMap.forEach((key, value) -> Collections.sort(value));\n    this.result = new LinkedList<String>();\n    // Step 3). post-order DFS\n    this.DFS(\"JFK\");\n    return this.result;\n  }\n  protected void DFS(String origin) {\n    // Visit all the outgoing edges first.\n    if (this.flightMap.containsKey(origin)) {\n      LinkedList<String> destList = this.flightMap.get(origin);\n      while (!destList.isEmpty()) {\n        // while we visit the edge, we trim it off from graph.\n        String dest = destList.pollFirst();\n        DFS(dest);\n      }\n    }\n    // add the airport to the head of the itinerary\n    this.result.offerFirst(origin);\n  }\n}\n"]}
{"number": 336, "statement": "Given a list of unique words, find all pairs of distinct indices (i, j) in the given list, so that the concatenation of the two words, i.e. words[i] + words[j] is a palindrome.\n", "solutions": ["class Solution {\n    public List<List<Integer>> palindromePairs(String[] words) {\n        List<List<Integer>> pairs = new ArrayList<>();\n        for (int i = 0; i < words.length; i++) {\n            for (int j = 0; j < words.length; j++) {\n                if (i == j) continue;\n                String combined = words[i].concat(words[j]);\n                String reversed = new StringBuilder(combined).reverse().toString();\n                if (combined.equals(reversed)) {\n                    pairs.add(Arrays.asList(i, j));\n                }\n            }   \n        }\n        return pairs;\n    }\n}\n", "class Solution {\n    private List<String> allValidPrefixes(String word) {\n        List<String> validPrefixes = new ArrayList<>();\n        for (int i = 0; i < word.length(); i++) {\n            if (isPalindromeBetween(word, i, word.length() - 1)) {\n                validPrefixes.add(word.substring(0, i));\n            }\n        }\n        return validPrefixes;\n    }\n    private List<String> allValidSuffixes(String word) {\n        List<String> validSuffixes = new ArrayList<>();\n        for (int i = 0; i < word.length(); i++) {\n            if (isPalindromeBetween(word, 0, i)) {\n                validSuffixes.add(word.substring(i + 1, word.length()));\n            }\n        }\n        return validSuffixes;\n    }\n    // Is the prefix ending at i a palindrome?\n    private boolean isPalindromeBetween(String word, int front, int back) {\n        while (front < back) {\n            if (word.charAt(front) != word.charAt(back)) return false;\n            front++;\n            back--;\n        }\n        return true;\n    }\n    public List<List<Integer>> palindromePairs(String[] words) {\n        // Build a word -> original index mapping for efficient lookup.\n        Map<String, Integer> wordSet = new HashMap<>();\n        for (int i = 0; i < words.length; i++) {\n            wordSet.put(words[i], i);\n        }\n        // Make a list to put all the palindrome pairs we find in.\n        List<List<Integer>> solution = new ArrayList<>();\n        for (String word : wordSet.keySet()) {\n            int currentWordIndex = wordSet.get(word);\n            String reversedWord = new StringBuilder(word).reverse().toString();\n            // Build solutions of case #1. This word will be word 1.\n            if (wordSet.containsKey(reversedWord)\n              && wordSet.get(reversedWord) != currentWordIndex) {\n                solution.add(Arrays.asList(currentWordIndex, wordSet.get(reversedWord)));\n            }\n            // Build solutions of case #2. This word will be word 2.\n            for (String suffix : allValidSuffixes(word)) {\n                String reversedSuffix = new StringBuilder(suffix).reverse().toString();\n                if (wordSet.containsKey(reversedSuffix)) {\n                    solution.add(Arrays.asList(wordSet.get(reversedSuffix), currentWordIndex));\n                }\n            }\n            // Build solutions of case #3. This word will be word 1.\n            for (String prefix : allValidPrefixes(word)) {\n                String reversedPrefix = new StringBuilder(prefix).reverse().toString();\n                if (wordSet.containsKey(reversedPrefix)) {\n                    solution.add(Arrays.asList(currentWordIndex, wordSet.get(reversedPrefix)));\n                }\n            }\n        }\n        return solution;\n    }\n}\n"]}
{"number": 338, "statement": "Given a non negative integer number num. For every numbers i in the range 0 \u2264 i \u2264 num calculate the number of 1's in their binary representation and return them as an array.\n", "solutions": ["public class Solution {\n    public int[] countBits(int num) {\n        int[] ans = new int[num + 1];\n        for (int i = 0; i <= num; ++i)\n            ans[i] = popcount(i);\n        return ans;\n    }\n    private int popcount(int x) {\n        int count;\n        for (count = 0; x != 0; ++count)\n          x &= x - 1; //zeroing out the least significant nonzero bit\n        return count;\n    }\n}\n", "public class Solution {\n  public int[] countBits(int num) {\n      int[] ans = new int[num + 1];\n      for (int i = 1; i <= num; ++i)\n        ans[i] = ans[i >> 1] + (i & 1); // x / 2 is x >> 1 and x % 2 is x & 1\n      return ans;\n  }\n}\n", "public class Solution {\n  public int[] countBits(int num) {\n      int[] ans = new int[num + 1];\n      for (int i = 1; i <= num; ++i)\n        ans[i] = ans[i & (i - 1)] + 1;\n      return ans;\n  }\n}\n"]}
{"number": 340, "statement": "Given a string, find the length of the longest substring T that contains at most k distinct characters.\n", "solutions": ["class Solution {\n  public int lengthOfLongestSubstringKDistinct(String s, int k) {\n    int n = s.length();\n    if (n*k == 0) return 0;\n    // sliding window left and right pointers\n    int left = 0;\n    int right = 0;\n    // hashmap character -> its rightmost position \n    // in the sliding window\n    HashMap<Character, Integer> hashmap = new HashMap<Character, Integer>();\n    int max_len = 1;\n    while (right < n) {\n      // add new character and move right pointer\n      hashmap.put(s.charAt(right), right++);\n      // slidewindow contains 3 characters\n      if (hashmap.size() == k + 1) {\n        // delete the leftmost character\n        int del_idx = Collections.min(hashmap.values());\n        hashmap.remove(s.charAt(del_idx));\n        // move left pointer of the slidewindow\n        left = del_idx + 1;\n      }\n      max_len = Math.max(max_len, right - left);\n    }\n    return max_len;\n  }\n}\n", "class Solution {\n  public int lengthOfLongestSubstringKDistinct(String s, int k) {\n    int n = s.length();\n    if (n*k == 0) return 0;\n    // sliding window left and right pointers\n    int left = 0;\n    int right = 0;\n    // hashmap character -> its rightmost position \n    // in the sliding window\n    LinkedHashMap<Character, Integer> hashmap = new LinkedHashMap<Character, Integer>(k + 1);\n    int max_len = 1;\n    while (right < n) {\n      Character character = s.charAt(right);\n      // if character is already in the hashmap -\n      // delete it, so that after insert it becomes\n      // the rightmost element in the hashmap\n      if (hashmap.containsKey(character))\n        hashmap.remove(character);\n      hashmap.put(character, right++);\n      // slidewindow contains k + 1 characters\n      if (hashmap.size() == k + 1) {\n        // delete the leftmost character\n        Map.Entry<Character, Integer> leftmost = hashmap.entrySet().iterator().next();\n        hashmap.remove(leftmost.getKey());\n        // move left pointer of the slidewindow\n        left = leftmost.getValue() + 1;\n      }\n      max_len = Math.max(max_len, right - left);\n    }\n    return max_len;\n  }\n}\n"]}
{"number": 341, "statement": "Given a nested list of integers, implement an iterator to flatten it.\nEach element is either an integer, or a list -- whose elements may also be integers or other lists.\n", "solutions": ["import java.util.NoSuchElementException;\npublic class NestedIterator implements Iterator<Integer> {\n    \n    private List<Integer> integers = new ArrayList<Integer>();\n    private int position = 0; // Pointer to next integer to return.\n    \n    public NestedIterator(List<NestedInteger> nestedList) {\n        flattenList(nestedList);\n    }\n    // Recursively unpacks a nested list in DFS order.\n    private void flattenList(List<NestedInteger> nestedList) {\n        for (NestedInteger nestedInteger : nestedList) {\n            if (nestedInteger.isInteger()) {\n                integers.add(nestedInteger.getInteger());\n            } else {\n                flattenList(nestedInteger.getList());\n            }\n        }\n    }\n    \n    @Override\n    public Integer next() {\n        // As per Java specs, we should throw an exception if no more ints.\n        if (!hasNext()) throw new NoSuchElementException();\n        // Return int at current position, and then *after*, increment position.\n        return integers.get(position++);\n    }\n    @Override\n    public boolean hasNext() {\n        return position < integers.size();\n    }\n}\n", "import java.util.NoSuchElementException;\npublic class NestedIterator implements Iterator<Integer> {\n    // In Java, the Stack class is considered deprecated. Best practice is to use\n    // a Deque instead. We'll use addFirst() for push, and removeFirst() for pop.\n    private Deque<NestedInteger> stack;\n    \n    public NestedIterator(List<NestedInteger> nestedList) {\n        // The constructor puts them on in the order we require. No need to reverse.\n        stack = new ArrayDeque(nestedList);\n    }\n        \n    \n    @Override\n    public Integer next() {\n        // As per java specs, throw an exception if there's no elements left.\n        if (!hasNext()) throw new NoSuchElementException();\n        // hasNext ensures the stack top is now an integer. Pop and return\n        // this integer.\n        return stack.removeFirst().getInteger();\n    }\n    \n    @Override\n    public boolean hasNext() {\n        // Check if there are integers left by getting one onto the top of stack.\n        makeStackTopAnInteger();\n        // If there are any integers remaining, one will be on the top of the stack,\n        // and therefore the stack can't possibly be empty.\n        return !stack.isEmpty();\n    }\n    private void makeStackTopAnInteger() {\n        // While there are items remaining on the stack and the front of \n        // stack is a list (i.e. not integer), keep unpacking.\n        while (!stack.isEmpty() && !stack.peekFirst().isInteger()) {\n            // Put the NestedIntegers onto the stack in reverse order.\n            List<NestedInteger> nestedList = stack.removeFirst().getList();\n            for (int i = nestedList.size() - 1; i >= 0; i--) {\n                stack.addFirst(nestedList.get(i));\n            }\n        }\n    }\n}\n", "import java.util.NoSuchElementException;\npublic class NestedIterator implements Iterator<Integer> {\n    private Deque<List<NestedInteger>> listStack = new ArrayDeque<>();\n    private Deque<Integer> indexStack = new ArrayDeque<>();\n    \n    public NestedIterator(List<NestedInteger> nestedList) {\n        listStack.addFirst(nestedList);\n        indexStack.addFirst(0);\n    }\n        \n    @Override\n    public Integer next() {\n        if (!hasNext()) throw new NoSuchElementException();\n        int currentPosition = indexStack.removeFirst();\n        indexStack.addFirst(currentPosition + 1);\n        return listStack.peekFirst().get(currentPosition).getInteger();\n    }\n    \n    @Override\n    public boolean hasNext() {\n        makeStackTopAnInteger();\n        return !indexStack.isEmpty();\n    }\n    private void makeStackTopAnInteger() {\n    \n        while (!indexStack.isEmpty()) {\n                        \n            // If the top list is used up, pop it and its index.\n            if (indexStack.peekFirst() >= listStack.peekFirst().size()) {\n                indexStack.removeFirst();\n                listStack.removeFirst();\n                continue;\n            }\n            // Otherwise, if it's already an integer, we don't need to do anything.\n            if (listStack.peekFirst().get(indexStack.peekFirst()).isInteger()) {\n                break;\n            }\n            // Otherwise, it must be a list. We need to update the previous index\n            // and then add the new list with an index of 0.\n            listStack.addFirst(listStack.peekFirst().get(indexStack.peekFirst()).getList());\n            indexStack.addFirst(indexStack.removeFirst() + 1);\n            indexStack.addFirst(0);\n        }\n    }\n}\n", "import java.util.NoSuchElementException;\npublic class NestedIterator implements Iterator<Integer> {\n    \n    // This time, our stack will hold list iterators instead of just lists.\n    private Deque<ListIterator<NestedInteger>> stackOfIterators = new ArrayDeque();\n    private Integer peeked = null;\n    public NestedIterator(List<NestedInteger> nestedList) {\n        // Make an iterator with the input and put it on the stack. \n        // Note that creating a list iterator is an O(1) operation.\n        stackOfIterators.addFirst(nestedList.listIterator());\n    }\n    private void setPeeked() {\n        \n        // If peeked is already set, there's nothing to do.\n        if (peeked != null) return;\n        \n        while (!stackOfIterators.isEmpty()) {\n            \n            // If the iterator at the top of the stack doesn't have a next,\n            // remove that iterator and continue on.\n            if (!stackOfIterators.peekFirst().hasNext()) {\n                stackOfIterators.removeFirst();\n                continue;\n            }\n            \n            // Otherwise, we need to check whether that next is a list or \n            // an integer.\n            NestedInteger next = stackOfIterators.peekFirst().next();\n            \n            // If it's an integer, set peeked to it and return as we're done.\n            if (next.isInteger()) {\n                peeked = next.getInteger();\n                return;\n            }\n            \n            // Otherwise, it's a list. Create a new iterator with it, and put\n            // the new iterator on the top of the stack.\n            stackOfIterators.addFirst(next.getList().listIterator());\n        }        \n    }\n    \n    @Override\n    public Integer next() {\n        \n        // As per Java specs, throw an exception if there are no further elements.\n        if (!hasNext()) throw new NoSuchElementException();\n        \n        // hasNext() called setPeeked(), which ensures peeked has the next integer \n        // in it. We need to clear the peeked field so that the element is returned\n        // again.\n        Integer result = peeked;\n        peeked = null;\n        return result;\n    }\n    @Override\n    public boolean hasNext() {\n        // Try to set the peeked field. If any integers are remaining, it will\n        // contain the next one to be returned after this call.\n        setPeeked();\n        \n        // There are elements remaining iff peeked contains a value.\n        return peeked != null;\n    }\n}\n", "class NestedIterator:\n    def __init__(self, nestedList: [NestedInteger]):\n        # Get a generator object from the generator function, passing in\n        # nestedList as the parameter.\n        self._generator = self._int_generator(nestedList)\n        # All values are placed here before being returned.\n        self._peeked = None\n    # This is the generator function. It can be used to create generator\n    # objects.\n    def _int_generator(self, nested_list) -> \"Generator[int]\":\n        # This code is the same as Approach 1. It's a recursive DFS.\n        for nested in nested_list:\n            if nested.isInteger():\n                yield nested.getInteger()\n            else:\n                # We always use \"yield from\" on recursive generator calls.\n                yield from self._int_generator(nested.getList())\n        # Will automatically raise a StopIteration.\n    \n    def next(self) -> int:\n        # Check there are integers left, and if so, then this will\n        # also put one into self._peeked.\n        if not self.hasNext(): return None\n        # Return the value of self._peeked, also clearing it.\n        next_integer, self._peeked = self._peeked, None\n        return next_integer\n        \n    def hasNext(self) -> bool:\n        if self._peeked is not None: return True\n        try: # Get another integer out of the generator.\n            self._peeked = next(self._generator)\n            return True\n        except: # The generator is finished so raised StopIteration.\n            return False\n"]}
{"number": 342, "statement": "Given an integer (signed 32 bits), write a function to check whether it is a power of 4.\n", "solutions": ["class Solution {\n  public boolean isPowerOfTwo(int n) {\n    if (n == 0) return false;\n    while (n % 4 == 0) n /= 4;\n    return n == 1;\n  }\n}\n", "class Powers {\n  private int n = 15;\n  public List<Integer> nums = new ArrayList();\n  Powers() {\n    int lastNum = 1;\n    nums.add(lastNum);\n    for (int i = 1; i < n + 1; ++i) {\n      lastNum = lastNum * 4;\n      nums.add(lastNum);\n    }\n  }\n}\nclass Solution {\n  public static Powers p = new Powers();\n  public boolean isPowerOfFour(int num) {\n    return p.nums.contains(num);\n  }\n}\n", "class Solution {\n  public boolean isPowerOfFour(int num) {\n    return (num > 0) && (Math.log(num) / Math.log(2) % 2 == 0);\n  }\n}\n", "class Solution {\n  public boolean isPowerOfFour(int num) {\n    return (num > 0) && ((num & (num - 1)) == 0) && ((num & 0xaaaaaaaa) == 0);\n  }\n}\n", "class Solution {\n  public boolean isPowerOfFour(int num) {\n    return (num > 0) && ((num & (num - 1)) == 0) && (num % 3 == 1);\n  }\n}\n"]}
{"number": 344, "statement": "Write a function that reverses a string. The input string is given as an array of characters char[].\nDo not allocate extra space for another array, you must do this by modifying the input arrayin-place with O(1) extra memory.\nYou may assume all the characters consist of printable ascii characters.\n", "solutions": ["class Solution:\n    def reverseString(self, s):\n        s.reverse()\n", "class Solution {\n  public void helper(char[] s, int left, int right) {\n    if (left >= right) return;\n    char tmp = s[left];\n    s[left++] = s[right];\n    s[right--] = tmp;\n    helper(s, left, right);\n  }\n  public void reverseString(char[] s) {\n    helper(s, 0, s.length - 1);\n  }\n}\n", "class Solution {\n    public void reverseString(char[] s) {\n        int left = 0, right = s.length - 1;\n        while (left < right) {\n            char tmp = s[left];\n            s[left++] = s[right];\n            s[right--] = tmp;\n        }\n    }\n}\n"]}
{"number": 346, "statement": "Given a stream of integers and a window size, calculate the moving average of all integers in the sliding window.\n", "solutions": ["class MovingAverage {\n  int size;\n  List queue = new ArrayList<Integer>();\n  public MovingAverage(int size) {\n    this.size = size;\n  }\n\u200b\n  public double next(int val) {\n    queue.add(val);\n    // calculate the sum of the moving window\n    int windowSum = 0;\n    for(int i = Math.max(0, queue.size() - size); i < queue.size(); ++i)\n      windowSum += (int)queue.get(i);\n\u200b\n    return windowSum * 1.0 / Math.min(queue.size(), size);\n  }\n}\n", "class MovingAverage {\n  int size, windowSum = 0, count = 0;\n  Deque queue = new ArrayDeque<Integer>();\n    \n  public MovingAverage(int size) {\n    this.size = size;\n  }\n  public double next(int val) {\n    ++count;\n    // calculate the new sum by shifting the window\n    queue.add(val);\n    int tail = count > size ? (int)queue.poll() : 0;\n     \n    windowSum = windowSum - tail + val;\n    return windowSum * 1.0 / Math.min(size, count);\n  }\n}\n", "class MovingAverage {\n  int size, head = 0, windowSum = 0, count = 0;\n  int[] queue;\n  public MovingAverage(int size) {\n    this.size = size;\n    queue = new int[size];\n  }\n\u200b\n  public double next(int val) {\n    ++count;\n    // calculate the new sum by shifting the window\n    int tail = (head + 1) % size;\n    windowSum = windowSum - queue[tail] + val;\n    // move on to the next head\n    head = (head + 1) % size;\n    queue[head] = val;\n    return windowSum * 1.0 / Math.min(size, count);\n  }\n}\n"]}
{"number": 347, "statement": "Given a non-empty array of integers, return the k most frequent elements.\n", "solutions": ["class Solution {\n  public List<Integer> topKFrequent(int[] nums, int k) {\n    // build hash map : character and how often it appears\n    HashMap<Integer, Integer> count = new HashMap();\n    for (int n: nums) {\n      count.put(n, count.getOrDefault(n, 0) + 1);\n    }\n    // init heap 'the less frequent element first'\n    PriorityQueue<Integer> heap =\n            new PriorityQueue<Integer>((n1, n2) -> count.get(n1) - count.get(n2));\n    // keep k top frequent elements in the heap\n    for (int n: count.keySet()) {\n      heap.add(n);\n      if (heap.size() > k)\n        heap.poll();\n    }\n    // build output list\n    List<Integer> top_k = new LinkedList();\n    while (!heap.isEmpty())\n      top_k.add(heap.poll());\n    Collections.reverse(top_k);\n    return top_k;\n  }\n}\n"]}
{"number": 349, "statement": "Given two arrays, write a function to compute their intersection.\n", "solutions": ["class Solution {\n  public int[] set_intersection(HashSet<Integer> set1, HashSet<Integer> set2) {\n    int [] output = new int[set1.size()];\n    int idx = 0;\n    for (Integer s : set1)\n      if (set2.contains(s)) output[idx++] = s;\n    return Arrays.copyOf(output, idx);\n  }\n  public int[] intersection(int[] nums1, int[] nums2) {\n    HashSet<Integer> set1 = new HashSet<Integer>();\n    for (Integer n : nums1) set1.add(n);\n    HashSet<Integer> set2 = new HashSet<Integer>();\n    for (Integer n : nums2) set2.add(n);\n    if (set1.size() < set2.size()) return set_intersection(set1, set2);\n    else return set_intersection(set2, set1);\n  }\n}\n", "class Solution {\n  public int[] intersection(int[] nums1, int[] nums2) {\n    HashSet<Integer> set1 = new HashSet<Integer>();\n    for (Integer n : nums1) set1.add(n);\n    HashSet<Integer> set2 = new HashSet<Integer>();\n    for (Integer n : nums2) set2.add(n);\n    set1.retainAll(set2);\n    int [] output = new int[set1.size()];\n    int idx = 0;\n    for (int s : set1) output[idx++] = s;\n    return output;\n  }\n}\n"]}
{"number": 350, "statement": "Given two arrays, write a function to compute their intersection.\n", "solutions": ["vector<int> intersect(vector<int>& nums1, vector<int>& nums2) {\n    if (nums1.size() > nums2.size()) {\n        return intersect(nums2, nums1);\n    }\n    unordered_map<int, int> m;\n    for (auto n : nums1) {\n        ++m[n];\n    }\n    int k = 0;\n    for (auto n : nums2) {\n        auto it = m.find(n);\n        if (it != end(m) && --it->second >= 0) {\n            nums1[k++] = n;\n        }\n    }\n    return vector(begin(nums1), begin(nums1) + k);\n}\n", "vector<int> intersect(vector<int>& nums1, vector<int>& nums2) {\n    sort(begin(nums1), end(nums1));\n    sort(begin(nums2), end(nums2));\n    int i = 0, j = 0, k = 0;\n    while (i < nums1.size() && j < nums2.size()) {\n        if (nums1[i] < nums2[j]) {\n            ++i;\n        } else if (nums1[i] > nums2[j]) {\n            ++j;\n        } else {\n            nums1[k++] = nums1[i++];\n            ++j;\n        }\n    }\n    return vector<int>(begin(nums1), begin(nums1) + k);\n}\n", "vector<int> intersect(vector<int>& nums1, vector<int>& nums2) {\n    sort(begin(nums1), end(nums1));\n    sort(begin(nums2), end(nums2));\n    nums1.erase(set_intersection(begin(nums1), end(nums1), \n        begin(nums2), end(nums2), begin(nums1)), end(nums1));\n    return nums1;\n}\n"]}
{"number": 354, "statement": "You have a number of envelopes with widths and heights given as a pair of integers (w, h). One envelope can fit into another if and only if both the width and height of one envelope is greater than the width and height of the other envelope.\nWhat is the maximum number of envelopes can you Russian doll? (put one inside other)\nNote:\nRotation is not allowed.\n", "solutions": ["class Solution {\n    public int lengthOfLIS(int[] nums) {\n        int[] dp = new int[nums.length];\n        int len = 0;\n        for (int num : nums) {\n            int i = Arrays.binarySearch(dp, 0, len, num);\n            if (i < 0) {\n                i = -(i + 1);\n            }\n            dp[i] = num;\n            if (i == len) {\n                len++;\n            }\n        }\n        return len;\n    }\n    public int maxEnvelopes(int[][] envelopes) {\n        // sort on increasing in first dimension and decreasing in second\n        Arrays.sort(envelopes, new Comparator<int[]>() {\n            public int compare(int[] arr1, int[] arr2) {\n                if (arr1[0] == arr2[0]) {\n                    return arr2[1] - arr1[1];\n                } else {\n                    return arr1[0] - arr2[0];\n                }\n           }\n        });\n        // extract the second dimension and run LIS\n        int[] secondDim = new int[envelopes.length];\n        for (int i = 0; i < envelopes.length; ++i) secondDim[i] = envelopes[i][1];\n        return lengthOfLIS(secondDim);\n    }\n}\n"]}
{"number": 359, "statement": "Design a logger system that receive stream of messages along with its timestamps, each message should be printed if and only if it is not printed in the last 10 seconds.\nGiven a message and a timestamp (in seconds granularity), return true if the message should be printed in the given timestamp, otherwise returns false.\nIt is possible that several messages arrive roughly at the same time.\n", "solutions": ["class Pair<U, V> {\n  public U first;\n  public V second;\n  public Pair(U first, V second) {\n    this.first = first;\n    this.second = second;\n  }\n}\nclass Logger {\n  private LinkedList<Pair<String, Integer>> msgQueue;\n  private HashSet<String> msgSet;\n  /** Initialize your data structure here. */\n  public Logger() {\n    msgQueue = new LinkedList<Pair<String, Integer>>();\n    msgSet = new HashSet<String>();\n  }\n  /**\n   * Returns true if the message should be printed in the given timestamp, otherwise returns false.\n   */\n  public boolean shouldPrintMessage(int timestamp, String message) {\n    // clean up.\n    while (msgQueue.size() > 0) {\n      Pair<String, Integer> head = msgQueue.getFirst();\n      if (timestamp - head.second >= 10) {\n        msgQueue.removeFirst();\n        msgSet.remove(head.first);\n      } else\n        break;\n    }\n    if (!msgSet.contains(message)) {\n      Pair<String, Integer> newEntry = new Pair<String, Integer>(message, timestamp);\n      msgQueue.addLast(newEntry);\n      msgSet.add(message);\n      return true;\n    } else\n      return false;\n  }\n}\n", "class Logger {\n  private HashMap<String, Integer> msgDict;\n  /** Initialize your data structure here. */\n  public Logger() {\n    msgDict = new HashMap<String, Integer>();\n  }\n  /**\n   * Returns true if the message should be printed in the given timestamp, otherwise returns false.\n   */\n  public boolean shouldPrintMessage(int timestamp, String message) {\n    if (!this.msgDict.containsKey(message)) {\n      this.msgDict.put(message, timestamp);\n      return true;\n    }\n    Integer oldTimestamp = this.msgDict.get(message);\n    if (timestamp - oldTimestamp >= 10) {\n      this.msgDict.put(message, timestamp);\n      return true;\n    } else\n      return false;\n  }\n}\n"]}
{"number": 367, "statement": "Given a positive integer num, write a function which returns True if num is a perfect square else False.\nFollow up: Do not use any built-in library function such as sqrt.\n", "solutions": ["class Solution {\n  public boolean isPerfectSquare(int num) {\n    if (num < 2) {\n      return true;\n    }\n    long left = 2, right = num / 2, x, guessSquared;\n    while (left <= right) {\n      x = left + (right - left) / 2;\n      guessSquared = x * x;\n      if (guessSquared == num) {\n        return true;\n      }\n      if (guessSquared > num) {\n        right = x - 1;\n      } else {\n        left = x + 1;\n      }\n    }\n    return false;\n  }\n}\n", "class Solution {\n  public boolean isPerfectSquare(int num) {\n    if (num < 2) return true;\n    long x = num / 2;\n    while (x * x > num) {\n      x = (x + num / x) / 2;\n    }\n    return (x * x == num);\n  }\n}\n"]}
{"number": 368, "statement": "Given a set of distinct positive integers, find the largest subset such that every pair (Si, Sj) of elements in this subset satisfies:\nSi % Sj = 0 or Sj % Si = 0.\nIf there are multiple solutions, return any subset is fine.\n", "solutions": ["class Solution {\n  public List<Integer> largestDivisibleSubset(int[] nums) {\n    // Test case with empty set.\n    int n = nums.length;\n    if (n == 0) return new ArrayList();\n        \n    // Container to keep the largest divisible subset\n    //   that ends with each of the nums.\n    List<ArrayList> EDS = new ArrayList();\n    for (int num : nums) EDS.add(new ArrayList());\n    /* Sort the original list in ascending order. */\n    Arrays.sort(nums);\n    /* Calculate all the values of EDS(X_i) */\n    for (int i = 0; i < n; ++i) {\n      List<Integer> maxSubset = new ArrayList();\n            \n      // Find the largest divisible subset of previous elements.\n      for (int k = 0; k < i; ++k) \n        if (nums[i] % nums[k] == 0 && maxSubset.size() < EDS.get(k).size())\n          maxSubset = EDS.get(k);\n          \n      // Extend the found subset with the element itself.\n      EDS.get(i).addAll(maxSubset);\n      EDS.get(i).add(nums[i]);\n    }\n    /* Find the largest of EDS values  */\n    List<Integer> ret = new ArrayList();\n    for (int i = 0; i < n; ++i) \n      if (ret.size() < EDS.get(i).size()) ret = EDS.get(i);\n    return ret;\n  }  \n}\n", "class Solution {\n  public List<Integer> largestDivisibleSubset(int[] nums) {\n    // Test case with empty set.\n    int n = nums.length;\n    if (n == 0) return new ArrayList();\n        \n    // Container to keep the size of the largest divisible subset\n    //   that ends with each of the nums.\n    Integer[] dp = new Integer[n];\n    /* Sort the original list in ascending order. */\n    Arrays.sort(nums);\n    Integer maxSubsetSize = -1, maxSubsetIndex = -1;\n    \n    /* Calculate the rest of EDS(X_i) */\n    for (int i = 0; i < n; ++i) {\n      Integer subsetSize = 0;\n      // Find the size of the largest divisible subset.\n      for (int k = 0; k < i; ++k) \n        if (nums[i] % nums[k] == 0 && subsetSize < dp[k])\n          subsetSize = dp[k];\n      // Extend the found subset with the element itself.\n      dp[i] = subsetSize + 1;\n    \n      // We reuse this loop to obtain the largest subset size \n      //   in order to prepare for the reconstruction of subset.\n      if (maxSubsetSize < dp[i]) {\n        maxSubsetSize = dp[i];\n        maxSubsetIndex = i;\n      }\n    }\n    \n    /* Reconstruct the largest divisible subset  */\n    LinkedList<Integer> subset = new LinkedList();\n    Integer currSize = maxSubsetSize;\n    Integer currTail = nums[maxSubsetIndex];\n    for (int i = maxSubsetIndex; i >= 0; --i) {\n      if (currSize == 0) break;\n    \n      if (currTail % nums[i] == 0 && currSize == dp[i]) {\n        subset.addFirst(nums[i]);\n        currTail = nums[i];\n        currSize -= 1;\n      }\n    }\n    return subset;\n  }  \n}\n"]}
{"number": 369, "statement": "Given a non-negative integer represented as non-empty a singly linked list of digits, plus one to the integer.\nYou may assume the integer do not contain any leading zero, except the number 0 itself.\nThe digits are stored such that the most significant digit is at the head of the list.\n", "solutions": ["class Solution {\n  public ListNode plusOne(ListNode head) {\n    // sentinel head\n    ListNode sentinel = new ListNode(0);\n    sentinel.next = head;\n    ListNode notNine = sentinel;\n    // find the rightmost not-nine digit\n    while (head != null) {\n      if (head.val != 9) notNine = head;\n      head = head.next;\n    }\n    \n    // increase this rightmost not-nine digit by 1\n    notNine.val++;\n    notNine = notNine.next;\n    \n    // set all the following nines to zeros\n    while (notNine != null) {\n      notNine.val = 0;\n      notNine = notNine.next;\n    }\n    \n    return sentinel.val != 0 ? sentinel : sentinel.next;\n  }\n}\n"]}
{"number": 370, "statement": "Assume you have an array of length n initialized with all 0's and are given k update operations.\nEach operation is represented as a triplet: [startIndex, endIndex, inc] which increments each element of subarray A[startIndex ... endIndex] (startIndex and endIndex inclusive) with inc.\nReturn the modified array after all k operations were executed.\n", "solutions": ["vector<int> getModifiedArray(int length, vector<vector<int> > updates)\n{\n    vector<int> result(length, 0);\n    for (auto& tuple : updates) {\n        int start = tuple[0], end = tuple[1], val = tuple[2];\n        for (int i = start; i <= end; i++) {\n            result[i] += val;\n        }\n    }\n    return result;\n}\n", "vector<int> getModifiedArray(int length, vector<vector<int> > updates)\n{\n    vector<int> result(length, 0);\n    for (auto& tuple : updates) {\n        int start = tuple[0], end = tuple[1], val = tuple[2];\n        result[start] += val;\n        if (end < length - 1)\n            result[end + 1] -= val;\n    }\n    // partial_sum applies the following operation (by default) for the parameters {x[0], x[n], y[0]}:\n    // y[0] = x[0]\n    // y[1] = y[0] + x[1]\n    // y[2] = y[1] + x[2]\n    // ...  ...  ...\n    // y[n] = y[n-1] + x[n]\n    partial_sum(result.begin(), result.end(), result.begin());\n    return result;\n}\n"]}
{"number": 374, "statement": "We are playing the Guess Game. The game is as follows:\nI pick a number from 1 to n. You have to guess which number I picked.\nEvery time you guess wrong, I'll tell you whether the number is higher or lower.\nYou call a pre-defined API guess(int num) which returns 3 possible results (-1, 1, or 0):\n-1 : My number is lower\n 1 : My number is higher\n 0 : Congrats! You got it!\n", "solutions": ["/* The guess API is defined in the parent class GuessGame.\n   @param num, your guess\n   @return -1 if my number is lower, 1 if my number is higher, otherwise return 0\n      int guess(int num); */\npublic class Solution extends GuessGame {\n    public int guessNumber(int n) {\n        for (int i = 1; i < n; i++)\n            if (guess(i) == 0)\n                return i;\n        return n;\n    }\n}\n", "/* The guess API is defined in the parent class GuessGame.\n   @param num, your guess\n   @return -1 if my number is lower, 1 if my number is higher, otherwise return 0\n      int guess(int num); */\npublic class Solution extends GuessGame {\n    public int guessNumber(int n) {\n        int low = 1;\n        int high = n;\n        while (low <= high) {\n            int mid = low + (high - low) / 2;\n            int res = guess(mid);\n            if (res == 0)\n                return mid;\n            else if (res < 0)\n                high = mid - 1;\n            else\n                low = mid + 1;\n        }\n        return -1;\n    }\n}\n"]}
{"number": 375, "statement": "We are playing the Guess Game. The game is as follows:\nI pick a number from 1 to n. You have to guess which number I picked.\nEvery time you guess wrong, I'll tell you whether the number I picked is higher or lower.\nHowever, when you guess a particular number x, and you guess wrong, you pay $x. You win the game when you guess the number I picked.\n", "solutions": ["public class Solution {\n    public int calculate(int low, int high) {\n        if (low >= high)\n            return 0;\n        int minres = Integer.MAX_VALUE;\n        for (int i = low; i <= high; i++) {\n            int res = i + Math.max(calculate(i + 1, high), calculate(low, i - 1));\n            minres = Math.min(res, minres);\n        }\n        return minres;\n    }\n    public int getMoneyAmount(int n) {\n        return calculate(1, n);\n    }\n}\n", "public class Solution {\n    public int calculate(int low, int high) {\n        if (low >= high)\n            return 0;\n        int minres = Integer.MAX_VALUE;\n        for (int i = (low + high) / 2; i <= high; i++) {\n            int res = i + Math.max(calculate(i + 1, high), calculate(low, i - 1));\n            minres = Math.min(res, minres);\n        }\n        return minres;\n    }\n    public int getMoneyAmount(int n) {\n        return calculate(1, n);\n    }\n}\n", "public class Solution {\n    public int getMoneyAmount(int n) {\n        int[][] dp = new int[n + 1][n + 1];\n        for (int len = 2; len <= n; len++) {\n            for (int start = 1; start <= n - len + 1; start++) {\n                int minres = Integer.MAX_VALUE;\n                for (int piv = start; piv < start + len - 1; piv++) {\n                    int res = piv + Math.max(dp[start][piv - 1], dp[piv + 1][start + len - 1]);\n                    minres = Math.min(res, minres);\n                }\n                dp[start][start + len - 1] = minres;\n            }\n        }\n        return dp[1][n];\n    }\n}\n", "public class Solution {\n    public int getMoneyAmount(int n) {\n        int[][] dp = new int[n + 1][n + 1];\n        for (int len = 2; len <= n; len++) {\n            for (int start = 1; start <= n - len + 1; start++) {\n                int minres = Integer.MAX_VALUE;\n                for (int piv = start + (len - 1) / 2; piv < start + len - 1; piv++) {\n                    int res = piv + Math.max(dp[start][piv - 1], dp[piv + 1][start + len - 1]);\n                    minres = Math.min(res, minres);\n                }\n                dp[start][start + len - 1] = minres;\n            }\n        }\n        return dp[1][n];\n    }\n}\n"]}
{"number": 376, "statement": "A sequence of numbers is called a wiggle sequence if the differences between successive numbers strictly alternate between positive and negative. The first difference (if one exists) may be either positive or negative. A sequence with fewer than two elements is trivially a wiggle sequence.\nFor example, [1,7,4,9,2,5] is a wiggle sequence because the differences (6,-3,5,-7,3) are alternately positive and negative. In contrast, [1,4,7,2,5] and [1,7,4,5,5] are not wiggle sequences, the first because its first two differences are positive and the second because its last difference is zero.\nGiven a sequence of integers, return the length of the longest subsequence that is a wiggle sequence. A subsequence is obtained by deleting some number of elements (eventually, also zero) from the original sequence, leaving the remaining elements in their original order.\n", "solutions": ["public class Solution {\n    private int calculate(int[] nums, int index, boolean isUp) {\n        int maxcount = 0;\n        for (int i = index + 1; i < nums.length; i++) {\n            if ((isUp && nums[i] > nums[index]) || (!isUp && nums[i] < nums[index]))\n                maxcount = Math.max(maxcount, 1 + calculate(nums, i, !isUp));\n        }\n        return maxcount;\n    }\n    public int wiggleMaxLength(int[] nums) {\n        if (nums.length < 2)\n            return nums.length;\n        return 1 + Math.max(calculate(nums, 0, true), calculate(nums, 0, false));\n    }\n}\n", "public class Solution {\n    public int wiggleMaxLength(int[] nums) {\n        if (nums.length < 2)\n            return nums.length;\n        int[] up = new int[nums.length];\n        int[] down = new int[nums.length];\n        for (int i = 1; i < nums.length; i++) {\n            for(int j = 0; j < i; j++) {\n                if (nums[i] > nums[j]) {\n                    up[i] = Math.max(up[i],down[j] + 1);\n                } else if (nums[i] < nums[j]) {\n                    down[i] = Math.max(down[i],up[j] + 1);\n                }\n            }\n        }\n        return 1 + Math.max(down[nums.length - 1], up[nums.length - 1]);\n    }\n}\n"]}
{"number": 378, "statement": "Given a n x n matrix where each of the rows and columns are sorted in ascending order, find the kth smallest element in the matrix.\nNote that it is the kth smallest element in the sorted order, not the kth distinct element.\n", "solutions": ["class MyHeapNode {\n  int row;\n  int column;\n  int value;\n  public MyHeapNode(int v, int r, int c) {\n    this.value = v;\n    this.row = r;\n    this.column = c;\n  }\n  public int getValue() {\n    return this.value;\n  }\n  public int getRow() {\n    return this.row;\n  }\n  public int getColumn() {\n    return this.column;\n  }\n}\nclass MyHeapComparator implements Comparator<MyHeapNode> {\n  public int compare(MyHeapNode x, MyHeapNode y) {\n    return x.value - y.value;\n  }\n}\nclass Solution {\n  public int kthSmallest(int[][] matrix, int k) {\n    int N = matrix.length;\n    PriorityQueue<MyHeapNode> minHeap =\n        new PriorityQueue<MyHeapNode>(Math.min(N, k), new MyHeapComparator());\n    // Preparing our min-heap\n    for (int r = 0; r < Math.min(N, k); r++) {\n      // We add triplets of information for each cell\n      minHeap.offer(new MyHeapNode(matrix[r][0], r, 0));\n    }\n    MyHeapNode element = minHeap.peek();\n    while (k-- > 0) {\n      // Extract-Min\n      element = minHeap.poll();\n      int r = element.getRow(), c = element.getColumn();\n      // If we have any new elements in the current row, add them\n      if (c < N - 1) {\n        minHeap.offer(new MyHeapNode(matrix[r][c + 1], r, c + 1));\n      }\n    }\n    return element.getValue();\n  }\n}\n", "class Solution {\n  public int kthSmallest(int[][] matrix, int k) {\n    int n = matrix.length;\n    int start = matrix[0][0], end = matrix[n - 1][n - 1];\n    while (start < end) {\n      int mid = start + (end - start) / 2;\n      // first number is the smallest and the second number is the largest\n      int[] smallLargePair = {matrix[0][0], matrix[n - 1][n - 1]};\n      int count = this.countLessEqual(matrix, mid, smallLargePair);\n      if (count == k) return smallLargePair[0];\n      if (count < k) start = smallLargePair[1]; // search higher\n      else end = smallLargePair[0]; // search lower\n    }\n    return start;\n  }\n  private int countLessEqual(int[][] matrix, int mid, int[] smallLargePair) {\n    int count = 0;\n    int n = matrix.length, row = n - 1, col = 0;\n    while (row >= 0 && col < n) {\n      if (matrix[row][col] > mid) {\n        // as matrix[row][col] is bigger than the mid, let's keep track of the\n        // smallest number greater than the mid\n        smallLargePair[1] = Math.min(smallLargePair[1], matrix[row][col]);\n        row--;\n      } else {\n        // as matrix[row][col] is less than or equal to the mid, let's keep track of the\n        // biggest number less than or equal to the mid\n        smallLargePair[0] = Math.max(smallLargePair[0], matrix[row][col]);\n        count += row + 1;\n        col++;\n      }\n    }\n    return count;\n  }\n}\n"]}
{"number": 380, "statement": "Design a data structure that supports all following operations in average O(1) time.\ninsert(val): Inserts an item val to the set if not already present.\nremove(val): Removes an item val from the set if present.\ngetRandom: Returns a random element from current set of elements. Each element must have the same probability of being returned.\n", "solutions": ["/** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\npublic boolean insert(int val) {\n  if (dict.containsKey(val)) return false;\n    \n  dict.put(val, list.size());\n  list.add(list.size(), val);\n  return true;\n}\n", "/** Removes a value from the set. Returns true if the set contained the specified element. */\npublic boolean remove(int val) {\n  if (! dict.containsKey(val)) return false;\n  // move the last element to the place idx of the element to delete\n  int lastElement = list.get(list.size() - 1);\n  int idx = dict.get(val);\n  list.set(idx, lastElement);\n  dict.put(lastElement, idx);\n  // delete the last element\n  list.remove(list.size() - 1);\n  dict.remove(val);\n  return true;\n}\n", "/** Get a random element from the set. */\npublic int getRandom() {\n  return list.get(rand.nextInt(list.size()));\n}\n", "class RandomizedSet {\n  Map<Integer, Integer> dict;\n  List<Integer> list;\n  Random rand = new Random();\n  /** Initialize your data structure here. */\n  public RandomizedSet() {\n    dict = new HashMap();\n    list = new ArrayList();\n  }\n  /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\n  public boolean insert(int val) {\n    if (dict.containsKey(val)) return false;\n    dict.put(val, list.size());\n    list.add(list.size(), val);\n    return true;\n  }\n  /** Removes a value from the set. Returns true if the set contained the specified element. */\n  public boolean remove(int val) {\n    if (! dict.containsKey(val)) return false;\n    // move the last element to the place idx of the element to delete\n    int lastElement = list.get(list.size() - 1);\n    int idx = dict.get(val);\n    list.set(idx, lastElement);\n    dict.put(lastElement, idx);\n    // delete the last element\n    list.remove(list.size() - 1);\n    dict.remove(val);\n    return true;\n  }\n  /** Get a random element from the set. */\n  public int getRandom() {\n    return list.get(rand.nextInt(list.size()));\n  }\n}\n"]}
{"number": 381, "statement": "Design a data structure that supports all following operations in average O(1) time.\nNote: Duplicate elements are allowed.\ninsert(val): Inserts an item val to the collection.\nremove(val): Removes an item val from the collection if present.\ngetRandom: Returns a random element from current collection of elements. The probability of each element being returned is linearly related to the number of same value the collection contains.\n", "solutions": ["public class RandomizedCollection {\n    ArrayList<Integer> lst;\n    HashMap<Integer, Set<Integer>> idx;\n    java.util.Random rand = new java.util.Random();\n    /** Initialize your data structure here. */\n    public RandomizedCollection() {\n        lst = new ArrayList<Integer>();\n          idx = new HashMap<Integer, Set<Integer>>();\n    }\n    /** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */\n    public boolean insert(int val) {\n        if (!idx.containsKey(val)) idx.put(val, new LinkedHashSet<Integer>());\n        idx.get(val).add(lst.size());\n        lst.add(val);\n        return idx.get(val).size() == 1;\n    }\n    /** Removes a value from the collection. Returns true if the collection contained the specified element. */\n    public boolean remove(int val) {\n        if (!idx.containsKey(val) || idx.get(val).size() == 0) return false;\n          int remove_idx = idx.get(val).iterator().next();\n        idx.get(val).remove(remove_idx);\n        int last = lst.get(lst.size() - 1);\n        lst.set(remove_idx, last);\n        idx.get(last).add(remove_idx);\n        idx.get(last).remove(lst.size() - 1);\n          lst.remove(lst.size() - 1);\n        return true;\n    }\n    /** Get a random element from the collection. */\n    public int getRandom() {\n        return lst.get(rand.nextInt(lst.size()));\n    }\n}\n"]}
{"number": 383, "statement": "Given an arbitrary ransom note string and another string containing letters from all the magazines, write a function that will return true if the ransom note can be constructed from the magazines ; otherwise, it will return false.\nEach letter in the magazine string can only be used once in your ransom note.\n", "solutions": ["public boolean canConstruct(String ransomNote, String magazine) {\n    // For each character, c,  in the ransom note.\n    for (char c : ransomNote.toCharArray()) {\n        // Find the index of the first occurrence of c in the magazine.\n        int index = magazine.indexOf(c);\n        // If there are none of c left in the String, return False.\n        if (index == -1) {\n            return false;\n        }\n        // Use substring to make a new string with the characters \n        // before \"index\" (but not including), and the characters \n        // after \"index\". \n        magazine = magazine.substring(0, index) + magazine.substring(index + 1);\n    }\n    // If we got this far, we can successfully build the note.\n    return true;\n}\n", "class Solution {\n    \n    // Takes a String, and returns a HashMap with counts of\n    // each character.\n    private Map<Character, Integer> makeCountsMap(String s) {\n        Map<Character, Integer> counts = new HashMap<>();\n        for (char c : s.toCharArray()) {\n            int currentCount = counts.getOrDefault(c, 0);\n            counts.put(c, currentCount + 1);\n        }\n        return counts;\n    }\n    \n    \n    public boolean canConstruct(String ransomNote, String magazine) {\n        \n        // Check for obvious fail case.\n        if (ransomNote.length() > magazine.length()) {\n            return false;\n        }\n        // Make the count maps.\n        Map<Character, Integer> ransomNoteCounts = makeCountsMap(ransomNote);\n        Map<Character, Integer> magazineCounts = makeCountsMap(magazine);\n        \n        // For each unique character, c, in the ransom note:\n        for (char c : ransomNoteCounts.keySet()) {\n            // Check that the count of char in the magazine is equal\n            // or higher than the count in the ransom note.\n            int countInMagazine = magazineCounts.getOrDefault(c, 0);\n            int countInRansomNote = ransomNoteCounts.get(c);\n            if (countInMagazine < countInRansomNote) {\n                return false;\n            }\n        }\n        \n        // If we got this far, we can successfully build the note.\n        return true;\n    }\n}\n", "class Solution {\n    \n    // Takes a String, and returns a HashMap with counts of\n    // each character.\n    private Map<Character, Integer> makeCountsMap(String s) {\n        Map<Character, Integer> counts = new HashMap<>();\n        for (char c : s.toCharArray()) {\n            int currentCount = counts.getOrDefault(c, 0);\n            counts.put(c, currentCount + 1);\n        }\n        return counts;\n    }\n    \n    \n    public boolean canConstruct(String ransomNote, String magazine) {\n        \n        // Check for obvious fail case.\n        if (ransomNote.length() > magazine.length()) {\n            return false;\n        }\n        // Make a counts map for the magazine.\n        Map<Character, Integer> magazineCounts = makeCountsMap(magazine);\n        \n        // For each character in the ransom note:\n        for (char c : ransomNote.toCharArray()) {\n            // Get the current count for c in the magazine.\n            int countInMagazine = magazineCounts.getOrDefault(c, 0);\n            // If there are none of c left, return false.\n            if (countInMagazine == 0) {\n                return false;\n            }\n            // Put the updated count for c back into magazineCounts.\n            magazineCounts.put(c, countInMagazine - 1);\n        }\n        \n        // If we got this far, we can successfully build the note.\n        return true;\n    }\n}\n", "class Solution {\n    \n    // Please, if there's a nicer way of doing this, without getting tangled in\n    // primitives vs Java's generics let me know in the article comments :-)\n    private Stack<Character> sortedCharacterStack(String s) {\n        char[] charArray = s.toCharArray();\n        Arrays.sort(charArray);\n        Stack<Character> stack = new Stack<>();\n        for (int i = s.length() - 1; i >= 0; i--) {\n            stack.push(charArray[i]);\n        }\n        return stack;\n    }\n    \n    \n    public boolean canConstruct(String ransomNote, String magazine) {\n        \n        // Check for obvious fail case.\n        if (ransomNote.length() > magazine.length()) {\n            return false;\n        }\n        \n        // Reverse sort the characters of the note and magazine, and then\n        // put them into stacks.\n        Stack<Character> magazineStack = sortedCharacterStack(magazine);\n        Stack<Character> ransomNoteStack = sortedCharacterStack(ransomNote);\n        \n        // And now process the stacks, while both have letters remaining.\n        while (!magazineStack.isEmpty() && !ransomNoteStack.isEmpty()) {\n            // If the tops are the same, pop both because we have found a match.\n            if (magazineStack.peek().equals(ransomNoteStack.peek())) {\n                ransomNoteStack.pop();\n                magazineStack.pop();\n            } \n            // If magazine's top is earlier in the alphabet, we should remove that \n            // character of magazine as we definitely won't need that letter.\n            else if (magazineStack.peek() < ransomNoteStack.peek()) {\n                magazineStack.pop();\n            }\n            // Otherwise, it's impossible for top of ransomNote to be in magazine.\n            else {\n                return false;\n            }\n        }\n                \n        // Return true iff the entire ransomNote was built.\n        return ransomNoteStack.isEmpty();\n        \n    }\n}\n"]}
{"number": 384, "statement": "Shuffle a set of numbers without duplicates.\n", "solutions": ["class Solution {\n    private int[] array;\n    private int[] original;\n    private Random rand = new Random();\n    private List<Integer> getArrayCopy() {\n        List<Integer> asList = new ArrayList<Integer>();\n        for (int i = 0; i < array.length; i++) {\n            asList.add(array[i]);\n        }\n        return asList;\n    }\n    public Solution(int[] nums) {\n        array = nums;\n        original = nums.clone();\n    }\n    \n    public int[] reset() {\n        array = original;\n        original = original.clone();\n        return array;\n    }\n    \n    public int[] shuffle() {\n        List<Integer> aux = getArrayCopy();\n        for (int i = 0; i < array.length; i++) {\n            int removeIdx = rand.nextInt(aux.size());\n            array[i] = aux.get(removeIdx);\n            aux.remove(removeIdx);\n        }\n        return array;\n    }\n}\n", "class Solution {\n    private int[] array;\n    private int[] original;\n    Random rand = new Random();\n    private int randRange(int min, int max) {\n        return rand.nextInt(max - min) + min;\n    }\n    private void swapAt(int i, int j) {\n        int temp = array[i];\n        array[i] = array[j];\n        array[j] = temp;\n    }\n    public Solution(int[] nums) {\n        array = nums;\n        original = nums.clone();\n    }\n    \n    public int[] reset() {\n        array = original;\n        original = original.clone();\n        return original;\n    }\n    \n    public int[] shuffle() {\n        for (int i = 0; i < array.length; i++) {\n            swapAt(i, randRange(i, array.length));\n        }\n        return array;\n    }\n}\n"]}
{"number": 387, "statement": "Given a string, find the first non-repeating character in it and return it's index. If it doesn't exist, return -1.\n", "solutions": ["class Solution {\n    public int firstUniqChar(String s) {\n        HashMap<Character, Integer> count = new HashMap<Character, Integer>();\n        int n = s.length();\n        // build hash map : character and how often it appears\n        for (int i = 0; i < n; i++) {\n            char c = s.charAt(i);\n            count.put(c, count.getOrDefault(c, 0) + 1);\n        }\n        \n        // find the index\n        for (int i = 0; i < n; i++) {\n            if (count.get(s.charAt(i)) == 1) \n                return i;\n        }\n        return -1;\n    }\n}\n"]}
{"number": 389, "statement": "Given two strings s and t which consist of only lowercase letters.\nString t is generated by random shuffling string s and then add one more letter at a random position.\nFind the letter that was added in t.\n", "solutions": ["class Solution {\n    public char findTheDifference(String s, String t) {\n        // Sort both the strings\n        char[] sortedS = s.toCharArray();\n        char[] sortedT = t.toCharArray();\n        Arrays.sort(sortedS);\n        Arrays.sort(sortedT);\n        // Character by character comparison\n        int i = 0;\n        while (i < s.length()) {\n            if (sortedS[i] != sortedT[i]) {\n                return sortedT[i];\n            }\n            i += 1;\n        }\n        return sortedT[i];\n    }\n}\n", "class Solution {\n    public char findTheDifference(String s, String t) {\n        char extraChar = '\\0';\n        // Prepare a counter for string s.\n        // This hash map holds the characters as keys and respective frequency as value.\n        HashMap <Character,Integer> counterS = new HashMap <>();\n        for (int i = 0; i < s.length(); i++) {\n            char ch = s.charAt(i);\n            counterS.put(ch, counterS.getOrDefault(ch, 0) + 1);\n        }\n        // Iterate through string t and find the character which is not in s.\n        for (int i = 0; i < t.length(); i += 1) {\n            char ch = t.charAt(i);\n            int countOfChar = counterS.getOrDefault(ch, 0);\n            if (countOfChar == 0) {\n                extraChar = ch;\n                break;\n            } else {\n                // Once a match is found we reduce frequency left.\n                // This eliminates the possibility of a false match later.\n                counterS.put(ch, countOfChar - 1);\n            }\n        }\n        return extraChar;\n    }\n}\n", "class Solution {\n    public char findTheDifference(String s, String t) {\n        // Initialize ch with 0, because 0 ^ X = X\n        // 0 when XORed with any bit would not change the bits value.\n        char ch = 0;\n        // XOR all the characters of both s and t.\n        for (int i = 0; i < s.length(); i += 1) {\n            ch ^= s.charAt(i);\n        }\n        for (int i = 0; i < t.length(); i += 1) {\n            ch ^= t.charAt(i);\n        }\n        // What is left after XORing everything is the difference.\n        return ch;\n    }\n}\n"]}
{"number": 393, "statement": "A character in UTF8 can be from 1 to 4 bytes long, subjected to the following rules:\nFor 1-byte character, the first bit is a 0, followed by its unicode code.\nFor n-bytes character, the first n-bits are all one's, the n+1 bit is 0, followed by n-1 bytes with most significant 2 bits being 10.\nThis is how the UTF-8 encoding would work:\n   Char. number range  |        UTF-8 octet sequence\n      (hexadecimal)    |              (binary)\n   --------------------+---------------------------------------------\n   0000 0000-0000 007F | 0xxxxxxx\n   0000 0080-0000 07FF | 110xxxxx 10xxxxxx\n   0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx\n   0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\nGiven an array of integers representing the data, return whether it is a valid utf-8 encoding.\nNote:\nThe input is an array of integers. Only the least significant 8 bits of each integer is used to store the data. This means each integer represents only 1 byte of data.\n", "solutions": ["class Solution {\n  public boolean validUtf8(int[] data) {\n    // Number of bytes in the current UTF-8 character\n    int numberOfBytesToProcess = 0;\n    // For each integer in the data array.\n    for (int i = 0; i < data.length; i++) {\n      // Get the binary representation. We only need the least significant 8 bits\n      // for any given number.\n      String binRep = Integer.toBinaryString(data[i]);\n      binRep =\n          binRep.length() >= 8\n              ? binRep.substring(binRep.length() - 8)\n              : \"00000000\".substring(binRep.length() % 8) + binRep;\n      // If this is the case then we are to start processing a new UTF-8 character.\n      if (numberOfBytesToProcess == 0) {\n        // Get the number of 1s in the beginning of the string.\n        for (int j = 0; j < binRep.length(); j++) {\n          if (binRep.charAt(j) == '0') {\n            break;\n          }\n          numberOfBytesToProcess += 1;\n        }\n        // 1 byte characters\n        if (numberOfBytesToProcess == 0) {\n          continue;\n        }\n        // Invalid scenarios according to the rules of the problem.\n        if (numberOfBytesToProcess > 4 || numberOfBytesToProcess == 1) {\n          return false;\n        }\n      } else {\n        // Else, we are processing integers which represent bytes which are a part of\n        // a UTF-8 character. So, they must adhere to the pattern `10xxxxxx`.\n        if (!(binRep.charAt(0) == '1' && binRep.charAt(1) == '0')) {\n          return false;\n        }\n      }\n      // We reduce the number of bytes to process by 1 after each integer.\n      numberOfBytesToProcess -= 1;\n    }\n    // This is for the case where we might not have the complete data for\n    // a particular UTF-8 character.\n    return numberOfBytesToProcess == 0;\n  }\n}\n", "class Solution {\n    public boolean validUtf8(int[] data) {\n        // Number of bytes in the current UTF-8 character\n        int numberOfBytesToProcess = 0;\n        // Masks to check two most significant bits in a byte.\n        int mask1 = 1 << 7;\n        int mask2 = 1 << 6;\n        // For each integer in the data array.\n        for(int i = 0; i < data.length; i++) {\n            // If this is the case then we are to start processing a new UTF-8 character.\n            if (numberOfBytesToProcess == 0) {\n                int mask = 1 << 7;\n                 while ((mask & data[i]) != 0) {\n                    numberOfBytesToProcess += 1;\n                    mask = mask >> 1;\n                 }\n                // 1 byte characters\n                if (numberOfBytesToProcess == 0) {\n                    continue;\n                }\n                // Invalid scenarios according to the rules of the problem.\n                if (numberOfBytesToProcess > 4 || numberOfBytesToProcess == 1) {\n                    return false;\n                }\n            } else {\n                // data[i] should have most significant bit set and\n                // second most significant bit unset. So, we use the two masks\n                // to make sure this is the case.\n                if (!((data[i] & mask1) != 0 && (mask2 & data[i]) == 0)) {\n                    return false;\n                }\n            }\n            // We reduce the number of bytes to process by 1 after each integer.\n            numberOfBytesToProcess -= 1;\n        }\n        // This is for the case where we might not have the complete data for\n        // a particular UTF-8 character.\n        return numberOfBytesToProcess == 0;\n    }\n}\n"]}
{"number": 402, "statement": "Given a non-negative integer num represented as a string, remove k digits from the number so that the new number is the smallest possible.\nNote:\nThe length of num is less than 10002 and will be \u2265 k.\nThe given num does not contain any leading zero.\n", "solutions": ["class Solution {\n  public String removeKdigits(String num, int k) {\n    LinkedList<Character> stack = new LinkedList<Character>();\n        \n    for(char digit : num.toCharArray()) {\n      while(stack.size() > 0 && k > 0 && stack.peekLast() > digit) {\n        stack.removeLast();\n        k -= 1;\n      }\n      stack.addLast(digit);\n    }\n        \n    /* remove the remaining digits from the tail. */\n    for(int i=0; i<k; ++i) {\n      stack.removeLast();\n    }\n        \n    // build the final string, while removing the leading zeros.\n    StringBuilder ret = new StringBuilder();\n    boolean leadingZero = true;\n    for(char digit: stack) {\n      if(leadingZero && digit == '0') continue;\n      leadingZero = false;\n      ret.append(digit);\n    }\n        \n    /* return the final string  */\n    if (ret.length() == 0) return \"0\";\n    return ret.toString();\n  }\n}\n"]}
{"number": 403, "statement": "A frog is crossing a river. The river is divided into x units and at each unit there may or may not exist a stone. The frog can jump on a stone, but it must not jump into the water.\nGiven a list of stones' positions (in units) in sorted ascending order, determine if the frog is able to cross the river by landing on the last stone. Initially, the frog is on the first stone and assume the first jump must be 1 unit.\nIf the frog's last jump was k units, then its next jump must be either k - 1, k, or k + 1 units. Note that the frog can only jump in the forward direction.\nNote:\nThe number of stones is \u2265 2 and is  1,100.\nEach stone's position will be a non-negative integer  231.\nThe first stone's position is always 0.\n", "solutions": ["public class Solution {\n    public boolean canCross(int[] stones) {\n        return can_Cross(stones, 0, 0);\n    }\n    public boolean can_Cross(int[] stones, int ind, int jumpsize) {\n        for (int i = ind + 1; i < stones.length; i++) {\n            int gap = stones[i] - stones[ind];\n            if (gap >= jumpsize - 1 && gap <= jumpsize + 1) {\n                if (can_Cross(stones, i, gap)) {\n                    return true;\n                }\n            }\n        }\n        return ind == stones.length - 1;\n    }\n}\n", "public class Solution {\n    public boolean canCross(int[] stones) {\n        return can_Cross(stones, 0, 0);\n    }\n    public boolean can_Cross(int[] stones, int ind, int jumpsize) {\n        if (ind == stones.length - 1) {\n            return true;\n        }\n        int ind1 = Arrays.binarySearch(stones, ind + 1, stones.length, stones[ind] + jumpsize);\n        if (ind1 >= 0 && can_Cross(stones, ind1, jumpsize)) {\n            return true;\n        }\n        int ind2 = Arrays.binarySearch(stones, ind + 1, stones.length, stones[ind] + jumpsize - 1);\n        if (ind2 >= 0 && can_Cross(stones, ind2, jumpsize - 1)) {\n            return true;\n        }\n        int ind3 = Arrays.binarySearch(stones, ind + 1, stones.length, stones[ind] + jumpsize + 1);\n        if (ind3 >= 0 && can_Cross(stones, ind3, jumpsize + 1)) {\n            return true;\n        }\n        return false;\n    }\n}\n", "public class Solution {\n    public boolean canCross(int[] stones) {\n        int[][] memo = new int[stones.length][stones.length];\n        for (int[] row : memo) {\n            Arrays.fill(row, -1);\n        }\n        return can_Cross(stones, 0, 0, memo) == 1;\n    }\n    public int can_Cross(int[] stones, int ind, int jumpsize, int[][] memo) {\n        if (memo[ind][jumpsize] >= 0) {\n            return memo[ind][jumpsize];\n        }\n        for (int i = ind + 1; i < stones.length; i++) {\n            int gap = stones[i] - stones[ind];\n            if (gap >= jumpsize - 1 && gap <= jumpsize + 1) {\n                if (can_Cross(stones, i, gap, memo) == 1) {\n                    memo[ind][gap] = 1;\n                    return 1;\n                }\n            }\n        }\n        memo[ind][jumpsize] = (ind == stones.length - 1) ? 1 : 0;\n        return memo[ind][jumpsize];\n    }\n}\n", "public class Solution {\n    public boolean canCross(int[] stones) {\n        int[][] memo = new int[stones.length][stones.length];\n        for (int[] row : memo) {\n            Arrays.fill(row, -1);\n        }\n        return can_Cross(stones, 0, 0, memo) == 1;\n    }\n    public int can_Cross(int[] stones, int ind, int jumpsize, int[][] memo) {\n        if (memo[ind][jumpsize] >= 0) {\n            return memo[ind][jumpsize];\n        }\n        int ind1 = Arrays.binarySearch(stones, ind + 1, stones.length, stones[ind] + jumpsize);\n        if (ind1 >= 0 && can_Cross(stones, ind1, jumpsize, memo) == 1) {\n            memo[ind][jumpsize] = 1;\n            return 1;\n        }\n        int ind2 = Arrays.binarySearch(stones, ind + 1, stones.length, stones[ind] + jumpsize - 1);\n        if (ind2 >= 0 && can_Cross(stones, ind2, jumpsize - 1, memo) == 1) {\n            memo[ind][jumpsize - 1] = 1;\n            return 1;\n        }\n        int ind3 = Arrays.binarySearch(stones, ind + 1, stones.length, stones[ind] + jumpsize + 1);\n        if (ind3 >= 0 && can_Cross(stones, ind3, jumpsize + 1, memo) == 1) {\n            memo[ind][jumpsize + 1] = 1;\n            return 1;\n        }\n        memo[ind][jumpsize] = ((ind == stones.length - 1) ? 1 : 0);\n        return memo[ind][jumpsize];\n    }\n}\n", "public class Solution {\n    public boolean canCross(int[] stones) {\n        HashMap<Integer, Set<Integer>> map = new HashMap<>();\n        for (int i = 0; i < stones.length; i++) {\n            map.put(stones[i], new HashSet<Integer>());\n        }\n        map.get(0).add(0);\n        for (int i = 0; i < stones.length; i++) {\n            for (int k : map.get(stones[i])) {\n                for (int step = k - 1; step <= k + 1; step++) {\n                    if (step > 0 && map.containsKey(stones[i] + step)) {\n                        map.get(stones[i] + step).add(step);\n                    }\n                }\n            }\n        }\n        return map.get(stones[stones.length - 1]).size() > 0;\n    }\n}\n"]}
{"number": 404, "statement": "Find the sum of all left leaves in a given binary tree.\n", "solutions": ["class Solution { \n    \n  private boolean isLeaf(TreeNode node) {\n    return node != null && node.left == null && node.right == null;\n  }\n  public int sumOfLeftLeaves(TreeNode root) {\n    if (root == null) {\n      return 0;\n    }\n    int total = 0;\n    Deque<TreeNode> stack = new ArrayDeque<>();\n    stack.push(root);\n    while (!stack.isEmpty()) {\n      TreeNode subRoot = stack.pop();\n      // Check if the left node is a leaf node.\n      if (isLeaf(subRoot.left)) {\n        total += subRoot.left.val;\n      }\n      // If the right node exists, put it on the stack.\n      if (subRoot.right != null) {    \n        stack.push(subRoot.right);\n      }\n      // If the left node exists, put it on the stack.\n      if (subRoot.left != null) {\n        stack.push(subRoot.left);\n      }\n    }\n    return total;\n  }\n}\n", "class Solution { \n    \n  public int sumOfLeftLeaves(TreeNode root) {\n    if (root == null) {\n      return 0;\n    }\n    return processSubtree(root, false);\n  }\n    \n  private int processSubtree(TreeNode subtree, boolean isLeft) {\n        \n    // Base case: This is a leaf node.\n    if (subtree.left == null && subtree.right == null) {\n      return isLeft ? subtree.val : 0;\n    }\n        \n    // Recursive case: We need to add and return the results of the\n    // left and right subtrees.\n    int total = 0;\n    if (subtree.left != null) {\n      total += processSubtree(subtree.left, true);\n    }\n    if (subtree.right != null) {\n      total += processSubtree(subtree.right, false);\n    }\n    return total;\n  }\n}\n", "class Solution { \n    \n  public int sumOfLeftLeaves(TreeNode root) {\n    return processSubtree(root, false);\n  }\n    \n  private int processSubtree(TreeNode subtree, boolean isLeft) {\n    \n    // Base case: This is an empty subtree.\n    if (subtree == null) {\n      return 0;\n    }\n    \n    // Base case: This is a leaf node.\n    if (subtree.left == null && subtree.right == null) {\n      return isLeft ? subtree.val : 0;\n    }\n    \n    // Recursive case: We need to add and return the results of the\n    // left and right subtrees.\n    return processSubtree(subtree.left, true) + processSubtree(subtree.right, false);\n  }\n}\n", "class Solution {\n  public int sumOfLeftLeaves(TreeNode root) {\n    int totalSum = 0;\n    TreeNode currentNode = root;\n    while (currentNode != null) {\n      // If there is no left child, we can simply explore the right subtree\n      // without needing to worry about keeping track of currentNode's other\n      // child.\n      if (currentNode.left == null) {\n        currentNode = currentNode.right;\n      } else {\n        TreeNode previous = currentNode.left;\n        // Check if this left node is a leaf node.\n        if (previous.left == null && previous.right == null) {\n          totalSum += previous.val;\n        }\n        // Find the inorder predecessor for currentNode.\n        while (previous.right != null && !previous.right.equals(currentNode)) {\n          previous = previous.right;\n        }\n        // We've not yet visited the inorder predecessor. This means that we \n        // still need to explore currentNode's left subtree. Before doing this,\n        // we will put a link back so that we can get back to the right subtree\n        // when we need to.\n        if (previous.right == null) {\n          previous.right = currentNode;\n          currentNode = currentNode.left;\n        }\n        // We have already visited the inorder predecessor. This means that we\n        // need to remove the link we added, and then move onto the right\n        // subtree and explore it.\n        else {\n          previous.right = null;\n          currentNode = currentNode.right;\n        }\n      }\n    }\n    return totalSum;\n  }\n}\n"]}
{"number": 406, "statement": "Suppose you have a random list of people standing in a queue. Each person is described by a pair of integers (h, k), where h is the height of the person and k is the number of people in front of this person who have a height greater than or equal to h. Write an algorithm to reconstruct the queue.\nNote:\nThe number of people is less than 1,100.\n", "solutions": ["class Solution {\n  public int[][] reconstructQueue(int[][] people) {\n    Arrays.sort(people, new Comparator<int[]>() {\n      @Override\n      public int compare(int[] o1, int[] o2) {\n        // if the heights are equal, compare k-values\n        return o1[0] == o2[0] ? o1[1] - o2[1] : o2[0] - o1[0];\n      }\n    });\n    List<int[]> output = new LinkedList<>();\n    for(int[] p : people){\n      output.add(p[1], p);\n    }\n    int n = people.length;\n    return output.toArray(new int[n][2]);\n  }\n}\n"]}
{"number": 409, "statement": "Given a string which consists of lowercase or uppercase letters, find the length of the longest palindromes that can be built with those letters.\nThis is case sensitive, for example \"Aa\" is not considered a palindrome here.\nNote:\nAssume the length of given string will not exceed 1,010.\n", "solutions": ["class Solution {\n    public int longestPalindrome(String s) {\n        int[] count = new int[128];\n        for (char c: s.toCharArray())\n            count[c]++;\n        int ans = 0;\n        for (int v: count) {\n            ans += v / 2 * 2;\n            if (ans % 2 == 0 && v % 2 == 1)\n                ans++;\n        }\n        return ans;\n    }\n}\n"]}
{"number": 410, "statement": "Given an array which consists of non-negative integers and an integer m, you can split the array into m non-empty continuous subarrays. Write an algorithm to minimize the largest sum among these m subarrays.\nNote:\nIf n is the length of array, assume the following constraints are satisfied:\n1 \u2264 n \u2264 1000\n1 \u2264 m \u2264 min(50, n)\n", "solutions": ["class Solution {\npublic:\n    int ans;\n    int n, m;\n    void dfs(vector<int>& nums, int i, int cntSubarrays, int curSum, int curMax) {\n        if (i == n && cntSubarrays == m) {\n            ans = min(ans, curMax);\n            return;\n        }\n        if (i == n) {\n            return;  \n        }\n        if (i > 0) {\n            dfs(nums, i + 1, cntSubarrays, curSum + nums[i], max(curMax, curSum + nums[i]));\n        }\n        if (cntSubarrays < m) {\n            dfs(nums, i + 1, cntSubarrays + 1, nums[i], max(curMax, nums[i]));\n        }\n    }\n    int splitArray(vector<int>& nums, int M) {\n        ans = INT_MAX;\n        n = nums.size();\n        m = M;\n        dfs(nums, 0, 0, 0, 0);\n        return ans;\n    }\n};\n", "class Solution {\npublic:\n    int splitArray(vector<int>& nums, int m) {\n        int n = nums.size();\n        vector<vector<int>> f(n + 1, vector<int>(m + 1, INT_MAX));\n        vector<int> sub(n + 1, 0);\n        for (int i = 0; i < n; i++) {\n            sub[i + 1] = sub[i] + nums[i];\n        }\n        f[0][0] = 0;\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= m; j++) {\n                for (int k = 0; k < i; k++) {\n                    f[i][j] = min(f[i][j], max(f[k][j - 1], sub[i] - sub[k]));\n                }\n            }\n        }\n        return f[n][m];\n    }\n};\n", "#define LL long long\nclass Solution {\npublic:\n    int splitArray(vector<int>& nums, int m) {\n        LL l = 0, r = 0;\n        int n = nums.size();\n        for (int i = 0; i < n; i++) {\n            r += nums[i];\n            if (l < nums[i]) {\n                l = nums[i];\n            }\n        }\n        LL ans =  r;\n        while (l <= r) {\n            LL mid = (l + r) >> 1;\n            LL sum = 0;\n            int cnt = 1;            \n            for (int i = 0; i < n; i++) {\n                if (sum + nums[i] > mid) {\n                    cnt ++;\n                    sum = nums[i];\n                } else {\n                    sum += nums[i];\n                }\n            }\n            if (cnt <= m) {\n                ans = min(ans, mid);\n                r = mid - 1;\n            } else {\n                l = mid + 1;\n            }\n        }\n        return ans;\n    }\n};\n"]}
{"number": 412, "statement": "Write a program that outputs the string representation of numbers from 1 to n.\nBut for multiples of three it should output \u201cFizz\u201d instead of the number and for the multiples of five output \u201cBuzz\u201d. For numbers which are multiples of both three and five output \u201cFizzBuzz\u201d.\n", "solutions": ["class Solution {\n  public List<String> fizzBuzz(int n) {\n    // ans list\n    List<String> ans = new ArrayList<String>();\n    for (int num = 1; num <= n; num++) {\n      boolean divisibleBy3 = (num % 3 == 0);\n      boolean divisibleBy5 = (num % 5 == 0);\n      if (divisibleBy3 && divisibleBy5) {\n        // Divides by both 3 and 5, add FizzBuzz\n        ans.add(\"FizzBuzz\");\n      } else if (divisibleBy3) {\n        // Divides by 3, add Fizz\n        ans.add(\"Fizz\");\n      } else if (divisibleBy5) {\n        // Divides by 5, add Buzz\n        ans.add(\"Buzz\");\n      } else {\n        // Not divisible by 3 or 5, add the number\n        ans.add(Integer.toString(num));\n      }\n    }\n    return ans;\n  }\n}\n", "class Solution {\n  public List<String> fizzBuzz(int n) {\n    // ans list\n    List<String> ans = new ArrayList<String>();\n    for (int num = 1; num <= n; num++) {\n      boolean divisibleBy3 = (num % 3 == 0);\n      boolean divisibleBy5 = (num % 5 == 0);\n      String numAnsStr = \"\";\n      if (divisibleBy3) {\n        // Divides by 3, add Fizz\n        numAnsStr += \"Fizz\";\n      }\n      if (divisibleBy5) {\n        // Divides by 5, add Buzz\n        numAnsStr += \"Buzz\";\n      }\n      if (numAnsStr.equals(\"\")) {\n        // Not divisible by 3 or 5, add the number\n        numAnsStr += Integer.toString(num);\n      }\n      // Append the current answer str to the ans list\n      ans.add(numAnsStr);\n    }\n    return ans;\n  }\n}\n", "class Solution {\n  public List<String> fizzBuzz(int n) {\n    // ans list\n    List<String> ans = new ArrayList<String>();\n    // Hash map to store all fizzbuzz mappings.\n    HashMap<Integer, String> fizzBizzDict =\n        new HashMap<Integer, String>() {\n          {\n            put(3, \"Fizz\");\n            put(5, \"Buzz\");\n          }\n        };\n    for (int num = 1; num <= n; num++) {\n      String numAnsStr = \"\";\n      for (Integer key : fizzBizzDict.keySet()) {\n        // If the num is divisible by key,\n        // then add the corresponding string mapping to current numAnsStr\n        if (num % key == 0) {\n          numAnsStr += fizzBizzDict.get(key);\n        }\n      }\n      if (numAnsStr.equals(\"\")) {\n        // Not divisible by 3 or 5, add the number\n        numAnsStr += Integer.toString(num);\n      }\n      // Append the current answer str to the ans list\n      ans.add(numAnsStr);\n    }\n    return ans;\n  }\n}\n"]}
{"number": 413, "statement": "A sequence of number is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.\nFor example, these are arithmetic sequence:\n1, 3, 5, 7, 9\n7, 7, 7, 7\n3, -1, -5, -9\nThe following sequence is not arithmetic. 1, 1, 2, 5, 7 \nA zero-indexed array A consisting of N numbers is given. A slice of that array is any pair of integers (P, Q) such that 0 = P  Q  N.\nA slice (P, Q) of array A is called arithmetic if the sequence:\n    A[P], A[p + 1], ..., A[Q - 1], A[Q] is arithmetic. In particular, this means that P + 1  Q.\nThe function should return the number of arithmetic slices in the array A. \n", "solutions": ["public class Solution {\n    public int numberOfArithmeticSlices(int[] A) {\n        int count = 0;\n        for (int s = 0; s < A.length - 2; s++) {\n            int d = A[s + 1] - A[s];\n            for (int e = s + 2; e < A.length; e++) {\n                int i = 0;\n                for (i = s + 1; i <= e; i++)\n                    if (A[i] - A[i - 1] != d)\n                        break;\n                if (i > e)\n                    count++;\n            }\n        }\n        return count;\n    }\n}\n", "public class Solution {\n    public int numberOfArithmeticSlices(int[] A) {\n        int count = 0;\n        for (int s = 0; s < A.length - 2; s++) {\n            int d = A[s + 1] - A[s];\n            for (int e = s + 2; e < A.length; e++) {\n                if (A[e] - A[e - 1] == d)\n                    count++;\n                else\n                    break;\n            }\n        }\n        return count;\n    }\n}\n", "public class Solution {\n    int sum = 0;\n    public int numberOfArithmeticSlices(int[] A) {\n        slices(A, A.length - 1);\n        return sum;\n    }\n    public int slices(int[] A, int i) {\n        if (i < 2)\n            return 0;\n        int ap = 0;\n        if (A[i] - A[i - 1] == A[i - 1] - A[i - 2]) {\n            ap = 1 + slices(A, i - 1);\n            sum += ap;\n        } else\n            slices(A, i - 1);\n        return ap;\n    }\n}\n", "public class Solution {\n    public int numberOfArithmeticSlices(int[] A) {\n        int[] dp = new int[A.length];\n        int sum = 0;\n        for (int i = 2; i < dp.length; i++) {\n            if (A[i] - A[i - 1] == A[i - 1] - A[i - 2]) {\n                dp[i] = 1 + dp[i - 1];\n                sum += dp[i];\n            }\n        }\n        return sum;\n    }\n}\n", "public class Solution {\n    public int numberOfArithmeticSlices(int[] A) {\n        int dp = 0;\n        int sum = 0;\n        for (int i = 2; i < A.length; i++) {\n            if (A[i] - A[i - 1] == A[i - 1] - A[i - 2]) {\n                dp = 1 + dp;\n                sum += dp;\n            } else\n                dp = 0;\n        }\n        return sum;\n    }\n}\n", "public class Solution {\n    public int numberOfArithmeticSlices(int[] A) {\n        int count = 0;\n        int sum = 0;\n        for (int i = 2; i < A.length; i++) {\n            if (A[i] - A[i - 1] == A[i - 1] - A[i - 2]) {\n                count++;\n            } else {\n                sum += (count + 1) * (count) / 2;\n                count = 0;\n            }\n        }\n        return sum += count * (count + 1) / 2;\n    }\n}\n"]}
{"number": 414, "statement": "Given a non-empty array of integers, return the third maximum number in this array. If it does not exist, return the maximum number. The time complexity must be in O(n).\n", "solutions": ["public int thirdMax(int[] nums) {\n    // Put the input integers into a HashSet.\n    Set<Integer> setNums = new HashSet<>();\n    for (int num : nums) setNums.add(num);\n    // Find the maximum.\n    int maximum = Collections.max(setNums);\n    // Check whether or not this is a case where we\n    // need to return the *maximum*.\n    if (setNums.size() < 3) {\n        return maximum;\n    }\n    // Otherwise, continue on to finding the third maximum.\n    setNums.remove(maximum);\n    int secondMaximum = Collections.max(setNums);\n    setNums.remove(secondMaximum);\n    return Collections.max(setNums);\n}\n", "class Solution {\n    public int thirdMax(int[] nums) {    \n        Set<Integer> seenMaximums = new HashSet<>();\n        \n        for (int i = 0; i < 3; i++) {\n            Integer curMaximum = maxIgnoringSeenMaximums(nums, seenMaximums);\n            if (curMaximum == null) {\n                return Collections.max(seenMaximums);\n            }\n            seenMaximums.add(curMaximum);\n        }\n        return Collections.min(seenMaximums);\n    }\n    private Integer maxIgnoringSeenMaximums(int[] nums, Set<Integer> seenMaximums) {\n        \n        Integer maximum = null;\n        for (int num : nums) {\n            if (seenMaximums.contains(num)) {\n                continue;\n            }\n            if (maximum == null || num > maximum) {\n                maximum = num;\n            }\n        }\n        return maximum;\n    }\n}\n", "public int thirdMax(int[] nums) {       \n    Set<Integer> maximums = new HashSet<Integer>();\n    for (int num : nums) {\n        maximums.add(num);\n        if (maximums.size() > 3) {\n            maximums.remove(Collections.min(maximums));\n        }\n    }\n    if (maximums.size() == 3) {\n        return Collections.min(maximums);\n    }\n    return Collections.max(maximums);\n}\n"]}
{"number": 421, "statement": "Given a non-empty array of numbers, a0, a1, a2, \u2026 , an-1, where 0 \u2264 ai  231.\nFind the maximum result of ai XOR aj, where 0 \u2264 i, j  n.\nCould you do this in O(n) runtime?\n", "solutions": ["class Solution {\n  public int findMaximumXOR(int[] nums) {\n    int maxNum = nums[0];\n    for(int num : nums) maxNum = Math.max(maxNum, num);\n    // length of max number in a binary representation\n    int L = (Integer.toBinaryString(maxNum)).length();\n    int maxXor = 0, currXor;\n    Set<Integer> prefixes = new HashSet<>();\n    for(int i = L - 1; i > -1; --i) {\n      // go to the next bit by the left shift\n      maxXor <<= 1;\n      // set 1 in the smallest bit\n      currXor = maxXor | 1;\n      prefixes.clear();\n      // compute all possible prefixes \n      // of length (L - i) in binary representation\n      for(int num: nums) prefixes.add(num >> i);\n      // Update maxXor, if two of these prefixes could result in currXor.\n      // Check if p1^p2 == currXor, i.e. p1 == currXor^p2.\n      for(int p: prefixes) {\n        if (prefixes.contains(currXor^p)) {\n          maxXor = currXor;\n          break;\n        }\n      }\n    }\n    return maxXor;\n  }\n}\n", "TrieNode trie = new TrieNode();\nfor (String num : strNums) {\n  TrieNode node = trie;\n  for (Character bit : num.toCharArray()) { \n    if (node.children.containsKey(bit)) {\n      node = node.children.get(bit);\n    } else {\n      TrieNode newNode = new TrieNode();\n      node.children.put(bit, newNode);\n      node = newNode;\n    }\n  }  \n}\n", "TrieNode trie = new TrieNode();\nfor (String num : strNums) {\n  TrieNode xorNode = trie;\n  int currXor = 0;\n  for (Character bit : num.toCharArray()) {\n    Character toggledBit = bit == '1' ? '0' : '1';\n    if (xorNode.children.containsKey(toggledBit)) {\n      currXor = (currXor << 1) | 1;\n      xorNode = xorNode.children.get(toggledBit);\n    } else {\n      currXor = currXor << 1;\n      xorNode = xorNode.children.get(bit);\n    }\n  }\n}\n", "class TrieNode {\n  HashMap<Character, TrieNode> children = new HashMap<Character, TrieNode>();\n  public TrieNode() {}\n}\nclass Solution {\n  public int findMaximumXOR(int[] nums) {\n    // Compute length L of max number in a binary representation\n    int maxNum = nums[0];\n    for(int num : nums) maxNum = Math.max(maxNum, num);\n    int L = (Integer.toBinaryString(maxNum)).length();\n    // zero left-padding to ensure L bits for each number\n    int n = nums.length, bitmask = 1 << L;\n    String [] strNums = new String[n];\n    for(int i = 0; i < n; ++i) {\n      strNums[i] = Integer.toBinaryString(bitmask | nums[i]).substring(1);\n    }\n    TrieNode trie = new TrieNode();\n    int maxXor = 0;\n    for (String num : strNums) {\n      TrieNode node = trie, xorNode = trie;\n      int currXor = 0;\n      for (Character bit : num.toCharArray()) {\n        // insert new number in trie  \n        if (node.children.containsKey(bit)) {\n          node = node.children.get(bit);\n        } else {\n          TrieNode newNode = new TrieNode();\n          node.children.put(bit, newNode);\n          node = newNode;\n        }\n        // compute max xor of that new number \n        // with all previously inserted\n        Character toggledBit = bit == '1' ? '0' : '1';\n        if (xorNode.children.containsKey(toggledBit)) {\n          currXor = (currXor << 1) | 1;\n          xorNode = xorNode.children.get(toggledBit);\n        } else {\n          currXor = currXor << 1;\n          xorNode = xorNode.children.get(bit);\n        }\n      }\n      maxXor = Math.max(maxXor, currXor);\n    }\n    return maxXor;\n  }\n}\n"]}
{"number": 423, "statement": "Given a non-empty string containing an out-of-order English representation of digits 0-9, output the digits in ascending order.\nNote:\nInput contains only lowercase English letters.\nInput is guaranteed to be valid and can be transformed to its original digits. That means invalid inputs such as \"abc\" or \"zerone\" are not permitted.\nInput length is less than 50,000.\n", "solutions": ["class Solution {\n  public String originalDigits(String s) {\n    // building hashmap letter -> its frequency\n    char[] count = new char[26 + (int)'a'];\n    for(char letter: s.toCharArray()) {\n      count[letter]++;\n    }\n    // building hashmap digit -> its frequency\n    int[] out = new int[10];\n    // letter \"z\" is present only in \"zero\"\n    out[0] = count['z'];\n    // letter \"w\" is present only in \"two\"\n    out[2] = count['w'];\n    // letter \"u\" is present only in \"four\"\n    out[4] = count['u'];\n    // letter \"x\" is present only in \"six\"\n    out[6] = count['x'];\n    // letter \"g\" is present only in \"eight\"\n    out[8] = count['g'];\n    // letter \"h\" is present only in \"three\" and \"eight\"\n    out[3] = count['h'] - out[8];\n    // letter \"f\" is present only in \"five\" and \"four\"\n    out[5] = count['f'] - out[4];\n    // letter \"s\" is present only in \"seven\" and \"six\"\n    out[7] = count['s'] - out[6];\n    // letter \"i\" is present in \"nine\", \"five\", \"six\", and \"eight\"\n    out[9] = count['i'] - out[5] - out[6] - out[8];\n    // letter \"n\" is present in \"one\", \"nine\", and \"seven\"\n    out[1] = count['n'] - out[7] - 2 * out[9];\n    // building output string\n    StringBuilder output = new StringBuilder();\n    for(int i = 0; i < 10; i++)\n      for (int j = 0; j < out[i]; j++)\n        output.append(i);\n    return output.toString();\n  }\n}\n"]}
{"number": 425, "statement": "Given a set of words (without duplicates), find all word squares you can build from them.\nA sequence of words forms a valid word square if the kth row and column read the exact same string, where 0 \u2264 k  max(numRows, numColumns).\nFor example, the word sequence [\"ball\",\"area\",\"lead\",\"lady\"] forms a word square because each word reads the same both horizontally and vertically.\nb a l l\na r e a\nl e a d\nl a d y\nNote:\nThere are at least 1 and at most 1000 words.\nAll words will have the exact same length.\nWord length is at least 1 and at most 5.\nEach word contains only lowercase English alphabet a-z.\n", "solutions": ["class Solution:\n    def wordSquares(self, words: List[str]) -> List[List[str]]:\n        self.words = words\n        self.N = len(words[0])\n        results = []\n        word_squares = []\n        for word in words:\n            # try with every word as the starting word\n            word_squares = [word]\n            self.backtracking(1, word_squares, results)\n        return results\n    def backtracking(self, step, word_squares, results):\n        if step == self.N:\n            results.append(word_squares[:])\n            return\n        prefix = ''.join([word[step] for word in word_squares])\n        # find out all words that start with the given prefix        \n        for candidate in self.getWordsWithPrefix(prefix):\n            # iterate row by row\n            word_squares.append(candidate)\n            self.backtracking(step+1, word_squares, results)\n            word_squares.pop()\n    def getWordsWithPrefix(self, prefix):\n        for word in self.words:\n            if word.startswith(prefix):\n                yield word\n", "class Solution {\n  int N = 0;\n  String[] words = null;\n  HashMap<String, List<String>> prefixHashTable = null;\n  public List<List<String>> wordSquares(String[] words) {\n    this.words = words;\n    this.N = words[0].length();\n    List<List<String>> results = new ArrayList<List<String>>();\n    this.buildPrefixHashTable(words);\n    for (String word : words) {\n      LinkedList<String> wordSquares = new LinkedList<String>();\n      wordSquares.addLast(word);\n      this.backtracking(1, wordSquares, results);\n    }\n    return results;\n  }\n  protected void backtracking(int step, LinkedList<String> wordSquares,\n                              List<List<String>> results) {\n    if (step == N) {\n      results.add((List<String>) wordSquares.clone());\n      return;\n    }\n    StringBuilder prefix = new StringBuilder();\n    for (String word : wordSquares) {\n      prefix.append(word.charAt(step));\n    }\n    for (String candidate : this.getWordsWithPrefix(prefix.toString())) {\n      wordSquares.addLast(candidate);\n      this.backtracking(step + 1, wordSquares, results);\n      wordSquares.removeLast();\n    }\n  }\n  protected void buildPrefixHashTable(String[] words) {\n    this.prefixHashTable = new HashMap<String, List<String>>();\n    for (String word : words) {\n      for (int i = 1; i < this.N; ++i) {\n        String prefix = word.substring(0, i);\n        List<String> wordList = this.prefixHashTable.get(prefix);\n        if (wordList == null) {\n          wordList = new ArrayList<String>();\n          wordList.add(word);\n          this.prefixHashTable.put(prefix, wordList);\n        } else {\n          wordList.add(word);\n        }\n      }\n    }\n  }\n  protected List<String> getWordsWithPrefix(String prefix) {\n    List<String> wordList = this.prefixHashTable.get(prefix);\n    return (wordList != null ? wordList : new ArrayList<String>());\n  }\n}\n", "class TrieNode {\n  HashMap<Character, TrieNode> children = new HashMap<Character, TrieNode>();\n  List<Integer> wordList = new ArrayList<Integer>();\n  public TrieNode() {}\n}\nclass Solution {\n  int N = 0;\n  String[] words = null;\n  TrieNode trie = null;\n  public List<List<String>> wordSquares(String[] words) {\n    this.words = words;\n    this.N = words[0].length();\n    List<List<String>> results = new ArrayList<List<String>>();\n    this.buildTrie(words);\n    for (String word : words) {\n      LinkedList<String> wordSquares = new LinkedList<String>();\n      wordSquares.addLast(word);\n      this.backtracking(1, wordSquares, results);\n    }\n    return results;\n  }\n  protected void backtracking(int step, LinkedList<String> wordSquares,\n                              List<List<String>> results) {\n    if (step == N) {\n      results.add((List<String>) wordSquares.clone());\n      return;\n    }\n    StringBuilder prefix = new StringBuilder();\n    for (String word : wordSquares) {\n      prefix.append(word.charAt(step));\n    }\n    for (Integer wordIndex : this.getWordsWithPrefix(prefix.toString())) {\n      wordSquares.addLast(this.words[wordIndex]);\n      this.backtracking(step + 1, wordSquares, results);\n      wordSquares.removeLast();\n    }\n  }\n  protected void buildTrie(String[] words) {\n    this.trie = new TrieNode();\n    for (int wordIndex = 0; wordIndex < words.length; ++wordIndex) {\n      String word = words[wordIndex];\n      TrieNode node = this.trie;\n      for (Character letter : word.toCharArray()) {\n        if (node.children.containsKey(letter)) {\n          node = node.children.get(letter);\n        } else {\n          TrieNode newNode = new TrieNode();\n          node.children.put(letter, newNode);\n          node = newNode;\n        }\n        node.wordList.add(wordIndex);\n      }\n    }\n  }\n  protected List<Integer> getWordsWithPrefix(String prefix) {\n    TrieNode node = this.trie;\n    for (Character letter : prefix.toCharArray()) {\n      if (node.children.containsKey(letter)) {\n        node = node.children.get(letter);\n      } else {\n        // return an empty list.\n        return new ArrayList<Integer>();\n      }\n    }\n    return node.wordList;\n  }\n}\n"]}
{"number": 426, "statement": "Convert a Binary Search Treeto a sorted Circular Doubly-Linked Listin place.\nYou can think of the left and right pointers as synonymous to the predecessor and successor pointers in a doubly-linked list. For a circular doubly linked list, the predecessor of the first element is the last element, and the successor of the last element is the first element.\nWe want to do the transformation in place. After the transformation, the left pointer of the tree node should point to its predecessor, and the right pointer should point to its successor. You should return the pointer to the smallest element of the linked list.\n", "solutions": ["class Solution {\n  public:\n  // the smallest (first) and the largest (last) nodes\n  Node* first = NULL;\n  Node* last = NULL;\n  void helper(Node* node) {\n    if (node) {\n      // left\n      helper(node->left);\n      // node \n      if (last) {\n        // link the previous node (last)\n        // with the current one (node)\n        last->right = node;\n        node->left = last;\n      }\n      else {\n        // keep the smallest node\n        // to close DLL later on\n        first = node;\n      }\n      last = node;\n      // right\n      helper(node->right);\n    }\n  }\n  Node* treeToDoublyList(Node* root) {\n    if (!root) return NULL;\n    helper(root);\n    // close DLL\n    last->right = first;\n    first->left = last;\n    return first;\n  }\n};\n"]}
{"number": 428, "statement": "Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.\nDesign an algorithm to serialize and deserialize an N-ary tree. An N-ary tree is a rooted tree in which each node has no more than N children. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that an N-ary tree can be serialized to a string and this string can be deserialized to the original tree structure.\nFor example, you may serialize the following3-arytree\nas[1 [3[5 6] 2 4]]. Note that this is just an example, you do not necessarily need to follow this format.\nOr you can follow LeetCode's level order traversal serialization format, where each group of children is separated by the null value.\nFor example, the above tree may be serialized as [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14].\nYou do not necessarily need to follow the above suggested formats, there are many more different formats that work so please be creative and come up with different approaches yourself.\nConstraints:\nThe height of the n-ary tree is less than or equal to 1000\nThe total number of nodes is between [0,10^4]\nDo not use class member/global/static variables to store states. Your encode and decode algorithms should be stateless.\n", "solutions": ["class Codec {\n    // A wrapper class to pass the index in the data\n    // string by reference since the problem statement\n    // says that we are not allowed to use any globals or\n    // member variables to store the states. It should be\n    // stateless. Primitives are pass by value, so we create\n    // a wrapper object.\n    class WrappableInt {\n        private int value;\n        public WrappableInt(int x) {\n            this.value = x;\n        }\n        public int getValue() {\n            return this.value;\n        }\n        public void increment() {\n            this.value++;\n        }\n    }\n    \n    // Encodes a tree to a single string.\n    public String serialize(Node root) {\n        \n        StringBuilder sb = new StringBuilder();\n        this._serializeHelper(root, sb);\n        return sb.toString();\n    }\n    \n    private void _serializeHelper(Node root, StringBuilder sb) {\n        // To be written for every approach\n    }\n    // Decodes your encoded data to tree.\n    public Node deserialize(String data) {\n        if(data.isEmpty())\n            return null;\n        \n        Node rootNode = new Node(data.charAt(0) - '0', new ArrayList<Node>());\n        WrappableInt index = new WrappableInt(1);\n        this._deserializeHelper(data, rootNode, index);\n        return rootNode;\n    }\n    \n    private void _deserializeHelper(String data, Node node, WrappableInt index) {  \n        \n        // To be written for every approach.\n    }\n}\n", "class Codec {\n    class WrappableInt {\n        private Integer value;\n        public WrappableInt(Integer x) {\n            this.value = x;\n        }\n        public Integer getValue() {\n            return this.value;\n        }\n        public void increment() {\n            this.value++;\n        }\n    }\n    \n    // Was searching for typedef alternatives in Java and came across fake classes\n    // Mostly considered an anti-pattern but it definitely makes our code much more\n    // readable!\n    class DeserializedObject extends HashMap<Integer, Pair<Integer, Pair<Integer, Node>>> {}\n    \n    \n    // Encodes a tree to a single string.\n    public String serialize(Node root) {\n        \n        StringBuilder sb = new StringBuilder();\n        this._serializeHelper(root, sb, new WrappableInt(1), null);\n        return sb.toString();\n    }\n    \n    private void _serializeHelper(Node root, StringBuilder sb, WrappableInt identity, Integer parentId) {\n        \n        if (root == null) {\n            return;\n        }\n        \n        // Own identity\n        sb.append((char) (identity.getValue() + '0'));\n        \n        // Actual value\n        sb.append((char) (root.val + '0'));\n        \n        // Parent's identity\n        sb.append((char) (parentId == null ? 'N' : parentId + '0'));\n        \n        parentId = identity.getValue();\n        for (Node child : root.children) {\n            identity.increment();\n            this._serializeHelper(child, sb, identity, parentId);\n        }\n    }\n    // Decodes your encoded data to tree.\n    public Node deserialize(String data) {\n        if(data.isEmpty())\n            return null;\n        \n        return this._deserializeHelper(data);\n    }\n    \n    private Node _deserializeHelper(String data) {  \n        \n        // HashMap explained in the algorithm\n        DeserializedObject nodesAndParents = new DeserializedObject();\n        \n        // Constructing the hashmap using the input string\n        for (int i = 0; i < data.length(); i+=3) {\n            int id = data.charAt(i) - '0';\n            int orgValue = data.charAt(i + 1) - '0';\n            int parentId = data.charAt(i + 2) - '0';\n            Pair<Integer, Pair<Integer, Node>> node = new Pair<Integer, Pair<Integer, Node>>(orgValue, \n                                           new Pair<Integer, Node>(parentId, \n                                           new Node(orgValue, new ArrayList<Node>())));\n            nodesAndParents.put(id, node);\n        }\n        \n        // A second pass for tying up the proper child connections\n        for (int i = 3; i < data.length(); i+=3) {\n            \n            // Current node\n            int id = data.charAt(i) - '0';\n            Node node = nodesAndParents.get(id).getValue().getValue();\n            \n            // Parent node\n            int parentId = data.charAt(i + 2) - '0';\n            Node parentNode = nodesAndParents.get(parentId).getValue().getValue();\n            \n            // Attach!\n            parentNode.children.add(node);\n        }\n        \n        // Return the root node.\n        return nodesAndParents.get(data.charAt(0) - '0').getValue().getValue();\n    }\n}\n", "class Codec {\n    class WrappableInt {\n        private int value;\n        public WrappableInt(int x) {\n            this.value = x;\n        }\n        public int getValue() {\n            return this.value;\n        }\n        public void increment() {\n            this.value++;\n        }\n    }\n    \n    // Encodes a tree to a single string.\n    public String serialize(Node root) {\n        \n        StringBuilder sb = new StringBuilder();\n        this._serializeHelper(root, sb);\n        return sb.toString();\n    }\n    \n    private void _serializeHelper(Node root, StringBuilder sb) {\n        \n        if (root == null) {\n            return;\n        }\n        \n        // Add the value of the node\n        sb.append((char) (root.val + '0'));\n        \n        // Add the number of children\n        sb.append((char) (root.children.size() + '0'));\n        \n        // Recurse on the subtrees and build the \n        // string accordingly\n        for (Node child : root.children) {\n            this._serializeHelper(child, sb);\n        }\n    }\n    // Decodes your encoded data to tree.\n    public Node deserialize(String data) {\n        if(data.isEmpty())\n            return null;\n        \n        return this._deserializeHelper(data, new WrappableInt(0));\n    }\n    \n    private Node _deserializeHelper(String data, WrappableInt index) {  \n        \n        if (index.getValue() == data.length()) {\n            return null;\n        }\n        \n        // The invariant here is that the \"index\" always\n        // points to a node and the value next to it \n        // represents the number of children it has.\n        Node node = new Node(data.charAt(index.getValue()) - '0', new ArrayList<Node>());\n        index.increment();\n        int numChildren = data.charAt(index.getValue()) - '0';\n        for (int i = 0; i < numChildren; i++) {\n            index.increment();\n            node.children.add(this._deserializeHelper(data, index));\n        }\n        \n        return node;\n    }\n}\n", "class Codec {\n    class WrappableInt {\n        private int value;\n        public WrappableInt(int x) {\n            this.value = x;\n        }\n        public int getValue() {\n            return this.value;\n        }\n        public void increment() {\n            this.value++;\n        }\n    }\n    \n    // Encodes a tree to a single string.\n    public String serialize(Node root) {\n        \n        StringBuilder sb = new StringBuilder();\n        this._serializeHelper(root, sb);\n        return sb.toString();\n    }\n    \n    private void _serializeHelper(Node root, StringBuilder sb) {\n        \n        if (root == null) {\n            return;\n        }\n        \n        // Add the value of the node\n        sb.append((char) (root.val + '0'));\n        \n        // Recurse on the subtrees and build the \n        // string accordingly\n        for (Node child : root.children) {\n            this._serializeHelper(child, sb);\n        }\n        \n        // Add the sentinel to indicate that all the children\n        // for the current node have been processed\n        sb.append('#');\n    }\n    // Decodes your encoded data to tree.\n    public Node deserialize(String data) {\n        if(data.isEmpty())\n            return null;\n        \n        return this._deserializeHelper(data, new WrappableInt(0));\n    }\n    \n    private Node _deserializeHelper(String data, WrappableInt index) {  \n        \n        if (index.getValue() == data.length()) {\n            return null;\n        }\n        \n        Node node = new Node(data.charAt(index.getValue()) - '0', new ArrayList<Node>());\n        index.increment();\n        while (data.charAt(index.getValue()) != '#') {\n            node.children.add(this._deserializeHelper(data, index));\n        }\n        \n        // Discard the sentinel. Note that this also moves us\n        // forward in the input string. So, we don't have the index\n        // progressing inside the above while loop!\n        index.increment();\n        \n        return node;\n    }\n}\n", "class Codec {\n    // Encodes a tree to a single string.\n    public String serialize(Node root) {\n        \n        if (root == null) {\n            return \"\";\n        }\n        \n        StringBuilder sb = new StringBuilder();\n        this._serializeHelper(root, sb);\n        return sb.toString();\n    }\n    \n    private void _serializeHelper(Node root, StringBuilder sb) {\n        \n        // Queue to perform a level order traversal of the tree\n        Queue<Node> q = new LinkedList<Node>();\n        \n        // Two dummy nodes that will help us in serialization string formation.\n        // We insert the \"endNode\" whenever a level ends and the \"childNode\"\n        // whenever a node's children are added to the queue and we are about\n        // to switch over to the next node.\n        Node endNode = new Node();\n        Node childNode = new Node();\n        q.add(root);\n        q.add(endNode);\n        \n        while (!q.isEmpty()) {\n            \n            // Pop a node\n            Node node = q.poll();\n            \n            // If this is an \"endNode\", we need to add another one\n            // to mark the end of the current level unless this\n            // was the last level.\n            if (node == endNode) {\n                \n                // We add a sentinal value of \"#\" here\n                sb.append('#');\n                if (!q.isEmpty()) {\n                    q.add(endNode);  \n                }\n            } else if (node == childNode) {\n                \n                // Add a sentinal value of \"$\" here to mark the switch to a\n                // different parent.\n                sb.append('$');\n            } else {\n                \n                // Add value of the current node and add all of it's\n                // children nodes to the queue. Note how we convert\n                // the integers to their corresponding ASCII counterparts.\n                sb.append((char) (node.val + '0'));\n                for (Node child : node.children) {\n                    q.add(child);\n                }\n                \n                // If this not is NOT the last one on the current level, \n                // add a childNode as well since we move on to processing\n                // the next node.\n                if (q.peek() != endNode) {\n                    q.add(childNode);\n                }\n            }\n        }\n    }\n    // Decodes your encoded data to tree.\n    public Node deserialize(String data) {\n        if (data.isEmpty()) {\n            return null;\n        }\n            \n        Node rootNode = new Node(data.charAt(0) - '0', new ArrayList<Node>());\n        this._deserializeHelper(data, rootNode);\n        return rootNode;\n    }\n    \n    private void _deserializeHelper(String data, Node rootNode) {  \n        \n        // We move one level at a time and at every level, we need access\n        // to the nodes on the previous level as well so that we can form\n        // the children arrays properly. Hence two arrays.\n        LinkedList<Node> currentLevel = new LinkedList<Node>();\n        LinkedList<Node> prevLevel = new LinkedList<Node>();\n        currentLevel.add(rootNode);\n        Node parentNode = rootNode;\n        \n        // Process the characters in the string one at a time.\n        for (int i = 1; i < data.length(); i++) {\n            char d = data.charAt(i);\n            if (d == '#') {\n                // Special processing for end of level. We need to swap the\n                // array lists. Here, we simply re-initialize the \"currentLevel\"\n                // arraylist rather than clearing it.\n                prevLevel = currentLevel;\n                currentLevel = new LinkedList<Node>();\n                \n                // Since we move one level down, we take the parent as the first\n                // node on the current level.\n                parentNode = prevLevel.poll();\n            } else {\n                if (d == '$') {\n                    \n                    // Special handling for change in parent on the same level\n                    parentNode = prevLevel.poll();\n                } else {\n                    Node childNode = new Node(d - '0', new ArrayList<Node>());    \n                    currentLevel.add(childNode);\n                    parentNode.children.add(childNode);\n                }\n            }\n        }\n    }\n}\n"]}
{"number": 429, "statement": "Given an n-ary tree, return the level order traversal of its nodes' values.\nNary-Tree input serializationis represented in their level order traversal, each group of children is separated by the null value (See examples).\n", "solutions": ["// This code is a modified version of the code posted by\n// #zzzliu on the discussion forums.\nclass Solution {\n    public List<List<Integer>> levelOrder(Node root) {      \n        List<List<Integer>> result = new ArrayList<>();\n        if (root == null) return result;\n        Queue<Node> queue = new LinkedList<>();\n        queue.add(root);\n        while (!queue.isEmpty()) {\n            List<Integer> level = new ArrayList<>();\n            int size = queue.size();\n            for (int i = 0; i < size; i++) {\n                Node node = queue.poll();\n                level.add(node.val);\n                queue.addAll(node.children);\n            }\n            result.add(level);\n        }\n        return result;\n    }\n}\n", "// This code is a modified version of the code posted by\n// #zzzliu on the discussion forums.\nclass Solution {\n    public List<List<Integer>> levelOrder(Node root) {\n        List<List<Integer>> result = new ArrayList<>();\n        if (root == null) return result;\n        List<Node> previousLayer = Arrays.asList(root);\n        while (!previousLayer.isEmpty()) {\n            List<Node> currentLayer = new ArrayList<>();\n            List<Integer> previousVals = new ArrayList<>();\n            for (Node node : previousLayer) {\n                previousVals.add(node.val);\n                currentLayer.addAll(node.children);\n            }\n            result.add(previousVals);\n            previousLayer = currentLayer;\n        }\n        return result;\n    }\n}\n", "class Solution {\n    private List<List<Integer>> result = new ArrayList<>();\n    public List<List<Integer>> levelOrder(Node root) {\n        if (root != null) traverseNode(root, 0);\n        return result;\n    }\n    private void traverseNode(Node node, int level) {\n        if (result.size() <= level) {\n            result.add(new ArrayList<>());\n        }\n        result.get(level).add(node.val);\n        for (Node child : node.children) {\n            traverseNode(child, level + 1);\n        }\n    }\n}\n"]}
{"number": 430, "statement": "You are given a doubly linked list which in addition to the next and previous pointers, it could have a child pointer, which may or may not point to a separate doubly linked list. These child lists may have one or more children of their own, and so on, to produce a multilevel data structure, as shown in the example below.\nFlatten the list so that all the nodes appear in a single-level, doubly linked list. You are given the head of the first level of the list.\n", "solutions": ["/*\n// Definition for a Node.\nclass Node {\n    public int val;\n    public Node prev;\n    public Node next;\n    public Node child;\n    public Node() {}\n    public Node(int _val,Node _prev,Node _next,Node _child) {\n        val = _val;\n        prev = _prev;\n        next = _next;\n        child = _child;\n    }\n};\n*/\nclass Solution {\n  public Node flatten(Node head) {\n    if (head == null) return head;\n    // pseudo head to ensure the `prev` pointer is never none\n    Node pseudoHead = new Node(0, null, head, null);\n    flattenDFS(pseudoHead, head);\n    // detach the pseudo head from the real head\n    pseudoHead.next.prev = null;\n    return pseudoHead.next;\n  }\n  /* return the tail of the flatten list */\n  public Node flattenDFS(Node prev, Node curr) {\n    if (curr == null) return prev;\n    curr.prev = prev;\n    prev.next = curr;\n    // the curr.next would be tempered in the recursive function\n    Node tempNext = curr.next;\n    Node tail = flattenDFS(curr, curr.child);\n    curr.child = null;\n    return flattenDFS(tail, tempNext);\n  }\n}\n", "/*\n// Definition for a Node.\nclass Node {\n    public int val;\n    public Node prev;\n    public Node next;\n    public Node child;\n    public Node() {}\n    public Node(int _val,Node _prev,Node _next,Node _child) {\n        val = _val;\n        prev = _prev;\n        next = _next;\n        child = _child;\n    }\n};\n*/\nclass Solution {\n  public Node flatten(Node head) {\n    if (head == null) return head;\n    Node pseudoHead = new Node(0, null, head, null);\n    Node curr, prev = pseudoHead;\n    Deque<Node> stack = new ArrayDeque<>();\n    stack.push(head);\n    while (!stack.isEmpty()) {\n      curr = stack.pop();\n      prev.next = curr;\n      curr.prev = prev;\n      if (curr.next != null) stack.push(curr.next);\n      if (curr.child != null) {\n        stack.push(curr.child);\n        // don't forget to remove all child pointers.\n        curr.child = null;\n      }\n      prev = curr;\n    }\n    // detach the pseudo node from the result\n    pseudoHead.next.prev = null;\n    return pseudoHead.next;\n  }\n}\n"]}
{"number": 431, "statement": "Design an algorithm to encode an N-ary tree into a binary tree and decode the binary tree to get the original N-ary tree. An N-ary tree is a rooted tree in which each node has no more than N children. Similarly, a binary tree is a rooted tree in which each node has no more than 2 children. There is no restriction on how your encode/decode algorithm should work. You just need to ensure that an N-ary tree can be encoded to a binary tree and this binary tree can be decoded to the original N-nary tree structure.\nNary-Tree input serializationis represented in their level order traversal, each group of children is separated by the null value (See following example).\nFor example, you may encode the following3-arytree to a binary tree in this way:\nInput: root = [1,null,3,2,4,null,5,6]\nNote that the above is just an example whichmight or might notwork. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.\nConstraints:\nThe height of the n-ary tree is less than or equal to 1000\nThe total number of nodes is between [0,10^4]\nDo not use class member/global/static variables to store states. Your encode and decode algorithms should be stateless.\n", "solutions": ["/*\n// Definition for a Node.\nclass Node {\n    public int val;\n    public List<Node> children;\n    public Node() {}\n    public Node(int _val) {\n        val = _val;\n    }\n    public Node(int _val, List<Node> _children) {\n        val = _val;\n        children = _children;\n    }\n};\n*/\n/*\n// Definition for a binary tree node.\npublic class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n   TreeNode(int x) { val = x; }\n}\n*/\nclass Pair<U, V> {\n  public U first;\n  public V second;\n  public Pair(U first, V second) {\n    this.first = first;\n    this.second = second;\n  }\n}\nclass Codec {\n  // Encodes an n-ary tree to a binary tree.\n  public TreeNode encode(Node root) {\n    if (root == null) {\n      return null;\n    }\n    TreeNode newRoot = new TreeNode(root.val);\n    Pair<TreeNode, Node> head = new Pair<TreeNode, Node>(newRoot, root);\n    // Add the first element to kickoff the loop\n    Queue<Pair<TreeNode, Node>> queue = new ArrayDeque<Pair<TreeNode, Node>>();\n    queue.add(head);\n    while (queue.size() > 0) {\n      Pair<TreeNode, Node> pair = queue.remove();\n      TreeNode bNode = pair.first;\n      Node nNode = pair.second;\n      // Encoding the children nodes into a list of TreeNode.\n      TreeNode prevBNode = null, headBNode = null;\n      for (Node nChild : nNode.children) {\n        TreeNode newBNode = new TreeNode(nChild.val);\n        if (prevBNode == null) {\n          headBNode = newBNode;\n        } else {\n          prevBNode.right = newBNode;\n        }\n        prevBNode = newBNode;\n        Pair<TreeNode, Node> nextEntry = new Pair<TreeNode, Node>(newBNode, nChild);\n        queue.add(nextEntry);\n      }\n      // Attach the list of children to the left node.\n      bNode.left = headBNode;\n    }\n    return newRoot;\n  }\n  // Decodes your binary tree to an n-ary tree.\n  public Node decode(TreeNode root) {\n    if (root == null) {\n      return null;\n    }\n    Node newRoot = new Node(root.val, new ArrayList<Node>());\n    // adding the first element to kickoff the loop\n    Queue<Pair<Node, TreeNode>> queue = new ArrayDeque<Pair<Node, TreeNode>>();\n    Pair<Node, TreeNode> head = new Pair<Node, TreeNode>(newRoot, root);\n    queue.add(head);\n    while (queue.size() > 0) {\n      Pair<Node, TreeNode> entry = queue.remove();\n      Node nNode = entry.first;\n      TreeNode bNode = entry.second;\n      // Decoding the children list\n      TreeNode firstChild = bNode.left;\n      TreeNode sibling = firstChild;\n      while (sibling != null) {\n        Node nChild = new Node(sibling.val, new ArrayList<Node>());\n        nNode.children.add(nChild);\n        // prepare the decoding the children of the child, by standing in the queue.\n        Pair<Node, TreeNode> nextEntry = new Pair<Node, TreeNode>(nChild, sibling);\n        queue.add(nextEntry);\n        sibling = sibling.right;\n      }\n    }\n    return newRoot;\n  }\n}\n// Your Codec object will be instantiated and called as such:\n// Codec codec = new Codec();\n// codec.decode(codec.encode(root));\n", "/*\n// Definition for a Node.\nclass Node {\n    public int val;\n    public List<Node> children;\n    public Node() {}\n    public Node(int _val) {\n        val = _val;\n    }\n    public Node(int _val, List<Node> _children) {\n        val = _val;\n        children = _children;\n    }\n};\n*/\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Codec {\n  // Encodes an n-ary tree to a binary tree.\n  public TreeNode encode(Node root) {\n    if (root == null) {\n      return null;\n    }\n    TreeNode newRoot = new TreeNode(root.val);\n    // Encode the first child of n-ary node to the left node of binary tree.\n    if (root.children.size() > 0) {\n      Node firstChild = root.children.get(0);\n      newRoot.left = this.encode(firstChild);\n    }\n    // Encoding the rest of the sibling nodes.\n    TreeNode sibling = newRoot.left;\n    for (int i = 1; i < root.children.size(); ++i) {\n      sibling.right = this.encode(root.children.get(i));\n      sibling = sibling.right;\n    }\n    return newRoot;\n  }\n  // Decodes your binary tree to an n-ary tree.\n  public Node decode(TreeNode root) {\n    if (root == null) {\n      return null;\n    }\n    Node newRoot = new Node(root.val, new ArrayList<Node>());\n    // Decoding all the children nodes\n    TreeNode sibling = root.left;\n    while (sibling != null) {\n      newRoot.children.add(this.decode(sibling));\n      sibling = sibling.right;\n    }\n    return newRoot;\n  }\n}\n// Your Codec object will be instantiated and called as such:\n// Codec codec = new Codec();\n// codec.decode(codec.encode(root));\n"]}
{"number": 434, "statement": "Count the number of segments in a string, where a segment is defined to be a contiguous sequence of non-space characters.\nPlease note that the string does not contain any non-printable characters.\n", "solutions": ["class Solution {\n    public int countSegments(String s) {\n        String trimmed = s.trim();\n        if (trimmed.equals(\"\")) {\n            return 0;\n        }\n        return trimmed.split(\"\\\\s+\").length;\n    }\n}\n", "class Solution {\n    public int countSegments(String s) {\n        int segmentCount = 0;\n        for (int i = 0; i < s.length(); i++) {\n            if ((i == 0 || s.charAt(i-1) == ' ') && s.charAt(i) != ' ') {\n                segmentCount++;\n            }\n        }\n        return segmentCount;\n    }\n}\n"]}
{"number": 435, "statement": "Given a collection of intervals, find the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping.\n", "solutions": ["class Solution {\n  class myComparator implements Comparator<int[]> {\n    public int compare(int[] a, int[] b) {\n      return a[1] - b[1];\n    }\n  }\n  public int eraseOverlapIntervals(int[][] intervals) {\n    Arrays.sort(intervals, new myComparator());\n    return erase_Overlap_Intervals(-1, 0, intervals);\n  }\n  public int erase_Overlap_Intervals(int prev, int curr, int[][] intervals) {\n    if (curr == intervals.length) {\n      return 0;\n    }\n    int taken = Integer.MAX_VALUE, nottaken;\n    if (prev == -1 || intervals[prev][1] <= intervals[curr][0]) {\n      taken = erase_Overlap_Intervals(curr, curr + 1, intervals);\n    }\n    nottaken = erase_Overlap_Intervals(prev, curr + 1, intervals) + 1;\n    return Math.min(taken, nottaken);\n  }\n}\n", "class Solution {\n  class myComparator implements Comparator<int[]> {\n    public int compare(int[] a, int[] b) {\n      return a[1] - b[1];\n    }\n  }\n  public boolean isOverlapping(int[] i, int[] j) {\n    return i[1] > j[0];\n  }\n  public int eraseOverlapIntervals(int[][] intervals) {\n    if (intervals.length == 0) {\n      return 0;\n    }\n    Arrays.sort(intervals, new myComparator());\n    int dp[] = new int[intervals.length];\n    dp[0] = 1;\n    int ans = 1;\n    for (int i = 1; i < dp.length; i++) {\n      int max = 0;\n      for (int j = i - 1; j >= 0; j--) {\n        if (!isOverlapping(intervals[j], intervals[i])) {\n          max = Math.max(dp[j], max);\n        }\n      }\n      dp[i] = max + 1;\n      ans = Math.max(ans, dp[i]);\n    }\n    return intervals.length - ans;\n  }\n}\n", "class Solution {\n  class myComparator implements Comparator<int[]> {\n    public int compare(int[] a, int[] b) {\n      return a[1] - b[1];\n    }\n  }\n  public boolean isOverlapping(int[] i, int[] j) {\n    return i[1] > j[0];\n  }\n  public int eraseOverlapIntervals(int[][] intervals) {\n    if (intervals.length == 0) {\n      return 0;\n    }\n    Arrays.sort(intervals, new myComparator());\n    int dp[] = new int[intervals.length];\n    dp[0] = 1;\n    int ans = 1;\n    for (int i = 1; i < dp.length; i++) {\n      int max = 0;\n      for (int j = i - 1; j >= 0; j--) {\n        if (!isOverlapping(intervals[j], intervals[i])) {\n          max = Math.max(dp[j], max);\n          break;\n        }\n      }\n      dp[i] = Math.max(max + 1, dp[i - 1]);\n      ans = Math.max(ans, dp[i]);\n    }\n    return intervals.length - ans;\n  }\n}\n", "class Solution {\n  class myComparator implements Comparator<int[]> {\n    public int compare(int[] a, int[] b) {\n      return a[1] - b[1];\n    }\n  }\n  public int eraseOverlapIntervals(int[][] intervals) {\n    if (intervals.length == 0) {\n      return 0;\n    }\n    Arrays.sort(intervals, new myComparator());\n    int end = intervals[0][1], prev = 0, count = 0;\n    for (int i = 1; i < intervals.length; i++) {\n      if (intervals[prev][1] > intervals[i][0]) {\n        if (intervals[prev][1] > intervals[i][1]) {\n          prev = i;\n        }\n        count++;\n      } else {\n        prev = i;\n      }\n    }\n    return count;\n  }\n}\n", "class Solution {\n  class myComparator implements Comparator<int[]> {\n    public int compare(int[] a, int[] b) {\n      return a[1] - b[1];\n    }\n  }\n  public int eraseOverlapIntervals(int[][] intervals) {\n    if (intervals.length == 0) {\n      return 0;\n    }\n    Arrays.sort(intervals, new myComparator());\n    int end = intervals[0][1];\n    int count = 1;\n    for (int i = 1; i < intervals.length; i++) {\n      if (intervals[i][0] >= end) {\n        end = intervals[i][1];\n        count++;\n      }\n    }\n    return intervals.length - count;\n  }\n}\n"]}
{"number": 436, "statement": "Given a set of intervals, for each of the interval i, check if there exists an interval j whose start point is bigger than or equal to the end point of the interval i, which can be called that j is on the \"right\" of i.\nFor any interval i, you need to store the minimum interval j's index, which means that the interval j has the minimum start point to build the \"right\" relationship for interval i. If the interval j doesn't exist, store -1 for the interval i. Finally, you need output the stored value of each interval as an array.\nNote:\nYou may assume the interval's end point is always bigger than its start point.\nYou may assume none of these intervals have the same start point.\n", "solutions": ["class Solution {\n    public int[] findRightInterval(int[][] intervals) {\n        int[] res = new int[intervals.length];\n        for (int i = 0; i < intervals.length; i++) {\n            int min = Integer.MAX_VALUE;\n            int minindex = -1;\n            for (int j = 0; j < intervals.length; j++) {\n                if (intervals[j][0] >= intervals[i][1] && intervals[j][0] < min) {\n                    min = intervals[j][0];\n                    minindex = j;\n                }\n            }\n            res[i] = minindex;\n        }\n        return res;\n    }\n}\n", "class Solution {\n    public int[] findRightInterval(int[][] intervals) {\n        int[] res = new int[intervals.length];\n        Map<int[], Integer> hash = new HashMap<>();\n        for (int i = 0; i < intervals.length; i++) {\n            hash.put(intervals[i], i);\n        }\n        Arrays.sort(intervals, (a, b) -> a[0] - b[0]);\n        for (int i = 0; i < intervals.length; i++) {\n            int min = Integer.MAX_VALUE;\n            int minindex = -1;\n            for (int j = i + 1; j < intervals.length; j++) {\n                if (intervals[j][0] >= intervals[i][1] && intervals[j][0] < min) {\n                    min = intervals[j][0];\n                    minindex = hash.get(intervals[j]);\n                }\n            }\n            res[hash.get(intervals[i])] = minindex;\n        }\n        return res;\n    }\n}\n", "public class Solution {\n  public int[] binary_search(int[][] intervals, int target, int start, int end) {\n    if (start >= end) {\n      if (intervals[start][0] >= target) {\n        return intervals[start];\n      }\n      return null;\n    }\n    int mid = (start + end) / 2;\n    if (intervals[mid][0] < target) {\n      return binary_search(intervals, target, mid + 1, end);\n    } else {\n      return binary_search(intervals, target, start, mid);\n    }\n  }\n  public int[] findRightInterval(int[][] intervals) {\n        int[] res = new int[intervals.length];\n        HashMap<int[], Integer> hash = new HashMap<>();\n        for (int i = 0; i < intervals.length; i++) {\n            hash.put(intervals[i], i);\n        }\n        Arrays.sort(intervals, (a, b) -> a[0] - b[0]);\n        for (int i = 0; i < intervals.length; i++) {\n            int[] interval = binary_search(intervals, intervals[i][1], 0, intervals.length - 1);\n            res[hash.get(intervals[i])] = interval == null ? -1 : hash.get(interval);\n        }\n        return res;\n    }\n}\n", "public class Solution {\n  public int[] findRightInterval(int[][] intervals) {\n    TreeMap<Integer, Integer> starts = new TreeMap<>();\n    int res[] = new int[intervals.length];\n    for (int i = 0; i < intervals.length; i++) {\n      starts.put(intervals[i][0], i);\n    }\n    for (int i = 0; i < intervals.length; i++) {\n      Map.Entry<Integer, Integer> pos = starts.ceilingEntry(intervals[i][1]);\n      res[i] = pos == null ? -1 : pos.getValue();\n    }\n    return res;\n  }\n}\n", "public class Solution {\n  public int[] findRightInterval(int[][] intervals) {\n    int[][] endIntervals = Arrays.copyOf(intervals, intervals.length);\n    HashMap<int[], Integer> hash = new HashMap<>();\n    for (int i = 0; i < intervals.length; i++) {\n      hash.put(intervals[i], i);\n    }\n    Arrays.sort(intervals, (a, b) -> a[0] - b[0]);\n    Arrays.sort(endIntervals, (a, b) -> a[1] - b[1]);\n    int j = 0;\n    int[] res = new int[intervals.length];\n    for (int i = 0; i < endIntervals.length; i++) {\n      while (j < intervals.length && intervals[j][0] < endIntervals[i][1]) {\n        j++;\n      }\n      res[hash.get(endIntervals[i])] = j == intervals.length ? -1 : hash.get(intervals[j]);\n    }\n    return res;\n  }\n}\n"]}
{"number": 438, "statement": "Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.\nStrings consists of lowercase English letters only and the length of both strings s and p will not be larger than 20,100.\nThe order of output does not matter.\n", "solutions": ["class Solution {\n  public List<Integer> findAnagrams(String s, String p) {\n    int ns = s.length(), np = p.length();\n    if (ns < np) return new ArrayList();\n    Map<Character, Integer> pCount = new HashMap();\n    Map<Character, Integer> sCount = new HashMap();\n    // build reference hashmap using string p\n    for (char ch : p.toCharArray()) {\n      if (pCount.containsKey(ch)) {\n        pCount.put(ch, pCount.get(ch) + 1);\n      }\n      else {\n        pCount.put(ch, 1);\n      }\n    }\n    List<Integer> output = new ArrayList();\n    // sliding window on the string s\n    for (int i = 0; i < ns; ++i) {\n      // add one more letter \n      // on the right side of the window\n      char ch = s.charAt(i);\n      if (sCount.containsKey(ch)) {\n        sCount.put(ch, sCount.get(ch) + 1);\n      }\n      else {\n        sCount.put(ch, 1);\n      }\n      // remove one letter \n      // from the left side of the window\n      if (i >= np) {\n        ch = s.charAt(i - np);\n        if (sCount.get(ch) == 1) {\n          sCount.remove(ch);\n        }\n        else {\n          sCount.put(ch, sCount.get(ch) - 1);\n        }\n      }\n      // compare hashmap in the sliding window\n      // with the reference hashmap\n      if (pCount.equals(sCount)) {\n        output.add(i - np + 1);\n      }\n    }\n    return output;\n  }\n}\n", "class Solution {\n  public List<Integer> findAnagrams(String s, String p) {\n    int ns = s.length(), np = p.length();\n    if (ns < np) return new ArrayList();\n    int [] pCount = new int[26];\n    int [] sCount = new int[26];\n    // build reference array using string p\n    for (char ch : p.toCharArray()) {\n      pCount[(int)(ch - 'a')]++;\n    }\n    List<Integer> output = new ArrayList();\n    // sliding window on the string s\n    for (int i = 0; i < ns; ++i) {\n      // add one more letter \n      // on the right side of the window\n      sCount[(int)(s.charAt(i) - 'a')]++;\n      // remove one letter \n      // from the left side of the window\n      if (i >= np) {\n        sCount[(int)(s.charAt(i - np) - 'a')]--;\n      }\n      // compare array in the sliding window\n      // with the reference array\n      if (Arrays.equals(pCount, sCount)) {\n        output.add(i - np + 1);\n      }\n    }\n    return output;\n  }\n}\n"]}
{"number": 441, "statement": "You have a total of n coins that you want to form in a staircase shape, where every k-th row must have exactly k coins.\nGiven n, find the total number of full staircase rows that can be formed.\nn is a non-negative integer and fits within the range of a 32-bit signed integer.\n", "solutions": ["class Solution {\n  public int arrangeCoins(int n) {\n    long left = 0, right = n;\n    long k, curr;\n    while (left <= right) {\n      k = left + (right - left) / 2;\n      curr = k * (k + 1) / 2;\n      if (curr == n) return (int)k;\n      if (n < curr) {\n        right = k - 1;\n      } else {\n        left = k + 1;\n      }\n    }\n    return (int)right;\n  }\n}\n", "class Solution {\n  public int arrangeCoins(int n) {\n    return (int)(Math.sqrt(2 * (long)n + 0.25) - 0.5);\n  }\n}\n"]}
{"number": 446, "statement": "A sequence of numbers is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.\nFor example, these are arithmetic sequences:\n1, 3, 5, 7, 9\n7, 7, 7, 7\n3, -1, -5, -9\nThe following sequence is not arithmetic.\n1, 1, 2, 5, 7\nA zero-indexed array A consisting of N numbers is given. A subsequence slice of that array is any sequence of integers (P0, P1, ..., Pk) such that 0 \u2264 P0  P1  ...  Pk  N.\nA subsequence slice (P0, P1, ..., Pk) of array A is called arithmetic if the sequence A[P0], A[P1], ..., A[Pk-1], A[Pk] is arithmetic. In particular, this means that k \u2265 2.\nThe function should return the number of arithmetic subsequence slices in the array A.\nThe input contains N integers. Every integer is in the range of -231 and 231-1 and 0 \u2264 N \u2264 1000. The output is guaranteed to be less than 231-1.\n", "solutions": ["#define LL long long\nclass Solution {\npublic:\n    int n;\n    int ans;\n    void dfs(int dep, vector<int>& A, vector<LL> cur) {\n        if (dep == n) {\n            if (cur.size() < 3) {\n                return;\n            }\n            for (int i = 1; i < cur.size(); i++) {\n                if (cur[i] - cur[i - 1] != cur[1] - cur[0]) {\n                    return;\n                }\n            }\n            ans ++;\n            return;\n        }\n        dfs(dep + 1, A, cur);\n        cur.push_back(A[dep]);\n        dfs(dep + 1, A, cur);\n    }\n    int numberOfArithmeticSlices(vector<int>& A) {\n        n = A.size();\n        ans = 0;\n        vector<LL> cur;\n        dfs(0, A, cur);\n        return (int)ans;\n    }\n};\n", "#define LL long long\nclass Solution {\npublic:\n    int numberOfArithmeticSlices(vector<int>& A) {\n        int n = A.size();\n        LL ans = 0;\n        vector<map<LL, int>> cnt(n);\n        for (int i = 1; i < n; i++) {\n            for (int j = 0; j < i; j++) {\n                LL delta = (LL)A[i] - (LL)A[j];\n                int sum = 0;\n                if (cnt[j].find(delta) != cnt[j].end()) {\n                    sum = cnt[j][delta];\n                }\n                cnt[i][delta] += sum + 1;\n                ans += sum;\n            }\n        }\n        return (int)ans;\n    }\n};\n"]}
{"number": 448, "statement": "Given an array of integers where 1 \u2264 a[i] \u2264 n (n = size of array), some elements appear twice and others appear once.\nFind all the elements of [1, n] inclusive that do not appear in this array.\nCould you do it without extra space and in O(n) runtime? You may assume the returned list does not count as extra space.\n", "solutions": ["class Solution {\n    public List<Integer> findDisappearedNumbers(int[] nums) {\n        \n        // Hash table for keeping track of the numbers in the array\n        // Note that we can also use a set here since we are not \n        // really concerned with the frequency of numbers.\n        HashMap<Integer, Boolean> hashTable = new HashMap<Integer, Boolean>();\n        \n        // Add each of the numbers to the hash table\n        for (int i = 0; i < nums.length; i++) {\n            hashTable.put(nums[i], true);\n        }\n        \n        // Response array that would contain the missing numbers\n        List<Integer> result = new LinkedList<Integer>();\n        \n        // Iterate over the numbers from 1 to N and add all those\n        // that don't appear in the hash table. \n        for (int i = 1; i <= nums.length; i++) {\n            if (!hashTable.containsKey(i)) {\n                result.add(i);\n            }\n        }\n        \n        return result;\n    }\n}\n", "class Solution {\n    public List<Integer> findDisappearedNumbers(int[] nums) {\n        \n        // Iterate over each of the elements in the original array\n        for (int i = 0; i < nums.length; i++) {\n            \n            // Treat the value as the new index\n            int newIndex = Math.abs(nums[i]) - 1;\n            \n            // Check the magnitude of value at this new index\n            // If the magnitude is positive, make it negative \n            // thus indicating that the number nums[i] has \n            // appeared or has been visited.\n            if (nums[newIndex] > 0) {\n                nums[newIndex] *= -1;\n            }\n        }\n        \n        // Response array that would contain the missing numbers\n        List<Integer> result = new LinkedList<Integer>();\n        \n        // Iterate over the numbers from 1 to N and add all those\n        // that have positive magnitude in the array\n        for (int i = 1; i <= nums.length; i++) {\n            \n            if (nums[i - 1] > 0) {\n                result.add(i);\n            }\n        }\n        \n        return result;\n    }\n}\n"]}
{"number": 449, "statement": "Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.\nDesign an algorithm to serialize and deserialize a binary search tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary search tree can be serialized to a string and this string can be deserialized to the original tree structure.\nThe encoded string should be as compact as possible.\nNote: Do not use class member/global/static variables to store states. Your serialize and deserialize algorithms should be stateless.\n", "solutions": ["public class Codec {\n  public StringBuilder postorder(TreeNode root, StringBuilder sb) {\n    if (root == null) return sb;\n    postorder(root.left, sb);\n    postorder(root.right, sb);\n    sb.append(root.val);\n    sb.append(' ');\n    return sb;\n  }\n  // Encodes a tree to a single string.\n  public String serialize(TreeNode root) {\n    StringBuilder sb = postorder(root, new StringBuilder());\n    sb.deleteCharAt(sb.length() - 1);\n    return sb.toString();\n  }\n  public TreeNode helper(Integer lower, Integer upper, ArrayDeque<Integer> nums) {\n    if (nums.isEmpty()) return null;\n    int val = nums.getLast();\n    if (val < lower || val > upper) return null;\n    nums.removeLast();\n    TreeNode root = new TreeNode(val);\n    root.right = helper(val, upper, nums);\n    root.left = helper(lower, val, nums);\n    return root;\n  }\n  // Decodes your encoded data to tree.\n  public TreeNode deserialize(String data) {\n    if (data.isEmpty()) return null;\n    ArrayDeque<Integer> nums = new ArrayDeque<Integer>();\n    for (String s : data.split(\"\\\\s+\"))\n      nums.add(Integer.valueOf(s));\n    return helper(Integer.MIN_VALUE, Integer.MAX_VALUE, nums);\n  }\n}\n", "class Codec:\n    def postorder(self, root):\n        return self.postorder(root.left) + self.postorder(root.right) + [root.val] if root else []\n        \n    def int_to_str(self, x):\n        \"\"\"\n        Encodes integer to bytes string.\n        \"\"\"\n        bytes = [chr(x >> (i * 8) & 0xff) for i in range(4)]\n        bytes.reverse()\n        bytes_str = ''.join(bytes)\n        return bytes_str\n        \n    def serialize(self, root):\n        \"\"\"\n        Encodes a tree to a single string.\n        \"\"\"\n        lst = self.postorder(root)\n        lst = [self.int_to_str(x) for x in lst]\n        return '\u00e7'.join(map(str, lst))\n    \n    def str_to_int(self, bytes_str):\n        \"\"\"\n        Decodes bytes string to integer.\n        \"\"\"\n        result = 0\n        for ch in bytes_str:\n            result = result * 256 + ord(ch)\n        return result\n        \n    def deserialize(self, data):\n        \"\"\"\n        Decodes your encoded data to tree.\n        \"\"\"\n        def helper(lower = float('-inf'), upper = float('inf')):\n            if not data or data[-1] < lower or data[-1] > upper:\n                return None\n            \n            val = data.pop()\n            root = TreeNode(val)\n            root.right = helper(val, upper)\n            root.left = helper(lower, val)\n            return root\n        \n        data = [self.str_to_int(x) for x in data.split('\u00e7') if x]\n        return helper() \n"]}
{"number": 450, "statement": "Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return the root node reference (possibly updated) of the BST.\nBasically, the deletion can be divided into two stages:\nSearch for a node to remove.\nIf the node is found, delete the node.\nNote: Time complexity should be O(height of tree).\n", "solutions": ["public LinkedList<Integer> inorder(TreeNode root, LinkedList<Integer> arr) {\n  if (root == null) return arr;\n  inorder(root.left, arr);\n  arr.add(root.val);\n  inorder(root.right, arr);\n  return arr;\n}  \n", "public int successor(TreeNode root) {\n  root = root.right;\n  while (root.left != null) root = root.left;\n  return root;\n} \n"]}
{"number": 451, "statement": "Given a string, sort it in decreasing order based on the frequency of characters.\n", "solutions": ["public String frequencySort(String s) {\n        \n    if (s == null || s.isEmpty()) return s;\n    \n    // Create a sorted Array of chars.\n    char[] chars = s.toCharArray();\n    Arrays.sort(chars);\n    \n    // Convert identical chars into single Strings.\n    List<String> charStrings = new ArrayList<String>();\n    StringBuilder currentString = new StringBuilder();\n    currentString.append(chars[0]);\n    for (int i = 1; i < chars.length; i++) {\n        if (chars[i] != chars[i - 1]) {\n            charStrings.add(currentString.toString());\n            currentString = new StringBuilder();\n        }\n        currentString.append(chars[i]);\n    }\n    charStrings.add(currentString.toString());\n        \n    // Our comparator is (a, b) -> b.length() - a.length().\n    // If a is longer than b, then a negative number will be returned\n    // telling the sort algorithm to place a first. Otherwise, a positive\n    // number will be returned, telling it to place a second.\n    // This results in a longest to shortest sorted list of the strings.\n    Collections.sort(charStrings, (a, b) -> b.length() - a.length());\n    \n    // Use StringBuilder to build the String to return.\n    StringBuilder sb = new StringBuilder();\n    for (String str : charStrings) sb.append(str);\n    return sb.toString();\n}\n", "public String frequencySort(String s) {\n    // Count up the occurances.\n    Map<Character, Integer> counts = new HashMap<>();\n    for (char c : s.toCharArray()) {\n        counts.put(c, counts.getOrDefault(c, 0) + 1);\n    }\n            \n    // Make a list of the keys, sorted by frequency.\n    List<Character> characters = new ArrayList<>(counts.keySet());        \n    Collections.sort(characters, (a, b) -> counts.get(b) - counts.get(a));\n    // Convert the counts into a string with a sb.\n    StringBuilder sb = new StringBuilder();\n    for (char c : characters) {\n        int copies = counts.get(c);\n        for (int i = 0; i < copies; i++) {\n            sb.append(c);\n        }\n    }\n    return sb.toString();\n}\n"]}
{"number": 452, "statement": "There are a number of spherical balloons spread in two-dimensional space. For each balloon, provided input is the start and end coordinates of the horizontal diameter. Since it's horizontal, y-coordinates don't matter and hence the x-coordinates of start and end of the diameter suffice. Start is always smaller than end. There will be at most 104 balloons.\nAn arrow can be shot up exactly vertically from different points along the x-axis. A balloon with xstart and xend bursts by an arrow shot at x if xstart \u2264 x \u2264 xend. There is no limit to the number of arrows that can be shot. An arrow once shot keeps travelling up infinitely. The problem is to find the minimum number of arrows that must be shot to burst all balloons.\n", "solutions": ["class Solution {\n  public:\n  int findMinArrowShots(vector<vector<int>>& points) {\n    if (points.size() == 0) return 0;\n    // sort by x_end\n    sort(begin(points), end(points),\n         [](const vector<int> &o1, const vector<int> &o2) {\n      return (o1[1] < o2[1]);\n    });\n    int arrows = 1;\n    int xStart, xEnd, firstEnd = points[0][1];\n    for (auto p : points) {\n      xStart = p[0];\n      xEnd = p[1];\n      // if the current balloon starts after the end of another one,\n      // one needs one more arrow\n      if (firstEnd < xStart) {\n        arrows++;\n        firstEnd = xEnd;\n      }\n    }\n    return arrows;\n  }\n};\n"]}
{"number": 453, "statement": "Given a non-empty integer array of size n, find the minimum number of moves required to make all array elements equal, where a move is incrementing n - 1 elements by 1.\n", "solutions": ["public class Solution {\n    public int minMoves(int[] nums) {\n        int min = 0, max = nums.length - 1, count = 0;\n        while (true) {\n            for (int i = 0; i < nums.length; i++) {\n                if (nums[max] < nums[i]) {\n                    max = i;\n                }\n                if (nums[min] > nums[i]) {\n                    min = i;\n                }\n            }\n            if (nums[max] == nums[min]) {\n                break;\n            }\n            for (int i = 0; i < nums.length; i++) {\n                if (i != max) {\n                    nums[i]++;\n                }\n            }\n            count++;\n        }\n        return count;\n    }\n}\n", "public class Solution {\n    public int minMoves(int[] nums) {\n        int min = 0, max = nums.length - 1, count = 0;\n        while (true) {\n            for (int i = 0; i < nums.length; i++) {\n                if (nums[max] < nums[i]) {\n                    max = i;\n                }\n                if (nums[min] > nums[i]) {\n                    min = i;\n                }\n            }\n            int diff = nums[max] - nums[min];\n            if (diff == 0) {\n                break;\n            }\n            count += diff;\n            for (int i = 0; i < nums.length; i++) {\n                if (i != max) {\n                    nums[i] = nums[i] + diff;\n                }\n            }\n        }\n        return count;\n    }\n}\n", "public class Solution {\n    public int minMoves(int[] nums) {\n        Arrays.sort(nums);\n        int count = 0;\n        for (int i = nums.length - 1; i > 0; i--) {\n            count += nums[i] - nums[0];\n        }\n        return count;\n    }\n}\n", "public class Solution {\n    public int minMoves(int[] nums) {\n        Arrays.sort(nums);\n        int moves = 0;\n        for (int i = 1; i < nums.length; i++) {\n            int diff = (moves + nums[i]) - nums[i - 1];\n            nums[i] += moves;\n            moves += diff;\n        }\n        return moves;\n    }\n}\n", "public class Solution {\n    public int minMoves(int[] nums) {\n        int moves = 0, min = Integer.MAX_VALUE;\n        for (int i = 0; i < nums.length; i++) {\n            moves += nums[i];\n            min = Math.min(min, nums[i]);\n        }\n        return moves - min * nums.length;\n    }\n}\n", "public class Solution {\n    public int minMoves(int[] nums) {\n        int moves = 0, min = Integer.MAX_VALUE;\n        for (int i = 0; i < nums.length; i++) {\n            min = Math.min(min, nums[i]);\n        }\n        for (int i = 0; i < nums.length; i++) {\n            moves += nums[i] - min;\n        }\n        return moves;\n    }\n}\n"]}
{"number": 456, "statement": "Given a sequence of n integers a1, a2, ..., an, a 132 pattern is a subsequence ai, aj, ak such\nthat i  j  k and ai  ak  aj. Design an algorithm that takes a list of n numbers as input and checks whether there is a 132 pattern in the list.\nNote: n will be less than 15,000.\n", "solutions": ["public class Solution {\n    public boolean find132pattern(int[] nums) {\n        for (int i = 0; i < nums.length - 2; i++) {\n            for (int j = i + 1; j < nums.length - 1; j++) {\n                for (int k = j + 1; k < nums.length; k++) {\n                    if (nums[k] > nums[i] && nums[j] > nums[k])\n                        return true;\n                }\n            }\n        }\n        return false;\n    }\n}\n", "public class Solution {\n    public boolean find132pattern(int[] nums) {\n        int min_i = Integer.MAX_VALUE;\n        for (int j = 0; j < nums.length - 1; j++) {\n            min_i = Math.min(min_i, nums[j]);\n            for (int k = j + 1; k < nums.length; k++) {\n                if (nums[k] < nums[j] && min_i < nums[k])\n                    return true;\n            }\n        }\n        return false;\n    }\n}\n"]}
{"number": 458, "statement": "There are 1000 buckets, one and only one of them is poisonous, while the rest are filled with water. They all look identical. If a pig drinks the poison it will die within 15 minutes. What is the minimum amount of pigs you need to figure out which bucket is poisonous within one hour?\nAnswer this question, and write an algorithm for the general case.\nGeneral case: \nIf there are n buckets and a pig drinking poison will die within m minutes, how many pigs (x) you need to figure out the poisonousbucket within p minutes? There is exactly one bucket with poison.\nNote:\nA pig can be allowed to drink simultaneously on as many buckets as one would like, and the feeding takes no time.\nAfter a pig has instantly finished drinking buckets, there has to be a cool down time of mminutes. During this time, only observation is allowed and no feedings at all.\nAny given bucket can be sampled an infinite number of times (by an unlimited number of pigs).\n", "solutions": ["class Solution {\n  public:\n  int poorPigs(int buckets, int minutesToDie, int minutesToTest) {\n    int states = minutesToTest / minutesToDie + 1;\n    return ceil(log(buckets) / log(states));\n  }\n};\n"]}
{"number": 459, "statement": "Given a non-empty string check if it can be constructed by taking a substring of it and appending multiple copies of the substring together. You may assume the given string consists of lowercase English letters only and its length will not exceed 10000.\n", "solutions": ["class Solution {\npublic:\n    bool repeatedSubstringPattern(string s) {\n        regex pat(\"^(.+)\\\\1+$\");\n        return regex_match(s, pat);\n    }\n};\n", "class Solution {\npublic:\n    bool repeatedSubstringPattern(string s) {\n        return (s + s).substr(1, 2 * s.size() - 2).find(s) != string::npos;\n    }\n};\n"]}
{"number": 461, "statement": "The Hamming distance between two integers is the number of positions at which the corresponding bits are different.\nGiven two integers x and y, calculate the Hamming distance.\nNote:\n0 \u2264 x, y  231.\n", "solutions": ["class Solution {\n    public int hammingDistance(int x, int y) {\n        return Integer.bitCount(x ^ y); \n    }\n}\n", "class Solution {\n  public int hammingDistance(int x, int y) {\n    int xor = x ^ y;\n    int distance = 0;\n    while (xor != 0) {\n      if (xor % 2 == 1)\n        distance += 1;\n      xor = xor >> 1;\n    }\n    return distance;\n  }\n}\n"]}
{"number": 462, "statement": "Given a non-empty integer array, find the minimum number of moves required to make all array elements equal, where a move is incrementing a selected element by 1 or decrementing a selected element by 1.\nYou may assume the array's length is at most 10,000.\n", "solutions": ["public class Solution {\n    public int minMoves2(int[] nums) {\n        long ans = Long.MAX_VALUE;\n        int minval = Integer.MAX_VALUE;\n        int maxval = Integer.MIN_VALUE;\n        for (int num : nums) {\n            minval = Math.min(minval, num);\n            maxval = Math.max(maxval, num);\n        }\n        for (int i = minval; i <= maxval; i++) {\n            long sum = 0;\n            for (int num : nums) {\n                sum += Math.abs(num - i);\n            }\n            ans = Math.min(ans, sum);\n        }\n        return (int) ans;\n    }\n}\n", "public class Solution {\n    public int minMoves2(int[] nums) {\n        long min = Integer.MAX_VALUE;\n        for (int num : nums) {\n            long sum = 0;\n            for (int n : nums) {\n                sum += Math.abs(n - num);\n            }\n            min = Math.min(min, sum);\n        }\n        return (int) min;\n    }\n}\n"]}
{"number": 466, "statement": "Define S = [s,n] as the string S which consists of n connected strings s. For example, [\"abc\", 3] =\"abcabcabc\". \nOn the other hand, we define that string s1 can be obtained from string s2 if we can remove some characters from s2 such that it becomes s1. For example, \u201cabc\u201d  can be obtained from \u201cabdbec\u201d based on our definition, but it can not be obtained from \u201cacbbe\u201d.\nYou are given two non-empty strings s1 and s2 (each at most 100 characters long) and two integers 0 \u2264 n1 \u2264 106 and 1 \u2264 n2 \u2264 106. Now consider the strings S1 and S2, where S1=[s1,n1] and S2=[s2,n2]. Find the maximum integer M such that [S2,M] can be obtained from S1.\n", "solutions": ["int getMaxRepetitions(string s1, int n1, string s2, int n2)\n{\n    int index = 0, repeat_count = 0;\n    int s1_size = s1.size(), s2_size = s2.size();\n    for (int i = 0; i < n1; i++) {\n        for (int j = 0; j < s1_size; j++) {\n            if (s1[j] == s2[index])\n                ++index;\n            if (index == s2_size) {\n                index = 0;\n                ++repeat_count;\n            }\n        }\n    }\n    return repeat_count / n2;\n}\n", "int getMaxRepetitions(string s1, int n1, string s2, int n2)\n{\n    if (n1 == 0)\n        return 0;\n    int indexr[s2.size() + 1] = { 0 }; // index at start of each s1 block\n    int countr[s2.size() + 1] = { 0 }; // count of repititions till the present s1 block\n    int index = 0, count = 0;\n    for (int i = 0; i < n1; i++) {\n        for (int j = 0; j < s1.size(); j++) {\n            if (s1[j] == s2[index])\n                ++index;\n            if (index == s2.size()) {\n                index = 0;\n                ++count;\n            }\n        }\n        countr[i] = count;\n        indexr[i] = index;\n        for (int k = 0; k < i; k++) {\n            if (indexr[k] == index) {\n                int prev_count = countr[k];\n                int pattern_count = (countr[i] - countr[k]) * (n1 - 1 - k) / (i - k);\n                int remain_count = countr[k + (n1 - 1 - k) % (i - k)] - countr[k];\n                return (prev_count + pattern_count + remain_count) / n2;\n            }\n        }\n    }\n    return countr[n1 - 1] / n2;\n}\n"]}
{"number": 468, "statement": "Write a function to check whether an input string is a valid IPv4 address or IPv6 address or neither.\nIPv4 addresses are canonically represented in dot-decimal notation, which consists of four decimal numbers, each ranging from 0 to 255, separated by dots (\".\"), e.g.,172.16.254.1;\nBesides, leading zeros in the IPv4 is invalid. For example, the address 172.16.254.01 is invalid.\nIPv6 addresses are represented as eight groups of four hexadecimal digits, each group representing 16 bits. The groups are separated by colons (\":\"). For example, the address 2001:0db8:85a3:0000:0000:8a2e:0370:7334 is a valid one. Also, we could omit some leading zeros among four hexadecimal digits and some low-case characters in the address to upper-case ones, so 2001:db8:85a3:0:0:8A2E:0370:7334 is also a valid IPv6 address(Omit leading zeros and using upper cases).\nHowever, we don't replace a consecutive group of zero value with a single empty group using two consecutive colons (::) to pursue simplicity. For example, 2001:0db8:85a3::8A2E:0370:7334 is an invalid IPv6 address.\nBesides, extra leading zeros in the IPv6 is also invalid. For example, the address 02001:0db8:85a3:0000:0000:8a2e:0370:7334 is invalid.\nNote:\nYou may assume there is no extra space or special characters in the input string.\n", "solutions": ["import java.net.*;\nclass Solution {\n  public String validIPAddress(String IP) {\n    try {\n      return (InetAddress.getByName(IP) instanceof Inet6Address) ? \"IPv6\": \"IPv4\";\n    } catch(Exception e) {}\n    return \"Neither\";\n  }\n}\n", "import java.util.regex.Pattern;\nclass Solution {\n  String chunkIPv4 = \"([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\";\n  Pattern pattenIPv4 =\n          Pattern.compile(\"^(\" + chunkIPv4 + \"\\\\.){3}\" + chunkIPv4 + \"$\");\n  String chunkIPv6 = \"([0-9a-fA-F]{1,4})\";\n  Pattern pattenIPv6 =\n          Pattern.compile(\"^(\" + chunkIPv6 + \"\\\\:){7}\" + chunkIPv6 + \"$\");\n  public String validIPAddress(String IP) {\n    if (pattenIPv4.matcher(IP).matches()) return \"IPv4\";\n    return (pattenIPv6.matcher(IP).matches()) ? \"IPv6\" : \"Neither\";\n  }\n}\n"]}
{"number": 470, "statement": "Given a function rand7 which generates a uniform random integer in the range 1 to 7, write a function rand10which generates a uniform random integer in the range 1 to 10.\nDo NOT use system's Math.random().\n", "solutions": ["class Solution {\npublic:\n    int rand10() {\n        int row, col, idx;\n        do {\n            row = rand7();\n            col = rand7();\n            idx = col + (row - 1) * 7;\n        } while (idx > 40);\n        return 1 + (idx - 1) % 10;\n    }\n};\n", "class Solution {\npublic:\n    int rand10() {\n        int a, b, idx;\n        while (true) {\n            a = rand7();\n            b = rand7();\n            idx = b + (a - 1) * 7;\n            if (idx <= 40)\n                return 1 + (idx - 1) % 10;\n            a = idx - 40;\n            b = rand7();\n            // get uniform dist from 1 - 63\n            idx = b + (a - 1) * 7;\n            if (idx <= 60)\n                return 1 + (idx - 1) % 10;\n            a = idx - 60;\n            b = rand7();\n            // get uniform dist from 1 - 21\n            idx = b + (a - 1) * 7;\n            if (idx <= 20)\n                return 1 + (idx - 1) % 10;\n        }\n    }\n};\n"]}
{"number": 473, "statement": "Remember the story of Little Match Girl? By now, you know exactly what matchsticks the little match girl has, please find out a way you can make one square by using up all those matchsticks. You should not break any stick, but you can link them up, and each matchstick must be used exactly one time.\n Your input will be several matchsticks the girl has, represented with their stick length. Your output will either be true or false, to represent whether you could make one square using all the matchsticks the little match girl has.\n", "solutions": ["import java.util.HashMap;\nimport java.util.Collections;\nclass Solution {\n    public List<Integer> nums;\n    public int[] sums;\n    public int possibleSquareSide;\n    public Solution() {\n        this.sums = new int[4];\n    }\n    // Depth First Search function.\n    public boolean dfs(int index) {\n        // If we have exhausted all our matchsticks, check if all sides of the square are of equal length\n        if (index == this.nums.size()) {\n            return sums[0] == sums[1] && sums[1] == sums[2] && sums[2] == sums[3];\n        }\n        // Get current matchstick.\n        int element = this.nums.get(index);\n        // Try adding it to each of the 4 sides (if possible)\n        for(int i = 0; i < 4; i++) {\n            if (this.sums[i] + element <= this.possibleSquareSide) {\n                this.sums[i] += element;\n                if (this.dfs(index + 1)) {\n                    return true;\n                }\n                this.sums[i] -= element;\n            }\n        }\n        return false;\n    }\n    public boolean makesquare(int[] nums) {\n        // Empty matchsticks.\n        if (nums == null || nums.length == 0) {\n            return false;\n        }\n        // Find the perimeter of the square (if at all possible)\n        int L = nums.length;\n        int perimeter = 0;\n        for(int i = 0; i < L; i++) {\n            perimeter += nums[i];\n        }\n        this.possibleSquareSide =  perimeter / 4;\n        if (this.possibleSquareSide * 4 != perimeter) {\n            return false;\n        }\n        // Convert the array of primitive int to ArrayList (for sorting).\n        this.nums = Arrays.stream(nums).boxed().collect(Collectors.toList());\n        Collections.sort(this.nums, Collections.reverseOrder());\n        return this.dfs(0);\n    }\n}\n", "import java.util.HashMap;\nclass Solution {\n    // The memoization cache to be used during recursion.\n    public HashMap<Pair<Integer, Integer>, Boolean> memo;\n    // Array containing our matchsticks.\n    public int[] nums;\n    // Possible side of our square depending on the total sum of all the matchsticks.\u00a0\n    public int possibleSquareSide;\n    // Default constructor to initialise our memo cache.\n    public Solution() {\n        this.memo = new HashMap<Pair<Integer, Integer>, Boolean>();\n    }\n    // Main DP function.\n    public boolean recurse(Integer mask, Integer sidesDone) {\n        int total = 0;\n        int L = this.nums.length;\n        // The memo key for this recursion\n        Pair<Integer, Integer> memoKey = new Pair(mask, sidesDone);\n        // Find out the sum of matchsticks used till now.\n        for(int i = L - 1; i >= 0; i--) {\n            if ((mask&(1 << i)) == 0) {\n                total += this.nums[L - 1 - i];\n            }\n        }\n        // If the sum if divisible by our square's side, then we increment our number of complete sides formed variable.\n        if (total > 0 && total % this.possibleSquareSide == 0) {\n            sidesDone++;\n        }\n        // Base case.\n        if (sidesDone == 3) {\n            return true;\n        }\n        // Return precomputed results\n        if (this.memo.containsKey(memoKey)) {\n            return this.memo.get(memoKey);\n        }\n        boolean ans = false;\n        int c = total / this.possibleSquareSide;\n        // Remaining vlength in the current partially formed side.\n        int rem = this.possibleSquareSide * (c + 1) - total;\n        // Try out all remaining options (that are valid)\n        for(int i = L - 1; i >= 0; i--) {\n            if (this.nums[L - 1 - i] <= rem && (mask&(1 << i)) > 0) {\n                if (this.recurse(mask ^ (1 << i), sidesDone)) {\n                    ans = true;\n                    break;\n                }\n            }\n        }\n        // Cache the computed results.\n        this.memo.put(memoKey, ans);\n        return ans;\n    }\n    public boolean makesquare(int[] nums) {\n        // Empty matchsticks.\n        if (nums == null || nums.length == 0) {\n            return false;\n        }\n        // Find the perimeter of the square (if at all possible)\n        int L = nums.length;\n        int perimeter = 0;\n        for(int i = 0; i < L; i++) {\n            perimeter += nums[i];\n        }\n        int possibleSquareSide =  perimeter / 4;\n        if (possibleSquareSide * 4 != perimeter) {\n            return false;\n        }\n        this.nums = nums;\n        this.possibleSquareSide = possibleSquareSide;\n        return this.recurse((1 << L) - 1, 0);\n    }\n}\n"]}
{"number": 474, "statement": "Given an array, strs, with strings consisting of only 0s and 1s. Also two integers m and n.\nNow your task is to find the maximum number of strings that you can form with given m 0s and n 1s. Each 0 and 1 can be used at most once.\n", "solutions": ["public class Solution {\n    public int findMaxForm(String[] strs, int m, int n) {\n        int maxlen = 0;\n        for (int i = 0; i < (1 << strs.length); i++) {\n            int zeroes = 0, ones = 0, len = 0;\n            for (int j = 0; j < strs.length; j++) {\n                if ((i & (1 << j)) != 0) {\n                    int[] count = countzeroesones(strs[j]);\n                    zeroes += count[0];\n                    ones += count[1];\n                    len++;\n                }\n            }\n            if (zeroes <= m && ones <= n)\n                maxlen = Math.max(maxlen, len);\n        }\n        return maxlen;\n    }\n    public int[] countzeroesones(String s) {\n        int[] c = new int[2];\n        for (int i = 0; i < s.length(); i++) {\n            c[s.charAt(i)-'0']++;\n        }\n        return c;\n    }\n}\n", "public class Solution {\n    public int findMaxForm(String[] strs, int m, int n) {\n        int maxlen = 0;\n        for (int i = 0; i < (1 << strs.length); i++) {\n            int zeroes = 0, ones = 0, len = 0;\n            for (int j = 0; j < 32; j++) {\n                if ((i & (1 << j)) != 0) {\n                    int[] count = countzeroesones(strs[j]);\n                    zeroes += count[0];\n                    ones += count[1];\n                    if (zeroes > m || ones > n)\n                        break;\n                    len++;\n                }\n            }\n            if (zeroes <= m && ones <= n)\n                maxlen = Math.max(maxlen, len);\n        }\n        return maxlen;\n    }\n    public int[] countzeroesones(String s) {\n        int[] c = new int[2];\n        for (int i = 0; i < s.length(); i++) {\n            c[s.charAt(i)-'0']++;\n        }\n        return c;\n    }\n}\n", "public class Solution {\n    public int findMaxForm(String[] strs, int m, int n) {\n        return calculate(strs, 0, m, n);\n    }\n    public int calculate(String[] strs, int i, int zeroes, int ones) {\n        if (i == strs.length)\n            return 0;\n        int[] count = countzeroesones(strs[i]);\n        int taken = -1;\n        if (zeroes - count[0] >= 0 && ones - count[1] >= 0)\n            taken = calculate(strs, i + 1, zeroes - count[0], ones - count[1]) + 1;\n        int not_taken = calculate(strs, i + 1, zeroes, ones);\n        return Math.max(taken, not_taken);\n    }\n    public int[] countzeroesones(String s) {\n        int[] c = new int[2];\n        for (int i = 0; i < s.length(); i++) {\n            c[s.charAt(i)-'0']++;\n        }\n        return c;\n    }\n}\n", "public class Solution {\n    public int findMaxForm(String[] strs, int m, int n) {\n        int[][][] memo = new int[strs.length][m + 1][n + 1];\n        return calculate(strs, 0, m, n, memo);\n    }\n    public int calculate(String[] strs, int i, int zeroes, int ones, int[][][] memo) {\n        if (i == strs.length)\n            return 0;\n        if (memo[i][zeroes][ones] != 0)\n            return memo[i][zeroes][ones];\n        int[] count = countzeroesones(strs[i]);\n        int taken = -1;\n        if (zeroes - count[0] >= 0 && ones - count[1] >= 0)\n            taken = calculate(strs, i + 1, zeroes - count[0], ones - count[1], memo) + 1;\n        int not_taken = calculate(strs, i + 1, zeroes, ones, memo);\n        memo[i][zeroes][ones] = Math.max(taken, not_taken);\n        return memo[i][zeroes][ones];\n    }\n    public int[] countzeroesones(String s) {\n        int[] c = new int[2];\n        for (int i = 0; i < s.length(); i++) {\n            c[s.charAt(i)-'0']++;\n        }\n        return c;\n    }\n}\n", "public class Solution {\n    public int findMaxForm(String[] strs, int m, int n) {\n        int[][] dp = new int[m + 1][n + 1];\n        for (String s: strs) {\n            int[] count = countzeroesones(s);\n            for (int zeroes = m; zeroes >= count[0]; zeroes--)\n                for (int ones = n; ones >= count[1]; ones--)\n                    dp[zeroes][ones] = Math.max(1 + dp[zeroes - count[0]][ones - count[1]], dp[zeroes][ones]);\n        }\n        return dp[m][n];\n    }\n    public int[] countzeroesones(String s) {\n        int[] c = new int[2];\n        for (int i = 0; i < s.length(); i++) {\n            c[s.charAt(i)-'0']++;\n        }\n        return c;\n    }\n}\n"]}
{"number": 476, "statement": "Given a positive integer num, output its complement number. The complement strategy is to flip the bits of its binary representation.\n", "solutions": ["class Solution {\n  public int findComplement(int num) {\n    int todo = num, bit = 1;\n    while (todo != 0) {\n      // flip current bit\n      num = num ^ bit;\n      // prepare for the next run\n      bit = bit << 1;\n      todo = todo >> 1;\n    }\n    return num;\n  }\n}\n", "class Solution {\n  public int findComplement(int num) {\n    // n is a length of num in binary representation\n    int n = (int)( Math.log(num) / Math.log(2) ) + 1;\n    // bitmask has the same length as num and contains only ones 1...1\n    int bitmask = (1 << n) - 1;\n    // flip all bits\n    return bitmask ^ num;\n  }\n}\n", "class Solution {\n  public int findComplement(int num) {\n    return (Integer.highestOneBit(num) << 1) - num - 1;\n  }\n}\n", "class Solution {\n  public int findComplement(int num) {\n    // bitmask has the same length as num and contains only ones 1...1\n    int bitmask = num;\n    bitmask |= (bitmask >> 1);\n    bitmask |= (bitmask >> 2);\n    bitmask |= (bitmask >> 4);\n    bitmask |= (bitmask >> 8);\n    bitmask |= (bitmask >> 16);\n    // flip all bits \n    return bitmask ^ num;\n  }\n}\n"]}
{"number": 477, "statement": "The Hamming distance between two integers is the number of positions at which the corresponding bits are different.\nNow your job is to find the total Hamming distance between all pairs of the given numbers.\n", "solutions": ["int totalHammingDistance(vector<int>& nums)\n{\n    int ans = 0;\n    if (nums.empty())\n        return ans;\n    for (int i = 0; i < nums.size() - 1; i++)                  // for all unique pairs of elements\n        for (int j = i + 1; j < nums.size(); j++)\n            ans += __builtin_popcount(nums[i] ^ nums[j]);      // count number of 1 bits in xor resultant\n    return ans;\n}\n", "int totalHammingDistance(vector<int>& nums)\n{\n    if (nums.empty())\n        return 0;\n    int ans = 0, n = nums.size();\n    vector<int> cnt(32, 0);         // count of elements with a particular bit ON\n    for (auto num : nums) {         // loop over every element\n        int i = 0;\n        while (num > 0) {           // check every bit\n            cnt[i] += (num & 0x1);\n            num >>= 1;\n            i++;\n        }\n    }\n    for (auto&& k : cnt) {           // loop over every bit count\n        ans += k * (n - k);\n    }\n    return ans;\n}\n", "def totalHammingDistance(self, nums):\n    return sum((b.count('0') * b.count('1')) for b in zip(*map('{:032b}'.format, nums)))\n"]}
{"number": 478, "statement": "Given the radius and x-y positions of the center of a circle, write a function randPointwhichgenerates a uniform randompoint in the circle.\nNote:\ninput and output values areinfloating-point.\nradius and x-y position of the center of the circle is passed into the class constructor.\na point on the circumference of the circle is considered to bein the circle.\nrandPointreturnsa size 2 array containing x-position and y-position of the random point, in that order.\n", "solutions": ["class Solution {\npublic:\n    double rad, xc, yc;\n    //c++11 random floating point number generation\n    mt19937 rng{random_device{}()};\n    uniform_real_distribution<double> uni{0, 1};\n    Solution(double radius, double x_center, double y_center) {\n        rad = radius, xc = x_center, yc = y_center;\n    }\n    vector<double> randPoint() {\n        double x0 = xc - rad;\n        double y0 = yc - rad;\n        while(true) {\n            double xg = x0 + uni(rng) * 2 * rad;\n            double yg = y0 + uni(rng) * 2 * rad;\n            if (sqrt(pow((xg - xc), 2) + pow((yg - yc), 2)) <= rad)\n                return {xg, yg};\n        }\n    }\n};\n", "class Solution {\npublic:\n    double rad, xc, yc;\n    //c++11 random floating point number generation\n    mt19937 rng{random_device{}()};\n    uniform_real_distribution<double> uni{0, 1};\n    Solution(double radius, double x_center, double y_center) {\n        rad = radius, xc = x_center, yc = y_center;\n    }\n    vector<double> randPoint() {\n        double d = rad * sqrt(uni(rng));\n        double theta = uni(rng) * (2 * M_PI);\n        return {d * cos(theta) + xc, d * sin(theta) + yc};\n    }\n};\n"]}
{"number": 480, "statement": "Median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value.\n", "solutions": ["vector<double> medianSlidingWindow(vector<int>& nums, int k)\n{\n    vector<double> medians;\n    for (int i = 0; i + k <= nums.size(); i++) {\n        vector<int> window(nums.begin() + i, nums.begin() + i + k);\n        sort(window.begin(), window.end());\n        if (k & 1)\n            medians.push_back(window[k / 2]);\n        else\n            medians.push_back((double)(window[k / 2 - 1] + (double)window[k / 2]) / 2.0);\n    }\n    return medians;\n}\n", "vector<double> medianSlidingWindow(vector<int>& nums, int k)\n{\n    vector<double> medians;\n    unordered_map<int, int> hash_table;\n    priority_queue<int> lo;                                 // max heap\n    priority_queue<int, vector<int>, greater<int> > hi;     // min heap\n    int i = 0;      // index of current incoming element being processed\n    // initialize the heaps\n    while (i < k)\n        lo.push(nums[i++]);\n    for (int j = 0; j < k / 2; j++) {\n        hi.push(lo.top());\n        lo.pop();\n    }\n    while (true) {\n        // get median of current window\n        medians.push_back(k & 1 ? lo.top() : ((double)lo.top() + (double)hi.top()) * 0.5);\n        if (i >= nums.size())\n            break;                          // break if all elements processed\n        int out_num = nums[i - k],          // outgoing element\n            in_num = nums[i++],             // incoming element\n            balance = 0;                    // balance factor\n        // number `out_num` exits window\n        balance += (out_num <= lo.top() ? -1 : 1);\n        hash_table[out_num]++;\n        // number `in_num` enters window\n        if (!lo.empty() && in_num <= lo.top()) {\n            balance++;\n            lo.push(in_num);\n        }\n        else {\n            balance--;\n            hi.push(in_num);\n        }\n        // re-balance heaps\n        if (balance < 0) {                  // `lo` needs more valid elements\n            lo.push(hi.top());\n            hi.pop();\n            balance++;\n        }\n        if (balance > 0) {                  // `hi` needs more valid elements\n            hi.push(lo.top());\n            lo.pop();\n            balance--;\n        }\n        // remove invalid numbers that should be discarded from heap tops\n        while (hash_table[lo.top()]) {\n            hash_table[lo.top()]--;\n            lo.pop();\n        }\n        while (!hi.empty() && hash_table[hi.top()]) {\n            hash_table[hi.top()]--;\n            hi.pop();\n        }\n    }\n    return medians;\n}\n", "vector<double> medianSlidingWindow(vector<int>& nums, int k)\n{\n    vector<double> medians;\n    multiset<int> lo, hi;\n    for (int i = 0; i < nums.size(); i++) {\n        //remove outgoing element\n        if (i >= k) {\n            if (nums[i - k] <= *lo.rbegin())\n                lo.erase(lo.find(nums[i - k]));\n            else\n                hi.erase(hi.find(nums[i - k]));\n        }\n        // insert incoming element\n        lo.insert(nums[i]);\n        // balance the sets\n        hi.insert(*lo.rbegin());\n        lo.erase(prev(lo.end()));\n        if (lo.size() < hi.size()) {\n            lo.insert(*hi.begin());\n            hi.erase(hi.begin());\n        }\n        // get median\n        if (i >= k - 1) {\n            medians.push_back(k & 1 ? *lo.rbegin() : ((double)(*lo.rbegin()) + (double)(*hi.begin())) * 0.5);\n        }\n    }\n    return medians;\n}\n", "vector<double> medianSlidingWindow(vector<int>& nums, int k)\n{\n    vector<double> medians;\n    multiset<int> window(nums.begin(), nums.begin() + k);\n    auto mid = next(window.begin(), k / 2);\n    for (int i = k;; i++) {\n        // Push the current median\n        medians.push_back(((double)(*mid) + *next(mid, k % 2 - 1)) * 0.5);\n        // If all done, break\n        if (i == nums.size())\n            break;\n        // Insert incoming element\n        window.insert(nums[i]);\n        if (nums[i] < *mid)\n            mid--;                  // same as mid = prev(mid)\n        // Remove outgoing element\n        if (nums[i - k] <= *mid)\n            mid++;                  // same as mid = next(mid)\n        window.erase(window.lower_bound(nums[i - k]));\n    }\n    return medians;\n}\n"]}
{"number": 484, "statement": "By now, you are given a secret signature consisting of character 'D' and 'I'. 'D' represents a decreasing relationship between two numbers, 'I' represents an increasing relationship between two numbers. And our secret signature was constructed by a special integer array, which contains uniquely all the different number from 1 to n (n is the length of the secret signature plus 1). For example, the secret signature \"DI\" can be constructed by array [2,1,3] or [3,1,2], but won't be constructed by array [3,2,4] or [2,1,3,4], which are both illegal constructing special string that can't represent the \"DI\" secret signature.\nOn the other hand, now your job is to find the lexicographically smallest permutation of [1, 2, ... n] could refer to the given secret signature in the input.\n", "solutions": ["public class Solution {\n    public int[] findPermutation(String s) {\n        int[] res = new int[s.length() + 1];\n        Stack < Integer > stack = new Stack < > ();\n        int j = 0;\n        for (int i = 1; i <= s.length(); i++) {\n            if (s.charAt(i - 1) == 'I') {\n                stack.push(i);\n                while (!stack.isEmpty())\n                    res[j++] = stack.pop();\n            } else\n                stack.push(i);\n        }\n        stack.push(s.length() + 1);\n        while (!stack.isEmpty())\n            res[j++] = stack.pop();\n        return res;\n    }\n}\n", "public class Solution {\n    public int[] findPermutation(String s) {\n        int[] res = new int[s.length() + 1];\n        for (int i = 0; i < res.length; i++)\n            res[i] = i + 1;\n        int i = 1;\n        while (i <= s.length()) {\n            int j = i;\n            while (i <= s.length() && s.charAt(i - 1) == 'D')\n                i++;\n            reverse(res, j - 1, i);\n            i++;\n        }\n        return res;\n    }\n    public void reverse(int[] a, int start, int end) {\n        for (int i = 0; i < (end - start) / 2; i++) {\n            int temp = a[i + start];\n            a[i + start] = a[end - i - 1];\n            a[end - i - 1] = temp;\n        }\n    }\n}\n", "public class Solution {\n    public int[] findPermutation(String s) {\n        int[] res = new int[s.length() + 1];\n        res[0]=1;\n        int i = 1;\n        while (i <= s.length()) {\n            res[i]=i+1;\n            int j = i;\n            if(s.charAt(i-1)=='D')\n            {\n                while (i <= s.length() && s.charAt(i - 1) == 'D')\n                    i++;\n                for (int k = j - 1, c = i; k <= i - 1; k++, c--) {\n                    res[k] = c;\n                }\n            }\n            else\n                i++;\n        }\n        return res;\n    }\n}\n"]}
{"number": 485, "statement": "Given a binary array, find the maximum number of consecutive 1s in this array.\n", "solutions": ["class Solution {\n  public int findMaxConsecutiveOnes(int[] nums) {\n    int count = 0;\n    int maxCount = 0;\n    for(int i = 0; i < nums.length; i++) {\n      if(nums[i] == 1) {\n        // Increment the count of 1's by one.\n        count += 1;\n      } else {\n        // Find the maximum till now.\n        maxCount = Math.max(maxCount, count);\n        // Reset count of 1.\n        count = 0;\n      }\n    }\n    return Math.max(maxCount, count);\n  }\n}\n"]}
{"number": 486, "statement": "Given an array of scores that are non-negative integers. Player 1 picks one of the numbers from either end of the array followed by the player 2 and then player 1 and so on. Each time a player picks a number, that number will not be available for the next player. This continues until all the scores have been chosen. The player with the maximum score wins. \nGiven an array of scores, predict whether player 1 is the winner. You can assume each player plays to maximize his score. \n", "solutions": ["public class Solution {\n    public boolean PredictTheWinner(int[] nums) {\n        return winner(nums, 0, nums.length - 1, 1) >= 0;\n    }\n    public int winner(int[] nums, int s, int e, int turn) {\n        if (s == e)\n            return turn * nums[s];\n        int a = turn * nums[s] + winner(nums, s + 1, e, -turn);\n        int b = turn * nums[e] + winner(nums, s, e - 1, -turn);\n        return turn * Math.max(turn * a, turn * b);\n    }\n}\n", "public class Solution {\n    public boolean PredictTheWinner(int[] nums) {\n        Integer[][] memo = new Integer[nums.length][nums.length];\n        return winner(nums, 0, nums.length - 1, memo) >= 0;\n    }\n    public int winner(int[] nums, int s, int e, Integer[][] memo) {\n        if (s == e)\n            return nums[s];\n        if (memo[s][e] != null)\n            return memo[s][e];\n        int a = nums[s] - winner(nums, s + 1, e, memo);\n        int b = nums[e] - winner(nums, s, e - 1, memo);\n        memo[s][e] = Math.max(a, b);\n        return memo[s][e];\n    }\n}\n", "public class Solution {\n    public boolean PredictTheWinner(int[] nums) {\n        int[][] dp = new int[nums.length + 1][nums.length];\n        for (int s = nums.length; s >= 0; s--) {\n            for (int e = s + 1; e < nums.length; e++) {\n                int a = nums[s] - dp[s + 1][e];\n                int b = nums[e] - dp[s][e - 1];\n                dp[s][e] = Math.max(a, b);\n            }\n        }\n        return dp[0][nums.length - 1] >= 0;\n    }\n}\n", "public class Solution {\n    public boolean PredictTheWinner(int[] nums) {\n        int[] dp = new int[nums.length];\n        for (int s = nums.length; s >= 0; s--) {\n            for (int e = s + 1; e < nums.length; e++) {\n                int a = nums[s] - dp[e];\n                int b = nums[e] - dp[e - 1];\n                dp[e] = Math.max(a, b);\n            }\n        }\n        return dp[nums.length - 1] >= 0;\n    }\n}\n"]}
{"number": 489, "statement": "Given a robot cleaner in a room modeled as a grid.\nEach cell in the grid can be empty or blocked.\nThe robot cleaner with 4 given APIs can move forward, turn left or turn right. Each turn it made is 90 degrees.\nWhen it tries to move into a blocked cell, its bumper sensor detects the obstacle and it stays on the current cell.\nDesign an algorithm to clean the entire room using only the 4 given APIs shown below.\ninterface Robot {\n // returns true if next cell is open and robot moves into the cell.\n // returns false if next cell is obstacle and robot stays on the current cell.\n boolean move();\n  // Robot will stay on the same cell after calling turnLeft/turnRight.\n // Each turn will be 90 degrees.\n void turnLeft();\n void turnRight();\n  // Clean the current cell.\n  void clean();\n}\n", "solutions": ["class Solution {\n  // going clockwise : 0: 'up', 1: 'right', 2: 'down', 3: 'left'\n  int[][] directions = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};\n  Set<Pair<Integer, Integer>> visited = new HashSet();\n  Robot robot;\n  public void goBack() {\n    robot.turnRight();\n    robot.turnRight();\n    robot.move();\n    robot.turnRight();\n    robot.turnRight();\n  }\n  public void backtrack(int row, int col, int d) {\n    visited.add(new Pair(row, col));\n    robot.clean();\n    // going clockwise : 0: 'up', 1: 'right', 2: 'down', 3: 'left'\n    for (int i = 0; i < 4; ++i) {\n      int newD = (d + i) % 4;\n      int newRow = row + directions[newD][0];\n      int newCol = col + directions[newD][1];\n      if (!visited.contains(new Pair(newRow, newCol)) && robot.move()) {\n        backtrack(newRow, newCol, newD);\n        goBack();\n      }\n      // turn the robot following chosen direction : clockwise\n      robot.turnRight();\n    }\n  }\n  public void cleanRoom(Robot robot) {\n    this.robot = robot;\n    backtrack(0, 0, 0);\n  }\n}\n"]}
{"number": 490, "statement": "There is a ball in a maze with empty spaces and walls. The ball can go through empty spaces by rolling up, down, left or right, but it won't stop rolling until hitting a wall. When the ball stops, it could choose the next direction.\nGiven the ball's start position, the destination and the maze, determine whether the ball could stop at the destination.\nThe maze is represented by a binary 2D array. 1 means the wall and 0 means the empty space. You may assume that the borders of the maze are all walls. The start and destination coordinates are represented by row and column indexes.\n", "solutions": ["public class Solution {\n    public boolean hasPath(int[][] maze, int[] start, int[] destination) {\n        boolean[][] visited = new boolean[maze.length][maze[0].length];\n        return dfs(maze, start, destination, visited);\n    }\n    public boolean dfs(int[][] maze, int[] start, int[] destination, boolean[][] visited) {\n        if (visited[start[0]][start[1]])\n            return false;\n        if (start[0] == destination[0] && start[1] == destination[1])\n            return true;\n        visited[start[0]][start[1]] = true;\n        int r = start[1] + 1, l = start[1] - 1, u = start[0] - 1, d = start[0] + 1;\n        while (r < maze[0].length && maze[start[0]][r] == 0) // right\n            r++;\n        if (dfs(maze, new int[] {start[0], r - 1}, destination, visited))\n            return true;\n        while (l >= 0 && maze[start[0]][l] == 0) //left\n            l--;\n        if (dfs(maze, new int[] {start[0], l + 1}, destination, visited))\n            return true;\n        while (u >= 0 && maze[u][start[1]] == 0) //up\n            u--;\n        if (dfs(maze, new int[] {u + 1, start[1]}, destination, visited))\n            return true;\n        while (d < maze.length && maze[d][start[1]] == 0) //down\n            d++;\n        if (dfs(maze, new int[] {d - 1, start[1]}, destination, visited))\n            return true;\n        return false;\n    }\n}\n", "public class Solution {\n    public boolean hasPath(int[][] maze, int[] start, int[] destination) {\n        boolean[][] visited = new boolean[maze.length][maze[0].length];\n        int[][] dirs={{0, 1}, {0, -1}, {-1, 0}, {1, 0}};\n        Queue < int[] > queue = new LinkedList < > ();\n        queue.add(start);\n        visited[start[0]][start[1]] = true;\n        while (!queue.isEmpty()) {\n            int[] s = queue.remove();\n            if (s[0] == destination[0] && s[1] == destination[1])\n                return true;\n            for (int[] dir: dirs) {\n                int x = s[0] + dir[0];\n                int y = s[1] + dir[1];\n                while (x >= 0 && y >= 0 && x < maze.length && y < maze[0].length && maze[x][y] == 0) {\n                    x += dir[0];\n                    y += dir[1];\n                }\n                if (!visited[x - dir[0]][y - dir[1]]) {\n                    queue.add(new int[] {x - dir[0], y - dir[1]});\n                    visited[x - dir[0]][y - dir[1]] = true;\n                }\n            }\n        }\n        return false;\n    }\n}\n"]}
{"number": 493, "statement": "Given an array nums, we call (i, j) an important reverse pair if i  j and nums[i]  2*nums[j].\nYou need to return the number of important reverse pairs in the given array.\n", "solutions": ["int reversePairs(vector<int>& nums)\n{\n    int n = nums.size();\n    int count = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < i; j++) {\n            if (nums[j] > nums[i] * 2LL)\n                count++;\n        }\n    }\n    return count;\n}\n", "def reversePairs(self, nums):\n  return sum([nums[j] > 2 * nums[i] for i in range(len(nums)) for j in range(0 , i)])\n", "class Node {\npublic:\n    Node *left, *right;\n    int val;\n    int count_ge;\n    Node(int val)\n    {\n        this->val = val;\n        this->count_ge = 1;\n        this->left = NULL;\n        this->right = NULL;\n    }\n};\nNode* insert(Node* head, int val)\n{\n    if (head == NULL)\n        return new Node(val);\n    else if (val == head->val)\n        head->count_ge++;\n    else if (val < head->val)\n        head->left = insert(head->left, val);\n    else {\n        head->count_ge++;\n        head->right = insert(head->right, val);\n    }\n    return head;\n}\nint search(Node* head, long long target)\n{\n    if (head == NULL)\n        return 0;\n    else if (target == head->val)\n        return head->count_ge;\n    else if (target < head->val)\n        return head->count_ge + search(head->left, target);\n    else\n        return search(head->right, target);\n}\nint reversePairs(vector<int>& nums)\n{\n    Node* head = NULL;\n    int n = nums.size();\n    int count = 0;\n    for (int i = 0; i < n; i++) {\n        count += search(head, nums[i] * 2LL + 1);\n        head = insert(head, nums[i]);\n    }\n    return count;\n}\n", "void update(vector<int>& BIT, int index, int val)\n{\n    while (index > 0) {\n        BIT[index] += val;\n        index -= index & (-index);\n    }\n}\nint query(vector<int>& BIT, int index)\n{\n    int sum = 0;\n    while (index < BIT.size()) {\n        sum += BIT[index];\n        index += index & (-index);\n    }\n    return sum;\n}\nint reversePairs(vector<int>& nums)\n{\n    int n = nums.size();\n    vector<int> nums_copy(nums);\n    sort(nums_copy.begin(), nums_copy.end());\n    vector<int> BITS(n + 1, 0);\n    int count = 0;\n    for (int i = 0; i < n; i++) {\n        count += query(BITS, lower_bound(nums_copy.begin(), nums_copy.end(), 2LL * nums[i] + 1) - nums_copy.begin() + 1);\n        update(BITS, lower_bound(nums_copy.begin(), nums_copy.end(), nums[i]) - nums_copy.begin() + 1, 1);\n    }\n    return count;\n}\n", "void merge(vector<int>& A, int start, int mid, int end)\n{\n    int n1 = (mid - start + 1);\n    int n2 = (end - mid);\n    int L[n1], R[n2];\n    for (int i = 0; i < n1; i++)\n        L[i] = A[start + i];\n    for (int j = 0; j < n2; j++)\n        R[j] = A[mid + 1 + j];\n    int i = 0, j = 0;\n    for (int k = start; k <= end; k++) {\n        if (j >= n2 || (i < n1 && L[i] <= R[j]))\n            A[k] = L[i++];\n        else\n            A[k] = R[j++];\n    }\n}\nint mergesort_and_count(vector<int>& A, int start, int end)\n{\n    if (start < end) {\n        int mid = (start + end) / 2;\n        int count = mergesort_and_count(A, start, mid) + mergesort_and_count(A, mid + 1, end);\n        int j = mid + 1;\n        for (int i = start; i <= mid; i++) {\n            while (j <= end && A[i] > A[j] * 2LL)\n                j++;\n            count += j - (mid + 1);\n        }\n        merge(A, start, mid, end);\n        return count;\n    }\n    else\n        return 0;\n}\nint reversePairs(vector<int>& nums)\n{\n    return mergesort_and_count(nums, 0, nums.size() - 1);\n}\n"]}
{"number": 494, "statement": "You are given a list of non-negative integers, a1, a2, ..., an, and a target, S. Now you have 2 symbols + and -. For each integer, you should choose one from + and - as its new symbol.\nFind out how many ways to assign symbols to make sum of integers equal to target S.  \n", "solutions": ["public class Solution {\n    int count = 0;\n    public int findTargetSumWays(int[] nums, int S) {\n        calculate(nums, 0, 0, S);\n        return count;\n    }\n    public void calculate(int[] nums, int i, int sum, int S) {\n        if (i == nums.length) {\n            if (sum == S)\n                count++;\n        } else {\n            calculate(nums, i + 1, sum + nums[i], S);\n            calculate(nums, i + 1, sum - nums[i], S);\n        }\n    }\n}\n", "public class Solution {\n    int count = 0;\n    public int findTargetSumWays(int[] nums, int S) {\n        int[][] memo = new int[nums.length][2001];\n        for (int[] row: memo)\n            Arrays.fill(row, Integer.MIN_VALUE);\n        return calculate(nums, 0, 0, S, memo);\n    }\n    public int calculate(int[] nums, int i, int sum, int S, int[][] memo) {\n        if (i == nums.length) {\n            if (sum == S)\n                return 1;\n            else\n                return 0;\n        } else {\n            if (memo[i][sum + 1000] != Integer.MIN_VALUE) {\n                return memo[i][sum + 1000];\n            }\n            int add = calculate(nums, i + 1, sum + nums[i], S, memo);\n            int subtract = calculate(nums, i + 1, sum - nums[i], S, memo);\n            memo[i][sum + 1000] = add + subtract;\n            return memo[i][sum + 1000];\n        }\n    }\n}\n", "public class Solution {\n    public int findTargetSumWays(int[] nums, int S) {\n        int[][] dp = new int[nums.length][2001];\n        dp[0][nums[0] + 1000] = 1;\n        dp[0][-nums[0] + 1000] += 1;\n        for (int i = 1; i < nums.length; i++) {\n            for (int sum = -1000; sum <= 1000; sum++) {\n                if (dp[i - 1][sum + 1000] > 0) {\n                    dp[i][sum + nums[i] + 1000] += dp[i - 1][sum + 1000];\n                    dp[i][sum - nums[i] + 1000] += dp[i - 1][sum + 1000];\n                }\n            }\n        }\n        return S > 1000 ? 0 : dp[nums.length - 1][S + 1000];\n    }\n}\n", "public class Solution {\n    public int findTargetSumWays(int[] nums, int S) {\n        int[] dp = new int[2001];\n        dp[nums[0] + 1000] = 1;\n        dp[-nums[0] + 1000] += 1;\n        for (int i = 1; i < nums.length; i++) {\n            int[] next = new int[2001];\n            for (int sum = -1000; sum <= 1000; sum++) {\n                if (dp[sum + 1000] > 0) {\n                    next[sum + nums[i] + 1000] += dp[sum + 1000];\n                    next[sum - nums[i] + 1000] += dp[sum + 1000];\n                }\n            }\n            dp = next;\n        }\n        return S > 1000 ? 0 : dp[S + 1000];\n    }\n}\n"]}
{"number": 495, "statement": "In LOL world, there is a hero called Teemo and his attacking can make his enemy Ashe be in poisoned condition. Now, given the Teemo's attacking ascending time series towards Ashe and the poisoning time duration per Teemo's attacking, you need to output the total time that Ashe is in poisoned condition.\nYou may assume that Teemo attacks at the very beginning of a specific time point, and makes Ashe be in poisoned condition immediately.\n", "solutions": ["class Solution {\n  public int findPoisonedDuration(int[] timeSeries, int duration) {\n    int n = timeSeries.length;\n    if (n == 0) return 0;\n    int total = 0;\n    for(int i = 0; i < n - 1; ++i)\n      total += Math.min(timeSeries[i + 1] - timeSeries[i], duration);\n    return total + duration;\n  }\n}\n"]}
{"number": 496, "statement": "You are given two arrays (without duplicates) nums1 and nums2 where nums1\u2019s elements are subset of nums2. Find all the next greater numbers for nums1's elements in the corresponding places of nums2. \nThe Next Greater Number of a number x in nums1 is the first greater number to its right in nums2. If it does not exist, output -1 for this number.\n", "solutions": ["public class Solution {\n    public int[] nextGreaterElement(int[] findNums, int[] nums) {\n        int[] res = new int[findNums.length];\n        int j;\n        for (int i = 0; i < findNums.length; i++) {\n            boolean found = false;\n            for (j = 0; j < nums.length; j++) {\n                if (found && nums[j] > findNums[i]) {\n                    res[i] = nums[j];\n                    break;\n                }\n                if (nums[j] == findNums[i]) {\n                    found = true;\n                }\n            }\n            if (j == nums.length) {\n                res[i] = -1;\n            }\n        }\n        return res;\n    }\n}\n", "public class Solution {\n    public int[] nextGreaterElement(int[] findNums, int[] nums) {\n        HashMap < Integer, Integer > hash = new HashMap < > ();\n        int[] res = new int[findNums.length];\n        int j;\n        for (int i = 0; i < nums.length; i++) {\n            hash.put(nums[i], i);\n        }\n        for (int i = 0; i < findNums.length; i++) {\n            for (j = hash.get(findNums[i]) + 1; j < nums.length; j++) {\n                if (findNums[i] < nums[j]) {\n                    res[i] = nums[j];\n                    break;\n                }\n            }\n            if (j == nums.length) {\n                res[i] = -1;\n            }\n        }\n        return res;\n    }\n}\n", "public class Solution {\n    public int[] nextGreaterElement(int[] findNums, int[] nums) {\n        Stack < Integer > stack = new Stack < > ();\n        HashMap < Integer, Integer > map = new HashMap < > ();\n        int[] res = new int[findNums.length];\n        for (int i = 0; i < nums.length; i++) {\n            while (!stack.empty() && nums[i] > stack.peek())\n                map.put(stack.pop(), nums[i]);\n            stack.push(nums[i]);\n        }\n        while (!stack.empty())\n            map.put(stack.pop(), -1);\n        for (int i = 0; i < findNums.length; i++) {\n            res[i] = map.get(findNums[i]);\n        }\n        return res;\n    }\n}\n"]}
{"number": 497, "statement": "Given a list of non-overlappingaxis-aligned rectangles rects, write a function pick which randomly and uniformily picks an integer point in the spacecovered by the rectangles.\nNote:\nAn integer pointis a point that has integer coordinates.\nA pointon the perimeterof a rectangle isincluded in the space covered by the rectangles.\nith rectangle = rects[i] =[x1,y1,x2,y2], where [x1, y1]are the integer coordinates of the bottom-left corner, and [x2, y2]are the integer coordinates of the top-right corner.\nlength and width of each rectangle does not exceed 2000.\n1 = rects.length= 100\npick return a point as an array of integer coordinates[p_x, p_y]\npick is called at most 10000times.\n", "solutions": ["class Solution {\npublic:\n    vector<vector<int>> rects;\n    vector<int> psum;\n    int tot = 0;\n    //c++11 random integer generation\n    mt19937 rng{random_device{}()};\n    uniform_int_distribution<int> uni;\n    Solution(vector<vector<int>> rects) {\n        this->rects = rects;\n        for (auto& x : rects) {\n            tot += (x[2] - x[0] + 1) * (x[3] - x[1] + 1);\n            psum.push_back(tot);\n        }\n        uni = uniform_int_distribution<int>{0, tot - 1};\n    }\n    vector<int> pick() {\n        int targ = uni(rng);\n        int lo = 0;\n        int hi = rects.size() - 1;\n        while (lo != hi) {\n            int mid = (lo + hi) / 2;\n            if (targ >= psum[mid]) lo = mid + 1;\n            else hi = mid;\n        }\n        auto& x = rects[lo];\n        int width = x[2] - x[0] + 1;\n        int height = x[3] - x[1] + 1;\n        int base = psum[lo] - width * height;\n        return {x[0] + (targ - base) % width, x[1] + (targ - base) / width};\n    }\n};\n"]}
{"number": 498, "statement": "Given a matrix of M x N elements (M rows, N columns), return all elements of the matrix in diagonal order as shown in the below image.\n", "solutions": ["class Solution {\n    public int[] findDiagonalOrder(int[][] matrix) {\n        \n        // Check for empty matrices\n        if (matrix == null || matrix.length == 0) {\n            return new int[0];\n        }\n        \n        // Variables to track the size of the matrix\n        int N = matrix.length;\n        int M = matrix[0].length;\n        \n        // The two arrays as explained in the algorithm\n        int[] result = new int[N*M];\n        int k = 0;\n        ArrayList<Integer> intermediate = new ArrayList<Integer>();\n        \n        // We have to go over all the elements in the first\n        // row and the last column to cover all possible diagonals\n        for (int d = 0; d < N + M - 1; d++) {\n            \n            // Clear the intermediate array every time we start\n            // to process another diagonal\n            intermediate.clear();\n            \n            // We need to figure out the \"head\" of this diagonal\n            // The elements in the first row and the last column\n            // are the respective heads.\n            int r = d < M ? 0 : d - M + 1;\n            int c = d < M ? d : M - 1;\n            \n            // Iterate until one of the indices goes out of scope\n            // Take note of the index math to go down the diagonal\n            while (r < N && c > -1) {\n                \n                intermediate.add(matrix[r][c]);\n                ++r;\n                --c;\n            }\n                \n            // Reverse even numbered diagonals. The\n            // article says we have to reverse odd \n            // numbered articles but here, the numbering\n            // is starting from 0 :P\n            if (d % 2 == 0) {\n                Collections.reverse(intermediate);\n            }\n            \n            for (int i = 0; i < intermediate.size(); i++) {\n                result[k++] = intermediate.get(i);\n            }\n        }\n        return result;\n    }\n}\n", "class Solution {\n    public int[] findDiagonalOrder(int[][] matrix) {\n        \n        // Check for empty matrices\n        if (matrix == null || matrix.length == 0) {\n            return new int[0];\n        }\n        \n        // Variables to track the size of the matrix\n        int N = matrix.length;\n        int M = matrix[0].length;\n        \n        // Incides that will help us progress through \n        // the matrix, one element at a time.\n        int row = 0, column = 0;\n        \n        // As explained in the article, this is the variable\n        // that helps us keep track of what direction we are\n        // processing the current diaonal\n        int direction = 1;\n        \n         // The final result array\n        int[] result = new int[N*M];\n        int r = 0;\n        \n        // The uber while loop which will help us iterate over all\n        // the elements in the array.\n        while (row < N && column < M) {\n            \n            // First and foremost, add the current element to \n            // the result matrix. \n            result[r++] = matrix[row][column];\n            \n            // Move along in the current diagonal depending upon\n            // the current direction.[i, j] -> [i - 1, j + 1] if \n            // going up and [i, j] -> [i + 1][j - 1] if going down.\n            int new_row = row + (direction == 1 ? -1 : 1);\n            int new_column = column + (direction == 1 ? 1 : -1);\n            \n            // Checking if the next element in the diagonal is within the\n            // bounds of the matrix or not. If it's not within the bounds,\n            // we have to find the next head. \n            if (new_row < 0 || new_row == N || new_column < 0 || new_column == M) {\n                \n                // If the current diagonal was going in the upwards\n                // direction.\n                if (direction == 1) {\n                    \n                    // For an upwards going diagonal having [i, j] as its tail\n                    // If [i, j + 1] is within bounds, then it becomes\n                    // the next head. Otherwise, the element directly below\n                    // i.e. the element [i + 1, j] becomes the next head\n                    row += (column == M - 1 ? 1 : 0) ;\n                    column += (column < M - 1 ? 1 : 0);\n                        \n                } else {\n                    \n                    // For a downwards going diagonal having [i, j] as its tail\n                    // if [i + 1, j] is within bounds, then it becomes\n                    // the next head. Otherwise, the element directly below\n                    // i.e. the element [i, j + 1] becomes the next head\n                    column += (row == N - 1 ? 1 : 0);\n                    row += (row < N - 1 ? 1 : 0);\n                }\n                    \n                // Flip the direction\n                direction = 1 - direction;        \n                        \n            } else {\n                \n                row = new_row;\n                column = new_column;\n            }\n        }\n        return result;      \n    }\n}\n"]}
{"number": 502, "statement": "Suppose LeetCode will start its IPO soon. In order to sell a good price of its shares to Venture Capital, LeetCode would like to work on some projects to increase its capital before the IPO. Since it has limited resources, it can only finish at most k distinct projects before the IPO. Help LeetCode design the best way to maximize its total capital after finishing at most k distinct projects. \nYou are given several projects. For each project i, it has a pure profit Pi and a minimum capital of Ci is needed to start the corresponding project. Initially, you have W capital. When you finish a project, you will obtain its pure profit and the profit will be added to your total capital.\nTo sum up, pick a list of at most k distinct projects from given projects to maximize your final capital, and output your final maximized capital.\n", "solutions": ["class Solution {\n  public int findMaximizedCapital(int k, int W, int[] Profits, int[] Capital) {\n    // to speed up: if all projects are available\n    boolean speedUp = true;\n    for (int c: Capital) if (W < c) speedUp = false;\n    if (speedUp) {\n      PriorityQueue<Integer> heap = new PriorityQueue<>();\n      for (int p: Profits) {\n        heap.add(p);\n        if (heap.size() > k) heap.poll();\n      }\n      for (int h: heap) W += h;\n      return W;\n    }\n    int n = Profits.length;\n    // sort the projects\n    // the most available (= the smallest capital) is the head of the heap\n    PriorityQueue<int[]> projects = new PriorityQueue<>((x, y) -> (x[0] - y[0]));\n    for(int i = 0; i < n; i++) {\n      projects.add(new int[] {Capital[i], Profits[i]});\n    }\n    // max heap\n    PriorityQueue<Integer> available = new PriorityQueue<>((x, y) -> (y - x));\n    while (k > 0) {\n      // update available projects\n      while (!projects.isEmpty() && projects.peek()[0] <= W)\n        available.add(projects.poll()[1]);\n      // if there are available projects,\n      // pick the most profitable one\n      if (!available.isEmpty()) W += available.poll();\n      // not enough capital to start any project\n      else break;\n      --k;\n    }\n    return W;\n  }\n}\n", "class Solution {\n    public int findMaximizedCapital(int k, int W, int[] Profits, int[] Capital) {\n        // to speed up: if all projects are available\n        boolean speedUp = true;\n        for (int c: Capital) if (W < c) speedUp = false;\n        if (speedUp) {\n            PriorityQueue<Integer> heap = new PriorityQueue<>();\n            for (int p: Profits) {\n                heap.add(p);\n                if (heap.size() > k) heap.poll();    \n            }\n            for (int h: heap) W += h; \n            return W;\n        }\n        \n        int idx;\n        int n = Profits.length;\n        for(int i = 0; i < Math.min(k, n); ++i) {\n            idx = -1; \n            // if there are available projects,\n            // pick the most profitable one\n            for(int j = 0; j < n; ++j) { \n                if (W >= Capital[j]) {\n                    if (idx == -1 ) idx = j;\n                    else if (Profits[idx] < Profits[j]) idx = j;\n                }\n            }\n            // not enough capital to start any project\n            if(idx == -1) break;\n            \n            // add the profit from chosen project\n            // and remove the project from further consideration\n            W += Profits[idx];\n            Capital[idx] = Integer.MAX_VALUE;                \n        }\n        return  W;\n    }\n}\n"]}
{"number": 503, "statement": "Given a circular array (the next element of the last element is the first element of the array), print the Next Greater Number for every element. The Next Greater Number of a number x is the first greater number to its traversing-order next in the array, which means you could search circularly to find its next greater number. If it doesn't exist, output -1 for this number.\n", "solutions": [" public class Solution {\n    public int[] nextGreaterElements(int[] nums) {\n        int[] res = new int[nums.length];\n        int[] doublenums = new int[nums.length * 2];\n        System.arraycopy(nums, 0, doublenums, 0, nums.length);\n        System.arraycopy(nums, 0, doublenums, nums.length, nums.length);\n        for (int i = 0; i < nums.length; i++) {\n            res[i]=-1;\n            for (int j = i + 1; j < doublenums.length; j++) {\n                if (doublenums[j] > doublenums[i]) {\n                    res[i] = doublenums[j];\n                    break;\n                }\n            }\n        }\n        return res;\n    }\n}\n", " public class Solution {\n    public int[] nextGreaterElements(int[] nums) {\n        int[] res = new int[nums.length];\n        for (int i = 0; i < nums.length; i++) {\n            res[i] = -1;\n            for (int j = 1; j < nums.length; j++) {\n                if (nums[(i + j) % nums.length] > nums[i]) {\n                    res[i] = nums[(i + j) % nums.length];\n                    break;\n                }\n            }\n        }\n        return res;\n    }\n}\n", "public class Solution {\n    public int[] nextGreaterElements(int[] nums) {\n        int[] res = new int[nums.length];\n        Stack<Integer> stack = new Stack<>();\n        for (int i = 2 * nums.length - 1; i >= 0; --i) {\n            while (!stack.empty() && nums[stack.peek()] <= nums[i % nums.length]) {\n                stack.pop();\n            }\n            res[i % nums.length] = stack.empty() ? -1 : nums[stack.peek()];\n            stack.push(i % nums.length);\n        }\n        return res;\n    }\n}\n"]}
{"number": 505, "statement": "There is a ball in a maze with empty spaces and walls. The ball can go through empty spaces by rolling up, down, left or right, but it won't stop rolling until hitting a wall. When the ball stops, it could choose the next direction.\nGiven the ball's start position, the destination and the maze, find the shortest distance for the ball to stop at the destination. The distance is defined by the number of empty spaces traveled by the ball from the start position (excluded) to the destination (included). If the ball cannot stop at the destination, return -1.\nThe maze is represented by a binary 2D array. 1 means the wall and 0 means the empty space. You may assume that the borders of the maze are all walls. The start and destination coordinates are represented by row and column indexes.\n", "solutions": ["public class Solution {\n    public int shortestDistance(int[][] maze, int[] start, int[] dest) {\n        int[][] distance = new int[maze.length][maze[0].length];\n        for (int[] row: distance)\n            Arrays.fill(row, Integer.MAX_VALUE);\n        distance[start[0]][start[1]] = 0;\n        dfs(maze, start, distance);\n        return distance[dest[0]][dest[1]] == Integer.MAX_VALUE ? -1 : distance[dest[0]][dest[1]];\n    }\n    public void dfs(int[][] maze, int[] start, int[][] distance) {\n        int[][] dirs={{0,1}, {0,-1}, {-1,0}, {1,0}};\n        for (int[] dir: dirs) {\n            int x = start[0] + dir[0];\n            int y = start[1] + dir[1];\n            int count = 0;\n            while (x >= 0 && y >= 0 && x < maze.length && y < maze[0].length && maze[x][y] == 0) {\n                x += dir[0];\n                y += dir[1];\n                count++;\n            }\n            if (distance[start[0]][start[1]] + count < distance[x - dir[0]][y - dir[1]]) {\n                distance[x - dir[0]][y - dir[1]] = distance[start[0]][start[1]] + count;\n                dfs(maze, new int[]{x - dir[0],y - dir[1]}, distance);\n            }\n        }\n    }\n}\n", "public class Solution {\n    public int shortestDistance(int[][] maze, int[] start, int[] dest) {\n        int[][] distance = new int[maze.length][maze[0].length];\n        for (int[] row: distance)\n            Arrays.fill(row, Integer.MAX_VALUE);\n        distance[start[0]][start[1]] = 0;\n         int[][] dirs={{0, 1} ,{0, -1}, {-1, 0}, {1, 0}};\n        Queue < int[] > queue = new LinkedList < > ();\n        queue.add(start);\n        while (!queue.isEmpty()) {\n            int[] s = queue.remove();\n            for (int[] dir: dirs) {\n                int x = s[0] + dir[0];\n                int y = s[1] + dir[1];\n                int count = 0;\n                while (x >= 0 && y >= 0 && x < maze.length && y < maze[0].length && maze[x][y] == 0) {\n                    x += dir[0];\n                    y += dir[1];\n                    count++;\n                }\n                if (distance[s[0]][s[1]] + count < distance[x - dir[0]][y - dir[1]]) {\n                    distance[x - dir[0]][y - dir[1]] = distance[s[0]][s[1]] + count;\n                    queue.add(new int[] {x - dir[0], y - dir[1]});\n                }\n            }\n        }\n        return distance[dest[0]][dest[1]] == Integer.MAX_VALUE ? -1 : distance[dest[0]][dest[1]];\n    }\n}\n", "public class Solution {\n    public int shortestDistance(int[][] maze, int[] start, int[] dest) {\n        int[][] distance = new int[maze.length][maze[0].length];\n        boolean[][] visited = new boolean[maze.length][maze[0].length];\n        for (int[] row: distance)\n            Arrays.fill(row, Integer.MAX_VALUE);\n        distance[start[0]][start[1]] = 0;\n        dijkstra(maze, distance, visited);\n        return distance[dest[0]][dest[1]] == Integer.MAX_VALUE ? -1 : distance[dest[0]][dest[1]];\n    }\n    public int[] minDistance(int[][] distance, boolean[][] visited) {\n        int[] min={-1,-1};\n        int min_val = Integer.MAX_VALUE;\n        for (int i = 0; i < distance.length; i++) {\n            for (int j = 0; j < distance[0].length; j++) {\n                if (!visited[i][j] && distance[i][j] < min_val) {\n                    min = new int[] {i, j};\n                    min_val = distance[i][j];\n                }\n            }\n        }\n        return min;\n    }\n    public void dijkstra(int[][] maze, int[][] distance, boolean[][] visited) {\n        int[][] dirs={{0,1},{0,-1},{-1,0},{1,0}};\n        while (true) {\n            int[] s = minDistance(distance, visited);\n            if (s[0] < 0)\n                break;\n            visited[s[0]][s[1]] = true;\n            for (int[] dir: dirs) {\n                int x = s[0] + dir[0];\n                int y = s[1] + dir[1];\n                int count = 0;\n                while (x >= 0 && y >= 0 && x < maze.length && y < maze[0].length && maze[x][y] == 0) {\n                    x += dir[0];\n                    y += dir[1];\n                    count++;\n                }\n                if (distance[s[0]][s[1]] + count < distance[x - dir[0]][y - dir[1]]) {\n                    distance[x - dir[0]][y - dir[1]] = distance[s[0]][s[1]] + count;\n                }\n            }\n        }\n    }\n}\n", "public class Solution {\n    public int shortestDistance(int[][] maze, int[] start, int[] dest) {\n        int[][] distance = new int[maze.length][maze[0].length];\n        for (int[] row: distance)\n            Arrays.fill(row, Integer.MAX_VALUE);\n        distance[start[0]][start[1]] = 0;\n        dijkstra(maze, start, distance);\n        return distance[dest[0]][dest[1]] == Integer.MAX_VALUE ? -1 : distance[dest[0]][dest[1]];\n    }\n    public void dijkstra(int[][] maze, int[] start, int[][] distance) {\n        int[][] dirs={{0,1},{0,-1},{-1,0},{1,0}};\n        PriorityQueue < int[] > queue = new PriorityQueue < > ((a, b) -> a[2] - b[2]);\n        queue.offer(new int[]{start[0],start[1],0});\n        while (!queue.isEmpty()) {\n            int[] s = queue.poll();\n            if(distance[s[0]][s[1]] < s[2])\n                continue;\n            for (int[] dir: dirs) {\n                int x = s[0] + dir[0];\n                int y = s[1] + dir[1];\n                int count = 0;\n                while (x >= 0 && y >= 0 && x < maze.length && y < maze[0].length && maze[x][y] == 0) {\n                    x += dir[0];\n                    y += dir[1];\n                    count++;\n                }\n                if (distance[s[0]][s[1]] + count < distance[x - dir[0]][y - dir[1]]) {\n                    distance[x - dir[0]][y - dir[1]] = distance[s[0]][s[1]] + count;\n                    queue.offer(new int[]{x - dir[0], y - dir[1], distance[x - dir[0]][y - dir[1]]});\n                }\n            }\n        }\n    }\n}\n"]}
{"number": 507, "statement": "We define the Perfect Number is a positive integer that is equal to the sum of all its positive divisors except itself. \nNow, given an integer n, write a function that returns true when it is a perfect number and false when it is not.\n", "solutions": ["public class Solution {\n    public boolean checkPerfectNumber(int num) {\n        if (num <= 0) {\n            return false;\n        }\n        int sum = 0;\n        for (int i = 1; i < num; i++) {\n            if (num % i == 0) {\n                sum += i;\n            }\n        }\n        return sum == num;\n    }\n}\n", "public class Solution {\n    public boolean checkPerfectNumber(int num) {\n        if (num <= 0) {\n            return false;\n        }\n        int sum = 0;\n        for (int i = 1; i < num; i++) {\n            if (num % i == 0) {\n                sum += i;\n            }\n            if(sum>num) {\n                return false;\n            }\n        }\n        return sum == num;\n    }\n}\n", "    public boolean checkPerfectNumber(int num) {\n        if (num <= 0) {\n            return false;\n        }\n        int sum = 0;\n        for (int i = 1; i * i <= num; i++) {\n            if (num % i == 0) {\n                sum += i;\n                if (i * i != num) {\n                    sum += num / i;\n                }\n            }\n        }\n        return sum - num == num;\n    }\n}\n", "public class Solution {\n    public int pn(int p) {\n        return (1 << (p - 1)) * ((1 << p) - 1);\n    }\n    public boolean checkPerfectNumber(int num) {\n        int[] primes=new int[]{2,3,5,7,13,17,19,31};\n        for (int prime: primes) {\n            if (pn(prime) == num)\n                return true;\n        }\n        return false;\n    }\n}\n"]}
{"number": 509, "statement": "TheFibonacci numbers, commonly denotedF(n)form a sequence, called theFibonacci sequence, such that each number is the sum of the two preceding ones, starting from 0 and 1. That is,\nF(0) = 0, F(1)= 1\nF(N) = F(N - 1) + F(N - 2), for N  1.\nGiven N, calculate F(N).\n", "solutions": ["public class Solution {\n    public int fib(int N) {\n        if (N <= 1) {\n            return N;\n        }\n        return fib(N-1) + fib(N-2);\n    }\n}\n", "class Solution {\n    public int fib(int N) {\n        if (N <= 1) {\n            return N;\n        }\n        return memoize(N);\n    }\n    public int memoize(int N) {\n      int[] cache = new int[N + 1];\n      cache[1] = 1;\n      for (int i = 2; i <= N; i++) {\n          cache[i] = cache[i-1] + cache[i-2];\n      }\n      return cache[N];\n    }\n}\n", "class Solution {\n    private Integer[] cache = new Integer[31];\n    public int fib(int N) {\n        if (N <= 1) {\n            return N;\n        }\n        cache[0] = 0;\n        cache[1] = 1;\n        return memoize(N);\n    }\n    public int memoize(int N) {\n      if (cache[N] != null) {\n          return cache[N];\n      }\n      cache[N] = memoize(N-1) + memoize(N-2);\n      return memoize(N);\n    }\n}\n", "class Solution {\n    public int fib(int N) {\n        if (N <= 1) {\n            return N;\n        }\n        if (N == 2) {\n            return 1;\n        }\n        int current = 0;\n        int prev1 = 1;\n        int prev2 = 1;\n        for (int i = 3; i <= N; i++) {\n            current = prev1 + prev2;\n            prev2 = prev1;\n            prev1 = current;\n        }\n        return current;\n    }\n}\n", "class Solution {\n    int fib(int N) {\n        if (N <= 1) {\n          return N;\n        }\n        int[][] A = new int[][]{{1, 1}, {1, 0}};\n        matrixPower(A, N-1);\n        return A[0][0];\n    }\n    void matrixPower(int[][] A, int N) {\n        if (N <= 1) {\n          return;\n        }\n        matrixPower(A, N/2);\n        multiply(A, A);\n        int[][] B = new int[][]{{1, 1}, {1, 0}};\n        if (N%2 != 0) {\n            multiply(A, B);\n        }\n    }\n    void multiply(int[][] A, int[][] B) {\n        int x = A[0][0] * B[0][0] + A[0][1] * B[1][0];\n        int y = A[0][0] * B[0][1] + A[0][1] * B[1][1];\n        int z = A[1][0] * B[0][0] + A[1][1] * B[1][0];\n        int w = A[1][0] * B[0][1] + A[1][1] * B[1][1];\n        A[0][0] = x;\n        A[0][1] = y;\n        A[1][0] = z;\n        A[1][1] = w;\n    }\n}\n", "class Solution {\n    public int fib(int N) {\n        double goldenRatio = (1 + Math.sqrt(5)) / 2;\n        return (int)Math.round(Math.pow(goldenRatio, N)/ Math.sqrt(5));\n    }\n}\n"]}
{"number": 510, "statement": "Given a node in a binary search tree, findthe in-order successor of that node in the BST.\nIf that node has no in-order successor, returnnull.\nThe successor of a nodeis the node with the smallest key greater than node.val.\nYou will have direct access to the node but not to the root of the tree. Each node will have a reference to its parent node.Below is the definition for Node:\nclass Node {\n    public int val;\n    public Node left;\n    public Node right;\n    public Node parent;\n}\nFollow up:\nCould you solveit withoutlooking up any of thenode's values?\n", "solutions": ["class Solution {\npublic:\n    Node* inorderSuccessor(Node* node) {\n        // the successor is somewhere lower in the right subtree\n        if (node->right) {\n            node = node->right;\n            while (node->left) node = node->left;\n            return node;   \n        }\n        \n        // the successor is somewhere upper in the tree\n        while (node->parent && node == node->parent->right) node = node->parent;\n        return node->parent;\n    }\n};\n"]}
{"number": 517, "statement": "You have n super washing machines on a line. Initially, each washing machine has some dresses or is empty. \nFor each move, you could choose any m (1 \u2264 m \u2264 n) washing machines, and pass one dress of each washing machine to one of its adjacent washing machines  at the same time .  \nGiven an integer array representing the number of dresses in each washing machine from left to right on the line, you should find the minimum number of moves to make all the washing machines have the same number of dresses. If it is not possible to do it, return -1.\n", "solutions": ["class Solution {\n  public int findMinMoves(int[] machines) {\n    int n = machines.length, dressTotal = 0;\n    for (int m : machines) dressTotal += m;\n    if (dressTotal % n != 0) return -1;\n    int dressPerMachine = dressTotal / n;\n    // Change the number of dresses in the machines to\n    // the number of dresses to be removed from this machine\n    // (could be negative)\n    for (int i = 0; i < n; i++) machines[i] -= dressPerMachine;\n    // currSum is a number of dresses to move at this point, \n    // maxSum is a max number of dresses to move at this point or before,\n    // m is number of dresses to move out from the current machine.\n    int currSum = 0, maxSum = 0, tmpRes = 0, res = 0;\n    for (int m : machines) {\n      currSum += m;\n      maxSum = Math.max(maxSum, Math.abs(currSum));\n      tmpRes = Math.max(maxSum, m);\n      res = Math.max(res, tmpRes);\n    }\n    return res;\n  }\n}\n"]}
{"number": 518, "statement": "You are given coins of different denominations and a total amount of money. Write a function to compute the number of combinations that make up that amount. You may assume that you have infinite number of each kind of coin.\n", "solutions": ["class Solution {\n  public int change(int amount, int[] coins) {\n    int[] dp = new int[amount + 1];\n    dp[0] = 1;\n    for (int coin : coins) {\n      for (int x = coin; x < amount + 1; ++x) {\n        dp[x] += dp[x - coin];\n      }\n    }\n    return dp[amount];\n  }\n}\n"]}
{"number": 519, "statement": "You are given the number of rows n_rowsand number of columns n_colsof a2Dbinary matrixwhere all values are initially 0.Write a function flipwhich choosesa 0 valueuniformly at random,changes it to 1,and then returns the position [row.id, col.id] of that value. Also, write a function reset which sets all values back to 0.Try to minimize the number of calls to system's Math.random() and optimize the time andspace complexity.\nNote:\n1 = n_rows, n_cols= 10000\n0 = row.id  n_rows and 0 = col.id  n_cols\nflipwill not be called when the matrix has no0 values left.\nthe total number of calls toflipand resetwill not exceed1000.\n", "solutions": ["class Solution {\npublic:\n    unordered_map<int,int> V;\n    int nr, nc, rem;\n    //c++11 random integer generation\n    mt19937 rng{random_device{}()};\n    //uniform random integer in [0, bound]\n    int randint(int bound) {\n        uniform_int_distribution<int> uni(0, bound);\n        return uni(rng);\n    }\n    Solution(int n_rows, int n_cols) {\n        nr = n_rows, nc = n_cols, rem = nr * nc;\n    }\n    vector<int> flip() {\n        int r = randint(--rem);\n        int x = V.count(r) ? V[r] : V[r] = r;\n        V[r] = V.count(rem) ? V[rem] : V[rem] = rem;\n        return {x / nc, x % nc};\n    }\n    void reset() {\n        V.clear();\n        rem = nr*nc;\n    }\n};\n", "class Solution {\npublic:\n    int nr, nc, rem, b_size;\n    vector<unordered_set<int>> buckets;\n    //c++11 random integer generation\n    mt19937 rng{random_device{}()};\n    //uniform random integer in [0, bound)\n    int randint(int bound) {\n        uniform_int_distribution<int> uni(0, bound - 1);\n        return uni(rng);\n    }\n    Solution(int n_rows, int n_cols) {\n        nr = n_rows, nc = n_cols, rem = nr * nc;\n        b_size = sqrt(nr * nc);\n        for (int i = 0; i < nr * nc; i += b_size)\n            buckets.push_back({});\n    }\n    vector<int> flip() {\n        int c = 0;\n        int c0 = 0;\n        int k = randint(rem);\n        for (auto& b1 : buckets) {\n            if (c0 + b_size - b1.size() > k) {\n                while (true) {\n                    if (!b1.count(c)) {\n                        if (c0 == k) {\n                            b1.insert(c);\n                            rem--;\n                            return {c / nc, c % nc};\n                        }\n                        c0++;\n                    }\n                    c++;\n                }\n            }\n            c += b_size;\n            c0 += b_size - b1.size();\n        }\n    }\n    void reset() {\n        for (auto& b1 : buckets)\n            b1.clear();\n        rem = nr * nc;\n    }\n};\n"]}
{"number": 522, "statement": "Given a list of strings, you need to find the longest uncommon subsequence among them. The longest uncommon subsequence is defined as the longest subsequence of one of these strings and this subsequence should not be any subsequence of the other strings.\nA subsequence is a sequence that can be derived from one sequence by deleting some characters without changing the order of the remaining elements. Trivially, any string is a subsequence of itself and an empty string is a subsequence of any string.\nThe input will be a list of strings, and the output needs to be the length of the longest uncommon subsequence. If the longest uncommon subsequence doesn't exist, return -1.\n", "solutions": ["public class Solution {\n    public int findLUSlength(String[] strs) {\n        HashMap < String, Integer > map = new HashMap < > ();\n        for (String s: strs) {\n            for (int i = 0; i < (1 << s.length()); i++) {\n                String t = \"\";\n                for (int j = 0; j < s.length(); j++) {\n                    if (((i >> j) & 1) != 0)\n                        t += s.charAt(j);\n                }\n                if (map.containsKey(t))\n                    map.put(t, map.get(t) + 1);\n                else\n                    map.put(t, 1);\n            }\n        }\n        int res = -1;\n        for (String s: map.keySet()) {\n            if (map.get(s) == 1)\n                res = Math.max(res, s.length());\n        }\n        return res;\n    }\n}\n", "public class Solution {\n    public boolean isSubsequence(String x, String y) {\n        int j = 0;\n        for (int i = 0; i < y.length() && j < x.length(); i++)\n            if (x.charAt(j) == y.charAt(i))\n                j++;\n        return j == x.length();\n    }\n    public int findLUSlength(String[] strs) {\n        int res = -1;\n        for (int i = 0, j; i < strs.length; i++) {\n            for (j = 0; j < strs.length; j++) {\n                if (j == i)\n                    continue;\n                if (isSubsequence(strs[i], strs[j]))\n                    break;\n            }\n            if (j == strs.length)\n                res = Math.max(res, strs[i].length());\n        }\n        return res;\n    }\n}\n", "public class Solution {\n    public boolean isSubsequence(String x, String y) {\n        int j = 0;\n        for (int i = 0; i < y.length() && j < x.length(); i++)\n            if (x.charAt(j) == y.charAt(i))\n                j++;\n        return j == x.length();\n    }\n    public int findLUSlength(String[] strs) {\n        Arrays.sort(strs, new Comparator < String > () {\n            public int compare(String s1, String s2) {\n                return s2.length() - s1.length();\n            }\n        });\n        for (int i = 0, j; i < strs.length; i++) {\n            boolean flag = true;\n            for (j = 0; j < strs.length; j++) {\n                if (i == j)\n                    continue;\n                if (isSubsequence(strs[i], strs[j])) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag)\n                return strs[i].length();\n        }\n        return -1;\n    }\n}\n"]}
{"number": 523, "statement": "Given a list of non-negative numbers and a target integer k, write a function to check if the array has a continuous subarray of size at least 2 that sums up to a multiple of k, that is, sums up to n*k where n is also an integer.\n", "solutions": ["public class Solution {\n    public boolean checkSubarraySum(int[] nums, int k) {\n        for (int start = 0; start < nums.length - 1; start++) {\n            for (int end = start + 1; end < nums.length; end++) {\n                int sum = 0;\n                for (int i = start; i <= end; i++)\n                    sum += nums[i];\n                if (sum == k || (k != 0 && sum % k == 0))\n                    return true;\n            }\n        }\n        return false;\n    }\n}\n", "public class Solution {\n    public boolean checkSubarraySum(int[] nums, int k) {\n        int[] sum = new int[nums.length];\n        sum[0] = nums[0];\n        for (int i = 1; i < nums.length; i++)\n            sum[i] = sum[i - 1] + nums[i];\n        for (int start = 0; start < nums.length - 1; start++) {\n            for (int end = start + 1; end < nums.length; end++) {\n                int summ = sum[end] - sum[start] + nums[start];\n                if (summ == k || (k != 0 && summ % k == 0))\n                    return true;\n            }\n        }\n        return false;\n    }\n}\n", "public class Solution {\n    public boolean checkSubarraySum(int[] nums, int k) {\n        int sum = 0;\n        HashMap < Integer, Integer > map = new HashMap < > ();\n        map.put(0, -1);\n        for (int i = 0; i < nums.length; i++) {\n            sum += nums[i];\n            if (k != 0)\n                sum = sum % k;\n            if (map.containsKey(sum)) {\n                if (i - map.get(sum) > 1)\n                    return true;\n            } else\n                map.put(sum, i);\n        }\n        return false;\n    }\n}\n"]}
{"number": 524, "statement": "Given a string and a string dictionary, find the longest string in the dictionary that can be formed by deleting some characters of the given string. If there are more than one possible results, return the longest word with the smallest lexicographical order. If there is no possible result, return the empty string.\n", "solutions": ["public class Solution {\n    public String findLongestWord(String s, List < String > d) {\n        HashSet < String > set = new HashSet < > (d);\n        List < String > l = new ArrayList < > ();\n        generate(s, \"\", 0, l);\n        String max_str = \"\";\n        for (String str: l) {\n            if (set.contains(str))\n                if (str.length() > max_str.length() || (str.length() == max_str.length() && str.compareTo(max_str) < 0))\n                    max_str = str;\n        }\n        return max_str;\n    }\n    public void generate(String s, String str, int i, List < String > l) {\n        if (i == s.length())\n            l.add(str);\n        else {\n            generate(s, str + s.charAt(i), i + 1, l);\n            generate(s, str, i + 1, l);\n        }\n    }\n}\n", "public class Solution {\n    public String findLongestWord(String s, List < String > d) {\n        HashSet < String > set = new HashSet < > (d);\n        List < String > l = new ArrayList < > ();\n        for (int i = 0; i < (1 << s.length()); i++) {\n            String t = \"\";\n            for (int j = 0; j < s.length(); j++) {\n                if (((i >> j) & 1) != 0)\n                    t += s.charAt(j);\n            }\n            l.add(t);\n        }\n        String max_str = \"\";\n        for (String str: l) {\n            if (set.contains(str))\n                if (str.length() > max_str.length() || (str.length() == max_str.length() && str.compareTo(max_str) < 0))\n                    max_str = str;\n        }\n        return max_str;\n    }\n}\n", "public class Solution {\n    public boolean isSubsequence(String x, String y) {\n        int j = 0;\n        for (int i = 0; i < y.length() && j < x.length(); i++)\n            if (x.charAt(j) == y.charAt(i))\n                j++;\n        return j == x.length();\n    }\n    public String findLongestWord(String s, List < String > d) {\n        Collections.sort(d, new Comparator < String > () {\n            public int compare(String s1, String s2) {\n                return s2.length() != s1.length() ? s2.length() - s1.length() : s1.compareTo(s2);\n            }\n        });\n        for (String str: d) {\n            if (isSubsequence(str, s))\n                return str;\n        }\n        return \"\";\n    }\n}\n", "public class Solution {\n    public boolean isSubsequence(String x, String y) {\n        int j = 0;\n        for (int i = 0; i < y.length() && j < x.length(); i++)\n            if (x.charAt(j) == y.charAt(i))\n                j++;\n        return j == x.length();\n    }\n    public String findLongestWord(String s, List < String > d) {\n        String max_str = \"\";\n        for (String str: d) {\n            if (isSubsequence(str, s)) {\n                if (str.length() > max_str.length() || (str.length() == max_str.length() && str.compareTo(max_str) < 0))\n                    max_str = str;\n            }\n        }\n        return max_str;\n    }\n}\n"]}
{"number": 525, "statement": "Given a binary array, find the maximum length of a contiguous subarray with equal number of 0 and 1. \n", "solutions": ["public class Solution {\n    public int findMaxLength(int[] nums) {\n        int maxlen = 0;\n        for (int start = 0; start < nums.length; start++) {\n            int zeroes = 0, ones = 0;\n            for (int end = start; end < nums.length; end++) {\n                if (nums[end] == 0) {\n                    zeroes++;\n                } else {\n                    ones++;\n                }\n                if (zeroes == ones) {\n                    maxlen = Math.max(maxlen, end - start + 1);\n                }\n            }\n        }\n        return maxlen;\n    }\n}\n", "public class Solution {\n    public int findMaxLength(int[] nums) {\n        int[] arr = new int[2 * nums.length + 1];\n        Arrays.fill(arr, -2);\n        arr[nums.length] = -1;\n        int maxlen = 0, count = 0;\n        for (int i = 0; i < nums.length; i++) {\n            count = count + (nums[i] == 0 ? -1 : 1);\n            if (arr[count + nums.length] >= -1) {\n                maxlen = Math.max(maxlen, i - arr[count + nums.length]);\n            } else {\n                arr[count + nums.length] = i;\n            }\n        }\n        return maxlen;\n    }\n}\n", "public class Solution {\n    public int findMaxLength(int[] nums) {\n        Map<Integer, Integer> map = new HashMap<>();\n        map.put(0, -1);\n        int maxlen = 0, count = 0;\n        for (int i = 0; i < nums.length; i++) {\n            count = count + (nums[i] == 1 ? 1 : -1);\n            if (map.containsKey(count)) {\n                maxlen = Math.max(maxlen, i - map.get(count));\n            } else {\n                map.put(count, i);\n            }\n        }\n        return maxlen;\n    }\n}\n"]}
{"number": 526, "statement": "Suppose you have N integers from 1 to N. We define a beautiful arrangement as an array that is constructed by these N numbers successfully if one of the following is true for the ith position (1 = i = N) in this array:\nThe number at the ith position is divisible by i.\ni is divisible by the number at the ith position.\nNow given N, how many beautiful arrangements can you construct?\n", "solutions": ["public class Solution {\n    int count = 0;\n    public int countArrangement(int N) {\n        int[] nums = new int[N];\n        for (int i = 1; i <= N; i++)\n            nums[i - 1] = i;\n        permute(nums, 0);\n        return count;\n    }\n    public void permute(int[] nums, int l) {\n        if (l == nums.length - 1) {\n            int i;\n            for (i = 1; i <= nums.length; i++) {\n                if (nums[i - 1] % i != 0 && i % nums[i - 1] != 0)\n                    break;\n            }\n            if (i == nums.length + 1) {\n                count++;\n            }\n        }\n        for (int i = l; i < nums.length; i++) {\n            swap(nums, i, l);\n            permute(nums, l + 1);\n            swap(nums, i, l);\n        }\n    }\n    public void swap(int[] nums, int x, int y) {\n        int temp = nums[x];\n        nums[x] = nums[y];\n        nums[y] = temp;\n    }\n}\n", "public class Solution {\n    int count = 0;\n    public int countArrangement(int N) {\n        int[] nums = new int[N];\n        for (int i = 1; i <= N; i++)\n            nums[i - 1] = i;\n        permute(nums, 0);\n        return count;\n    }\n    public void permute(int[] nums, int l) {\n        if (l == nums.length) {\n            count++;\n        }\n        for (int i = l; i < nums.length; i++) {\n            swap(nums, i, l);\n            if (nums[l] % (l + 1) == 0 || (l + 1) % nums[l] == 0)\n                permute(nums, l + 1);\n            swap(nums, i, l);\n        }\n    }\n    public void swap(int[] nums, int x, int y) {\n        int temp = nums[x];\n        nums[x] = nums[y];\n        nums[y] = temp;\n    }\n}\n", "public class Solution {\n    int count = 0;\n    public int countArrangement(int N) {\n        boolean[] visited = new boolean[N + 1];\n        calculate(N, 1, visited);\n        return count;\n    }\n    public void calculate(int N, int pos, boolean[] visited) {\n        if (pos > N)\n            count++;\n        for (int i = 1; i <= N; i++) {\n            if (!visited[i] && (pos % i == 0 || i % pos == 0)) {\n                visited[i] = true;\n                calculate(N, pos + 1, visited);\n                visited[i] = false;\n            }\n        }\n    }\n}\n"]}
{"number": 527, "statement": "Given an array of n distinct non-empty strings, you need to generate minimal possible abbreviations for every word following rules below.\nBegin with the first character and then the number of characters abbreviated, which followed by the last character.\nIf there are any conflict, that is more than one words share the same abbreviation, a longer prefix is used instead of only the first character until making the map from word to abbreviation become unique. In other words, a final abbreviation cannot map to more than one original words.\n If the abbreviation doesn't make the word shorter, then keep it as original.\n", "solutions": ["class Solution {\n    public List<String> wordsAbbreviation(List<String> words) {\n        int N = words.size();\n        String[] ans = new String[N];\n        int[] prefix = new int[N];\n        for (int i = 0; i < N; ++i)\n            ans[i] = abbrev(words.get(i), 0);\n        for (int i = 0; i < N; ++i) {\n            while (true) {\n                Set<Integer> dupes = new HashSet();\n                for (int j = i+1; j < N; ++j)\n                    if (ans[i].equals(ans[j]))\n                        dupes.add(j);\n                if (dupes.isEmpty()) break;\n                dupes.add(i);\n                for (int k: dupes)\n                    ans[k] = abbrev(words.get(k), ++prefix[k]);\n            }\n        }\n        return Arrays.asList(ans);\n    }\n    public String abbrev(String word, int i) {\n        int N = word.length();\n        if (N - i <= 3) return word;\n        return word.substring(0, i+1) + (N - i - 2) + word.charAt(N-1);\n    }\n}\n", "class Solution {\n    public List<String> wordsAbbreviation(List<String> words) {\n        Map<String, List<IndexedWord>> groups = new HashMap();\n        String[] ans = new String[words.size()];\n        int index = 0;\n        for (String word: words) {\n            String ab = abbrev(word, 0);\n            if (!groups.containsKey(ab))\n                groups.put(ab, new ArrayList());\n            groups.get(ab).add(new IndexedWord(word, index));\n            index++;\n        }\n        for (List<IndexedWord> group: groups.values()) {\n            Collections.sort(group, (a, b) -> a.word.compareTo(b.word));\n            int[] lcp = new int[group.size()];\n            for (int i = 1; i < group.size(); ++i) {\n                int p = longestCommonPrefix(group.get(i-1).word, group.get(i).word);\n                lcp[i] = p;\n                lcp[i-1] = Math.max(lcp[i-1], p);\n            }\n            for (int i = 0; i < group.size(); ++i)\n                ans[group.get(i).index] = abbrev(group.get(i).word, lcp[i]);\n        }\n        return Arrays.asList(ans);\n    }\n    public String abbrev(String word, int i) {\n        int N = word.length();\n        if (N - i <= 3) return word;\n        return word.substring(0, i+1) + (N - i - 2) + word.charAt(N-1);\n    }\n    public int longestCommonPrefix(String word1, String word2) {\n        int i = 0;\n        while (i < word1.length() && i < word2.length()\n                && word1.charAt(i) == word2.charAt(i))\n            i++;\n        return i;\n    }\n}\nclass IndexedWord {\n    String word;\n    int index;\n    IndexedWord(String w, int i) {\n        word = w;\n        index = i;\n    }\n}\n", "class Solution {\n    public List<String> wordsAbbreviation(List<String> words) {\n        Map<String, List<IndexedWord>> groups = new HashMap();\n        String[] ans = new String[words.size()];\n        int index = 0;\n        for (String word: words) {\n            String ab = abbrev(word, 0);\n            if (!groups.containsKey(ab))\n                groups.put(ab, new ArrayList());\n            groups.get(ab).add(new IndexedWord(word, index));\n            index++;\n        }\n        for (List<IndexedWord> group: groups.values()) {\n            TrieNode trie = new TrieNode();\n            for (IndexedWord iw: group) {\n                TrieNode cur = trie;\n                for (char letter: iw.word.substring(1).toCharArray()) {\n                    if (cur.children[letter - 'a'] == null)\n                        cur.children[letter - 'a'] = new TrieNode();\n                    cur.count++;\n                    cur = cur.children[letter - 'a'];\n                }\n            }\n            for (IndexedWord iw: group) {\n                TrieNode cur = trie;\n                int i = 1;\n                for (char letter: iw.word.substring(1).toCharArray()) {\n                    if (cur.count == 1) break;\n                    cur = cur.children[letter - 'a'];\n                    i++;\n                }\n                ans[iw.index] = abbrev(iw.word, i-1);\n            }\n        }\n        return Arrays.asList(ans);\n    }\n    public String abbrev(String word, int i) {\n        int N = word.length();\n        if (N - i <= 3) return word;\n        return word.substring(0, i+1) + (N - i - 2) + word.charAt(N-1);\n    }\n    public int longestCommonPrefix(String word1, String word2) {\n        int i = 0;\n        while (i < word1.length() && i < word2.length()\n                && word1.charAt(i) == word2.charAt(i))\n            i++;\n        return i;\n    }\n}\nclass TrieNode {\n    TrieNode[] children;\n    int count;\n    TrieNode() {\n        children = new TrieNode[26];\n        count = 0;\n    }\n}\nclass IndexedWord {\n    String word;\n    int index;\n    IndexedWord(String w, int i) {\n        word = w;\n        index = i;\n    }\n}\n"]}
{"number": 528, "statement": "Given an array w of positive integers, where w[i] describes the weight of index i,write a function pickIndexwhich randomlypicks an indexin proportionto its weight.\nNote:\n1 = w.length = 10000\n1 = w[i] = 10^5\npickIndexwill be called at most 10000 times.\n", "solutions": ["class Solution {\n    vector<int> prefixSums;\npublic:\n    Solution(vector<int> &w) {\n        for (auto n : w)\n            prefixSums.push_back(n + (prefixSums.empty() ? \n                0 : prefixSums.back()));\n    }\n    int pickIndex() {\n        auto target = rand() % prefixSums.back();\n        // run a linear search to find the target zone\n        for (int i = 0; i < prefixSums.size(); ++i)\n            if (target < prefixSums[i])\n                return i;\n        return prefixSums.size() - 1;\n    }\n};\n", "class Solution {\n    vector<int> prefixSums;\npublic:\n    Solution(vector<int> &w) {\n        for (auto n : w)\n            prefixSums.push_back(n + (prefixSums.empty() ? \n                0 : prefixSums.back()));\n    }\n    int pickIndex() {\n        auto target = rand() % prefixSums.back();\n        return upper_bound(begin(prefixSums), end(prefixSums), target) - begin(prefixSums);\n    }\n};\n"]}
{"number": 535, "statement": "Note: This is a companion problem to the System Design problem: Design TinyURL.\nTinyURL is a URL shortening service where you enter a URL such as https://leetcode.com/problems/design-tinyurl and it returns a short URL such as http://tinyurl.com/4e9iAk.\nDesign the encode and decode methods for the TinyURL service. There is no restriction on how your encode/decode algorithm should work. You just need to ensure that a URL can be encoded to a tiny URL and the tiny URL can be decoded to the original URL.\n", "solutions": ["public class Codec {\n    Map<Integer, String> map = new HashMap<>();\n    int i = 0;\n    public String encode(String longUrl) {\n        map.put(i, longUrl);\n        return \"http://tinyurl.com/\" + i++;\n    }\n    public String decode(String shortUrl) {\n        return map.get(Integer.parseInt(shortUrl.replace(\"http://tinyurl.com/\", \"\")));\n    }\n}\n", "public class Codec {\n    String chars = \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    HashMap<String, String> map = new HashMap<>();\n    int count = 1;\n    public String getString() {\n        int c = count;\n        StringBuilder sb = new StringBuilder();\n        while (c > 0) {\n            c--;\n            sb.append(chars.charAt(c % 62));\n            c /= 62;\n        }\n        return sb.toString();\n    }\n    public String encode(String longUrl) {\n        String key = getString();\n        map.put(key, longUrl);\n        return \"http://tinyurl.com/\" + key;\n        count++;\n    }\n    public String decode(String shortUrl) {\n        return map.get(shortUrl.replace(\"http://tinyurl.com/\", \"\"));\n    }\n}\n", "public class Codec {\n    Map<Integer, String> map = new HashMap<>();\n    public String encode(String longUrl) {\n        map.put(longUrl.hashCode(), longUrl);\n        return \"http://tinyurl.com/\" + longUrl.hashCode();\n    }\n    public String decode(String shortUrl) {\n        return map.get(Integer.parseInt(shortUrl.replace(\"http://tinyurl.com/\", \"\")));\n    }\n}\n", "public class Codec {\n    Map<Integer, String> map = new HashMap<>();\n    Random r = new Random();\n    int key = r.nextInt(Integer.MAX_VALUE);\n    public String encode(String longUrl) {\n        while (map.containsKey(key)) {\n            key = r.nextInt(Integer.MAX_VALUE);\n        }\n        map.put(key, longUrl);\n        return \"http://tinyurl.com/\" + key;\n    }\n    public String decode(String shortUrl) {\n        return map.get(Integer.parseInt(shortUrl.replace(\"http://tinyurl.com/\", \"\")));\n    }\n}\n", "public class Codec {\n    String alphabet = \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    HashMap<String, String> map = new HashMap<>();\n    Random rand = new Random();\n    String key = getRand();\n    public String getRand() {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < 6; i++) {\n            sb.append(alphabet.charAt(rand.nextInt(62)));\n        }\n        return sb.toString();\n    }\n    public String encode(String longUrl) {\n        while (map.containsKey(key)) {\n            key = getRand();\n        }\n        map.put(key, longUrl);\n        return \"http://tinyurl.com/\" + key;\n    }\n    public String decode(String shortUrl) {\n        return map.get(shortUrl.replace(\"http://tinyurl.com/\", \"\"));\n    }\n}\n"]}
{"number": 537, "statement": "Given two strings representing two complex numbers.\nYou need to return a string representing their multiplication. Note i2 = -1 according to the definition.\n", "solutions": ["public class Solution {\n    public String complexNumberMultiply(String a, String b) {\n        String x[] = a.split(\"\\\\+|i\");\n        String y[] = b.split(\"\\\\+|i\");\n        int a_real = Integer.parseInt(x[0]);\n        int a_img = Integer.parseInt(x[1]);\n        int b_real = Integer.parseInt(y[0]);\n        int b_img = Integer.parseInt(y[1]);\n        return (a_real * b_real - a_img * b_img) + \"+\" + (a_real * b_img + a_img * b_real) + \"i\";\n    }\n}\n"]}
{"number": 538, "statement": "Given a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus sum of all keys greater than the original key in BST.\n", "solutions": ["class Solution {\n    private int sum = 0;\n    public TreeNode convertBST(TreeNode root) {\n        if (root != null) {\n            convertBST(root.right);\n            sum += root.val;\n            root.val = sum;\n            convertBST(root.left);\n        }\n        return root;\n    }\n}\n", "class Solution {\n    public TreeNode convertBST(TreeNode root) {\n        int sum = 0;\n        TreeNode node = root;\n        Stack<TreeNode> stack = new Stack<TreeNode>();\n        while (!stack.isEmpty() || node != null) {\n            /* push all nodes up to (and including) this subtree's maximum on\n             * the stack. */\n            while (node != null) {\n                stack.add(node);\n                node = node.right;\n            }\n            node = stack.pop();\n            sum += node.val;\n            node.val = sum;\n            /* all nodes with values between the current and its parent lie in\n             * the left subtree. */\n            node = node.left;\n        }\n        return root;\n    }\n}\n", "class Solution {\n    /* Get the node with the smallest value greater than this one. */\n    private TreeNode getSuccessor(TreeNode node) {\n        TreeNode succ = node.right;\n        while (succ.left != null && succ.left != node) {\n            succ = succ.left;\n        }\n        return succ;\n    }\n    public TreeNode convertBST(TreeNode root) {\n        int sum = 0;\n        TreeNode node = root;\n        while (node != null) {\n            /* \n             * If there is no right subtree, then we can visit this node and\n             * continue traversing left.\n             */\n            if (node.right == null) {\n                sum += node.val;\n                node.val = sum;\n                node = node.left;\n            }\n            /* \n             * If there is a right subtree, then there is at least one node that\n             * has a greater value than the current one. therefore, we must\n             * traverse that subtree first.\n             */\n            else {\n                TreeNode succ = getSuccessor(node);\n                /* \n                 * If the left subtree is null, then we have never been here before.\n                 */\n                if (succ.left == null) {\n                    succ.left = node;\n                    node = node.right;\n                }\n                /* \n                 * If there is a left subtree, it is a link that we created on a\n                 * previous pass, so we should unlink it and visit this node.\n                 */\n                else {\n                    succ.left = null;\n                    sum += node.val;\n                    node.val = sum;\n                    node = node.left;\n                }\n            }\n        }\n        \n        return root;\n    }\n}\n"]}
{"number": 540, "statement": "You are given a sorted array consisting of only integers where every element appears exactly twice, except for one element which appears exactlyonce. Find this single element that appears only once.\nFollow up: Your solution should run in O(log n) time and O(1) space.\n", "solutions": ["class Solution {\npublic:\n    int singleNonDuplicate(vector<int>& nums) {\n        for (int i = 0; i < nums.size() - 1; i += 2) {\n            if (nums[i] != nums[i + 1]) {\n                return nums[i];\n            }\n        }\n        return nums.back();\n    }\n};\n", "class Solution {\npublic:\n    int singleNonDuplicate(vector<int>& nums) {\n        int lo = 0;\n        int hi = nums.size() - 1;\n        while (lo < hi) {\n            int mid = lo + (hi - lo) / 2;\n            bool halvesAreEven = (hi - mid) % 2 == 0;\n            if (nums[mid + 1] == nums[mid]) {\n                if (halvesAreEven) {\n                    lo = mid + 2;\n                } else {\n                    hi = mid - 1;\n                }\n            } else if (nums[mid - 1] == nums[mid]) {\n                if (halvesAreEven) {\n                    hi = mid - 2;\n                } else {\n                    lo = mid + 1;\n                }\n            } else {\n                return nums[mid];\n            }\n        }\n        return nums[lo];\n    }\n};\n", "class Solution {\npublic:\n    int singleNonDuplicate(vector<int>& nums) {\n        int lo = 0;\n        int hi = nums.size() - 1;\n        while (lo < hi) {\n            int mid = lo + (hi - lo) / 2;\n            if (mid % 2 == 1) mid--;\n            if (nums[mid] == nums[mid + 1]) {\n                lo = mid + 2;\n            } else {\n                hi = mid;\n            }\n        }\n        return nums[lo];\n    }\n};\n"]}
{"number": 541, "statement": "Given a string and an integer k, you need to reverse the first k characters for every 2k characters counting from the start of the string. If there are less than k characters left, reverse all of them. If there are less than 2k but greater than or equal to k characters, then reverse the first k characters and left the other as original.\n", "solutions": ["class Solution {\n    public String reverseStr(String s, int k) {\n        char[] a = s.toCharArray();\n        for (int start = 0; start < a.length; start += 2 * k) {\n            int i = start, j = Math.min(start + k - 1, a.length - 1);\n            while (i < j) {\n                char tmp = a[i];\n                a[i++] = a[j];\n                a[j--] = tmp;\n            }\n        }\n        return new String(a);\n    }\n}\n"]}
{"number": 542, "statement": "Given a matrix consists of 0 and 1, find the distance of the nearest 0 for each cell.\nThe distance between two adjacent cells is 1.\n", "solutions": ["vector<vector<int> > updateMatrix(vector<vector<int> >& matrix)\n{\n    int rows = matrix.size();\n    if (rows == 0)\n        return matrix;\n    int cols = matrix[0].size();\n    vector<vector<int> > dist(rows, vector<int>(cols, INT_MAX));\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            if (matrix[i][j] == 0)\n                dist[i][j] = 0;\n            else {\n                for (int k = 0; k < rows; k++)\n                    for (int l = 0; l < cols; l++)\n                        if (matrix[k][l] == 0) {\n                            int dist_01 = abs(k - i) + abs(l - j);\n                            dist[i][j] = min(dist[i][j], abs(k - i) + abs(l - j));\n                        }\n            }\n        }\n    }\n    return dist;\n}\n", "vector<vector<int> > updateMatrix(vector<vector<int> >& matrix)\n{\n    int rows = matrix.size();\n    if (rows == 0)\n        return matrix;\n    int cols = matrix[0].size();\n    vector<vector<int> > dist(rows, vector<int>(cols, INT_MAX));\n    queue<pair<int, int> > q;\n    for (int i = 0; i < rows; i++)\n        for (int j = 0; j < cols; j++)\n            if (matrix[i][j] == 0) {\n                dist[i][j] = 0;\n                q.push({ i, j }); //Put all 0s in the queue.\n            }\n    int dir[4][2] = { { -1, 0 }, { 1, 0 }, { 0, -1 }, { 0, 1 } };\n    while (!q.empty()) {\n        pair<int, int> curr = q.front();\n        q.pop();\n        for (int i = 0; i < 4; i++) {\n            int new_r = curr.first + dir[i][0], new_c = curr.second + dir[i][1];\n            if (new_r >= 0 && new_c >= 0 && new_r < rows && new_c < cols) {\n                if (dist[new_r][new_c] > dist[curr.first][curr.second] + 1) {\n                    dist[new_r][new_c] = dist[curr.first][curr.second] + 1;\n                    q.push({ new_r, new_c });\n                }\n            }\n        }\n    }\n    return dist;\n}\n", "vector<vector<int> > updateMatrix(vector<vector<int> >& matrix)\n{\n    int rows = matrix.size();\n    if (rows == 0)\n        return matrix;\n    int cols = matrix[0].size();\n    vector<vector<int> > dist(rows, vector<int>(cols, INT_MAX - 100000));\n    //First pass: check for left and top\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            if (matrix[i][j] == 0)\n                dist[i][j] = 0;\n            else {\n                if (i > 0)\n                    dist[i][j] = min(dist[i][j], dist[i - 1][j] + 1);\n                if (j > 0)\n                    dist[i][j] = min(dist[i][j], dist[i][j - 1] + 1);\n            }\n        }\n    }\n    //Second pass: check for bottom and right\n    for (int i = rows - 1; i >= 0; i--) {\n        for (int j = cols - 1; j >= 0; j--) {\n            if (i < rows - 1)\n                dist[i][j] = min(dist[i][j], dist[i + 1][j] + 1);\n            if (j < cols - 1)\n                dist[i][j] = min(dist[i][j], dist[i][j + 1] + 1);\n        }\n    }\n    return dist;\n}\n"]}
{"number": 543, "statement": "Given a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.\n", "solutions": ["class Solution {\n    int ans;\n    public int diameterOfBinaryTree(TreeNode root) {\n        ans = 1;\n        depth(root);\n        return ans - 1;\n    }\n    public int depth(TreeNode node) {\n        if (node == null) return 0;\n        int L = depth(node.left);\n        int R = depth(node.right);\n        ans = Math.max(ans, L+R+1);\n        return Math.max(L, R) + 1;\n    }\n}\n"]}
{"number": 544, "statement": "During the NBA playoffs, we always arrange the rather strong team to play with the rather weak team, like make the rank 1 team play with the rank nth team, which is a good strategy to make the contest more interesting. Now, you're given n teams, you need to output their final contest matches in the form of a string.\nThe n teams are given in the form of positive integers from 1 to n, which represents their initial rank. (Rank 1 is the strongest team and Rank n is the weakest team.) We'll use parentheses('(', ')') and commas(',') to represent the contest team pairing - parentheses('(' , ')') for pairing and commas(',') for partition. During the pairing process in each round, you always need to follow the strategy of making the rather strong one pair with the rather weak one. \n", "solutions": ["class Solution {\n    public String findContestMatch(int n) {\n        String[] team = new String[n];\n        for (int i = 1; i <= n; ++i)\n            team[i-1] = \"\" + i;\n        for (; n > 1; n /= 2)\n            for (int i = 0; i < n / 2; ++i)\n                team[i] = \"(\" + team[i] + \",\" + team[n-1-i] + \")\";\n        return team[0];\n    }\n}\n", "class Solution {\n    int[] team;\n    int t;\n    StringBuilder ans;\n    public String findContestMatch(int n) {\n        team = new int[n];\n        t = 0;\n        ans = new StringBuilder();\n        write(n, Integer.numberOfTrailingZeros(n));\n        return ans.toString();\n    }\n    public void write(int n, int round) {\n        if (round == 0) {\n            int w = Integer.lowestOneBit(t);\n            team[t] = w > 0 ? n / w + 1 - team[t - w] : 1;\n            ans.append(\"\" + team[t++]);\n        } else {\n            ans.append(\"(\");\n            write(n, round - 1);\n            ans.append(\",\");\n            write(n, round - 1);\n            ans.append(\")\");\n        }\n    }\n}\n"]}
{"number": 545, "statement": "Given a binary tree, return the values of its boundary in anti-clockwise direction starting from root. Boundary includes left boundary, leaves, and right boundary in order without duplicate nodes. (The values of the nodes may still be duplicates.)\nLeft boundary is defined as the path from root to the left-most node. Right boundary is defined as the path from root to the right-most node. If the root doesn't have left subtree or right subtree, then the root itself is left boundary or right boundary. Note this definition only applies to the input binary tree, and not applies to any subtrees.\nThe left-most node is defined as a leaf node you could reach when you always firstly travel to the left subtree if exists. If not, travel to the right subtree. Repeat until you reach a leaf node.\nThe right-most node is also defined by the same way with left and right exchanged.\n", "solutions": ["/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public boolean isLeaf(TreeNode t) {\n        return t.left == null && t.right == null;\n    }\n    public void addLeaves(List<Integer> res, TreeNode root) {\n        if (isLeaf(root)) {\n            res.add(root.val);\n        } else {\n            if (root.left != null) {\n                addLeaves(res, root.left);\n            }\n            if (root.right != null) {\n                addLeaves(res, root.right);\n            }\n        }\n    }\n    public List<Integer> boundaryOfBinaryTree(TreeNode root) {\n        ArrayList<Integer> res = new ArrayList<>();\n        if (root == null) {\n            return res;\n        }\n        if (!isLeaf(root)) {\n            res.add(root.val);\n        }\n        TreeNode t = root.left;\n        while (t != null) {\n            if (!isLeaf(t)) {\n                res.add(t.val);\n            }\n            if (t.left != null) {\n                t = t.left;\n            } else {\n                t = t.right;\n            }\n        }\n        addLeaves(res, root);\n        Stack<Integer> s = new Stack<>();\n        t = root.right;\n        while (t != null) {\n            if (!isLeaf(t)) {\n                s.push(t.val);\n            }\n            if (t.right != null) {\n                t = t.right;\n            } else {\n                t = t.left;\n            }\n        }\n        while (!s.empty()) {\n            res.add(s.pop());\n        }\n        return res;\n    }\n}\n", "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public List < Integer > boundaryOfBinaryTree(TreeNode root) {\n        List < Integer > left_boundary = new LinkedList < > (), right_boundary = new LinkedList < > (), leaves = new LinkedList < > ();\n        preorder(root, left_boundary, right_boundary, leaves, 0);\n        left_boundary.addAll(leaves);\n        left_boundary.addAll(right_boundary);\n        return left_boundary;\n    }\n    public boolean isLeaf(TreeNode cur) {\n        return (cur.left == null && cur.right == null);\n    }\n    public boolean isRightBoundary(int flag) {\n        return (flag == 2);\n    }\n    public boolean isLeftBoundary(int flag) {\n        return (flag == 1);\n    }\n    public boolean isRoot(int flag) {\n        return (flag == 0);\n    }\n    public int leftChildFlag(TreeNode cur, int flag) {\n        if (isLeftBoundary(flag) || isRoot(flag))\n            return 1;\n        else if (isRightBoundary(flag) && cur.right == null)\n            return 2;\n        else return 3;\n    }\n    public int rightChildFlag(TreeNode cur, int flag) {\n        if (isRightBoundary(flag) || isRoot(flag))\n            return 2;\n        else if (isLeftBoundary(flag) && cur.left == null)\n            return 1;\n        else return 3;\n    }\n    public void preorder(TreeNode cur, List < Integer > left_boundary, List < Integer > right_boundary, List < Integer > leaves, int flag) {\n        if (cur == null)\n            return;\n        if (isRightBoundary(flag))\n            right_boundary.add(0, cur.val);\n        else if (isLeftBoundary(flag) || isRoot(flag))\n            left_boundary.add(cur.val);\n        else if (isLeaf(cur))\n            leaves.add(cur.val);\n        preorder(cur.left, left_boundary, right_boundary, leaves, leftChildFlag(cur, flag));\n        preorder(cur.right, left_boundary, right_boundary, leaves, rightChildFlag(cur, flag));\n    }\n}\n"]}
{"number": 546, "statement": "Given several boxes with different colors represented by different positive numbers.\nYou may experience several rounds to remove boxes until there is no box left. Each time you can choose some continuous boxes with the same color (composed of k boxes, k = 1), remove them and get k*k points.\nFind the maximum points you can get.\n", "solutions": ["public class Solution {\n    public int removeBoxes(int[] boxes) {\n        return remove(boxes);\n    }\n    public int remove(int[] boxes)\n    {\n        if(boxes.length==0)\n            return 0;\n        int res=0;\n        for(int i=0,j=i+1;i<boxes.length;i++)\n        {\n            while(j<boxes.length && boxes[i]==boxes[j])\n                j++;\n            int[] newboxes=new int[boxes.length-(j-i)];\n            for(int k=0,p=0;k<boxes.length;k++)\n            {\n                if(k==i)\n                    k=j;\n                if(k<boxes.length)\n                    newboxes[p++]=boxes[k];\n            }\n            res=Math.max(res,remove(newboxes)+(j-i)*(j-i));\n        }\n        return res;\n    }\n}\n", "class Solution {\n    public int removeBoxes(int[] boxes) {\n        int[][][] dp = new int[100][100][100];\n        return calculatePoints(boxes, dp, 0, boxes.length - 1, 0);\n    }\n    public int calculatePoints(int[] boxes, int[][][] dp, int l, int r, int k) {\n        if (l > r) return 0;\n        if (dp[l][r][k] != 0) return dp[l][r][k];\n        while (r > l && boxes[r] == boxes[r - 1]) {\n            r--;\n            k++;\n        }\n        dp[l][r][k] = calculatePoints(boxes, dp, l, r - 1, 0) + (k + 1) * (k + 1);\n        for (int i = l; i < r; i++) {\n            if (boxes[i] == boxes[r]) {\n                dp[l][r][k] = Math.max(dp[l][r][k], calculatePoints(boxes, dp, l, i, k + 1) + calculatePoints(boxes, dp, i + 1, r - 1, 0));\n            }\n        }\n        return dp[l][r][k];\n    }\n}\n"]}
{"number": 547, "statement": "There are N students in a class. Some of them are friends, while some are not. Their friendship is transitive in nature. For example, if A is a direct friend of B, and B is a direct friend of C, then A is an indirect friend of C. And we defined a friend circle is a group of students who are direct or indirect friends.\nGiven a N*N matrix M representing the friend relationship between students in the class. If M[i][j] = 1, then the ith and jth students are direct friends with each other, otherwise not. And you have to output the total number of friend circles among all the students.\n", "solutions": ["public class Solution {\n    public void dfs(int[][] M, int[] visited, int i) {\n        for (int j = 0; j < M.length; j++) {\n            if (M[i][j] == 1 && visited[j] == 0) {\n                visited[j] = 1;\n                dfs(M, visited, j);\n            }\n        }\n    }\n    public int findCircleNum(int[][] M) {\n        int[] visited = new int[M.length];\n        int count = 0;\n        for (int i = 0; i < M.length; i++) {\n            if (visited[i] == 0) {\n                dfs(M, visited, i);\n                count++;\n            }\n        }\n        return count;\n    }\n}\n", "public class Solution {\n    public int findCircleNum(int[][] M) {\n        int[] visited = new int[M.length];\n        int count = 0;\n        Queue < Integer > queue = new LinkedList < > ();\n        for (int i = 0; i < M.length; i++) {\n            if (visited[i] == 0) {\n                queue.add(i);\n                while (!queue.isEmpty()) {\n                    int s = queue.remove();\n                    visited[s] = 1;\n                    for (int j = 0; j < M.length; j++) {\n                        if (M[s][j] == 1 && visited[j] == 0)\n                            queue.add(j);\n                    }\n                }\n                count++;\n            }\n        }\n        return count;\n    }\n}\n", "public class Solution {\n    int find(int parent[], int i) {\n        if (parent[i] == -1)\n            return i;\n        return find(parent, parent[i]);\n    }\n    void union(int parent[], int x, int y) {\n        int xset = find(parent, x);\n        int yset = find(parent, y);\n        if (xset != yset)\n            parent[xset] = yset;\n    }\n    public int findCircleNum(int[][] M) {\n        int[] parent = new int[M.length];\n        Arrays.fill(parent, -1);\n        for (int i = 0; i < M.length; i++) {\n            for (int j = 0; j < M.length; j++) {\n                if (M[i][j] == 1 && i != j) {\n                    union(parent, i, j);\n                }\n            }\n        }\n        int count = 0;\n        for (int i = 0; i < parent.length; i++) {\n            if (parent[i] == -1)\n                count++;\n        }\n        return count;\n    }\n}\n"]}
{"number": 548, "statement": "Given an array with n integers, you need to find if there are triplets  (i, j, k) which satisfies following conditions:\n 0  i, i + 1  j, j + 1  k  n - 1 \n Sum of subarrays (0, i - 1), (i + 1, j - 1), (j + 1, k - 1) and (k + 1, n - 1) should be equal. \nwhere we define that subarray (L, R) represents a slice of the original array starting from the element indexed L to the element indexed R.\n", "solutions": ["public class Solution {\n    public int sum(int[] nums, int l, int r) {\n        int summ = 0;\n        for (int i = l; i < r; i++)\n            summ += nums[i];\n        return summ;\n    }\n    public boolean splitArray(int[] nums) {\n        if (nums.length < 7)\n            return false;\n        for (int i = 1; i < nums.length - 5; i++) {\n            int sum1 = sum(nums, 0, i);\n            for (int j = i + 2; j < nums.length - 3; j++) {\n                int sum2 = sum(nums, i + 1, j);\n                for (int k = j + 2; k < nums.length - 1; k++) {\n                    int sum3 = sum(nums, j + 1, k);\n                    int sum4 = sum(nums, k + 1, nums.length);\n                    if (sum1 == sum2 && sum3 == sum4 && sum2 == sum4)\n                        return true;\n                }\n            }\n        }\n        return false;\n    }\n}\n", "public class Solution {\n    public boolean splitArray(int[] nums) {\n        if (nums.length < 7)\n            return false;\n        int[] sum = new int[nums.length];\n        sum[0] = nums[0];\n        for (int i = 1; i < nums.length; i++) {\n            sum[i] = sum[i - 1] + nums[i];\n        }\n        for (int i = 1; i < nums.length - 5; i++) {\n            int sum1 = sum[i - 1];\n            for (int j = i + 2; j < nums.length - 3; j++) {\n                int sum2 = sum[j - 1] - sum[i];\n                for (int k = j + 2; k < nums.length - 1; k++) {\n                    int sum3 = sum[k - 1] - sum[j];\n                    int sum4 = sum[nums.length - 1] - sum[k];\n                    if (sum1 == sum2 && sum3 == sum4 && sum2 == sum4)\n                        return true;\n                }\n            }\n        }\n        return false;\n    }\n}\n", "public class Solution {\n    public boolean splitArray(int[] nums) {\n        if (nums.length < 7)\n            return false;\n        int[] sum = new int[nums.length];\n        sum[0] = nums[0];\n        for (int i = 1; i < nums.length; i++) {\n            sum[i] = sum[i - 1] + nums[i];\n        }\n        for (int i = 1; i < nums.length - 5; i++) {\n            int sum1 = sum[i - 1];\n            for (int j = i + 2; j < nums.length - 3; j++) {\n                int sum2 = sum[j - 1] - sum[i];\n                if (sum1 != sum2)\n                    continue;\n                for (int k = j + 2; k < nums.length - 1; k++) {\n                    int sum3 = sum[k - 1] - sum[j];\n                    int sum4 = sum[nums.length - 1] - sum[k];\n                    if (sum3 == sum4 && sum2 == sum4)\n                        return true;\n                }\n            }\n        }\n        return false;\n    }\n}\n", "public class Solution {\n    public boolean splitArray(int[] nums) {\n        HashMap < Integer, ArrayList < Integer >> map = new HashMap < > ();\n        int summ = 0, tot = 0;\n        for (int i = 0; i < nums.length; i++) {\n            summ += nums[i];\n            if (map.containsKey(summ))\n                map.get(summ).add(i);\n            else {\n                map.put(summ, new ArrayList < Integer > ());\n                map.get(summ).add(i);\n            }\n            tot += nums[i];\n        }\n        summ = nums[0];\n        for (int i = 1; i < nums.length - 5; i++) {\n            if (map.containsKey(2 * summ + nums[i])) {\n                for (int j: map.get(2 * summ + nums[i])) {\n                    j++;\n                    if (j > i + 1 && j < nums.length - 3 && map.containsKey(3 * summ + nums[i] + nums[j])) {\n                        for (int k: map.get(3 * summ + nums[j] + nums[i])) {\n                            k++;\n                            if (k < nums.length - 1 && k > j + 1 && 4 * summ + nums[i] + nums[j] + nums[k] == tot)\n                                return true;\n                        }\n                    }\n                }\n            }\n            summ += nums[i];\n        }\n        return false;\n    }\n}\n", "public class Solution {\n    public boolean splitArray(int[] nums) {\n        if (nums.length < 7)\n            return false;\n        int[] sum = new int[nums.length];\n        sum[0] = nums[0];\n        for (int i = 1; i < nums.length; i++) {\n            sum[i] = sum[i - 1] + nums[i];\n        }\n        for (int j = 3; j < nums.length - 3; j++) {\n            HashSet < Integer > set = new HashSet < > ();\n            for (int i = 1; i < j - 1; i++) {\n                if (sum[i - 1] == sum[j - 1] - sum[i])\n                    set.add(sum[i - 1]);\n            }\n            for (int k = j + 2; k < nums.length - 1; k++) {\n                if (sum[nums.length - 1] - sum[k] == sum[k - 1] - sum[j] && set.contains(sum[k - 1] - sum[j]))\n                    return true;\n            }\n        }\n        return false;\n    }\n}\n"]}
{"number": 549, "statement": "Given a binary tree, you need to find the length of Longest Consecutive Path in Binary Tree.\nEspecially, this path can be either increasing or decreasing. For example, [1,2,3,4] and [4,3,2,1] are both considered valid, but the path [1,2,4,3] is not valid. On the other hand, the path can be in the child-Parent-child order, where not necessarily be parent-child order.\n", "solutions": ["/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    int maxval = 0;\n    public int longestConsecutive(TreeNode root) {\n        longestPath(root);\n        return maxval;\n    }\n    public int[] longestPath(TreeNode root) {\n        if (root == null)\n            return new int[] {0,0};\n        int inr = 1, dcr = 1;\n        if (root.left != null) {\n            int[] l = longestPath(root.left);\n            if (root.val == root.left.val + 1)\n                dcr = l[1] + 1;\n            else if (root.val == root.left.val - 1)\n                inr = l[0] + 1;\n        }\n        if (root.right != null) {\n            int[] r = longestPath(root.right);\n            if (root.val == root.right.val + 1)\n                dcr = Math.max(dcr, r[1] + 1);\n            else if (root.val == root.right.val - 1)\n                inr = Math.max(inr, r[0] + 1);\n        }\n        maxval = Math.max(maxval, dcr + inr - 1);\n        return new int[] {inr, dcr};\n    }\n}\n"]}
{"number": 551, "statement": "You are given a string representing an attendance record for a student. The record only contains the following three characters:\n'A' : Absent. \n'L' : Late.\n 'P' : Present. \nA student could be rewarded if his attendance record doesn't contain more than one 'A' (absent) or more than two continuous 'L' (late).    \nYou need to return whether the student could be rewarded according to his attendance record.\n", "solutions": ["public class Solution {\n    public boolean checkRecord(String s) {\n        int count=0;\n        for(int i=0;i<s.length();i++)\n            if(s.charAt(i)=='A')\n                count++;\n        return count<2 && s.indexOf(\"LLL\")<0;\n    }\n}\n", "public class Solution {\n    public boolean checkRecord(String s) {\n        int count=0;\n        for(int i=0;i<s.length() && count<2 ;i++)\n            if(s.charAt(i)=='A')\n                count++;\n        return count<2 && s.indexOf(\"LLL\")<0;\n    }\n}\n", "public class Solution {\n    public boolean checkRecord(String s) {\n        int countA = 0;\n        for (int i = 0; i < s.length() && countA < 2; i++) {\n            if (s.charAt(i) == 'A')\n                countA++;\n            if (i <= s.length() - 3 && s.charAt(i) == 'L' && s.charAt(i + 1) == 'L' && s.charAt(i + 2) == 'L')\n                return false;\n        }\n        return countA < 2;\n    }\n}\n", "public class Solution {\n    public boolean checkRecord(String s) {\n        return !s.matches(\".*(A.*A|LLL).*\");\n    }\n}\n"]}
{"number": 552, "statement": "Given a positive integer n, return the number of all possible attendance records with length n, which will be regarded as rewardable. The answer may be very large, return it after mod 109 + 7.\nA student attendance record is a string that only contains the following three characters:\n'A' : Absent. \n'L' : Late.\n 'P' : Present. \nA record is regarded as rewardable if it doesn't contain more than one 'A' (absent) or more than two continuous 'L' (late).\n", "solutions": ["public class Solution {\n    int count,M=1000000007;\n    public int checkRecord(int n) {\n        count = 0;\n        gen(\"\", n);\n        return count;\n    }\n    public void gen(String s, int n) {\n        if (n == 0 && checkRecord(s))\n            count=(count+1)%M;\n        else if (n > 0) {\n            gen(s + \"A\", n - 1);\n            gen(s + \"P\", n - 1);\n            gen(s + \"L\", n - 1);\n        }\n    }\n    public boolean checkRecord(String s) {\n        int count = 0;\n        for (int i = 0; i < s.length() && count < 2; i++)\n            if (s.charAt(i) == 'A')\n                count++;\n        return s.length() > 0 && count < 2 && s.indexOf(\"LLL\") < 0;\n    }\n}\n", "public class Solution {\n    int M=1000000007;\n    public int checkRecord(int n) {\n        int[] f =new int[n+1];\n        f[0]=1;\n        for(int i=1;i<=n;i++)\n            f[i]=func(i);\n        int sum=func(n);\n        for(int i=1;i<=n;i++){\n            sum+=(f[i-1]*f[n-i])%M;\n        }\n        return sum%M;\n    }\n   public int func(int n)\n   {    \n       if(n==0)\n            return 1;\n        if(n==1)\n            return 2;\n        if(n==2)\n            return 4;\n        if(n==3)\n            return 7;\n        return (2*func(n-1) - func(n-4))%M;\n   }\n}\n", "public class Solution {\n    long M = 1000000007;\n    public int checkRecord(int n) {\n        long[] f = new long[n <= 5 ? 6 : n + 1];\n        f[0] = 1;\n        f[1] = 2;\n        f[2] = 4;\n        f[3] = 7;\n        for (int i = 4; i <= n; i++)\n            f[i] = ((2 * f[i - 1]) % M + (M - f[i - 4])) % M;\n        long sum = f[n];\n        for (int i = 1; i <= n; i++) {\n            sum += (f[i - 1] * f[n - i]) % M;\n        }\n        return (int)(sum % M);\n    }\n}\n", "public class Solution {\n    long M = 1000000007;\n    public int checkRecord(int n) {\n        long a0l0 = 1;\n        long a0l1 = 0, a0l2 = 0, a1l0 = 0, a1l1 = 0, a1l2 = 0;\n        for (int i = 0; i < n; i++) {\n            long new_a0l0 = (a0l0 + a0l1 + a0l2) % M;\n            long new_a0l1 = a0l0;\n            long new_a0l2 = a0l1;\n            long new_a1l0 = (a0l0 + a0l1 + a0l2 + a1l0 + a1l1 + a1l2) % M;\n            long new_a1l1 = a1l0;\n            long new_a1l2 = a1l1;\n            a0l0 = new_a0l0;\n            a0l1 = new_a0l1;\n            a0l2 = new_a0l2;\n            a1l0 = new_a1l0;\n            a1l1 = new_a1l1;\n            a1l2 = new_a1l2;\n        }\n        return (int)((a0l0 + a0l1 + a0l2 + a1l0 + a1l1 + a1l2) % M);\n    }\n}\n", "public class Solution {\n    long M = 1000000007;\n    public int checkRecord(int n) {\n        long a0l0 = 1, a0l1 = 0, a0l2 = 0, a1l0 = 0, a1l1 = 0, a1l2 = 0;\n        for (int i = 0; i <= n; i++) {\n            long a0l0_ = (a0l0 + a0l1 + a0l2) % M;\n            a0l2 = a0l1;\n            a0l1 = a0l0;\n            a0l0 = a0l0_;\n            long a1l0_ = (a0l0 + a1l0 + a1l1 + a1l2) % M;\n            a1l2 = a1l1;\n            a1l1 = a1l0;\n            a1l0 = a1l0_;\n        }\n        return (int) a1l0;\n    }\n}\n"]}
{"number": 553, "statement": "Given a list of positive integers, the adjacent integers will perform the float division. For example, [2,3,4] - 2 / 3 / 4.\nHowever, you can add any number of parenthesis at any position to change the priority of operations. You should find out how to add parenthesis to get the maximum result, and return the corresponding expression in string format. Your expression should NOT contain redundant parenthesis.\n", "solutions": ["public class Solution {\n    public String optimalDivision(int[] nums) {\n        T t = optimal(nums, 0, nums.length - 1, \"\");\n        return t.max_str;\n    }\n    class T {\n        float max_val, min_val;\n        String min_str, max_str;\n    }\n    public T optimal(int[] nums, int start, int end, String res) {\n        T t = new T();\n        if (start == end) {\n            t.max_val = nums[start];\n            t.min_val = nums[start];\n            t.min_str = \"\" + nums[start];\n            t.max_str = \"\" + nums[start];\n            return t;\n        }\n        t.min_val = Float.MAX_VALUE;\n        t.max_val = Float.MIN_VALUE;\n        t.min_str = t.max_str = \"\";\n        for (int i = start; i < end; i++) {\n            T left = optimal(nums, start, i, \"\");\n            T right = optimal(nums, i + 1, end, \"\");\n            if (t.min_val > left.min_val / right.max_val) {\n                t.min_val = left.min_val / right.max_val;\n                t.min_str = left.min_str + \"/\" + (i + 1 != end ? \"(\" : \"\") + right.max_str + (i + 1 != end ? \")\" : \"\");\n            }\n            if (t.max_val < left.max_val / right.min_val) {\n                t.max_val = left.max_val / right.min_val;\n                t.max_str = left.max_str + \"/\" + (i + 1 != end ? \"(\" : \"\") + right.min_str + (i + 1 != end ? \")\" : \"\");\n            }\n        }\n        return t;\n    }\n}\n", "public class Solution {\n    class T {\n        float max_val, min_val;\n        String min_str, max_str;\n    }\n    public String optimalDivision(int[] nums) {\n        T[][] memo = new T[nums.length][nums.length];\n        T t = optimal(nums, 0, nums.length - 1, \"\", memo);\n        return t.max_str;\n    }\n    public T optimal(int[] nums, int start, int end, String res, T[][] memo) {\n        if (memo[start][end] != null)\n            return memo[start][end];\n        T t = new T();\n        if (start == end) {\n            t.max_val = nums[start];\n            t.min_val = nums[start];\n            t.min_str = \"\" + nums[start];\n            t.max_str = \"\" + nums[start];\n            memo[start][end] = t;\n            return t;\n        }\n        t.min_val = Float.MAX_VALUE;\n        t.max_val = Float.MIN_VALUE;\n        t.min_str = t.max_str = \"\";\n        for (int i = start; i < end; i++) {\n            T left = optimal(nums, start, i, \"\", memo);\n            T right = optimal(nums, i + 1, end, \"\", memo);\n            if (t.min_val > left.min_val / right.max_val) {\n                t.min_val = left.min_val / right.max_val;\n                t.min_str = left.min_str + \"/\" + (i + 1 != end ? \"(\" : \"\") + right.max_str + (i + 1 != end ? \")\" : \"\");\n            }\n            if (t.max_val < left.max_val / right.min_val) {\n                t.max_val = left.max_val / right.min_val;\n                t.max_str = left.max_str + \"/\" + (i + 1 != end ? \"(\" : \"\") + right.min_str + (i + 1 != end ? \")\" : \"\");\n            }\n        }\n        memo[start][end] = t;\n        return t;\n    }\n}\n", "public class Solution {\n    public String optimalDivision(int[] nums) {\n        if (nums.length == 1)\n            return nums[0] + \"\";\n        if (nums.length == 2)\n            return nums[0] + \"/\" + nums[1];\n        StringBuilder res = new StringBuilder(nums[0] + \"/(\" + nums[1]);\n        for (int i = 2; i < nums.length; i++) {\n            res.append(\"/\" + nums[i]);\n        }\n        res.append(\")\");\n        return res.toString();\n    }\n}\n"]}
{"number": 554, "statement": "There is a brick wall in front of you. The wall is rectangular and has several rows of bricks. The bricks have the same height but different width. You want to draw a vertical line from the top to the bottom and cross the least bricks.\nThe brick wall is represented by a list of rows. Each row is a list of integers representing the width of each brick in this row from left to right.\nIf your line go through the edge of a brick, then the brick is not considered as crossed. You need to find out how to draw the line to cross the least bricks and return the number of crossed bricks.\nYou cannot draw a line just along one of the two vertical edges of the wall, in which case the line will obviously cross no bricks. \n", "solutions": ["public class Solution {\n    public int leastBricks(List < List < Integer >> wall) {\n        int[] pos = new int[wall.size()];\n        int c = 0, sum = 0, res = Integer.MAX_VALUE;\n        for (int el: wall.get(0))\n            sum += el;\n        while (sum != 0) {\n            int count = 0;\n            for (int i = 0; i < wall.size(); i++) {\n                List < Integer > row = wall.get(i);\n                if (row.get(pos[i]) != 0)\n                    count++;\n                else\n                    pos[i]++;\n                row.set(pos[i], row.get(pos[i]) - 1);\n            }\n            sum--;\n            res = Math.min(res, count);\n        }\n        return res;\n    }\n}\n", "public class Solution {\n    public int leastBricks(List < List < Integer >> wall) {\n        int[] pos = new int[wall.size()];\n        int sum = 0, res = Integer.MAX_VALUE;\n        for (int el: wall.get(0))\n            sum += el;\n        while (sum != 0) {\n            int count = 0, mini = Integer.MAX_VALUE;\n            for (int i = 0; i < wall.size(); i++) {\n                List < Integer > row = wall.get(i);\n                if (row.get(pos[i]) != 0) {\n                    count++;\n                } else\n                    pos[i]++;\n                mini = Math.min(mini, row.get(pos[i]));\n            }\n            for (int i = 0; i < wall.size(); i++) {\n                List < Integer > row = wall.get(i);\n                row.set(pos[i], row.get(pos[i]) - mini);\n            }\n            sum -= mini;\n            res = Math.min(res, count);\n        }\n        return res;\n    }\n}\n", "public class Solution {\n    public int leastBricks(List < List < Integer >> wall) {\n        HashMap < Integer, Integer > map = new HashMap < > ();\n        for (List < Integer > row: wall) {\n            int sum = 0;\n            for (int i = 0; i < row.size() - 1; i++) {\n                sum += row.get(i);\n                if (map.containsKey(sum))\n                    map.put(sum, map.get(sum) + 1);\n                else\n                    map.put(sum, 1);\n            }\n        }\n        int res = wall.size();\n        for (int key: map.keySet())\n            res = Math.min(res, wall.size() - map.get(key));\n        return res;\n    }\n}\n"]}
{"number": 555, "statement": "Given a list of strings, you could concatenate these strings together into a loop, where for each string you could choose to reverse it or not. Among all the possible loops, you need to find the lexicographically biggest string after cutting the loop, which will make the looped string into a regular one.\nSpecifically, to find the lexicographically biggest string, you need to experience two phases: \nConcatenate all the strings into a loop, where you can reverse some strings or not and connect them in the same order as given.\nCut and make one breakpoint in any place of the loop, which will make the looped string into a regular one starting from the character at the cutpoint. \nAnd your job is to find the lexicographically biggest one among all the possible regular strings.\n", "solutions": ["public class Solution {\n    String res = \"\";\n    public String splitLoopedString(String[] strs) {\n        dfs(strs, \"\", 0, strs.length);\n        return res;\n    }\n    public void dfs(String[] strs, String s, int i, int n) {\n        if (i < n) {\n            dfs(strs, s + strs[i], i + 1, n);\n            dfs(strs, s + new StringBuffer(strs[i]).reverse().toString(), i + 1, n);\n        } else {\n            for (int j = 0; j < s.length(); j++) {\n                String t = s.substring(j) + s.substring(0, j);\n                if (t.compareTo(res) > 0)\n                    res = t;\n            }\n        }\n    }\n}\n", "public class Solution {\n    public String splitLoopedString(String[] strs) {\n        Queue < String > queue = new LinkedList < > ();\n        String res = \"\";\n        int i = 0, j = 0;\n        queue.add(\"\");\n        while (i < strs.length) {\n            String t = queue.remove();\n            queue.add(t + strs[i]);\n            queue.add(t + new StringBuffer(strs[i]).reverse().toString());\n            j++;\n            if (j == 1 << i) {\n                i++;\n                j = 0;\n            }\n        }\n        while (!queue.isEmpty()) {\n            String t = queue.remove();\n            for (int k = 0; k < t.length(); k++) {\n                String t1 = t.substring(k) + t.substring(0, k);\n                if (t1.compareTo(res) > 0)\n                    res = t1;\n            }\n        }\n        return res;\n    }\n}\n", "public class Solution {\n    public String splitLoopedString(String[] strs) {\n        for (int i = 0; i < strs.length; i++) {\n            String rev = new StringBuilder(strs[i]).reverse().toString();\n            if (strs[i].compareTo(rev) < 0)\n                strs[i] = rev;\n        }\n        String res = \"\";\n        for (int i = 0; i < strs.length; i++) {\n            String rev = new StringBuilder(strs[i]).reverse().toString();\n            for (String st: new String[] {strs[i], rev}) {\n                for (int k = 0; k < st.length(); k++) {\n                    StringBuilder t = new StringBuilder(st.substring(k));\n                    for (int j = i + 1; j < strs.length; j++)\n                        t.append(strs[j]);\n                    for (int j = 0; j < i; j++)\n                        t.append(strs[j]);\n                    t.append(st.substring(0, k));\n                    if (t.toString().compareTo(res) > 0)\n                        res = t.toString();\n                }\n            }\n        }\n        return res;\n    }\n}\n"]}
{"number": 556, "statement": "Given a positive 32-bit integer n, you need to find the smallest 32-bit integer which has exactly the same digits existing in the integer n and is greater in value than n. If no such positive 32-bit integer exists, you need to return -1.\n", "solutions": ["public class Solution {\n    public String swap(String s, int i0, int i1) {\n        if (i0 == i1)\n            return s;\n        String s1 = s.substring(0, i0);\n        String s2 = s.substring(i0 + 1, i1);\n        String s3 = s.substring(i1 + 1);\n        return s1 + s.charAt(i1) + s2 + s.charAt(i0) + s3;\n    }\n    ArrayList < String > list = new ArrayList < > ();\n    void permute(String a, int l, int r) {\n        int i;\n        if (l == r)\n            list.add(a);\n        else {\n            for (i = l; i <= r; i++) {\n                a = swap(a, l, i);\n                permute(a, l + 1, r);\n                a = swap(a, l, i);\n            }\n        }\n    }\n    public int nextGreaterElement(int n) {\n        String s = \"\" + n;\n        permute(s, 0, s.length() - 1);\n        Collections.sort(list);\n        int i;\n        for (i = list.size() - 1; i >= 0; i--) {\n            if (list.get(i).equals(\"\" + n))\n                break;\n        }\n        return i == list.size() - 1 ? -1 : Integer.parseInt(list.get(i + 1));\n    }\n}\n", "public class Solution {\n    public int nextGreaterElement(int n) {\n        char[] a = (\"\" + n).toCharArray();\n        int i = a.length - 2;\n        while (i >= 0 && a[i + 1] <= a[i]) {\n            i--;\n        }\n        if (i < 0)\n            return -1;\n        int j = a.length - 1;\n        while (j >= 0 && a[j] <= a[i]) {\n            j--;\n        }\n        swap(a, i, j);\n        reverse(a, i + 1);\n        try {\n            return Integer.parseInt(new String(a));\n        } catch (Exception e) {\n            return -1;\n        }\n    }\n    private void reverse(char[] a, int start) {\n        int i = start, j = a.length - 1;\n        while (i < j) {\n            swap(a, i, j);\n            i++;\n            j--;\n        }\n    }\n    private void swap(char[] a, int i, int j) {\n        char temp = a[i];\n        a[i] = a[j];\n        a[j] = temp;\n    }\n}\n"]}
{"number": 557, "statement": "Given a string, you need to reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order.\n", "solutions": ["public class Solution {\n    public String reverseWords(String s) {\n        String words[] = s.split(\" \");\n        StringBuilder res=new StringBuilder();\n        for (String word: words)\n            res.append(new StringBuffer(word).reverse().toString() + \" \");\n        return res.toString().trim();\n    }\n}\n", "public class Solution {\n    public String reverseWords(String s) {\n        String words[] = split(s);\n        StringBuilder res=new StringBuilder();\n        for (String word: words)\n            res.append(reverse(word) + \" \");\n        return res.toString().trim();\n    }\n    public String[] split(String s) {\n        ArrayList < String > words = new ArrayList < > ();\n        StringBuilder word = new StringBuilder();\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == ' ') {\n                words.add(word.toString());\n                word = new StringBuilder();\n            } else\n                word.append( s.charAt(i));\n        }\n        words.add(word.toString());\n        return words.toArray(new String[words.size()]);\n    }\n    public String reverse(String s) {\n      StringBuilder res=new StringBuilder();\n        for (int i = 0; i < s.length(); i++)\n            res.insert(0,s.charAt(i));\n        return res.toString();\n    }\n}\n", "public class Solution {\n    public String reverseWords(String input) {\n        final StringBuilder result = new StringBuilder();\n        final StringBuilder word = new StringBuilder();\n        for (int i = 0; i < input.length(); i++) {\n            if (input.charAt(i) != ' ') {\n                word.append(input.charAt(i));\n            } else {\n                result.append(word.reverse());\n                result.append(\" \");\n                word.setLength(0);\n            }\n        }\n        result.append(word.reverse());\n        return result.toString();\n    }\n}\n"]}
{"number": 559, "statement": "Given a n-ary tree, find its maximum depth.\nThe maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.\nNary-Tree input serializationis represented in their level order traversal, each group of children is separated by the null value (See examples).\n", "solutions": ["// Definition for a Node.\nclass Node {\n  public int val;\n  public List<Node> children;\n  public Node() {}\n  public Node(int _val,List<Node> _children) {\n    val = _val;\n    children = _children;\n  }\n};\n", "class Solution {\n  public int maxDepth(Node root) {\n    if (root == null) {\n      return 0;\n    } else if (root.children.isEmpty()) {\n      return 1;  \n    } else {\n      List<Integer> heights = new LinkedList<>();\n      for (Node item : root.children) {\n        heights.add(maxDepth(item)); \n      }\n      return Collections.max(heights) + 1;\n    }\n  }\n}\n", "class Solution {\n  public int maxDepth(Node root) {\n    Queue<Pair<Node, Integer>> stack = new LinkedList<>();\n    if (root != null) {\n      stack.add(new Pair(root, 1));\n    }\n    int depth = 0;\n    while (!stack.isEmpty()) {\n      Pair<Node, Integer> current = stack.poll();\n      root = current.getKey();\n      int current_depth = current.getValue();\n      if (root != null) {\n        depth = Math.max(depth, current_depth);\n        for (Node c : root.children) {\n          stack.add(new Pair(c, current_depth + 1));    \n        }\n      }\n    }\n    return depth;\n  }\n}\n"]}
{"number": 560, "statement": "Given an array of integers and an integer k, you need to find the total number of continuous subarrays whose sum equals to k.\n", "solutions": ["public class Solution {\n    public int subarraySum(int[] nums, int k) {\n        int count = 0;\n        for (int start = 0; start < nums.length; start++) {\n            for (int end = start + 1; end <= nums.length; end++) {\n                int sum = 0;\n                for (int i = start; i < end; i++)\n                    sum += nums[i];\n                if (sum == k)\n                    count++;\n            }\n        }\n        return count;\n    }\n}\n", "public class Solution {\n    public int subarraySum(int[] nums, int k) {\n        int count = 0;\n        int[] sum = new int[nums.length + 1];\n        sum[0] = 0;\n        for (int i = 1; i <= nums.length; i++)\n            sum[i] = sum[i - 1] + nums[i - 1];\n        for (int start = 0; start < nums.length; start++) {\n            for (int end = start + 1; end <= nums.length; end++) {\n                if (sum[end] - sum[start] == k)\n                    count++;\n            }\n        }\n        return count;\n    }\n}\n", "public class Solution {\n    public int subarraySum(int[] nums, int k) {\n        int count = 0;\n        for (int start = 0; start < nums.length; start++) {\n            int sum=0;\n            for (int end = start; end < nums.length; end++) {\n                sum+=nums[end];\n                if (sum == k)\n                    count++;\n            }\n        }\n        return count;\n    }\n}\n", "public class Solution {\n    public int subarraySum(int[] nums, int k) {\n        int count = 0, sum = 0;\n        HashMap < Integer, Integer > map = new HashMap < > ();\n        map.put(0, 1);\n        for (int i = 0; i < nums.length; i++) {\n            sum += nums[i];\n            if (map.containsKey(sum - k))\n                count += map.get(sum - k);\n            map.put(sum, map.getOrDefault(sum, 0) + 1);\n        }\n        return count;\n    }\n}\n"]}
{"number": 561, "statement": "Given an array of 2n integers, your task is to group these integers into n pairs of integer, say (a1, b1), (a2, b2), ..., (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible.\n", "solutions": ["public class Solution {\n    int max_sum = Integer.MIN_VALUE;\n    public int arrayPairSum(int[] nums) {\n        permute(nums, 0);\n        return max_sum;\n    }\n    public void permute(int[] nums, int l) {\n        if (l == nums.length - 1) {\n            int sum = 0;\n            for (int i = 0; i < nums.length / 2; i++) {\n                sum += Math.min(nums[i], nums[nums.length / 2 + i]);\n            }\n            max_sum = Math.max(max_sum, sum);\n        }\n        for (int i = l; i < nums.length; i++) {\n            swap(nums, i, l);\n            permute(nums, l + 1);\n            swap(nums, i, l);\n        }\n    }\n    public void swap(int[] nums, int x, int y) {\n        int temp = nums[x];\n        nums[x] = nums[y];\n        nums[y] = temp;\n    }\n}\n", "public class Solution {\n    public int arrayPairSum(int[] nums) {\n        Arrays.sort(nums);\n        int sum = 0;\n        for (int i = 0; i < nums.length; i += 2) {\n            sum += nums[i];\n        }\n        return sum;\n    }\n}\n", "public class Solution {\n    public int arrayPairSum(int[] nums) {\n        int[] arr = new int[20001];\n        int lim = 10000;\n        for (int num: nums)\n            arr[num + lim]++;\n        int d = 0, sum = 0;\n        for (int i = -10000; i <= 10000; i++) {\n            sum += (arr[i + lim] + 1 - d) / 2 * i;\n            d = (2 + arr[i + lim] - d) % 2;\n        }\n        return sum;\n    }\n} \n"]}
{"number": 562, "statement": "Given a 01 matrix M, find the longest line of consecutive one in the matrix. The line could be horizontal, vertical, diagonal or anti-diagonal.\n", "solutions": ["class Solution {\n  public int longestLine(int[][] M) {\n    if (M.length == 0) return 0;\n    int ones = 0;\n    // horizontal\n    for (int i = 0; i < M.length; i++) {\n      int count = 0;\n      for (int j = 0; j < M[0].length; j++) {\n        if (M[i][j] == 1) {\n          count++;\n          ones = Math.max(ones, count);\n        } else count = 0;\n      }\n    }\n    // vertical\n    for (int i = 0; i < M[0].length; i++) {\n      int count = 0;\n      for (int j = 0; j < M.length; j++) {\n        if (M[j][i] == 1) {\n          count++;\n          ones = Math.max(ones, count);\n        } else count = 0;\n      }\n    }\n    // upper diagonal\n    for (int i = 0; i < M[0].length || i < M.length; i++) {\n      int count = 0;\n      for (int x = 0, y = i; x < M.length && y < M[0].length; x++, y++) {\n        if (M[x][y] == 1) {\n          count++;\n          ones = Math.max(ones, count);\n        } else count = 0;\n      }\n    }\n    // lower diagonal\n    for (int i = 0; i < M[0].length || i < M.length; i++) {\n      int count = 0;\n      for (int x = i, y = 0; x < M.length && y < M[0].length; x++, y++) {\n        if (M[x][y] == 1) {\n          count++;\n          ones = Math.max(ones, count);\n        } else count = 0;\n      }\n    }\n    // upper anti-diagonal\n    for (int i = 0; i < M[0].length || i < M.length; i++) {\n      int count = 0;\n      for (int x = 0, y = M[0].length - i - 1; x < M.length && y >= 0; x++, y--) {\n        if (M[x][y] == 1) {\n          count++;\n          ones = Math.max(ones, count);\n        } else count = 0;\n      }\n    }\n    // lower anti-diagonal\n    for (int i = 0; i < M[0].length || i < M.length; i++) {\n      int count = 0;\n      for (int x = i, y = M[0].length - 1; x < M.length && y >= 0; x++, y--) {\n        // System.out.println(x+\" \"+y);\n        if (M[x][y] == 1) {\n          count++;\n          ones = Math.max(ones, count);\n        } else count = 0;\n      }\n    }\n    return ones;\n  }\n}\n", "class Solution {\n  public int longestLine(int[][] M) {\n    if (M.length == 0) return 0;\n    int ones = 0;\n    int[][][] dp = new int[M.length][M[0].length][4];\n    for (int i = 0; i < M.length; i++) {\n      for (int j = 0; j < M[0].length; j++) {\n        if (M[i][j] == 1) {\n          dp[i][j][0] = j > 0 ? dp[i][j - 1][0] + 1 : 1;\n          dp[i][j][1] = i > 0 ? dp[i - 1][j][1] + 1 : 1;\n          dp[i][j][2] = (i > 0 && j > 0) ? dp[i - 1][j - 1][2] + 1 : 1;\n          dp[i][j][3] = (i > 0 && j < M[0].length - 1) ? dp[i - 1][j + 1][3] + 1 : 1;\n          ones =\n              Math.max(\n                  ones,\n                  Math.max(Math.max(dp[i][j][0], dp[i][j][1]), Math.max(dp[i][j][2], dp[i][j][3])));\n        }\n      }\n    }\n    return ones;\n  }\n}\n", "class Solution {\n  public int longestLine(int[][] M) {\n    if (M.length == 0) return 0;\n    int ones = 0;\n    int[][] dp = new int[M[0].length][4];\n    for (int i = 0; i < M.length; i++) {\n      int old = 0;\n      for (int j = 0; j < M[0].length; j++) {\n        if (M[i][j] == 1) {\n          dp[j][0] = j > 0 ? dp[j - 1][0] + 1 : 1;\n          dp[j][1] = i > 0 ? dp[j][1] + 1 : 1;\n          int prev = dp[j][2];\n          dp[j][2] = (i > 0 && j > 0) ? old + 1 : 1;\n          old = prev;\n          dp[j][3] = (i > 0 && j < M[0].length - 1) ? dp[j + 1][3] + 1 : 1;\n          ones =\n              Math.max(ones, Math.max(Math.max(dp[j][0], dp[j][1]), Math.max(dp[j][2], dp[j][3])));\n        } else {\n          old = dp[j][2];\n          dp[j][0] = dp[j][1] = dp[j][2] = dp[j][3] = 0;\n        }\n      }\n    }\n    return ones;\n  }\n}\n"]}
{"number": 563, "statement": "Given a binary tree, return the tilt of the whole tree.\nThe tilt of a tree node is defined as the absolute difference between the sum of all left subtree node values and the sum of all right subtree node values. Null node has tilt 0.\nThe tilt of the whole tree is defined as the sum of all nodes' tilt.\n", "solutions": ["/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    int tilt = 0;\n    public int findTilt(TreeNode root) {\n        traverse(root);\n        return tilt;\n    }\n    public int traverse(TreeNode root)\n    {\n        if (root == null )\n            return 0;\n        int left = traverse(root.left);\n        int right = traverse(root.right);\n        tilt += Math.abs(left-right);\n        return left + right + root.val;\n    }\n}\n"]}
{"number": 564, "statement": "Given an integer n, find the closest integer (not including itself), which is a palindrome. \nThe 'closest' is defined as absolute difference minimized between two integers.\n", "solutions": ["public class Solution {\n    public String nearestPalindromic(String n) {\n        long num = Long.parseLong(n);\n        for (long i = 1;; i++) {\n            if (isPalindrome(num - i))\n                return \"\" + (num - i);\n            if (isPalindrome(num + i))\n                return \"\" + (num + i);\n        }\n    }\n    boolean isPalindrome(long x) {\n        long t = x, rev = 0;\n        while (t > 0) {\n            rev = 10 * rev + t % 10;\n            t /= 10;\n        }\n        return rev == x;\n    }\n}\n", "public class Solution {\n    public String mirroring(String s) {\n        String x = s.substring(0, (s.length()) / 2);\n        return x + (s.length() % 2 == 1 ? s.charAt(s.length() / 2) : \"\") + new StringBuilder(x).reverse().toString();\n    }\n    public String nearestPalindromic(String n) {\n        if (n.equals(\"1\"))\n            return \"0\";\n        String a = mirroring(n);\n        long diff1 = Long.MAX_VALUE;\n        diff1 = Math.abs(Long.parseLong(n) - Long.parseLong(a));\n        if (diff1 == 0)\n            diff1 = Long.MAX_VALUE;\n        StringBuilder s = new StringBuilder(n);\n        int i = (s.length() - 1) / 2;\n        while (i >= 0 && s.charAt(i) == '0') {\n            s.replace(i, i + 1, \"9\");\n            i--;\n        }\n        if (i == 0 && s.charAt(i) == '1') {\n            s.delete(0, 1);\n            int mid = (s.length() - 1) / 2;\n            s.replace(mid, mid + 1, \"9\");\n        } else\n            s.replace(i, i + 1, \"\" + (char)(s.charAt(i) - 1));\n        String b = mirroring(s.toString());\n        long diff2 = Math.abs(Long.parseLong(n) - Long.parseLong(b));\n        s = new StringBuilder(n);\n        i = (s.length() - 1) / 2;\n        while (i >= 0 && s.charAt(i) == '9') {\n            s.replace(i, i + 1, \"0\");\n            i--;\n        }\n        if (i < 0) {\n            s.insert(0, \"1\");\n        } else\n            s.replace(i, i + 1, \"\" + (char)(s.charAt(i) + 1));\n        String c = mirroring(s.toString());\n        long diff3 = Math.abs(Long.parseLong(n) - Long.parseLong(c));\n        if (diff2 <= diff1 && diff2 <= diff3)\n            return b;\n        if (diff1 <= diff3 && diff1 <= diff2)\n            return a;\n        else\n            return c;\n    }\n}\n"]}
{"number": 565, "statement": "A zero-indexed array A of length N contains all integers from 0 to N-1. Find and return the longest length of set S, where S[i] = {A[i], A[A[i]], A[A[A[i]]], ... } subjected to the rule below.\nSuppose the first element in S starts with the selection of element A[i] of index = i, the next element in S should be A[A[i]], and then A[A[A[i]]]\u2026 By that analogy, we stop adding right before a duplicate element occurs in S.\n", "solutions": ["public class Solution {\n    public int arrayNesting(int[] nums) {\n        int res = 0;\n        for (int i = 0; i < nums.length; i++) {\n            int start = nums[i], count = 0;\n            do {\n                start = nums[start];\n                count++;\n            }\n            while (start != nums[i]);\n            res = Math.max(res, count);\n        }\n        return res;\n    }\n}\n", "public class Solution {\n    public int arrayNesting(int[] nums) {\n        boolean[] visited = new boolean[nums.length];\n        int res = 0;\n        for (int i = 0; i < nums.length; i++) {\n            if (!visited[i]) {\n                int start = nums[i], count = 0;\n                do {\n                    start = nums[start];\n                    count++;\n                    visited[start] = true;\n                }\n                while (start != nums[i]);\n                res = Math.max(res, count);\n            }\n        }\n        return res;\n    }\n}\n", "public class Solution {\n    public int arrayNesting(int[] nums) {\n        int res = 0;\n        for (int i = 0; i < nums.length; i++) {\n            if (nums[i] != Integer.MAX_VALUE) {\n                int start = nums[i], count = 0;\n                while (nums[start] != Integer.MAX_VALUE) {\n                    int temp = start;\n                    start = nums[start];\n                    count++;\n                    nums[temp] = Integer.MAX_VALUE;\n                }\n                res = Math.max(res, count);\n            }\n        }\n        return res;\n    }\n}\n"]}
{"number": 566, "statement": "In MATLAB, there is a very useful function called 'reshape', which can reshape a matrix into a new one with different size but keep its original data.\nYou're given a matrix represented by a two-dimensional array, and two positive integers r and c representing the row number and column number of the wanted reshaped matrix, respectively.\n The reshaped matrix need to be filled with all the elements of the original matrix in the same row-traversing order as they were.\nIf the 'reshape' operation with given parameters is possible and legal, output the new reshaped matrix; Otherwise, output the original matrix.\n", "solutions": ["public class Solution {\n    public int[][] matrixReshape(int[][] nums, int r, int c) {\n        int[][] res = new int[r][c];\n        if (nums.length == 0 || r * c != nums.length * nums[0].length)\n            return nums;\n        int count = 0;\n        Queue < Integer > queue = new LinkedList < > ();\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = 0; j < nums[0].length; j++) {\n                queue.add(nums[i][j]);\n            }\n        }\n        for (int i = 0; i < r; i++) {\n            for (int j = 0; j < c; j++) {\n                res[i][j] = queue.remove();\n            }\n        }\n        return res;\n    }\n}\n", "public class Solution {\n    public int[][] matrixReshape(int[][] nums, int r, int c) {\n        int[][] res = new int[r][c];\n        if (nums.length == 0 || r * c != nums.length * nums[0].length)\n            return nums;\n        int rows = 0, cols = 0;\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = 0; j < nums[0].length; j++) {\n                res[rows][cols] = nums[i][j];\n                cols++;\n                if (cols == c) {\n                    rows++;\n                    cols = 0;\n                }\n            }\n        }\n        return res;\n    }\n}\n", "public class Solution {\n    public int[][] matrixReshape(int[][] nums, int r, int c) {\n        int[][] res = new int[r][c];\n        if (nums.length == 0 || r * c != nums.length * nums[0].length)\n            return nums;\n        int count = 0;\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = 0; j < nums[0].length; j++) {\n                res[count / c][count % c] = nums[i][j];\n                count++;\n            }\n        }\n        return res;\n    }\n}\n"]}
{"number": 567, "statement": "Given two strings s1 and s2, write a function to return true if s2 contains the permutation of s1. In other words, one of the first string's permutations is the substring of the second string.\n", "solutions": ["public class Solution {\n    boolean flag = false;\n    public boolean checkInclusion(String s1, String s2) {\n        permute(s1, s2, 0);\n        return flag;\n    }\n    public String swap(String s, int i0, int i1) {\n        if (i0 == i1)\n            return s;\n        String s1 = s.substring(0, i0);\n        String s2 = s.substring(i0 + 1, i1);\n        String s3 = s.substring(i1 + 1);\n        return s1 + s.charAt(i1) + s2 + s.charAt(i0) + s3;\n    }\n    void permute(String s1, String s2, int l) {\n        if (l == s1.length()) {\n            if (s2.indexOf(s1) >= 0)\n                flag = true;\n        } else {\n            for (int i = l; i < s1.length(); i++) {\n                s1 = swap(s1, l, i);\n                permute(s1, s2, l + 1);\n                s1 = swap(s1, l, i);\n            }\n        }\n    }\n}\n", "public class Solution {\n    public boolean checkInclusion(String s1, String s2) {\n        s1 = sort(s1);\n        for (int i = 0; i <= s2.length() - s1.length(); i++) {\n            if (s1.equals(sort(s2.substring(i, i + s1.length()))))\n                return true;\n        }\n        return false;\n    }\n    public String sort(String s) {\n        char[] t = s.toCharArray();\n        Arrays.sort(t);\n        return new String(t);\n    }\n}\n", "public class Solution {\n    public boolean checkInclusion(String s1, String s2) {\n        if (s1.length() > s2.length())\n            return false;\n        HashMap < Character, Integer > s1map = new HashMap < > ();\n        for (int i = 0; i < s1.length(); i++)\n            s1map.put(s1.charAt(i), s1map.getOrDefault(s1.charAt(i), 0) + 1);\n        for (int i = 0; i <= s2.length() - s1.length(); i++) {\n            HashMap < Character, Integer > s2map = new HashMap < > ();\n            for (int j = 0; j < s1.length(); j++) {\n                s2map.put(s2.charAt(i + j), s2map.getOrDefault(s2.charAt(i + j), 0) + 1);\n            }\n            if (matches(s1map, s2map))\n                return true;\n        }\n        return false;\n    }\n    public boolean matches(HashMap < Character, Integer > s1map, HashMap < Character, Integer > s2map) {\n        for (char key: s1map.keySet()) {\n            if (s1map.get(key) - s2map.getOrDefault(key, -1) != 0)\n                return false;\n        }\n        return true;\n    }\n}\n", "public class Solution {\n    public boolean checkInclusion(String s1, String s2) {\n        if (s1.length() > s2.length())\n            return false;\n        int[] s1map = new int[26];\n        for (int i = 0; i < s1.length(); i++)\n            s1map[s1.charAt(i) - 'a']++;\n        for (int i = 0; i <= s2.length() - s1.length(); i++) {\n            int[] s2map = new int[26];\n            for (int j = 0; j < s1.length(); j++) {\n                s2map[s2.charAt(i + j) - 'a']++;\n            }\n            if (matches(s1map, s2map))\n                return true;\n        }\n        return false;\n    }\n    public boolean matches(int[] s1map, int[] s2map) {\n        for (int i = 0; i < 26; i++) {\n            if (s1map[i] != s2map[i])\n                return false;\n        }\n        return true;\n    }\n}\n", "public class Solution {\n    public boolean checkInclusion(String s1, String s2) {\n        if (s1.length() > s2.length())\n            return false;\n        int[] s1map = new int[26];\n        int[] s2map = new int[26];\n        for (int i = 0; i < s1.length(); i++) {\n            s1map[s1.charAt(i) - 'a']++;\n            s2map[s2.charAt(i) - 'a']++;\n        }\n        for (int i = 0; i < s2.length() - s1.length(); i++) {\n            if (matches(s1map, s2map))\n                return true;\n            s2map[s2.charAt(i + s1.length()) - 'a']++;\n            s2map[s2.charAt(i) - 'a']--;\n        }\n        return matches(s1map, s2map);\n    }\n    public boolean matches(int[] s1map, int[] s2map) {\n        for (int i = 0; i < 26; i++) {\n            if (s1map[i] != s2map[i])\n                return false;\n        }\n        return true;\n    }\n}\n", "public class Solution {\n    public boolean checkInclusion(String s1, String s2) {\n        if (s1.length() > s2.length())\n            return false;\n        int[] s1map = new int[26];\n        int[] s2map = new int[26];\n        for (int i = 0; i < s1.length(); i++) {\n            s1map[s1.charAt(i) - 'a']++;\n            s2map[s2.charAt(i) - 'a']++;\n        }\n        int count = 0;\n        for (int i = 0; i < 26; i++)\n            if (s1map[i] == s2map[i])\n                count++;\n        for (int i = 0; i < s2.length() - s1.length(); i++) {\n            int r = s2.charAt(i + s1.length()) - 'a', l = s2.charAt(i) - 'a';\n            if (count == 26)\n                return true;\n            s2map[r]++;\n            if (s2map[r] == s1map[r])\n                count++;\n            else if (s2map[r] == s1map[r] + 1)\n                count--;\n            s2map[l]--;\n            if (s2map[l] == s1map[l])\n                count++;\n            else if (s2map[l] == s1map[l] - 1)\n                count--;\n        }\n        return count == 26;\n    }\n}\n"]}
{"number": 568, "statement": "LeetCode wants to give one of its best employees the option to travel among N cities to collect algorithm problems. But all work and no play makes Jack a dull boy, you could take vacations in some particular cities and weeks. Your job is to schedule the traveling to maximize the number of vacation days you could take, but there are certain rules and restrictions you need to follow.\nRules and restrictions:\nYou can only travel among N cities, represented by indexes from 0 to N-1. Initially, you are in the city indexed 0 on Monday.\nThe cities are connected by flights. The flights are represented as a N*N matrix (not necessary symmetrical), called flights representing the airline status from the city i to the city j. If there is no flight from the city i to the city j, flights[i][j] = 0; Otherwise, flights[i][j] = 1. Also, flights[i][i] = 0 for all i.\nYou totally have K weeks (each week has 7 days) to travel. You can only take flights at most once per day and can only take flights on each week's Monday morning. Since flight time is so short, we don't consider the impact of flight time.\nFor each city, you can only have restricted vacation days in different weeks, given an N*K matrix called days representing this relationship. For the value of days[i][j], it represents the maximum days you could take vacation in the city i in the week j.\nYou're given the flights matrix and days matrix, and you need to output the maximum vacation days you could take during K weeks.\n", "solutions": ["public class Solution {\n    public int maxVacationDays(int[][] flights, int[][] days) {\n        return dfs(flights, days, 0, 0);\n    }\n    public int dfs(int[][] flights, int[][] days, int cur_city, int weekno) {\n        if (weekno == days[0].length)\n            return 0;\n        int maxvac = 0;\n        for (int i = 0; i < flights.length; i++) {\n            if (flights[cur_city][i] == 1 || i == cur_city) {\n                int vac = days[i][weekno] + dfs(flights, days, i, weekno + 1);\n                maxvac = Math.max(maxvac, vac);\n            }\n        }\n        return maxvac;\n    }\n}\n", "public class Solution {\n    public int maxVacationDays(int[][] flights, int[][] days) {\n        int[][] memo = new int[flights.length][days[0].length];\n        for (int[] l: memo)\n            Arrays.fill(l, Integer.MIN_VALUE);\n        return dfs(flights, days, 0, 0, memo);\n    }\n    public int dfs(int[][] flights, int[][] days, int cur_city, int weekno, int[][] memo) {\n        if (weekno == days[0].length)\n            return 0;\n        if (memo[cur_city][weekno] != Integer.MIN_VALUE)\n            return memo[cur_city][weekno];\n        int maxvac = 0;\n        for (int i = 0; i < flights.length; i++) {\n            if (flights[cur_city][i] == 1 || i == cur_city) {\n                int vac = days[i][weekno] + dfs(flights, days, i, weekno + 1, memo);\n                maxvac = Math.max(maxvac, vac);\n            }\n        }\n        memo[cur_city][weekno] = maxvac;\n        return maxvac;\n    }\n}\n"]}
{"number": 572, "statement": "Given two non-empty binary trees s and t, check whether tree t has exactly the same structure and node values with a subtree of s. A subtree of s is a tree consists of a node in s and all of this node's descendants. The tree s could also be considered as a subtree of itself.\n", "solutions": ["/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    HashSet < String > trees = new HashSet < > ();\n    public boolean isSubtree(TreeNode s, TreeNode t) {\n        String tree1 = preorder(s, true);\n        String tree2 = preorder(t, true);\n        return tree1.indexOf(tree2) >= 0;\n    }\n    public String preorder(TreeNode t, boolean left) {\n        if (t == null) {\n            if (left)\n                return \"lnull\";\n            else\n                return \"rnull\";\n        }\n        return \"#\"+t.val + \" \" +preorder(t.left, true)+\" \" +preorder(t.right, false);\n    }\n}\n", "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\n \npublic class Solution {\n    public boolean isSubtree(TreeNode s, TreeNode t) {\n        return traverse(s,t);\n    }\n    public boolean equals(TreeNode x,TreeNode y)\n    {\n        if(x==null && y==null)\n            return true;\n        if(x==null || y==null)\n            return false;\n        return x.val==y.val && equals(x.left,y.left) && equals(x.right,y.right);\n    }\n    public boolean traverse(TreeNode s,TreeNode t)\n    {\n        return  s!=null && ( equals(s,t) || traverse(s.left,t) || traverse(s.right,t));\n    }\n}\n"]}
{"number": 573, "statement": "There's a tree, a squirrel, and several nuts. Positions are represented by the cells in a 2D grid. Your goal is to find the minimal distance for the squirrel to collect all the nuts and put them under the tree one by one. The squirrel can only take at most one nut at one time and can move in four directions - up, down, left and right, to the adjacent cell. The distance is represented by the number of moves.\n", "solutions": ["public class Solution {\n    public int minDistance(int height, int width, int[] tree, int[] squirrel, int[][] nuts) {\n        int tot_dist = 0, d = Integer.MIN_VALUE;\n        for (int[] nut: nuts) {\n            tot_dist += (distance(nut, tree) * 2);\n            d = Math.max(d, distance(nut, tree) - distance(nut, squirrel));\n        }\n        return tot_dist - d;\n    }\n    public int distance(int[] a, int[] b) {\n        return Math.abs(a[0] - b[0]) + Math.abs(a[1] - b[1]);\n    }\n}\n"]}
{"number": 575, "statement": "Given an integer array with even length, where different numbers in this array represent different kinds of candies. Each number means one candy of the corresponding kind. You need to distribute these candies equally in number to brother and sister. Return the maximum number of kinds of candies the sister could gain. \n", "solutions": ["public class Solution {\n    int max_kind = 0;\n    public int distributeCandies(int[] nums) {\n        permute(nums, 0);\n        return max_kind;\n    }\n    public void permute(int[] nums, int l) {\n        if (l == nums.length - 1) {\n            HashSet < Integer > set = new HashSet < > ();\n            for (int i = 0; i < nums.length / 2; i++) {\n                set.add(nums[i]);\n            }\n            max_kind = Math.max(max_kind, set.size());\n        }\n        for (int i = l; i < nums.length; i++) {\n            swap(nums, i, l);\n            permute(nums, l + 1);\n            swap(nums, i, l);\n        }\n    }\n    public void swap(int[] nums, int x, int y) {\n        int temp = nums[x];\n        nums[x] = nums[y];\n        nums[y] = temp;\n    }\n}\n", "public class Solution {\n    public int distributeCandies(int[] candies) {\n        int count = 0;\n        for (int i = 0; i < candies.length && count < candies.length / 2; i++) {\n            if (candies[i] != Integer.MIN_VALUE) {\n                count++;\n                for (int j = i + 1; j < candies.length; j++) {\n                    if (candies[j] == candies[i])\n                        candies[j] = Integer.MIN_VALUE;\n                }\n            }\n        }\n        return count;\n    }\n}\n", "public class Solution {\n    public int distributeCandies(int[] candies) {\n        Arrays.sort(candies);\n        int count = 1;\n        for (int i = 1; i < candies.length && count < candies.length / 2; i++)\n            if (candies[i] > candies[i - 1])\n                count++;\n        return count;\n    }\n}\n", "public class Solution {\n    public int distributeCandies(int[] candies) {\n        HashSet < Integer > set = new HashSet < > ();\n        for (int candy: candies) {\n            set.add(candy);\n        }\n        return Math.min(set.size(), candies.length / 2);\n    }\n}\n"]}
{"number": 576, "statement": "There is an m by n grid with a ball. Given the start coordinate (i,j) of the ball, you can move the ball to adjacent cell or cross the grid boundary in four directions (up, down, left, right). However, you can at most move N times. Find out the number of paths to move the ball out of grid boundary. The answer may be very large, return it after mod 109 + 7.\n", "solutions": ["class Solution {\n  public int findPaths(int m, int n, int N, int i, int j) {\n    if (i == m || j == n || i < 0 || j < 0) return 1;\n    if (N == 0) return 0;\n    return findPaths(m, n, N - 1, i - 1, j)\n        + findPaths(m, n, N - 1, i + 1, j)\n        + findPaths(m, n, N - 1, i, j - 1)\n        + findPaths(m, n, N - 1, i, j + 1);\n  }\n}\n", "class Solution {\n  int M = 1000000007;\n  public int findPaths(int m, int n, int N, int i, int j) {\n    int[][][] memo = new int[m][n][N + 1];\n    for (int[][] l : memo) for (int[] sl : l) Arrays.fill(sl, -1);\n    return findPaths(m, n, N, i, j, memo);\n  }\n  public int findPaths(int m, int n, int N, int i, int j, int[][][] memo) {\n    if (i == m || j == n || i < 0 || j < 0) return 1;\n    if (N == 0) return 0;\n    if (memo[i][j][N] >= 0) return memo[i][j][N];\n    memo[i][j][N] = (\n        (findPaths(m, n, N - 1, i - 1, j, memo) + findPaths(m, n, N - 1, i + 1, j, memo)) % M +\n        (findPaths(m, n, N - 1, i, j - 1, memo) + findPaths(m, n, N - 1, i, j + 1, memo)) % M\n    ) % M;\n    return memo[i][j][N];\n  }\n}\n", "class Solution {\n  public int findPaths(int m, int n, int N, int x, int y) {\n    int M = 1000000000 + 7;\n    int dp[][] = new int[m][n];\n    dp[x][y] = 1;\n    int count = 0;\n    for (int moves = 1; moves <= N; moves++) {\n      int[][] temp = new int[m][n];\n      for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n          if (i == m - 1) count = (count + dp[i][j]) % M;\n          if (j == n - 1) count = (count + dp[i][j]) % M;\n          if (i == 0) count = (count + dp[i][j]) % M;\n          if (j == 0) count = (count + dp[i][j]) % M;\n          temp[i][j] = (\n              ((i > 0 ? dp[i - 1][j] : 0) + (i < m - 1 ? dp[i + 1][j] : 0)) % M +\n              ((j > 0 ? dp[i][j - 1] : 0) + (j < n - 1 ? dp[i][j + 1] : 0)) % M\n          ) % M;\n        }\n      }\n      dp = temp;\n    }\n    return count;\n  }\n}\n"]}
{"number": 581, "statement": "Given an integer array, you need to find one continuous subarray that if you only sort this subarray in ascending order, then the whole array will be sorted in ascending order, too.  \nYou need to find the shortest such subarray and output its length.\n", "solutions": ["public class Solution {\n    public int findUnsortedSubarray(int[] nums) {\n        int res = nums.length;\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i; j <= nums.length; j++) {\n                int min = Integer.MAX_VALUE, max = Integer.MIN_VALUE, prev = Integer.MIN_VALUE;\n                for (int k = i; k < j; k++) {\n                    min = Math.min(min, nums[k]);\n                    max = Math.max(max, nums[k]);\n                }\n                if ((i > 0 && nums[i - 1] > min) || (j < nums.length && nums[j] < max))\n                    continue;\n                int k = 0;\n                while (k < i && prev <= nums[k]) {\n                    prev = nums[k];\n                    k++;\n                }\n                if (k != i)\n                    continue;\n                k = j;\n                while (k < nums.length && prev <= nums[k]) {\n                    prev = nums[k];\n                    k++;\n                }\n                if (k == nums.length) {\n                    res = Math.min(res, j - i);\n                }\n            }\n        }\n        return res;\n    }\n}\n", "public class Solution {\n    public int findUnsortedSubarray(int[] nums) {\n        int l = nums.length, r = 0;\n        for (int i = 0; i < nums.length - 1; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] < nums[i]) {\n                    r = Math.max(r, j);\n                    l = Math.min(l, i);\n                }\n            }\n        }\n        return r - l < 0 ? 0 : r - l + 1;\n    }\n}\n", "public class Solution {\n    public int findUnsortedSubarray(int[] nums) {\n        int[] snums = nums.clone();\n        Arrays.sort(snums);\n        int start = snums.length, end = 0;\n        for (int i = 0; i < snums.length; i++) {\n            if (snums[i] != nums[i]) {\n                start = Math.min(start, i);\n                end = Math.max(end, i);\n            }\n        }\n        return (end - start >= 0 ? end - start + 1 : 0);\n    }\n}\n", "public class Solution {\n    public int findUnsortedSubarray(int[] nums) {\n        Stack < Integer > stack = new Stack < Integer > ();\n        int l = nums.length, r = 0;\n        for (int i = 0; i < nums.length; i++) {\n            while (!stack.isEmpty() && nums[stack.peek()] > nums[i])\n                l = Math.min(l, stack.pop());\n            stack.push(i);\n        }\n        stack.clear();\n        for (int i = nums.length - 1; i >= 0; i--) {\n            while (!stack.isEmpty() && nums[stack.peek()] < nums[i])\n                r = Math.max(r, stack.pop());\n            stack.push(i);\n        }\n        return r - l > 0 ? r - l + 1 : 0;\n    }\n}\n", "public class Solution {\n    public int findUnsortedSubarray(int[] nums) {\n        int min = Integer.MAX_VALUE, max = Integer.MIN_VALUE;\n        boolean flag = false;\n        for (int i = 1; i < nums.length; i++) {\n            if (nums[i] < nums[i - 1])\n                flag = true;\n            if (flag)\n                min = Math.min(min, nums[i]);\n        }\n        flag = false;\n        for (int i = nums.length - 2; i >= 0; i--) {\n            if (nums[i] > nums[i + 1])\n                flag = true;\n            if (flag)\n                max = Math.max(max, nums[i]);\n        }\n        int l, r;\n        for (l = 0; l < nums.length; l++) {\n            if (min < nums[l])\n                break;\n        }\n        for (r = nums.length - 1; r >= 0; r--) {\n            if (max > nums[r])\n                break;\n        }\n        return r - l < 0 ? 0 : r - l + 1;\n    }\n}\n"]}
{"number": 582, "statement": "Given n processes, each process has a unique PID (process id) and its PPID (parent process id). \nEach process only has one parent process, but may have one or more children processes. This is just like a tree structure.  Only one process has PPID that is 0, which means this process has no parent process. All the PIDs will be distinct positive integers.\nWe use two list of integers to represent a list of processes, where the first list contains PID for each process and the second list contains the corresponding PPID. \nNow given the two lists, and a PID representing a process you want to kill, return a list of PIDs of processes that will be killed in the end. You should assume that when a process is killed, all its children processes will be killed. No order is required for the final answer.\n", "solutions": ["public class Solution {\n    public List < Integer > killProcess(List < Integer > pid, List < Integer > ppid, int kill) {\n        List < Integer > l = new ArrayList < > ();\n        if (kill == 0)\n            return l;\n        l.add(kill);\n        for (int i = 0; i < ppid.size(); i++)\n            if (ppid.get(i) == kill)\n                l.addAll(killProcess(pid, ppid, pid.get(i)));\n        return l;\n    }\n}\n", "public class Solution {\n    class Node {\n        int val;\n        List < Node > children = new ArrayList < > ();\n    }\n    public List < Integer > killProcess(List < Integer > pid, List < Integer > ppid, int kill) {\n        HashMap < Integer, Node > map = new HashMap < > ();\n        for (int id: pid) {\n            Node node = new Node();\n            node.val = id;\n            map.put(id, node);\n        }\n        for (int i = 0; i < ppid.size(); i++) {\n            if (ppid.get(i) > 0) {\n                Node par = map.get(ppid.get(i));\n                par.children.add(map.get(pid.get(i)));\n            }\n        }\n        List < Integer > l = new ArrayList < > ();\n        l.add(kill);\n        getAllChildren(map.get(kill), l);\n        return l;\n    }\n    public void getAllChildren(Node pn, List < Integer > l) {\n        for (Node n: pn.children) {\n            l.add(n.val);\n            getAllChildren(n, l);\n        }\n    }\n}\n", "public class Solution {\n    public List < Integer > killProcess(List < Integer > pid, List < Integer > ppid, int kill) {\n        HashMap < Integer, List < Integer >> map = new HashMap < > ();\n        for (int i = 0; i < ppid.size(); i++) {\n            if (ppid.get(i) > 0) {\n                List < Integer > l = map.getOrDefault(ppid.get(i), new ArrayList < Integer > ());\n                l.add(pid.get(i));\n                map.put(ppid.get(i), l);\n            }\n        }\n        List < Integer > l = new ArrayList < > ();\n        l.add(kill);\n        getAllChildren(map, l, kill);\n        return l;\n    }\n    public void getAllChildren(HashMap < Integer, List < Integer >> map, List < Integer > l, int kill) {\n        if (map.containsKey(kill))\n            for (int id: map.get(kill)) {\n                l.add(id);\n                getAllChildren(map, l, id);\n            }\n    }\n}\n", "public class Solution {\n    public List < Integer > killProcess(List < Integer > pid, List < Integer > ppid, int kill) {\n        HashMap < Integer, List < Integer >> map = new HashMap < > ();\n        for (int i = 0; i < ppid.size(); i++) {\n            if (ppid.get(i) > 0) {\n                List < Integer > l = map.getOrDefault(ppid.get(i), new ArrayList < Integer > ());\n                l.add(pid.get(i));\n                map.put(ppid.get(i), l);\n            }\n        }\n        Queue < Integer > queue = new LinkedList < > ();\n        List < Integer > l = new ArrayList < > ();\n        queue.add(kill);\n        while (!queue.isEmpty()) {\n            int r = queue.remove();\n            l.add(r);\n            if (map.containsKey(r))\n                for (int id: map.get(r))\n                    queue.add(id);\n        }\n        return l;\n    }\n}\n"]}
{"number": 583, "statement": "Given two words word1 and word2, find the minimum number of steps required to make word1 and word2 the same, where in each step you can delete one character in either string.\n", "solutions": ["public class Solution {\n    public int minDistance(String s1, String s2) {\n        return s1.length() + s2.length() - 2 * lcs(s1, s2, s1.length(), s2.length());\n    }\n    public int lcs(String s1, String s2, int m, int n) {\n        if (m == 0 || n == 0)\n            return 0;\n        if (s1.charAt(m - 1) == s2.charAt(n - 1))\n            return 1 + lcs(s1, s2, m - 1, n - 1);\n        else\n            return Math.max(lcs(s1, s2, m, n - 1), lcs(s1, s2, m - 1, n));\n    }\n}\n", "public class Solution {\n    public int minDistance(String s1, String s2) {\n        int[][] memo = new int[s1.length() + 1][s2.length() + 1];\n        return s1.length() + s2.length() - 2 * lcs(s1, s2, s1.length(), s2.length(), memo);\n    }\n    public int lcs(String s1, String s2, int m, int n, int[][] memo) {\n        if (m == 0 || n == 0)\n            return 0;\n        if (memo[m][n] > 0)\n            return memo[m][n];\n        if (s1.charAt(m - 1) == s2.charAt(n - 1))\n            memo[m][n] = 1 + lcs(s1, s2, m - 1, n - 1, memo);\n        else\n            memo[m][n] = Math.max(lcs(s1, s2, m, n - 1, memo), lcs(s1, s2, m - 1, n, memo));\n        return memo[m][n];\n    }\n}\n", "public class Solution {\n    public int minDistance(String s1, String s2) {\n        int[][] dp = new int[s1.length() + 1][s2.length() + 1];\n        for (int i = 0; i <= s1.length(); i++) {\n            for (int j = 0; j <= s2.length(); j++) {\n                if (i == 0 || j == 0)\n                    continue;\n                if (s1.charAt(i - 1) == s2.charAt(j - 1))\n                    dp[i][j] = 1 + dp[i - 1][j - 1];\n                else\n                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\n            }\n        }\n        return s1.length() + s2.length() - 2 * dp[s1.length()][s2.length()];\n    }\n}\n", "public class Solution {\n    public int minDistance(String s1, String s2) {\n        int[][] dp = new int[s1.length() + 1][s2.length() + 1];\n        for (int i = 0; i <= s1.length(); i++) {\n            for (int j = 0; j <= s2.length(); j++) {\n                if (i == 0 || j == 0)\n                    dp[i][j] = i + j;\n                else if (s1.charAt(i - 1) == s2.charAt(j - 1))\n                    dp[i][j] = dp[i - 1][j - 1];\n                else\n                    dp[i][j] = 1 + Math.min(dp[i - 1][j], dp[i][j - 1]);\n            }\n        }\n        return dp[s1.length()][s2.length()];\n    }\n}\n", "public class Solution {\n    public int minDistance(String s1, String s2) {\n        int[] dp = new int[s2.length() + 1];\n        for (int i = 0; i <= s1.length(); i++) {\n            int[] temp=new int[s2.length()+1];\n            for (int j = 0; j <= s2.length(); j++) {\n                if (i == 0 || j == 0)\n                    temp[j] = i + j;\n                else if (s1.charAt(i - 1) == s2.charAt(j - 1))\n                    temp[j] = dp[j - 1];\n                else\n                    temp[j] = 1 + Math.min(dp[j], temp[j - 1]);\n            }\n            dp=temp;\n        }\n        return dp[s2.length()];\n    }\n}\n"]}
{"number": 587, "statement": "There are some trees, where each tree is represented by (x,y) coordinate in a two-dimensional garden. Your job is to fence the entire garden using the minimum length of rope as it is expensive. The garden is well fenced only if all the trees are enclosed. Your task is to help find the coordinates of trees which are exactly located on the fence perimeter.\n", "solutions": ["public class Solution {\n    public int orientation(int[] p, int[] q, int[] r) {\n        return (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1]);\n    }\n    public boolean inBetween(int[] p, int[] i, int[] q) {\n        boolean a = i[0] >= p[0] && i[0] <= q[0] || i[0] <= p[0] && i[0] >= q[0];\n        boolean b = i[1] >= p[1] && i[1] <= q[1] || i[1] <= p[1] && i[1] >= q[1];\n        return a && b;\n    }\n    public int[][] outerTrees(int[][] points) {\n        HashSet<int[]> hull = new HashSet<> ();\n        if (points.length < 4) {\n            for (int[] p: points)\n                hull.add(p);\n            return hull.toArray(new int[hull.size()][]);\n        }\n        int left_most = 0;\n        for (int i = 0; i < points.length; i++)\n            if (points[i][0] < points[left_most][0])\n                left_most = i;\n        int p = left_most;\n        do {\n            int q = (p + 1) % points.length;\n            for (int i = 0; i < points.length; i++) {\n                if (orientation(points[p], points[i], points[q]) < 0) {\n                    q = i;\n                }\n            }\n            for (int i = 0; i < points.length; i++) {\n                if (i != p && i != q && orientation(points[p], points[i], points[q]) == 0 && inBetween(points[p], points[i], points[q])) {\n                    hull.add(points[i]);\n                }\n            }\n            hull.add(points[q]);\n            p = q;\n        }\n        while (p != left_most);\n        return hull.toArray(new int[hull.size()][]);\n    }\n}\n", "public class Solution {\n    public int orientation(int[] p, int[] q, int[] r) {\n        return (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1]);\n    }\n    public int distance(int[] p, int[] q) {\n        return (p[0] - q[0]) * (p[0] - q[0]) + (p[1] - q[1]) * (p[1] - q[1]);\n    }\n    private static int[] bottomLeft(int[][] points) {\n        int[] bottomLeft = points[0];\n        for (int[] p: points)\n            if (p[1] < bottomLeft[1])\n                bottomLeft = p;\n        return bottomLeft;\n    }\n    public int[][] outerTrees(int[][] points) {\n        if (points.length <= 1)\n            return points;\n        int[] bm = bottomLeft(points);\n        Arrays.sort(points, new Comparator<int[]> () {\n            public int compare(int[] p, int[] q) {\n                double diff = orientation(bm, p, q) - orientation(bm, q, p);\n                if (diff == 0)\n                    return distance(bm, p) - distance(bm, q);\n                else\n                    return diff > 0 ? 1 : -1;\n            }\n        });\n        int i = points.length - 1;\n        while (i >= 0 && orientation(bm, points[points.length - 1], points[i]) == 0)\n            i--;\n        for (int l = i + 1, h = points.length - 1; l < h; l++, h--) {\n            int[] temp = points[l];\n            points[l] = points[h];\n            points[h] = temp;\n        }\n        Stack<int[]> stack = new Stack< > ();\n        stack.push(points[0]);\n        stack.push(points[1]);\n        for (int j = 2; j < points.length; j++) {\n            int[] top = stack.pop();\n            while (orientation(stack.peek(), top, points[j]) > 0)\n                top = stack.pop();\n            stack.push(top);\n            stack.push(points[j]);\n        }\n        return stack.toArray(new int[stack.size()][]);\n    }\n}\n", "public class Solution {\n    public int orientation(int[] p, int[] q, int[] r) {\n        return (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1]);\n    }\n    public int[][] outerTrees(int[][] points) {\n        Arrays.sort(points, new Comparator<int[]> () {\n            public int compare(int[] p, int[] q) {\n                return q[0] - p[0] == 0 ? q[1] - p[1] : q[0] - p[0];\n            }\n        });\n        Stack<int[]> hull = new Stack<>();\n        for (int i = 0; i < points.length; i++) {\n            while (hull.size() >= 2 && orientation(hull.get(hull.size() - 2), hull.get(hull.size() - 1), points[i]) > 0)\n                hull.pop();\n            hull.push(points[i]);\n        }\n        hull.pop();\n        for (int i = points.length - 1; i >= 0; i--) {\n            while (hull.size() >= 2 && orientation(hull.get(hull.size() - 2), hull.get(hull.size() - 1), points[i]) > 0)\n                hull.pop();\n            hull.push(points[i]);\n        }\n        // remove redundant elements from the stack\n        HashSet<int[]> ret = new HashSet<>(hull);\n        return ret.toArray(new int[ret.size()][]);\n    }\n}\n"]}
{"number": 588, "statement": "Design an in-memory file system to simulate the following functions:\nls: Given a path in string format. If it is a file path, return a list that only contains this file's name. If it is a directory path, return the list of file and directory names in this directory. Your output (file and directory names together) should in lexicographic order.\nmkdir: Given a directory path that does not exist, you should make a new directory according to the path. If the middle directories in the path don't exist either, you should create them as well. This function has void return type.\naddContentToFile: Given a file path and file content in string format. If the file doesn't exist, you need to create that file containing given content. If the file already exists, you need to append given content to original content. This function has void return type.\nreadContentFromFile: Given a file path, return its content in string format.\n", "solutions": ["public class FileSystem {\n    class Dir {\n        HashMap < String, Dir > dirs = new HashMap < > ();\n        HashMap < String, String > files = new HashMap < > ();\n    }\n    Dir root;\n    public FileSystem() {\n        root = new Dir();\n    }\n    public List < String > ls(String path) {\n        Dir t = root;\n        List < String > files = new ArrayList < > ();\n        if (!path.equals(\"/\")) {\n            String[] d = path.split(\"/\");\n            for (int i = 1; i < d.length - 1; i++) {\n                t = t.dirs.get(d[i]);\n            }\n            if (t.files.containsKey(d[d.length - 1])) {\n                files.add(d[d.length - 1]);\n                return files;\n            } else {\n                t = t.dirs.get(d[d.length - 1]);\n            }\n        }\n        files.addAll(new ArrayList < > (t.dirs.keySet()));\n        files.addAll(new ArrayList < > (t.files.keySet()));\n        Collections.sort(files);\n        return files;\n    }\n    public void mkdir(String path) {\n        Dir t = root;\n        String[] d = path.split(\"/\");\n        for (int i = 1; i < d.length; i++) {\n            if (!t.dirs.containsKey(d[i]))\n                t.dirs.put(d[i], new Dir());\n            t = t.dirs.get(d[i]);\n        }\n    }\n    public void addContentToFile(String filePath, String content) {\n        Dir t = root;\n        String[] d = filePath.split(\"/\");\n        for (int i = 1; i < d.length - 1; i++) {\n            t = t.dirs.get(d[i]);\n        }\n        t.files.put(d[d.length - 1], t.files.getOrDefault(d[d.length - 1], \"\") + content);\n    }\n    public String readContentFromFile(String filePath) {\n        Dir t = root;\n        String[] d = filePath.split(\"/\");\n        for (int i = 1; i < d.length - 1; i++) {\n            t = t.dirs.get(d[i]);\n        }\n        return t.files.get(d[d.length - 1]);\n    }\n}\n/**\n * Your FileSystem object will be instantiated and called as such:\n * FileSystem obj = new FileSystem();\n * List<String> param_1 = obj.ls(path);\n * obj.mkdir(path);\n * obj.addContentToFile(filePath,content);\n * String param_4 = obj.readContentFromFile(filePath);\n */\n", "public class FileSystem {\n    class File {\n        boolean isfile = false;\n        HashMap < String, File > files = new HashMap < > ();\n        String content = \"\";\n    }\n    File root;\n    public FileSystem() {\n        root = new File();\n    }\n    public List < String > ls(String path) {\n        File t = root;\n        List < String > files = new ArrayList < > ();\n        if (!path.equals(\"/\")) {\n            String[] d = path.split(\"/\");\n            for (int i = 1; i < d.length; i++) {\n                t = t.files.get(d[i]);\n            }\n            if (t.isfile) {\n                files.add(d[d.length - 1]);\n                return files;\n            }\n        }\n        List < String > res_files = new ArrayList < > (t.files.keySet());\n        Collections.sort(res_files);\n        return res_files;\n    }\n    public void mkdir(String path) {\n        File t = root;\n        String[] d = path.split(\"/\");\n        for (int i = 1; i < d.length; i++) {\n            if (!t.files.containsKey(d[i]))\n                t.files.put(d[i], new File());\n            t = t.files.get(d[i]);\n        }\n    }\n    public void addContentToFile(String filePath, String content) {\n        File t = root;\n        String[] d = filePath.split(\"/\");\n        for (int i = 1; i < d.length - 1; i++) {\n            t = t.files.get(d[i]);\n        }\n        if (!t.files.containsKey(d[d.length - 1]))\n            t.files.put(d[d.length - 1], new File());\n        t = t.files.get(d[d.length - 1]);\n        t.isfile = true;\n        t.content = t.content + content;\n    }\n    public String readContentFromFile(String filePath) {\n        File t = root;\n        String[] d = filePath.split(\"/\");\n        for (int i = 1; i < d.length - 1; i++) {\n            t = t.files.get(d[i]);\n        }\n        return t.files.get(d[d.length - 1]).content;\n    }\n}\n/**\n * Your FileSystem object will be instantiated and called as such:\n * FileSystem obj = new FileSystem();\n * List<String> param_1 = obj.ls(path);\n * obj.mkdir(path);\n * obj.addContentToFile(filePath,content);\n * String param_4 = obj.readContentFromFile(filePath);\n */\n"]}
{"number": 589, "statement": "Given an n-ary tree, return the preorder traversal of its nodes' values.\nNary-Tree input serializationis represented in their level order traversal, each group of children is separated by the null value (See examples).\nFollow up:\nRecursive solution is trivial, could you do it iteratively?\n", "solutions": ["// Definition for a Node.\nclass Node {\n  public int val;\n  public List<Node> children;\n  public Node() {}\n  public Node(int _val,List<Node> _children) {\n    val = _val;\n    children = _children;\n  }\n};\n", "class Solution {\n  public List<Integer> preorder(Node root) {\n    LinkedList<Node> stack = new LinkedList<>();\n    LinkedList<Integer> output = new LinkedList<>();\n    if (root == null) {\n      return output;\n    }\n    stack.add(root);\n    while (!stack.isEmpty()) {\n      Node node = stack.pollLast();\n      output.add(node.val);\n      Collections.reverse(node.children);\n      for (Node item : node.children) {\n        stack.add(item);\n      }\n    }\n    return output;\n  }\n}\n"]}
{"number": 590, "statement": "Given an n-ary tree, return the postorder traversal of its nodes' values.\nNary-Tree input serializationis represented in their level order traversal, each group of children is separated by the null value (See examples).\nFollow up:\nRecursive solution is trivial, could you do it iteratively?\n", "solutions": ["// Definition for a Node.\nclass Node {\n  public int val;\n  public List<Node> children;\n  public Node() {}\n  public Node(int _val, List<Node> _children) {\n    val = _val;\n    children = _children;\n  }\n};\n", "class Solution {\n  public List<Integer> postorder(Node root) {\n    LinkedList<Node> stack = new LinkedList<>();\n    LinkedList<Integer> output = new LinkedList<>();\n    if (root == null) {\n      return output;\n    }\n    stack.add(root);\n    while (!stack.isEmpty()) {\n      Node node = stack.pollLast();\n      output.addFirst(node.val);\n      for (Node item : node.children) {\n        if (item != null) {\n          stack.add(item);    \n        } \n      }\n    }\n    return output;\n  }\n}\n"]}
{"number": 591, "statement": "Given a string representing a code snippet, you need to implement a tag validator to parse the code and return whether it is valid. A code snippet is valid if all the following rules hold:\nThe code must be wrapped in a valid closed tag. Otherwise, the code is invalid.\nA closed tag (not necessarily valid) has exactly the following format : TAG_NAMETAG_CONTENT/TAG_NAME. Among them, TAG_NAME is the start tag, and /TAG_NAME is the end tag. The TAG_NAME in start and end tags should be the same. A closed tag is valid if and only if the TAG_NAME and TAG_CONTENT are valid.\nA valid TAG_NAME only contain upper-case letters, and has length in range [1,9]. Otherwise, the TAG_NAME is invalid.\nA valid TAG_CONTENT may contain other valid closed tags, cdata and any characters (see note1) EXCEPT unmatched , unmatched start and end tag, and unmatched or closed tags with invalid TAG_NAME. Otherwise, the TAG_CONTENT is invalid.\nA start tag is unmatched if no end tag exists with the same TAG_NAME, and vice versa. However, you also need to consider the issue of unbalanced when tags are nested.\nA  is unmatched if you cannot find a subsequent . And when you find a  or /, all the subsequent characters until the next  should be parsed as TAG_NAME  (not necessarily valid).\nThe cdata has the following format : ![CDATA[CDATA_CONTENT]]. The range of CDATA_CONTENT is defined as the characters between ![CDATA[ and the first subsequent ]]. \nCDATA_CONTENT may contain any characters. The function of cdata is to forbid the validator to parse CDATA_CONTENT, so even it has some characters that can be parsed as tag (no matter valid or invalid), you should treat it as regular characters. \nValid Code \n", "solutions": ["public class Solution {\n    Stack < String > stack = new Stack < > ();\n    boolean contains_tag = false;\n    public boolean isValidTagName(String s, boolean ending) {\n        if (s.length() < 1 || s.length() > 9)\n            return false;\n        for (int i = 0; i < s.length(); i++) {\n            if (!Character.isUpperCase(s.charAt(i)))\n                return false;\n        }\n        if (ending) {\n            if (!stack.isEmpty() && stack.peek().equals(s))\n                stack.pop();\n            else\n                return false;\n        } else {\n            contains_tag = true;\n            stack.push(s);\n        }\n        return true;\n    }\n    public boolean isValidCdata(String s) {\n        return s.indexOf(\"[CDATA[\") == 0;\n    }\n    public boolean isValid(String code) {\n        if (code.charAt(0) != '<' || code.charAt(code.length() - 1) != '>')\n            return false;\n        for (int i = 0; i < code.length(); i++) {\n            boolean ending = false;\n            int closeindex;\n            if(stack.isEmpty() && contains_tag)\n                return false;\n            if (code.charAt(i) == '<') {\n                if (!stack.isEmpty() && code.charAt(i + 1) == '!') {\n                    closeindex = code.indexOf(\"]]>\", i + 1);\n                    if (closeindex < 0 || !isValidCdata(code.substring(i + 2, closeindex)))\n                        return false;\n                } else {\n                    if (code.charAt(i + 1) == '/') {\n                        i++;\n                        ending = true;\n                    }\n                    closeindex = code.indexOf('>', i + 1);\n                    if (closeindex < 0 || !isValidTagName(code.substring(i + 1, closeindex), ending))\n                        return false;\n                }\n                i = closeindex;\n            }\n        }\n        return stack.isEmpty() && contains_tag;\n    }\n}\n", "import java.util.regex.*;\npublic class Solution {\n    Stack < String > stack = new Stack < > ();\n    boolean contains_tag = false;\n    public boolean isValidTagName(String s, boolean ending) {\n        if (ending) {\n            if (!stack.isEmpty() && stack.peek().equals(s))\n                stack.pop();\n            else\n                return false;\n        } else {\n            contains_tag = true;\n            stack.push(s);\n        }\n        return true;\n    }\n    public boolean isValid(String code) {\n        String regex = \"<[A-Z]{0,9}>([^<]*(<((\\\\/?[A-Z]{1,9}>)|(!\\\\[CDATA\\\\[(.*?)]]>)))?)*\";\n        if (!Pattern.matches(regex, code))\n            return false;\n        for (int i = 0; i < code.length(); i++) {\n            boolean ending = false;\n            if (stack.isEmpty() && contains_tag)\n                return false;\n            if (code.charAt(i) == '<') {\n                if (code.charAt(i + 1) == '!') {\n                    i = code.indexOf(\"]]>\", i + 1);\n                    continue;\n                }\n                if (code.charAt(i + 1) == '/') {\n                    i++;\n                    ending = true;\n                }\n                int closeindex = code.indexOf('>', i + 1);\n                if (closeindex < 0 || !isValidTagName(code.substring(i + 1, closeindex), ending))\n                    return false;\n                i = closeindex;\n            }\n        }\n        return stack.isEmpty();\n    }\n}\n"]}
{"number": 592, "statement": "Given a string representing an expression of fraction addition and subtraction, you need to return the calculation result in string format. The final result should be irreducible fraction. If your final result is an integer, say 2, you need to change it to the format of fraction that has denominator 1. So in this case, 2 should be converted to 2/1.\n", "solutions": ["class Solution {\n  public String fractionAddition(String expression) {\n    List<Character> sign = new ArrayList<>();\n    for (int i = 1; i < expression.length(); i++) {\n      if (expression.charAt(i) == '+' || expression.charAt(i) == '-')\n        sign.add(expression.charAt(i));\n    }\n    List<Integer> num = new ArrayList<>();\n    List<Integer> den = new ArrayList<>();\n    for (String sub : expression.split(\"\\\\+\")) {\n      for (String subsub : sub.split(\"-\")) {\n        if (subsub.length() > 0) {\n          String[] fraction = subsub.split(\"/\");\n          num.add(Integer.parseInt(fraction[0]));\n          den.add(Integer.parseInt(fraction[1]));\n        }\n      }\n    }\n    if (expression.charAt(0) == '-') num.set(0, -num.get(0));\n    int lcm = 1;\n    for (int x : den) {\n      lcm = lcm_(lcm, x);\n    }\n    int res = lcm / den.get(0) * num.get(0);\n    for (int i = 1; i < num.size(); i++) {\n      if (sign.get(i - 1) == '+') res += lcm / den.get(i) * num.get(i);\n      else res -= lcm / den.get(i) * num.get(i);\n    }\n    int g = gcd(Math.abs(res), Math.abs(lcm));\n    return (res / g) + \"/\" + (lcm / g);\n  }\n  public int lcm_(int a, int b) {\n    return a * b / gcd(a, b);\n  }\n  public int gcd(int a, int b) {\n    while (b != 0) {\n      int t = b;\n      b = a % b;\n      a = t;\n    }\n    return a;\n  }\n}\n", "class Solution {\n  public String fractionAddition(String expression) {\n    List<Character> sign = new ArrayList<>();\n    if (expression.charAt(0) != '-') sign.add('+');\n    for (int i = 0; i < expression.length(); i++) {\n      if (expression.charAt(i) == '+' || expression.charAt(i) == '-')\n        sign.add(expression.charAt(i));\n    }\n    int prev_num = 0, prev_den = 1, i = 0;\n    for (String sub : expression.split(\"(\\\\+)|(-)\")) {\n      if (sub.length() > 0) {\n        String[] fraction = sub.split(\"/\");\n        int num = (Integer.parseInt(fraction[0]));\n        int den = (Integer.parseInt(fraction[1]));\n        int g = Math.abs(gcd(den, prev_den));\n        if (sign.get(i++) == '+') prev_num = prev_num * den / g + num * prev_den / g;\n        else prev_num = prev_num * den / g - num * prev_den / g;\n        prev_den = den * prev_den / g;\n        g = Math.abs(gcd(prev_den, prev_num));\n        prev_num /= g;\n        prev_den /= g;\n      }\n    }\n    return prev_num + \"/\" + prev_den;\n  }\n  public int gcd(int a, int b) {\n    while (b != 0) {\n      int t = b;\n      b = a % b;\n      a = t;\n    }\n    return a;\n  }\n}\n"]}
{"number": 593, "statement": "Given the coordinates of four points in 2D space, return whether the four points could construct a square.\nThe coordinate (x,y) of a point is represented by an integer array with two integers.\n", "solutions": ["public class Solution {\n    public double dist(int[] p1, int[] p2) {\n        return (p2[1] - p1[1]) * (p2[1] - p1[1]) + (p2[0] - p1[0]) * (p2[0] - p1[0]);\n    }\n    public boolean check(int[] p1, int[] p2, int[] p3, int[] p4) {\n        return dist(p1,p2) > 0 && dist(p1, p2) == dist(p2, p3) && dist(p2, p3) == dist(p3, p4) && dist(p3, p4) == dist(p4, p1) && dist(p1, p3) == dist(p2, p4);\n    }\n    public boolean validSquare(int[] p1, int[] p2, int[] p3, int[] p4) {\n        int[][] p = {p1,p2,p3,p4};\n        return checkAllPermutations(p, 0);\n    }\n    boolean checkAllPermutations(int[][] p, int l) {\n        if (l == 4) {\n            return check(p[0], p[1], p[2], p[3]);\n        } else {\n            boolean res = false;\n            for (int i = l; i < 4; i++) {\n                swap(p, l, i);\n                res |= checkAllPermutations(p, l + 1);\n                swap(p, l, i);\n            }\n            return res;\n        }\n    }\n    public void swap(int[][] p, int x, int y) {\n        int[] temp = p[x];\n        p[x] = p[y];\n        p[y] = temp;\n    }\n}\n", "public class Solution {\n    public double dist(int[] p1, int[] p2) {\n        return (p2[1] - p1[1]) * (p2[1] - p1[1]) + (p2[0] - p1[0]) * (p2[0] - p1[0]);\n    }\n    public boolean validSquare(int[] p1, int[] p2, int[] p3, int[] p4) {\n        int[][] p={p1,p2,p3,p4};\n        Arrays.sort(p, (l1, l2) -> l2[0] == l1[0] ? l1[1] - l2[1] : l1[0] - l2[0]);\n        return dist(p[0], p[1]) != 0 && dist(p[0], p[1]) == dist(p[1], p[3]) && dist(p[1], p[3]) == dist(p[3], p[2]) && dist(p[3], p[2]) == dist(p[2], p[0])   && dist(p[0],p[3])==dist(p[1],p[2]);\n    }\n}\n", "public class Solution {\n    public double dist(int[] p1, int[] p2) {\n        return (p2[1] - p1[1]) * (p2[1] - p1[1]) + (p2[0] - p1[0]) * (p2[0] - p1[0]);\n    }\n    public boolean check(int[] p1, int[] p2, int[] p3, int[] p4) {\n        return dist(p1,p2) > 0 && dist(p1, p2) == dist(p2, p3) && dist(p2, p3) == dist(p3, p4) && dist(p3, p4) == dist(p4, p1) && dist(p1, p3) == dist(p2, p4);\n    }\n    public boolean validSquare(int[] p1, int[] p2, int[] p3, int[] p4) {\n        return check(p1, p2, p3, p4) || check(p1, p3, p2, p4) || check(p1, p2, p4, p3);\n    }\n}\n"]}
{"number": 594, "statement": "We define a harmounious array as an array where the difference between its maximum value and its minimum value is exactly 1.\nNow, given an integer array, you need to find the length of its longest harmonious subsequence among all its possible subsequences.\n", "solutions": ["public class Solution {\n    public int findLHS(int[] nums) {\n        int res = 0;\n        for (int i = 0; i < (1 << nums.length); i++) {\n            int count = 0, min = Integer.MAX_VALUE, max = Integer.MIN_VALUE;\n            for (int j = 0; j < nums.length; j++) {\n                if ((i & (1 << j)) != 0) {\n                    min = Math.min(min, nums[j]);\n                    max = Math.max(max, nums[j]);\n                    count++;\n                }\n            }\n            if (max - min == 1)\n                res = Math.max(res, count);\n        }\n        return res;\n    }\n}\n", "public class Solution {\n    public int findLHS(int[] nums) {\n        int res = 0;\n        for (int i = 0; i < nums.length; i++) {\n            int count = 0;\n            boolean flag = false;\n            for (int j = 0; j < nums.length; j++) {\n                if (nums[j] == nums[i])\n                    count++;\n                else if (nums[j] + 1 == nums[i]) {\n                    count++;\n                    flag = true;\n                }\n            }\n            if (flag)\n                res = Math.max(count, res);\n        }\n        return res;\n    }\n}\n", "public class Solution {\n    public int findLHS(int[] nums) {\n        Arrays.sort(nums);\n        int prev_count = 1, res = 0;\n        for (int i = 0; i < nums.length; i++) {\n            int count = 1;\n            if (i > 0 && nums[i] - nums[i - 1] == 1) {\n                while (i < nums.length - 1 && nums[i] == nums[i + 1]) {\n                    count++;\n                    i++;\n                }\n                res = Math.max(res, count + prev_count);\n                prev_count = count;\n            } else {\n                while (i < nums.length - 1 && nums[i] == nums[i + 1]) {\n                    count++;\n                    i++;\n                }\n                prev_count = count;\n            }\n        }\n        return res;\n    }\n}\n", "public class Solution {\n    public int findLHS(int[] nums) {\n        HashMap < Integer, Integer > map = new HashMap < > ();\n        int res = 0;\n        for (int num: nums) {\n            map.put(num, map.getOrDefault(num, 0) + 1);\n        }\n        for (int key: map.keySet()) {\n            if (map.containsKey(key + 1))\n                res = Math.max(res, map.get(key) + map.get(key + 1));\n        }\n        return res;\n    }\n}\n", "public class Solution {\n    public int findLHS(int[] nums) {\n        HashMap < Integer, Integer > map = new HashMap < > ();\n        int res = 0;\n        for (int num: nums) {\n            map.put(num, map.getOrDefault(num, 0) + 1);\n            if (map.containsKey(num + 1))\n                res = Math.max(res, map.get(num) + map.get(num + 1));\n            if (map.containsKey(num - 1))\n                res = Math.max(res, map.get(num) + map.get(num - 1));\n        }\n        return res;\n    }\n}\n"]}
{"number": 598, "statement": "Given an m * n matrix M initialized with all 0's and several update operations.\nOperations are represented by a 2D array, and each operation is represented by an array with two positive integers a and b, which means M[i][j] should be added by one for all 0 = i  a and 0 = j  b. \nYou need to count and return the number of maximum integers in the matrix after performing all the operations.\n", "solutions": ["public class Solution {\n    public int maxCount(int m, int n, int[][] ops) {\n        int[][] arr = new int[m][n];\n        for (int[] op: ops) {\n            for (int i = 0; i < op[0]; i++) {\n                for (int j = 0; j < op[1]; j++) {\n                    arr[i][j] += 1;\n                }\n            }\n        }\n        int count = 0;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (arr[i][j] == arr[0][0])\n                    count++;\n            }\n        }\n        return count;\n    }\n}\n", "public class Solution {\n    public int maxCount(int m, int n, int[][] ops) {\n        for (int[] op: ops) {\n            m = Math.min(m, op[0]);\n            n = Math.min(n, op[1]);\n        }\n        return m * n;\n    }\n}\n"]}
{"number": 599, "statement": "Suppose Andy and Doris want to choose a restaurant for dinner, and they both have a list of favorite restaurants represented by strings. \nYou need to help them find out their common interest with the least list index sum. If there is a choice tie between answers, output all of them with no order requirement. You could assume there always exists an answer.\n", "solutions": ["public class Solution {\n    public String[] findRestaurant(String[] list1, String[] list2) {\n        HashMap < Integer, List < String >> map = new HashMap < > ();\n        for (int i = 0; i < list1.length; i++) {\n            for (int j = 0; j < list2.length; j++) {\n                if (list1[i].equals(list2[j])) {\n                    if (!map.containsKey(i + j))\n                        map.put(i + j, new ArrayList < String > ());\n                    map.get(i + j).add(list1[i]);\n                }\n            }\n        }\n        int min_index_sum = Integer.MAX_VALUE;\n        for (int key: map.keySet())\n            min_index_sum = Math.min(min_index_sum, key);\n        String[] res = new String[map.get(min_index_sum).size()];\n        return map.get(min_index_sum).toArray(res);\n    }\n}\n", "public class Solution {\n    public String[] findRestaurant(String[] list1, String[] list2) {\n        List < String > res = new ArrayList < > ();\n        for (int sum = 0; sum < list1.length + list2.length - 1; sum++) {\n            for (int i = 0; i <= sum; i++) {\n                if (i < list1.length && sum - i < list2.length && list1[i].equals(list2[sum - i]))\n                    res.add(list1[i]);\n            }\n            if (res.size() > 0)\n                break;\n        }\n        return res.toArray(new String[res.size()]);\n    }\n}\n", "public class Solution {\n    public String[] findRestaurant(String[] list1, String[] list2) {\n        HashMap < String, Integer > map = new HashMap < String, Integer > ();\n        for (int i = 0; i < list1.length; i++)\n            map.put(list1[i], i);\n        List < String > res = new ArrayList < > ();\n        int min_sum = Integer.MAX_VALUE, sum;\n        for (int j = 0; j < list2.length && j <= min_sum; j++) {\n            if (map.containsKey(list2[j])) {\n                sum = j + map.get(list2[j]);\n                if (sum < min_sum) {\n                    res.clear();\n                    res.add(list2[j]);\n                    min_sum = sum;\n                } else if (sum == min_sum)\n                    res.add(list2[j]);\n            }\n        }\n        return res.toArray(new String[res.size()]);\n    }\n}\n"]}
{"number": 600, "statement": "Given a positive integer n, find the number of non-negative integers less than or equal to n, whose binary representations do NOT contain consecutive ones.\n", "solutions": ["public class Solution {\n    public int findIntegers(int num) {\n        int count = 0;\n        for (int i = 0; i <= num; i++)\n            if (check(i))\n                count++;\n        return count;\n    }\n    public boolean check(int n) {\n        int i = 31;\n        while (i > 0) {\n            if ((n & (1 << i)) != 0 && (n & (1 << (i - 1))) != 0)\n                return false;\n            i--;\n        }\n        return true;\n    }\n}\n", "public class Solution {\n    public int findIntegers(int num) {\n        return find(0, 0, num, false);\n    }\n    public int find(int i, int sum, int num, boolean prev) {\n        if (sum > num)\n            return 0;\n        if (1<<i > num)\n            return 1;\n        if (prev)\n            return find(i + 1, sum, num, false);\n        return find(i + 1, sum, num, false) + find(i + 1, sum + (1 << i), num, true);\n    }\n}\n", "public class Solution {\n    public int findIntegers(int num) {\n        int[] f = new int[32];\n        f[0] = 1;\n        f[1] = 2;\n        for (int i = 2; i < f.length; i++)\n            f[i] = f[i - 1] + f[i - 2];\n        int i = 30, sum = 0, prev_bit = 0;\n        while (i >= 0) {\n            if ((num & (1 << i)) != 0) {\n                sum += f[i];\n                if (prev_bit == 1) {\n                    sum--;\n                    break;\n                }\n                prev_bit = 1;\n            } else\n                prev_bit = 0;\n            i--;\n        }\n        return sum + 1;\n    }\n}\n"]}
{"number": 604, "statement": "Design and implement a data structure for a compressed string iterator. It should support the following operations: next and hasNext.\nThe given compressed string will be in the form of each letter followed by a positive integer representing the number of this letter existing in the original uncompressed string.\nnext() - if the original string still has uncompressed characters, return the next letter; Otherwise return a white space.\nhasNext() - Judge whether there is any letter needs to be uncompressed.\nNote:\nPlease remember to RESET your class variables declared in StringIterator, as static/class variables are persisted across multiple test cases. Please see here for more details.\n", "solutions": ["public class StringIterator {\n    StringBuilder res=new StringBuilder();\n    int ptr=0;\n    public StringIterator(String s) {\n        int i = 0;\n        while (i < s.length()) {\n                char ch = s.charAt(i++);\n                int num = 0;\n                while (i < s.length() && Character.isDigit(s.charAt(i))) {\n                    num = num * 10 + s.charAt(i) - '0';\n                    i++;\n                }\n                for (int j = 0; j < num; j++)\n                    res.append(ch);\n        }\n    }\n    public char next() {\n        if (!hasNext())\n            return ' ';\n        return res.charAt(ptr++);\n    }\n    public boolean hasNext() {\n        return ptr!=res.length();\n    }\n}\n", "import java.util.regex.Pattern;\npublic class StringIterator {\n    int ptr = 0;\n    String[] chars;int[] nums;\n    public StringIterator(String compressedString) {\n        nums = Arrays.stream(compressedString.substring(1).split(\"[a-zA-Z]+\")).mapToInt(Integer::parseInt).toArray();;\n        chars = compressedString.split(\"[0-9]+\");\n    }\n    public char next() {\n        if (!hasNext())\n            return ' ';\n        nums[ptr]--;\n        char res=chars[ptr].charAt(0);\n        if(nums[ptr]==0)\n            ptr++;\n        return res;\n    }\n    public boolean hasNext() {\n        return ptr != chars.length;\n    }\n}\n", "public class StringIterator {\n    String res;\n    int ptr = 0, num = 0;\n    char ch = ' ';\n    public StringIterator(String s) {\n        res = s;\n    }\n    public char next() {\n        if (!hasNext())\n            return ' ';\n        if (num == 0) {\n            ch = res.charAt(ptr++);\n            while (ptr < res.length() && Character.isDigit(res.charAt(ptr))) {\n                num = num * 10 + res.charAt(ptr++) - '0';\n            }\n        }\n        num--;\n        return ch;\n    }\n    public boolean hasNext() {\n        return ptr != res.length() || num != 0;\n    }\n}\n"]}
{"number": 605, "statement": "Suppose you have a long flowerbed in which some of the plots are planted and some are not. However, flowers cannot be planted in adjacent plots - they would compete for water and both would die.\nGiven a flowerbed (represented as an array containing 0 and 1, where 0 means empty and 1 means not empty), and a number n, return if n new flowers can be planted in it without violating the no-adjacent-flowers rule.\n", "solutions": ["public class Solution {\n    public boolean canPlaceFlowers(int[] flowerbed, int n) {\n        int i = 0, count = 0;\n        while (i < flowerbed.length) {\n            if (flowerbed[i] == 0 && (i == 0 || flowerbed[i - 1] == 0) && (i == flowerbed.length - 1 || flowerbed[i + 1] == 0)) {\n                flowerbed[i] = 1;\n                count++;\n            }\n            i++;\n        }\n        return count >= n;\n    }\n}\n", "public class Solution {\n    public boolean canPlaceFlowers(int[] flowerbed, int n) {\n        int i = 0, count = 0;\n        while (i < flowerbed.length) {\n            if (flowerbed[i] == 0 && (i == 0 || flowerbed[i - 1] == 0) && (i == flowerbed.length - 1 || flowerbed[i + 1] == 0)) {\n                flowerbed[i++] = 1;\n                count++;\n            }\n             if(count>=n)\n                return true;\n            i++;\n        }\n        return false;\n    }\n}\n"]}
{"number": 606, "statement": "You need to construct a string consists of parenthesis and integers from a binary tree with the preorder traversing way.\nThe null node needs to be represented by empty parenthesis pair \"()\". And you need to omit all the empty parenthesis pairs that don't affect the one-to-one mapping relationship between the string and the original binary tree.\n", "solutions": ["/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public String tree2str(TreeNode t) {\n        if(t==null)\n            return \"\";\n        if(t.left==null && t.right==null)\n            return t.val+\"\";\n        if(t.right==null)\n            return t.val+\"(\"+tree2str(t.left)+\")\";\n        return t.val+\"(\"+tree2str(t.left)+\")(\"+tree2str(t.right)+\")\";   \n    }\n}\n", "public class Solution {\n    public String tree2str(TreeNode t) {\n        if (t == null)\n            return \"\";\n        Stack < TreeNode > stack = new Stack < > ();\n        stack.push(t);\n        Set < TreeNode > visited = new HashSet < > ();\n        StringBuilder s = new StringBuilder();\n        while (!stack.isEmpty()) {\n            t = stack.peek();\n            if (visited.contains(t)) {\n                stack.pop();\n                s.append(\")\");\n            } else {\n                visited.add(t);\n                s.append(\"(\" + t.val);\n                if (t.left == null && t.right != null)\n                    s.append(\"()\");\n                if (t.right != null)\n                    stack.push(t.right);\n                if (t.left != null)\n                    stack.push(t.left);\n            }\n        }\n        return s.substring(1, s.length() - 1);\n    }\n}\n"]}
{"number": 609, "statement": "Given a list of directory info including directory path, and all the files with contents in this directory, you need to find out all the groups of duplicate files in the file system in terms of their paths.\nA group of duplicate files consists of at least two files that have exactly the same content.\nA single directory info string in the input list has the following format:\n\"root/d1/d2/.../dm f1.txt(f1_content) f2.txt(f2_content) ... fn.txt(fn_content)\"\nIt means there are n files (f1.txt, f2.txt ... fn.txt with content f1_content, f2_content ... fn_content, respectively) in directory root/d1/d2/.../dm. Note that n = 1 and m = 0. If m = 0, it means the directory is just the root directory.\nThe output is a list of group of duplicate file paths. For each group, it contains all the file paths of the files that have the same content. A file path is a string that has the following format:\n\"directory_path/file_name.txt\"\n", "solutions": ["public class Solution {\n    public List < List < String >> findDuplicate(String[] paths) {\n        List < String[] > list = new ArrayList < > ();\n        for (String path: paths) {\n            String[] values = path.split(\" \");\n            for (int i = 1; i < values.length; i++) {\n                String[] name_cont = values[i].split(\"\\\\(\");\n                name_cont[1] = name_cont[1].replace(\")\", \"\");\n                list.add(new String[] {\n                    values[0] + \"/\" + name_cont[0], name_cont[1]\n                });\n            }\n        }\n        boolean[] visited = new boolean[list.size()];\n        List < List < String >> res = new ArrayList < > ();\n        for (int i = 0; i < list.size() - 1; i++) {\n            if (visited[i])\n                continue;\n            List < String > l = new ArrayList < > ();\n            for (int j = i + 1; j < list.size(); j++) {\n                if (list.get(i)[1].equals(list.get(j)[1])) {\n                    l.add(list.get(j)[0]);\n                    visited[j] = true;\n                }\n            }\n            if (l.size() > 0) {\n                l.add(list.get(i)[0]);\n                res.add(l);\n            }\n        }\n        return res;\n    }\n}\n", "public class Solution {\n    public List < List < String >> findDuplicate(String[] paths) {\n        HashMap < String, List < String >> map = new HashMap < > ();\n        for (String path: paths) {\n            String[] values = path.split(\" \");\n            for (int i = 1; i < values.length; i++) {\n                String[] name_cont = values[i].split(\"\\\\(\");\n                name_cont[1] = name_cont[1].replace(\")\", \"\");\n                List < String > list = map.getOrDefault(name_cont[1], new ArrayList < String > ());\n                list.add(values[0] + \"/\" + name_cont[0]);\n                map.put(name_cont[1], list);\n            }\n        }\n        List < List < String >> res = new ArrayList < > ();\n        for (String key: map.keySet()) {\n            if (map.get(key).size() > 1)\n                res.add(map.get(key));\n        }\n        return res;\n    }\n}\n"]}
{"number": 611, "statement": "Given an array consists of non-negative integers,  your task is to count the number of triplets chosen from the array that can make triangles if we take them as side lengths of a triangle.\n", "solutions": ["public class Solution {\n    public int triangleNumber(int[] nums) {\n        int count = 0;\n        for (int i = 0; i < nums.length - 2; i++) {\n            for (int j = i + 1; j < nums.length - 1; j++) {\n                for (int k = j + 1; k < nums.length; k++) {\n                    if (nums[i] + nums[j] > nums[k] && nums[i] + nums[k] > nums[j] && nums[j] + nums[k] > nums[i])\n                        count++;\n                }\n            }\n \u00a0 \u00a0 \u00a0 \u00a0} I\n \u00a0 \u00a0 \u00a0 \u00a0return count;\n    }\n}\n", "public class Solution {\n    int binarySearch(int nums[], int l, int r, int x) {\n        while (r >= l && r < nums.length) {\n            int mid = (l + r) / 2;\n            if (nums[mid] >= x)\n                r = mid - 1;\n            else\n                l = mid + 1;\n        }\n        return l;\n    }\n    public int triangleNumber(int[] nums) {\n        int count = 0;\n        Arrays.sort(nums);\n        for (int i = 0; i < nums.length - 2; i++) {\n            int k = i + 2;\n            for (int j = i + 1; j < nums.length - 1 && nums[i] != 0; j++) {\n                k = binarySearch(nums, k, nums.length - 1, nums[i] + nums[j]);\n                count += k - j - 1;\n            }\n        }\n        return count;\n    }\n}\n", "public class Solution {\n    public int triangleNumber(int[] nums) {\n        int count = 0;\n        Arrays.sort(nums);\n        for (int i = 0; i < nums.length - 2; i++) {\n            int k = i + 2;\n            for (int j = i + 1; j < nums.length - 1 && nums[i] != 0; j++) {\n                while (k < nums.length && nums[i] + nums[j] > nums[k])\n                    k++;\n                count += k - j - 1;\n            }\n        }\n        return count;\n    }\n}\n"]}
{"number": 616, "statement": "Given a string s and a list of strings dict, you need to add a closed pair of bold tag b and /b to wrap the substrings in s that exist in dict. If two such substrings overlap, you need to wrap them together by only one pair of closed bold tag. Also, if two substrings wrapped by bold tags are consecutive, you need to combine them.\n", "solutions": ["class Solution {\n    public String boldWords(String S, String[] words) {\n        int N = S.length();\n        boolean[] mask = new boolean[N];\n        for (int i = 0; i < N; ++i)\n            for (String word: words) search: {\n                for (int k = 0; k < word.length(); ++k)\n                    if (k+i >= S.length() || S.charAt(k+i) != word.charAt(k))\n                        break search;\n                for (int j = i; j < i+word.length(); ++j)\n                    mask[j] = true;\n            }\n        StringBuilder ans = new StringBuilder();\n        int anchor = 0;\n        for (int i = 0; i < N; ++i) {\n            if (mask[i] && (i == 0 || !mask[i-1]))\n                ans.append(\"<b>\");\n            ans.append(S.charAt(i));\n            if (mask[i] && (i == N-1 || !mask[i+1]))\n                ans.append(\"</b>\");\n        }\n        return ans.toString();\n    }\n    public boolean match(String S, int i, int j, String T) {\n        for (int k = i; k < j; ++k)\n            if (k >= S.length() || S.charAt(k) != T.charAt(k-i))\n                return false;\n        return true;\n    }\n}\n"]}
{"number": 617, "statement": "Given two binary trees and imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not.\nYou need to merge them into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of new tree.\n", "solutions": ["/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public TreeNode mergeTrees(TreeNode t1, TreeNode t2) {\n        if (t1 == null)\n            return t2;\n        if (t2 == null)\n            return t1;\n        t1.val += t2.val;\n        t1.left = mergeTrees(t1.left, t2.left);\n        t1.right = mergeTrees(t1.right, t2.right);\n        return t1;\n    }\n}\n", "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public TreeNode mergeTrees(TreeNode t1, TreeNode t2) {\n        if (t1 == null)\n            return t2;\n        Stack < TreeNode[] > stack = new Stack < > ();\n        stack.push(new TreeNode[] {t1, t2});\n        while (!stack.isEmpty()) {\n            TreeNode[] t = stack.pop();\n            if (t[0] == null || t[1] == null) {\n                continue;\n            }\n            t[0].val += t[1].val;\n            if (t[0].left == null) {\n                t[0].left = t[1].left;\n            } else {\n                stack.push(new TreeNode[] {t[0].left, t[1].left});\n            }\n            if (t[0].right == null) {\n                t[0].right = t[1].right;\n            } else {\n                stack.push(new TreeNode[] {t[0].right, t[1].right});\n            }\n        }\n        return t1;\n    }\n}\n"]}
{"number": 619, "statement": "SQL SchemaTable my_numbers contains many numbers in column num including duplicated ones.\nCan you write a SQL query to find the biggest number, which only appears once.\n+---+\n|num|\n+---+\n| 8 |\n| 8 |\n| 3 |\n| 3 |\n| 1 |\n| 4 |\n| 5 |\n| 6 | \nFor the sample data above, your query should return the following result:\n+---+\n|num|\n+---+\n| 6 |\nNote:\nIf there is no such number, just output null.\n", "solutions": ["SELECT\n    num\nFROM\n    `number`\nGROUP BY num\nHAVING COUNT(num) = 1;\n", "SELECT\n    MAX(num) AS num\nFROM\n    (SELECT\n        num\n    FROM\n        number\n    GROUP BY num\n    HAVING COUNT(num) = 1) AS t\n;\n"]}
{"number": 621, "statement": "Given a char array representing tasks CPU need to do. It contains capital letters A to Z where different letters represent different tasks. Tasks could be done without original order. Each task could be done in one interval. For each interval, CPU could finish one task or just be idle.\nHowever, there is a non-negative cooling interval n that means between two same tasks, there must be at least n intervals that CPU are doing different tasks or just be idle.\nYou need to return the least number of intervals the CPU will take to finish all the given tasks.\n", "solutions": ["public class Solution {\n    public int leastInterval(char[] tasks, int n) {\n        int[] map = new int[26];\n        for (char c: tasks)\n            map[c - 'A']++;\n        Arrays.sort(map);\n        int time = 0;\n        while (map[25] > 0) {\n            int i = 0;\n            while (i <= n) {\n                if (map[25] == 0)\n                    break;\n                if (i < 26 && map[25 - i] > 0)\n                    map[25 - i]--;\n                time++;\n                i++;\n            }\n            Arrays.sort(map);\n        }\n        return time;\n    }\n}\n", "public class Solution {\n    public int leastInterval(char[] tasks, int n) {\n        int[] map = new int[26];\n        for (char c: tasks)\n            map[c - 'A']++;\n        PriorityQueue < Integer > queue = new PriorityQueue < > (26, Collections.reverseOrder());\n        for (int f: map) {\n            if (f > 0)\n                queue.add(f);\n        }\n        int time = 0;\n        while (!queue.isEmpty()) {\n            int i = 0;\n            List < Integer > temp = new ArrayList < > ();\n            while (i <= n) {\n                if (!queue.isEmpty()) {\n                    if (queue.peek() > 1)\n                        temp.add(queue.poll() - 1);\n                    else\n                        queue.poll();\n                }\n                time++;\n                if (queue.isEmpty() && temp.size() == 0)\n                    break;\n                i++;\n            }\n            for (int l: temp)\n                queue.add(l);\n        }\n        return time;\n    }\n}\n"]}
{"number": 622, "statement": "Design your implementation of the circular queue. The circular queue is a linear data structure in which the operations are performed based on FIFO (First In First Out) principle and the last position is connected back to the first position to make a circle. It is also called \"Ring Buffer\".\nOne of the benefits of the circular queue is that we can make use of the spaces in front of the queue. In a normal queue, once the queue becomes full, we cannot insert the next element even if there is a space in front of the queue. But using the circular queue, we can use the space to store new values.\nYour implementation should support following operations:\nMyCircularQueue(k): Constructor, set the size of the queue to be k.\nFront: Get the front item from the queue. If the queue is empty, return -1.\nRear: Get the last item from the queue. If the queue is empty, return -1.\nenQueue(value): Insert an element into the circular queue. Return true if the operation is successful.\ndeQueue(): Delete an element from the circular queue. Return true if the operation is successful.\nisEmpty(): Checks whether the circular queue is empty or not.\nisFull(): Checks whether the circular queue is full or not.\n", "solutions": ["class MyCircularQueue {\n  private int[] queue;\n  private int headIndex;\n  private int count;\n  private int capacity;\n  /** Initialize your data structure here. Set the size of the queue to be k. */\n  public MyCircularQueue(int k) {\n    this.capacity = k;\n    this.queue = new int[k];\n    this.headIndex = 0;\n    this.count = 0;\n  }\n  /** Insert an element into the circular queue. Return true if the operation is successful. */\n  public boolean enQueue(int value) {\n    if (this.count == this.capacity)\n      return false;\n    this.queue[(this.headIndex + this.count) % this.capacity] = value;\n    this.count += 1;\n    return true;\n  }\n  /** Delete an element from the circular queue. Return true if the operation is successful. */\n  public boolean deQueue() {\n    if (this.count == 0)\n      return false;\n    this.headIndex = (this.headIndex + 1) % this.capacity;\n    this.count -= 1;\n    return true;\n  }\n  /** Get the front item from the queue. */\n  public int Front() {\n    if (this.count == 0)\n      return -1;\n    return this.queue[this.headIndex];\n  }\n  /** Get the last item from the queue. */\n  public int Rear() {\n    if (this.count == 0)\n      return -1;\n    int tailIndex = (this.headIndex + this.count - 1) % this.capacity;\n    return this.queue[tailIndex];\n  }\n  /** Checks whether the circular queue is empty or not. */\n  public boolean isEmpty() {\n    return (this.count == 0);\n  }\n  /** Checks whether the circular queue is full or not. */\n  public boolean isFull() {\n    return (this.count == this.capacity);\n  }\n}\n", "class MyCircularQueue {\n  private Node head, tail;\n  private int count;\n  private int capacity;\n  // Additional variable to secure the access of our queue\n  private ReentrantLock queueLock = new ReentrantLock();\n  /** Initialize your data structure here. Set the size of the queue to be k. */\n  public MyCircularQueue(int k) {\n    this.capacity = k;\n  }\n  /** Insert an element into the circular queue. Return true if the operation is successful. */\n  public boolean enQueue(int value) {\n    // ensure the exclusive access for the following block.\n    queueLock.lock();\n    try {\n      if (this.count == this.capacity)\n        return false;\n      Node newNode = new Node(value);\n      if (this.count == 0) {\n        head = tail = newNode;\n      } else {\n        tail.nextNode = newNode;\n        tail = newNode;\n      }\n      this.count += 1;\n    } finally {\n      queueLock.unlock();\n    }\n    return true;\n  }\n}\n"]}
{"number": 623, "statement": "Given the root of a binary tree, then value v and depth d, you need to add a row of nodes with value v at the given depth d. The root node is at depth 1. \nThe adding rule is: given a positive integer depth d, for each NOT null tree nodes N in depth d-1, create two tree nodes with value v as N's left subtree root and right subtree root. And N's original left subtree should be the left subtree of the new left subtree root, its original right subtree should be the right subtree of the new right subtree root. If depth d is 1 that means there is no depth d-1 at all, then create a tree node with value v as the new root of the whole original tree, and the original tree is the new root's left subtree.\n", "solutions": ["/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public TreeNode addOneRow(TreeNode t, int v, int d) {\n        if (d == 1) {\n            TreeNode n = new TreeNode(v);\n            n.left = t;\n            return n;\n        }\n        insert(v, t, 1, d);\n        return t;\n    }\n    public void insert(int val, TreeNode node, int depth, int n) {\n        if (node == null)\n            return;\n        if (depth == n - 1) {\n            TreeNode t = node.left;\n            node.left = new TreeNode(val);\n            node.left.left = t;\n            t = node.right;\n            node.right = new TreeNode(val);\n            node.right.right = t;\n        } else {\n            insert(val, node.left, depth + 1, n);\n            insert(val, node.right, depth + 1, n);\n        }\n    }\n}\n", "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    class Node{\n        Node(TreeNode n,int d){\n            node=n;\n            depth=d;\n        }\n        TreeNode node;\n        int depth;\n    }\n    public TreeNode addOneRow(TreeNode t, int v, int d) {\n        if (d == 1) {\n            TreeNode n = new TreeNode(v);\n            n.left = t;\n            return n;\n        } \n        Stack<Node> stack=new Stack<>();\n        stack.push(new Node(t,1));\n        while(!stack.isEmpty())\n        {\n            Node n=stack.pop();\n            if(n.node==null)\n                continue;\n            if (n.depth == d - 1 ) {\n                TreeNode temp = n.node.left;\n                n.node.left = new TreeNode(v);\n                n.node.left.left = temp;\n                temp = n.node.right;\n                n.node.right = new TreeNode(v);\n                n.node.right.right = temp;\n                \n            } else{\n                stack.push(new Node(n.node.left, n.depth + 1));\n                stack.push(new Node(n.node.right, n.depth + 1));\n            }\n        }\n        return t;\n    }\n}\n"]}
{"number": 624, "statement": "Given m arrays, and each array is sorted in ascending order. Now you can pick up two integers from two different arrays (each array picks one) and calculate the distance. We define the distance between two integers a and b to be their absolute difference |a-b|. Your task is to find the maximum distance.\n", "solutions": ["public class Solution {\n    public int maxDistance(int[][] list) {\n        int res = 0;\n        for (int i = 0; i < list.length - 1; i++) {\n            for (int j = 0; j < list[i].length; j++) {\n                for (int k = i + 1; k < list.length; k++) {\n                    for (int l = 0; l < list[k].length; l++) {\n                        res = Math.max(res, Math.abs(list[i][j] - list[k][l]));\n                    }\n                }\n            }\n        }\n        return res;\n    }\n}\n", "public class Solution {\n    public int maxDistance(int[][] list) {\n        int res = 0;\n        for (int i = 0; i < list.length - 1; i++) {\n            for (int j = i + 1; j < list.length; j++) {\n                res = Math.max(res, Math.abs(list[i][0] - list[j][list[j].length - 1]));\n                res = Math.max(res, Math.abs(list[j][0] - list[i][list[i].length - 1]));\n            }\n        }\n        return res;\n    }\n}\n"]}
{"number": 625, "statement": "Given a positive integer a, find the smallest positive integer b whose multiplication of each digit equals to a. \nIf there is no answer or the answer is not fit in 32-bit signed integer, then return 0.\n", "solutions": ["public class Solution {\n    public int smallestFactorization(int a) {\n        for (int i = 1; i < 999999999; i++) {\n            long mul = 1, t = i;\n            while (t != 0) {\n                mul *= t % 10;\n                t /= 10;\n            }\n            if (mul == a && mul <= Integer.MAX_VALUE)\n                return i;\n        }\n        return 0;\n    }\n}\n", "public class Solution {\n    long ans;\n    public int smallestFactorization(int a) {\n        if(a < 2)\n            return a;\n        int[] dig=new int[]{9, 8, 7, 6, 5, 4, 3, 2};\n        if (search(dig, 0, a, 1, \"\") && ans <= Integer.MAX_VALUE)\n            return (int)ans;\n        return 0;\n    }\n    public boolean search(int[] dig, int i, int a, long mul, String res) {\n        if (mul > a || i == dig.length )\n            return false;\n        if (mul == a) {\n            ans = Long.parseLong(res);\n            return true;\n        }\n        return search(dig, i, a, mul * dig[i], dig[i] + res) || search(dig, i + 1, a, mul, res);\n    }\n}\n"]}
{"number": 628, "statement": "Given an integer array, find three numbers whose product is maximum and output the maximum product.\n", "solutions": ["public class Solution {\n    public int maximumProduct(int[] nums) {\n        Arrays.sort(nums);\n        return Math.max(nums[0] * nums[1] * nums[nums.length - 1], nums[nums.length - 1] * nums[nums.length - 2] * nums[nums.length - 3]);\n    }\n}\n", "public class Solution {\n    public int maximumProduct(int[] nums) {\n        int min1 = Integer.MAX_VALUE, min2 = Integer.MAX_VALUE;\n        int max1 = Integer.MIN_VALUE, max2 = Integer.MIN_VALUE, max3 = Integer.MIN_VALUE;\n        for (int n: nums) {\n            if (n <= min1) {\n                min2 = min1;\n                min1 = n;\n            } else if (n <= min2) {     // n lies between min1 and min2\n                min2 = n;\n            }\n            if (n >= max1) {            // n is greater than max1, max2 and max3\n                max3 = max2;\n                max2 = max1;\n                max1 = n;\n            } else if (n >= max2) {     // n lies betweeen max1 and max2\n                max3 = max2;\n                max2 = n;\n            } else if (n >= max3) {     // n lies betwen max2 and max3\n                max3 = n;\n            }\n        }\n        return Math.max(min1 * min2 * max1, max1 * max2 * max3);\n    }\n}\n"]}
{"number": 629, "statement": "Given two integers n and k, find how many different arrays consist of numbers from 1 to n such that there are exactly k inverse pairs.\nWe define an inverse pair as following: For ith and jth element in the array, if i  j and a[i]  a[j] then it's an inverse pair; Otherwise, it's not.\nSince the answer may be very large, the answer should be modulo 109 + 7.\n", "solutions": ["public class Solution {\n    Integer[][] memo = new Integer[1001][1001];\n    public int kInversePairs(int n, int k) {\n        if (n == 0)\n            return 0;\n        if (k == 0)\n            return 1;\n        if (memo[n][k] != null)\n            return memo[n][k];\n        int inv = 0;\n        for (int i = 0; i <= Math.min(k, n - 1); i++)\n            inv = (inv + kInversePairs(n - 1, k - i)) % 1000000007;\n        memo[n][k] = inv;\n        return inv;\n    }\n}\n", "public class Solution {\n    public int kInversePairs(int n, int k) {\n        int[][] dp = new int[n + 1][k + 1];\n        for (int i = 1; i <= n; i++) {\n            for (int j = 0; j <= k; j++) {\n                if (j == 0)\n                    dp[i][j] = 1;\n                else {\n                    for (int p = 0; p <= Math.min(j, i - 1); p++)\n                        dp[i][j] = (dp[i][j] + dp[i - 1][j - p]) % 1000000007;\n                }\n            }\n        }\n        return dp[n][k];\n    }\n}\n"]}
{"number": 630, "statement": "There are n different online courses numbered from 1 to n. Each course has some duration(course length) t and closed on dth day. A course should be taken continuously for t days and must be finished before or on the dth day. You will start at the 1st day.\nGiven n online courses represented by pairs (t,d), your task is to find the maximal number of courses that can be taken.\n", "solutions": ["public class Solution {\n    public int scheduleCourse(int[][] courses) {\n        Arrays.sort(courses, (a, b) -> a[1] - b[1]);\n        Integer[][] memo = new Integer[courses.length][courses[courses.length - 1][1] + 1];\n        return schedule(courses, 0, 0, memo);\n    }\n    public int schedule(int[][] courses, int i, int time, Integer[][] memo) {\n        if (i == courses.length)\n            return 0;\n        if (memo[i][time] != null)\n            return memo[i][time];\n        int taken = 0;\n        if (time + courses[i][0] <= courses[i][1])\n            taken = 1 + schedule(courses, i + 1, time + courses[i][0], memo);\n        int not_taken = schedule(courses, i + 1, time, memo);\n        memo[i][time] = Math.max(taken, not_taken);\n        return memo[i][time];\n    }\n}\n", "public class Solution {\n    public int scheduleCourse(int[][] courses) {\n        System.out.println(courses.length);\n        Arrays.sort(courses, (a, b) -> a[1] - b[1]);\n        int time = 0, count = 0;\n        for (int i = 0; i < courses.length; i++) {\n            if (time + courses[i][0] <= courses[i][1]) {\n                time += courses[i][0];\n                count++;\n            } else {\n                int max_i = i;\n                for (int j = 0; j < i; j++) {\n                    if (courses[j][0] > courses[max_i][0])\n                        max_i = j;\n                }\n                if (courses[max_i][0] > courses[i][0]) {\n                    time += courses[i][0] - courses[max_i][0];\n                }\n                courses[max_i][0] = -1;\n            }\n        }\n        return count;\n    }\n}\n"]}
{"number": 631, "statement": "Your task is to design the basic function of Excel and implement the function of sum formula.  Specifically, you need to implement the following functions:\nExcel(int H, char W): This is the constructor. The inputs represents the height and width of the Excel form. H is a positive integer, range from 1 to 26. It represents the height. W is a character range from 'A' to 'Z'. It represents that the width is the number of characters from 'A' to W. The Excel form content is represented by a height * width 2D integer array C, it should be initialized to zero. You should assume that the first row of C starts from 1, and the first column of C starts from 'A'.\nvoid Set(int row, char column, int val): Change the value at C(row, column) to be val.\nint Get(int row, char column): Return the value at C(row, column).\nint Sum(int row, char column, List of Strings : numbers): This function calculate and set the value at C(row, column), where the value should be the sum of cells represented by numbers. This function return the sum result at C(row, column). This sum formula should exist until this cell is overlapped by another value or another sum formula.\nnumbers is a list of strings that each string represent a cell or a range of cells. If the string represent a single cell, then it has the following format : ColRow. For example, \"F7\" represents the cell at (7, F). \nIf the string represent a range of cells, then it has the following format : ColRow1:ColRow2. The range will always be a rectangle, and ColRow1 represent the position of the top-left cell, and ColRow2 represents the position of the bottom-right cell. \n", "solutions": ["public class Excel {\n    Formula[][] Formulas;\n    class Formula {\n        Formula(HashMap < String, Integer > c, int v) {\n            val = v;\n            cells = c;\n        }\n        HashMap < String, Integer > cells;\n        int val;\n    }\n    Stack < int[] > stack = new Stack < > ();\n    public Excel(int H, char W) {\n        Formulas = new Formula[H][(W - 'A') + 1];\n    }\n    public int get(int r, char c) {\n        if (Formulas[r - 1][c - 'A'] == null)\n            return 0;\n        return Formulas[r - 1][c - 'A'].val;\n    }\n    public void set(int r, char c, int v) {\n        Formulas[r - 1][c - 'A'] = new Formula(new HashMap < String, Integer > (), v);\n        topologicalSort(r - 1, c - 'A');\n        execute_stack();\n    }\n    public int sum(int r, char c, String[] strs) {\n        HashMap < String, Integer > cells = convert(strs);\n        int summ = calculate_sum(r - 1, c - 'A', cells);\n        set(r, c, summ);\n        Formulas[r - 1][c - 'A'] = new Formula(cells, summ);\n        return summ;\n    }\n    public void topologicalSort(int r, int c) {\n        for (int i = 0; i < Formulas.length; i++)\n            for (int j = 0; j < Formulas[0].length; j++)\n                if (Formulas[i][j] != null && Formulas[i][j].cells.containsKey(\"\" + (char)('A' + c) + (r + 1))) {\n                    topologicalSort(i, j);\n                }\n        stack.push(new int[] {r,c});\n    }\n    public void execute_stack() {\n        while (!stack.isEmpty()) {\n            int[] top = stack.pop();\n            if (Formulas[top[0]][top[1]].cells.size() > 0)\n                calculate_sum(top[0], top[1], Formulas[top[0]][top[1]].cells);\n        }\n    }\n    public HashMap < String, Integer > convert(String[] strs) {\n        HashMap < String, Integer > res = new HashMap < > ();\n        for (String st: strs) {\n            if (st.indexOf(\":\") < 0)\n                res.put(st, res.getOrDefault(st, 0) + 1);\n            else {\n                String[] cells = st.split(\":\");\n                int si = Integer.parseInt(cells[0].substring(1)), ei = Integer.parseInt(cells[1].substring(1));\n                char sj = cells[0].charAt(0), ej = cells[1].charAt(0);\n                for (int i = si; i <= ei; i++) {\n                    for (char j = sj; j <= ej; j++) {\n                        res.put(\"\" + j + i, res.getOrDefault(\"\" + j + i, 0) + 1);\n                    }\n                }\n            }\n        }\n        return res;\n    }\n    public int calculate_sum(int r, int c, HashMap < String, Integer > cells) {\n        int sum = 0;\n        for (String s: cells.keySet()) {\n            int x = Integer.parseInt(s.substring(1)) - 1, y = s.charAt(0) - 'A';\n            sum += (Formulas[x][y] != null ? Formulas[x][y].val : 0) * cells.get(s);\n        }\n        Formulas[r][c] = new Formula(cells, sum);\n        return sum;\n    }\n}\n"]}
{"number": 632, "statement": "You have k lists of sorted integers in ascending order. Find the smallest range that includes at least one number from each of the k lists.\nWe define the range [a,b] is smaller than range [c,d] if b-a  d-c or a  c if b-a == d-c.\n", "solutions": ["public class Solution {\n    public int[] smallestRange(int[][] nums) {\n        int minx = 0, miny = Integer.MAX_VALUE;\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = 0; j < nums[i].length; j++) {\n                for (int k = i; k < nums.length; k++) {\n                    for (int l = (k == i ? j : 0); l < nums[k].length; l++) {\n                        int min = Math.min(nums[i][j], nums[k][l]);\n                        int max = Math.max(nums[i][j], nums[k][l]);\n                        int n, m;\n                        for (m = 0; m < nums.length; m++) {\n                            for (n = 0; n < nums[m].length; n++) {\n                                if (nums[m][n] >= min && nums[m][n] <= max)\n                                    break;\n                            }\n                            if (n == nums[m].length)\n                                break;\n                        }\n                        if (m == nums.length) {\n                            if (miny - minx > max - min || (miny - minx == max - min && minx > min)) {\n                                miny = max;\n                                minx = min;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return new int[] {minx, miny};\n    }\n}\n", "public class Solution {\n    public int[] smallestRange(int[][] nums) {\n        int minx = 0, miny = Integer.MAX_VALUE;\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = 0; j < nums[i].length; j++) {\n                for (int k = i; k < nums.length; k++) {\n                    for (int l = (k == i ? j : 0); l < nums[k].length; l++) {\n                        int min = Math.min(nums[i][j], nums[k][l]);\n                        int max = Math.max(nums[i][j], nums[k][l]);\n                        int n, m;\n                        for (m = 0; m < nums.length; m++) {\n                            n = Arrays.binarySearch(nums[m], min);\n                            if (n < 0)\n                                n = -1 - n;\n                            if (n == nums[m].length || nums[m][n] < min || nums[m][n] > max)\n                                break;\n                        }\n                        if (m == nums.length) {\n                            if (miny - minx > max - min || (miny - minx == max - min && minx > min)) {\n                                miny = max;\n                                minx = min;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return new int[] {minx, miny};\n    }\n}\n"]}
{"number": 633, "statement": "Given a non-negative integer c, your task is to decide whether there're two integers a and b such that a2 + b2 = c.\n", "solutions": ["public class Solution {\n    public boolean judgeSquareSum(int c) {\n        for (long a = 0; a * a <= c; a++) {\n            for (long b = 0; b * b <= c; b++) {\n                if (a * a + b * b == c)\n                    return true;\n            }\n        }\n        return false;\n    }\n}\n", "public class Solution {\n    public boolean judgeSquareSum(int c) {\n        for (long a = 0; a * a <= c; a++) {\n            int b =  c - (int)(a * a);\n            int i = 1, sum = 0;\n            while (sum < b) {\n                sum += i;\n                i += 2;\n            }\n            if (sum == b)\n                return true;\n        }\n        return false;\n    }\n}\n"]}
{"number": 634, "statement": "In combinatorial mathematics, a derangement is a permutation of the elements of a set, such that no element appears in its original position.\nThere's originally an array consisting of n integers from 1 to n in ascending order, you need to find the number of derangement it can generate.\nAlso, since the answer may be very large, you should return the output mod 109 + 7.\n", "solutions": ["public class Solution {\n    public int findDerangement(int n) {\n        Integer[] memo = new Integer[n + 1];\n        return find(n, memo);\n    }\n    public int find(int n, Integer[] memo) {\n        if (n == 0)\n            return 1;\n        if (n == 1)\n            return 0;\n        if (memo[n] != null)\n            return memo[n];\n        memo[n] = (int)(((n - 1L) * (find(n - 1, memo) + find(n - 2, memo))) % 1000000007);\n        return memo[n];\n    }\n}\n", "public class Solution {\n    public int findDerangement(int n) {\n        if (n == 0)\n            return 1;\n        if (n == 1)\n            return 0;\n        int[] dp = new int[n + 1];\n        dp[0] = 1;\n        dp[1] = 0;\n        for (int i = 2; i <= n; i++)\n            dp[i] = (int)(((i - 1L) * (dp[i - 1] + dp[i - 2])) % 1000000007);\n        return dp[n];\n    }\n}\n"]}
{"number": 635, "statement": "You are given several logs that each log contains a unique id and timestamp. Timestamp is a string that has the following format: Year:Month:Day:Hour:Minute:Second, for example, 2017:01:01:23:59:59. All domains are zero-padded decimal numbers. \nDesign a log storage system to implement the following functions:\nvoid Put(int id, string timestamp): Given a log's unique id and timestamp, store the log in your storage system.\nint[] Retrieve(String start, String end, String granularity): Return the id of logs whose timestamps are within the range from start to end. Start and end all have the same format as timestamp. However, granularity means the time level for consideration. For example, start = \"2017:01:01:23:59:59\", end = \"2017:01:02:23:59:59\", granularity = \"Day\", it means that we need to find the logs within the range from Jan. 1st 2017 to Jan. 2nd 2017.\n", "solutions": ["public class LogSystem {\n    ArrayList < long[] > list;\n    public LogSystem() {\n        list = new ArrayList < long[] > ();\n    }\n    public void put(int id, String timestamp) {\n        int[] st = Arrays.stream(timestamp.split(\":\")).mapToInt(Integer::parseInt).toArray();\n        list.add(new long[] {convert(st), id});\n    }\n    public long convert(int[] st) {\n        st[1] = st[1] - (st[1] == 0 ? 0 : 1);\n        st[2] = st[2] - (st[2] == 0 ? 0 : 1);\n        return (st[0] - 1999L) * (31 * 12) * 24 * 60 * 60 + st[1] * 31 * 24 * 60 * 60 + st[2] * 24 * 60 * 60 + st[3] * 60 * 60 + st[4] * 60 + st[5];\n    }\n    public List < Integer > retrieve(String s, String e, String gra) {\n        ArrayList < Integer > res = new ArrayList();\n        long start = granularity(s, gra, false);\n        long end = granularity(e, gra, true);\n        for (int i = 0; i < list.size(); i++) {\n            if (list.get(i)[0] >= start && list.get(i)[0] < end)\n                res.add((int) list.get(i)[1]);\n        }\n        return res;\n    }\n    public long granularity(String s, String gra, boolean end) {\n        HashMap < String, Integer > h = new HashMap();\n        h.put(\"Year\", 0);\n        h.put(\"Month\", 1);\n        h.put(\"Day\", 2);\n        h.put(\"Hour\", 3);\n        h.put(\"Minute\", 4);\n        h.put(\"Second\", 5);\n        String[] res = new String[] {\"1999\", \"00\", \"00\", \"00\", \"00\", \"00\"};\n        String[] st = s.split(\":\");\n        for (int i = 0; i <= h.get(gra); i++) {\n            res[i] = st[i];\n        }\n        int[] t = Arrays.stream(res).mapToInt(Integer::parseInt).toArray();\n        if (end)\n            t[h.get(gra)]++;\n        return convert(t);\n    }\n}\n", "public class LogSystem {\n    TreeMap < Long, Integer > map;\n    public LogSystem() {\n        map = new TreeMap < Long, Integer > ();\n    }\n    public void put(int id, String timestamp) {\n        int[] st = Arrays.stream(timestamp.split(\":\")).mapToInt(Integer::parseInt).toArray();\n        map.put(convert(st), id);\n    }\n    public long convert(int[] st) {\n        st[1] = st[1] - (st[1] == 0 ? 0 : 1);\n        st[2] = st[2] - (st[2] == 0 ? 0 : 1);\n        return (st[0] - 1999L) * (31 * 12) * 24 * 60 * 60 + st[1] * 31 * 24 * 60 * 60 + st[2] * 24 * 60 * 60 + st[3] * 60 * 60 + st[4] * 60 + st[5];\n    }\n    public List < Integer > retrieve(String s, String e, String gra) {\n        ArrayList < Integer > res = new ArrayList();\n        long start = granularity(s, gra, false);\n        long end = granularity(e, gra, true);\n        for (long key: map.tailMap(start).keySet()) {\n            if (key >= start && key < end)\n                res.add(map.get(key));\n        }\n        return res;\n    }\n    public long granularity(String s, String gra, boolean end) {\n        HashMap < String, Integer > h = new HashMap();\n        h.put(\"Year\", 0);\n        h.put(\"Month\", 1);\n        h.put(\"Day\", 2);\n        h.put(\"Hour\", 3);\n        h.put(\"Minute\", 4);\n        h.put(\"Second\", 5);\n        String[] res = new String[] {\"1999\", \"00\", \"00\", \"00\", \"00\", \"00\"};\n        String[] st = s.split(\":\");\n        for (int i = 0; i <= h.get(gra); i++) {\n            res[i] = st[i];\n        }\n        int[] t = Arrays.stream(res).mapToInt(Integer::parseInt).toArray();\n        if (end)\n            t[h.get(gra)]++;\n        return convert(t);\n    }\n}\n"]}
{"number": 636, "statement": "On a single threaded CPU, we execute some functions. Each function has a unique id between 0 and N-1.\nWe store logs in timestamp order that describe when a function is entered or exited.\nEach log is a string with this format: \"{function_id}:{\"start\" | \"end\"}:{timestamp}\". For example, \"0:start:3\"means the function with id 0 started at the beginning of timestamp 3. \"1:end:2\" means the function with id 1 ended at the end of timestamp 2.\nA function's exclusive timeis the number of units of time spent in this function. Note that this does not include any recursivecalls to child functions.\nThe CPU is single threaded which means that only one function is being executed at a given time unit.\nReturn the exclusive time of each function, sorted by their function id.\n", "solutions": ["public class Solution {\n    public int[] exclusiveTime(int n, List < String > logs) {\n        Stack < Integer > stack = new Stack < > ();\n        int[] res = new int[n];\n        String[] s = logs.get(0).split(\":\");\n        stack.push(Integer.parseInt(s[0]));\n        int i = 1, time = Integer.parseInt(s[2]);\n        while (i < logs.size()) {\n            s = logs.get(i).split(\":\");\n            while (time < Integer.parseInt(s[2])) {\n                res[stack.peek()]++;\n                time++;\n            }\n            if (s[1].equals(\"start\"))\n                stack.push(Integer.parseInt(s[0]));\n            else {\n                res[stack.peek()]++;\n                time++;\n                stack.pop();\n            }\n            i++;\n        }\n        return res;\n    }\n}\n", "public class Solution {\n    public int[] exclusiveTime(int n, List < String > logs) {\n        Stack < Integer > stack = new Stack < > ();\n        int[] res = new int[n];\n        String[] s = logs.get(0).split(\":\");\n        stack.push(Integer.parseInt(s[0]));\n        int i = 1, prev = Integer.parseInt(s[2]);\n        while (i < logs.size()) {\n            s = logs.get(i).split(\":\");\n            if (s[1].equals(\"start\")) {\n                if (!stack.isEmpty())\n                    res[stack.peek()] += Integer.parseInt(s[2]) - prev;\n                stack.push(Integer.parseInt(s[0]));\n                prev = Integer.parseInt(s[2]);\n            } else {\n                res[stack.peek()] += Integer.parseInt(s[2]) - prev + 1;\n                stack.pop();\n                prev = Integer.parseInt(s[2]) + 1;\n            }\n            i++;\n        }\n        return res;\n    }\n}\n"]}
{"number": 637, "statement": "Given a non-empty binary tree, return the average value of the nodes on each level in the form of an array.\n", "solutions": ["/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public List < Double > averageOfLevels(TreeNode root) {\n        List < Integer > count = new ArrayList < > ();\n        List < Double > res = new ArrayList < > ();\n        average(root, 0, res, count);\n        for (int i = 0; i < res.size(); i++)\n            res.set(i, res.get(i) / count.get(i));\n        return res;\n    }\n    public void average(TreeNode t, int i, List < Double > sum, List < Integer > count) {\n        if (t == null)\n            return;\n        if (i < sum.size()) {\n            sum.set(i, sum.get(i) + t.val);\n            count.set(i, count.get(i) + 1);\n        } else {\n            sum.add(1.0 * t.val);\n            count.add(1);\n        }\n        average(t.left, i + 1, sum, count);\n        average(t.right, i + 1, sum, count);\n    }\n}\n", "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public List < Double > averageOfLevels(TreeNode root) {\n        List < Double > res = new ArrayList < > ();\n        Queue < TreeNode > queue = new LinkedList < > ();\n        queue.add(root);\n        while (!queue.isEmpty()) {\n            long sum = 0, count = 0;\n            Queue < TreeNode > temp = new LinkedList < > ();\n            while (!queue.isEmpty()) {\n                TreeNode n = queue.remove();\n                sum += n.val;\n                count++;\n                if (n.left != null)\n                    temp.add(n.left);\n                if (n.right != null)\n                    temp.add(n.right);\n            }\n            queue = temp;\n            res.add(sum * 1.0 / count);\n        }\n        return res;\n    }\n}\n"]}
{"number": 638, "statement": "In LeetCode Store, there are some kinds of items to sell. Each item has a price.\nHowever, there are some special offers, and a special offer consists of one or more different kinds of items with a sale price.\nYou are given the each item's price, a set of special offers, and the number we need to buy for each item.\nThe job is to output the lowest price you have to pay for exactly certain items as given, where you could make optimal use of the special offers.\nEach special offer is represented in the form of an array, the last number represents the price you need to pay for this special offer, other numbers represents how many specific items you could get if you buy this offer.\nYou could use any of special offers as many times as you want.\n", "solutions": ["public class Solution {\n    public int shoppingOffers(List < Integer > price, List < List < Integer >> special, List < Integer > needs) {\n        return shopping(price, special, needs);\n    }\n    public int shopping(List < Integer > price, List < List < Integer >> special, List < Integer > needs) {\n        int j = 0, res = dot(needs, price);\n        for (List < Integer > s: special) {\n            ArrayList < Integer > clone = new ArrayList < > (needs);\n            for (j = 0; j < needs.size(); j++) {\n                int diff = clone.get(j) - s.get(j);\n                if (diff < 0)\n                    break;\n                clone.set(j, diff);\n            }\n            if (j == needs.size())\n                res = Math.min(res, s.get(j) + shopping(price, special, clone));\n        }\n        return res;\n    }\n    public int dot(List < Integer > a, List < Integer > b) {\n        int sum = 0;\n        for (int i = 0; i < a.size(); i++) {\n            sum += a.get(i) * b.get(i);\n        }\n        return sum;\n    }\n}\n", "public class Solution {\n    public int shoppingOffers(List < Integer > price, List < List < Integer >> special, List < Integer > needs) {\n        Map < List < Integer > , Integer > map = new HashMap();\n        return shopping(price, special, needs, map);\n    }\n    public int shopping(List < Integer > price, List < List < Integer >> special, List < Integer > needs, Map < List < Integer > , Integer > map) {\n        if (map.containsKey(needs))\n            return map.get(needs);\n        int j = 0, res = dot(needs, price);\n        for (List < Integer > s: special) {\n            ArrayList < Integer > clone = new ArrayList < > (needs);\n            for (j = 0; j < needs.size(); j++) {\n                int diff = clone.get(j) - s.get(j);\n                if (diff < 0)\n                    break;\n                clone.set(j, diff);\n            }\n            if (j == needs.size())\n                res = Math.min(res, s.get(j) + shopping(price, special, clone, map));\n        }\n        map.put(needs, res);\n        return res;\n    }\n    public int dot(List < Integer > a, List < Integer > b) {\n        int sum = 0;\n        for (int i = 0; i < a.size(); i++) {\n            sum += a.get(i) * b.get(i);\n        }\n        return sum;\n    }\n}\n"]}
{"number": 639, "statement": "A message containing letters from A-Z is being encoded to numbers using the following mapping way:\n'A' - 1\n'B' - 2\n...\n'Z' - 26\nBeyond that, now the encoded string can also contain the character '*', which can be treated as one of the numbers from 1 to 9.\nGiven the encoded message containing digits and the character '*', return the total number of ways to decode it.\nAlso, since the answer may be very large, you should return the output mod 109 + 7.\n", "solutions": ["public class Solution {\n    int M = 1000000007;\n    public int numDecodings(String s) {\n        Integer[] memo=new Integer[s.length()];\n        return ways(s, s.length() - 1,memo);\n    }\n    public int ways(String s, int i,Integer[] memo) {\n        if (i < 0)\n            return 1;\n        if(memo[i]!=null)\n            return memo[i];\n        if (s.charAt(i) == '*') {\n            long res = 9 * ways(s, i - 1,memo);\n            if (i > 0 && s.charAt(i - 1) == '1')\n                res = (res + 9 * ways(s, i - 2,memo)) % M;\n            else if (i > 0 && s.charAt(i - 1) == '2')\n                res = (res + 6 * ways(s, i - 2,memo)) % M;\n            else if (i > 0 && s.charAt(i - 1) == '*')\n                res = (res + 15 * ways(s, i - 2,memo)) % M;\n            memo[i]=(int)res;\n            return memo[i];\n        }\n        long res = s.charAt(i) != '0' ? ways(s, i - 1,memo) : 0;\n        if (i > 0 && s.charAt(i - 1) == '1')\n            res = (res + ways(s, i - 2,memo)) % M;\n        else if (i > 0 && s.charAt(i - 1) == '2' && s.charAt(i) <= '6')\n            res = (res + ways(s, i - 2,memo)) % M;\n        else if (i > 0 && s.charAt(i - 1) == '*')\n                res = (res + (s.charAt(i)<='6'?2:1) * ways(s, i - 2,memo)) % M;\n        memo[i]= (int)res;\n        return memo[i];\n    }\n}\n", "public class Solution {\n    int M = 1000000007;\n    public int numDecodings(String s) {\n        long[] dp = new long[s.length() + 1];\n        dp[0] = 1;\n        dp[1] = s.charAt(0) == '*' ? 9 : s.charAt(0) == '0' ? 0 : 1;\n        for (int i = 1; i < s.length(); i++) {\n            if (s.charAt(i) == '*') {\n                dp[i + 1] = 9 * dp[i];\n                if (s.charAt(i - 1) == '1')\n                    dp[i + 1] = (dp[i + 1] + 9 * dp[i - 1]) % M;\n                else if (s.charAt(i - 1) == '2')\n                    dp[i + 1] = (dp[i + 1] + 6 * dp[i - 1]) % M;\n                else if (s.charAt(i - 1) == '*')\n                    dp[i + 1] = (dp[i + 1] + 15 * dp[i - 1]) % M;\n            } else {\n                dp[i + 1] = s.charAt(i) != '0' ? dp[i] : 0;\n                if (s.charAt(i - 1) == '1')\n                    dp[i + 1] = (dp[i + 1] + dp[i - 1]) % M;\n                else if (s.charAt(i - 1) == '2' && s.charAt(i) <= '6')\n                    dp[i + 1] = (dp[i + 1] + dp[i - 1]) % M;\n                else if (s.charAt(i - 1) == '*')\n                    dp[i + 1] = (dp[i + 1] + (s.charAt(i) <= '6' ? 2 : 1) * dp[i - 1]) % M;\n            }\n        }\n        return (int) dp[s.length()];\n    }\n}\n"]}
{"number": 640, "statement": "Solve a given equation and return the value of x in the form of string \"x=#value\". The equation contains only '+', '-' operation, the variable x and its coefficient.\nIf there is no solution for the equation, return \"No solution\".\nIf there are infinite solutions for the equation, return \"Infinite solutions\".\nIf there is exactly one solution for the equation, we ensure that the value of x is an integer.\n", "solutions": ["public class Solution {\n    public String coeff(String x) {\n        if (x.length() > 1 && x.charAt(x.length() - 2) >= '0' && x.charAt(x.length() - 2) <= '9')\n            return x.replace(\"x\", \"\");\n        return x.replace(\"x\", \"1\");\n    }\n    public String solveEquation(String equation) {\n        String[] lr = equation.split(\"=\");\n        int lhs = 0, rhs = 0;\n        for (String x: breakIt(lr[0])) {\n            if (x.indexOf(\"x\") >= 0) {\n                lhs += Integer.parseInt(coeff(x));\n            } else\n                rhs -= Integer.parseInt(x);\n        }\n        for (String x: breakIt(lr[1])) {\n            if (x.indexOf(\"x\") >= 0)\n                lhs -= Integer.parseInt(coeff(x));\n            else\n                rhs += Integer.parseInt(x);\n        }\n        if (lhs == 0) {\n            if (rhs == 0)\n                return \"Infinite solutions\";\n            else\n                return \"No solution\";\n        }\n        return \"x=\" + rhs / lhs;\n    }\n    public List < String > breakIt(String s) {\n        List < String > res = new ArrayList < > ();\n        String r = \"\";\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == '+' || s.charAt(i) == '-') {\n                if (r.length() > 0)\n                    res.add(r);\n                r = \"\" + s.charAt(i);\n            } else\n                r += s.charAt(i);\n        }\n        res.add(r);\n        return res;\n    }\n}\n", "public class Solution {\n    public String coeff(String x) {\n        if (x.length() > 1 && x.charAt(x.length() - 2) >= '0' && x.charAt(x.length() - 2) <= '9')\n            return x.replace(\"x\", \"\");\n        return x.replace(\"x\", \"1\");\n    }\n    public String solveEquation(String equation) {\n        String[] lr = equation.split(\"=\");\n        int lhs = 0, rhs = 0;\n        for (String x: lr[0].split(\"(?=\\\\+)|(?=-)\")) {\n            if (x.indexOf(\"x\") >= 0) {\n                lhs += Integer.parseInt(coeff(x));\n            } else\n                rhs -= Integer.parseInt(x);\n        }\n        for (String x: lr[1].split(\"(?=\\\\+)|(?=-)\")) {\n            if (x.indexOf(\"x\") >= 0)\n                lhs -= Integer.parseInt(coeff(x));\n            else\n                rhs += Integer.parseInt(x);\n        }\n        if (lhs == 0) {\n            if (rhs == 0)\n                return \"Infinite solutions\";\n            else\n                return \"No solution\";\n        } else\n            return \"x=\" + rhs / lhs;\n    }\n}\n"]}
{"number": 642, "statement": "Design a search autocomplete system for a search engine. Users may input a sentence (at least one word and end with a special character '#'). For each character they type except '#', you need to return the top 3 historical hot sentences that have prefix the same as the part of sentence already typed. Here are the specific rules:\nThe hot degree for a sentence is defined as the number of times a user typed the exactly same sentence before.\nThe returned top 3 hot sentences should be sorted by hot degree (The first is the hottest one). If several sentences have the same degree of hot, you need to use ASCII-code order (smaller one appears first).\nIf less than 3 hot sentences exist, then just return as many as you can.\nWhen the input is a special character, it means the sentence ends, and in this case, you need to return an empty list.\nYour job is to implement the following functions:\nThe constructor function:\nAutocompleteSystem(String[] sentences, int[] times): This is the constructor. The input is historical data. Sentences is a string array consists of previously typed sentences. Times is the corresponding times a sentence has been typed. Your system should record these historical data.\nNow, the user wants to input a new sentence. The following function will provide the next character the user types:\nListString input(char c): The input c is the next character typed by the user. The character will only be lower-case letters ('a' to 'z'), blank space (' ') or a special character ('#'). Also, the previously typed sentence should be recorded in your system. The output will be the top 3 historical hot sentences that have prefix the same as the part of sentence already typed.\n", "solutions": ["class Node {\n  String sentence;\n  int times;\n  Node(String st, int t) {\n    sentence = st;\n    times = t;\n  }\n}\nclass AutocompleteSystem {\n  private HashMap<String, Integer> map = new HashMap<>();\n  private String cur_sent = \"\";\n  public AutocompleteSystem(String[] sentences, int[] times) {\n    for (int i = 0; i < sentences.length; i++) map.put(sentences[i], times[i]);\n  }\n  public List<String> input(char c) {\n    List<String> res = new ArrayList<>();\n    if (c == '#') {\n      map.put(cur_sent, map.getOrDefault(cur_sent, 0) + 1);\n      cur_sent = \"\";\n    } else {\n      List<Node> list = new ArrayList<>();\n      cur_sent += c;\n      for (String key : map.keySet())\n        if (key.indexOf(cur_sent) == 0) {\n          list.add(new Node(key, map.get(key)));\n        }\n      Collections.sort(\n          list,\n          (a, b) -> a.times == b.times ? a.sentence.compareTo(b.sentence) : b.times - a.times);\n      for (int i = 0; i < Math.min(3, list.size()); i++) res.add(list.get(i).sentence);\n    }\n    return res;\n  }\n}\n/**\n * Your AutocompleteSystem object will be instantiated and called as such:\n * AutocompleteSystem obj = new AutocompleteSystem(sentences, times);\n * List<String> param_1 = obj.input(c);\n */\n", "class Node {\n  String sentence;\n  int times;\n  Node(String st, int t) {\n    sentence = st;\n    times = t;\n  }\n}\nclass AutocompleteSystem {\n  private HashMap<String, Integer>[] arr;\n  private String cur_sent = \"\";\n  public AutocompleteSystem(String[] sentences, int[] times) {\n    arr = new HashMap[26];\n    for (int i = 0; i < 26; i++) arr[i] = new HashMap<String, Integer>();\n    for (int i = 0; i < sentences.length; i++)\n      arr[sentences[i].charAt(0) - 'a'].put(sentences[i], times[i]);\n  }\n  public List<String> input(char c) {\n    List<String> res = new ArrayList<>();\n    if (c == '#') {\n      arr[cur_sent.charAt(0) - 'a'].put(\n          cur_sent, arr[cur_sent.charAt(0) - 'a'].getOrDefault(cur_sent, 0) + 1);\n      cur_sent = \"\";\n    } else {\n      List<Node> list = new ArrayList<>();\n      cur_sent += c;\n      for (String key : arr[cur_sent.charAt(0) - 'a'].keySet()) {\n        if (key.indexOf(cur_sent) == 0) {\n          list.add(new Node(key, arr[cur_sent.charAt(0) - 'a'].get(key)));\n        }\n      }\n      Collections.sort(\n          list,\n          (a, b) -> a.times == b.times ? a.sentence.compareTo(b.sentence) : b.times - a.times);\n      for (int i = 0; i < Math.min(3, list.size()); i++) res.add(list.get(i).sentence);\n    }\n    return res;\n  }\n}\n"]}
{"number": 643, "statement": "Given an array consisting of n integers, find the contiguous subarray of given length k that has the maximum average value. And you need to output the maximum average value.\n", "solutions": ["public class Solution {\n    public double findMaxAverage(int[] nums, int k) {\n        int[] sum = new int[nums.length];\n        sum[0] = nums[0];\n        for (int i = 1; i < nums.length; i++)\n        sum[i] = sum[i - 1] + nums[i];\n        double res = sum[k - 1] * 1.0 / k;\n        for (int i = k; i < nums.length; i++) {\n            res = Math.max(res, (sum[i] - sum[i - k]) * 1.0 / k);\n        }\n        return res;\n    }\n}\n", "public class Solution {\n    public double findMaxAverage(int[] nums, int k) {\n        double sum=0;\n        for(int i=0;i<k;i++)\n            sum+=nums[i];\n        double res=sum;\n        for(int i=k;i<nums.length;i++){\n            sum+=nums[i]-nums[i-k];\n                res=Math.max(res,sum);\n        }\n        return res/k;\n    }\n}\n"]}
{"number": 644, "statement": "Given an array consisting of n integers, find the contiguous subarray whose length is greater than or equal to k that has the maximum average value. And you need to output the maximum average value.\n", "solutions": ["public class Solution {\n    public double findMaxAverage(int[] nums, int k) {\n        double res = Integer.MIN_VALUE;\n        for (int s = 0; s < nums.length - k + 1; s++) {\n            long sum = 0;\n            for (int i = s; i < nums.length; i++) {\n                sum += nums[i];\n                if (i - s + 1 >= k)\n                    res = Math.max(res, sum * 1.0 / (i - s + 1));\n            }\n        }\n        return res;\n    }\n}\n", "public class Solution {\n    public double findMaxAverage(int[] nums, int k) {\n        double max_val = Integer.MIN_VALUE;\n        double min_val = Integer.MAX_VALUE;\n        for (int n: nums) {\n            max_val = Math.max(max_val, n);\n            min_val = Math.min(min_val, n);\n        }\n        double prev_mid = max_val, error = Integer.MAX_VALUE;\n        while (error > 0.00001) {\n            double mid = (max_val + min_val) * 0.5;\n            if (check(nums, mid, k))\n                min_val = mid;\n            else\n                max_val = mid;\n            error = Math.abs(prev_mid - mid);\n            prev_mid = mid;\n        }\n        return min_val;\n    }\n    public boolean check(int[] nums, double mid, int k) {\n        double sum = 0, prev = 0, min_sum = 0;\n        for (int i = 0; i < k; i++)\n            sum += nums[i] - mid;\n        if (sum >= 0)\n            return true;\n        for (int i = k; i < nums.length; i++) {\n            sum += nums[i] - mid;\n            prev += nums[i - k] - mid;\n            min_sum = Math.min(prev, min_sum);\n            if (sum >= min_sum)\n                return true;\n        }\n        return false;\n    }\n}\n"]}
{"number": 645, "statement": "The set S originally contains numbers from 1 to n. But unfortunately, due to the data error, one of the numbers in the set got duplicated to another number in the set, which results in repetition of one number and loss of another number. \nGiven an array nums representing the data status of this set after the error. Your task is to firstly find the number occurs twice and then find the number that is missing. Return them in the form of an array.\n", "solutions": ["public class Solution {\n    public int[] findErrorNums(int[] nums) {\n        int dup = -1, missing = -1;\n        for (int i = 1; i <= nums.length; i++) {\n            int count = 0;\n            for (int j = 0; j < nums.length; j++) {\n                if (nums[j] == i)\n                    count++;\n            }\n            if (count == 2)\n                dup = i;\n            else if (count == 0)\n                missing = i;\n        }\n        return new int[] {dup, missing};\n    }\n}\n", "public class Solution {\n    public int[] findErrorNums(int[] nums) {\n        int dup = -1, missing = -1;;\n        for (int i = 1; i <= nums.length; i++) {\n            int count = 0;\n            for (int j = 0; j < nums.length; j++) {\n                if (nums[j] == i)\n                    count++;\n            }\n            if (count == 2)\n                dup = i;\n            else if (count == 0)\n                missing = i;\n            if (dup > 0 && missing > 0)\n                break;\n        }\n        return new int[] {dup, missing};\n    }\n}\n", "public class Solution {\n    public int[] findErrorNums(int[] nums) {\n        Arrays.sort(nums);\n        int dup = -1, missing = 1;\n        for (int i = 1; i < nums.length; i++) {\n            if (nums[i] == nums[i - 1])\n                dup = nums[i];\n            else if (nums[i] > nums[i - 1] + 1)\n                missing = nums[i - 1] + 1;\n        }\n        return new int[] {dup, nums[nums.length - 1] != nums.length ? nums.length : missing};\n    }\n}\n", "public class Solution {\n    public int[] findErrorNums(int[] nums) {\n        Map < Integer, Integer > map = new HashMap();\n        int dup = -1, missing = 1;\n        for (int n: nums) {\n            map.put(n, map.getOrDefault(n, 0) + 1);\n        }\n        for (int i = 1; i <= nums.length; i++) {\n            if (map.containsKey(i)) {\n                if (map.get(i) == 2)\n                    dup = i;\n            } else\n                missing = i;\n        }\n        return new int[]{dup, missing};\n    }\n}\n", "public class Solution {\n    public int[] findErrorNums(int[] nums) {\n        int[] arr = new int[nums.length + 1];\n        int dup = -1, missing = 1;\n        for (int i = 0; i < nums.length; i++) {\n            arr[nums[i]] += 1;\n        }\n        for (int i = 1; i < arr.length; i++) {\n            if (arr[i] == 0)\n                missing = i;\n            else if (arr[i] == 2)\n                dup = i;\n        }\n        return new int[]{dup, missing};\n    }\n}\n", "public class Solution {\n    public int[] findErrorNums(int[] nums) {\n        int dup = -1, missing = 1;\n        for (int n: nums) {\n            if (nums[Math.abs(n) - 1] < 0)\n                dup = Math.abs(n);\n            else\n                nums[Math.abs(n) - 1] *= -1;\n        }\n        for (int i = 1; i < nums.length; i++) {\n            if (nums[i] > 0)\n                missing = i + 1;\n        }\n        return new int[]{dup, missing};\n    }\n}\n", "public class Solution {\n    public int[] findErrorNums(int[] nums) {\n        int xor = 0, xor0 = 0, xor1 = 0;\n        for (int n: nums)\n            xor ^= n;\n        for (int i = 1; i <= nums.length; i++)\n            xor ^= i;\n        int rightmostbit = xor & ~(xor - 1);\n        for (int n: nums) {\n            if ((n & rightmostbit) != 0)\n                xor1 ^= n;\n            else\n                xor0 ^= n;\n        }\n        for (int i = 1; i <= nums.length; i++) {\n            if ((i & rightmostbit) != 0)\n                xor1 ^= i;\n            else\n                xor0 ^= i;\n        }\n        for (int i = 0; i < nums.length; i++) {\n            if (nums[i] == xor0)\n                return new int[]{xor0, xor1};\n        }\n        return new int[]{xor1, xor0};\n    }\n}\n"]}
{"number": 646, "statement": "You are given n pairs of numbers. In every pair, the first number is always smaller than the second number.\nNow, we define a pair (c, d) can follow another pair (a, b) if and only if b  c. Chain of pairs can be formed in this fashion. \nGiven a set of pairs, find the length longest chain which can be formed. You needn't use up all the given pairs. You can select pairs in any order.\n", "solutions": ["class Solution {\n    public int findLongestChain(int[][] pairs) {\n        Arrays.sort(pairs, (a, b) -> a[0] - b[0]);\n        int N = pairs.length;\n        int[] dp = new int[N];\n        Arrays.fill(dp, 1);\n        for (int j = 1; j < N; ++j) {\n            for (int i = 0; i < j; ++i) {\n                if (pairs[i][1] < pairs[j][0])\n                    dp[j] = Math.max(dp[j], dp[i] + 1);\n            }\n        }\n        int ans = 0;\n        for (int x: dp) if (x > ans) ans = x;\n        return ans;\n    }\n}\n", "class Solution {\n    public int findLongestChain(int[][] pairs) {\n        Arrays.sort(pairs, (a, b) -> a[1] - b[1]);\n        int cur = Integer.MIN_VALUE, ans = 0;\n        for (int[] pair: pairs) if (cur < pair[0]) {\n            cur = pair[1];\n            ans++;\n        }\n        return ans;\n    }\n}\n"]}
{"number": 647, "statement": "Given a string, your task is to count how many palindromic substrings in this string.\nThe substrings with different start indexes or end indexes are counted as different substrings even they consist of same characters.\n", "solutions": ["class Solution {\n    public int countSubstrings(String S) {\n        int N = S.length(), ans = 0;\n        for (int center = 0; center <= 2*N-1; ++center) {\n            int left = center / 2;\n            int right = left + center % 2;\n            while (left >= 0 && right < N && S.charAt(left) == S.charAt(right)) {\n                ans++;\n                left--;\n                right++;\n            }\n        }\n        return ans;\n    }\n}\n", "class Solution {\n    public int countSubstrings(String S) {\n        char[] A = new char[2 * S.length() + 3];\n        A[0] = '@';\n        A[1] = '#';\n        A[A.length - 1] = '$';\n        int t = 2;\n        for (char c: S.toCharArray()) {\n            A[t++] = c;\n            A[t++] = '#';\n        }\n        int[] Z = new int[A.length];\n        int center = 0, right = 0;\n        for (int i = 1; i < Z.length - 1; ++i) {\n            if (i < right)\n                Z[i] = Math.min(right - i, Z[2 * center - i]);\n            while (A[i + Z[i] + 1] == A[i - Z[i] - 1])\n                Z[i]++;\n            if (i + Z[i] > right) {\n                center = i;\n                right = i + Z[i];\n            }\n        }\n        int ans = 0;\n        for (int v: Z) ans += (v + 1) / 2;\n        return ans;\n    }\n}\n"]}
{"number": 648, "statement": "In English, we have a concept called root, which can be followed by some other words to form another longer word - let's call this word successor. For example, the root an, followed by other, which can form another word another.\nNow, given a dictionary consisting of many roots and a sentence. You need to replace all the successor in the sentence with the root forming it. If a successor has many roots can form it, replace it with the root with the shortest length.\nYou need to output the sentence after the replacement.\n", "solutions": ["class Solution {\n    public String replaceWords(List<String> roots, String sentence) {\n        Set<String> rootset = new HashSet();\n        for (String root: roots) rootset.add(root);\n        StringBuilder ans = new StringBuilder();\n        for (String word: sentence.split(\"\\\\s+\")) {\n            String prefix = \"\";\n            for (int i = 1; i <= word.length(); ++i) {\n                prefix = word.substring(0, i);\n                if (rootset.contains(prefix)) break;\n            }\n            if (ans.length() > 0) ans.append(\" \");\n            ans.append(prefix);\n        }\n        return ans.toString();\n    }\n}\n", "class Solution {\n    public String replaceWords(List<String> roots, String sentence) {\n        TrieNode trie = new TrieNode();\n        for (String root: roots) {\n            TrieNode cur = trie;\n            for (char letter: root.toCharArray()) {\n                if (cur.children[letter - 'a'] == null)\n                    cur.children[letter - 'a'] = new TrieNode();\n                cur = cur.children[letter - 'a'];\n            }\n            cur.word = root;\n        }\n        StringBuilder ans = new StringBuilder();\n        for (String word: sentence.split(\"\\\\s+\")) {\n            if (ans.length() > 0)\n                ans.append(\" \");\n            TrieNode cur = trie;\n            for (char letter: word.toCharArray()) {\n                if (cur.children[letter - 'a'] == null || cur.word != null)\n                    break;\n                cur = cur.children[letter - 'a'];\n            }\n            ans.append(cur.word != null ? cur.word : word);\n        }\n        return ans.toString();\n    }\n}\nclass TrieNode {\n    TrieNode[] children;\n    String word;\n    TrieNode() {\n        children = new TrieNode[26];\n    }\n}\n"]}
{"number": 649, "statement": "In the world of Dota2, there are two parties: the Radiant and the Dire.\nThe Dota2 senate consists of senators coming from two parties. Now the senate wants to make a decision about a change in the Dota2 game. The voting for this change is a round-based procedure. In each round, each senator can exercise one of the two rights:\nBan one senator's right:\nA senator can make another senator lose all his rights in this and all the following rounds.\nAnnounce the victory:\nIf this senator found the senators who still have rights to vote are all from the same party, he can announce the victory and make the decision about the change in the game.\nGiven a string representing each senator's party belonging. The character 'R' and 'D' represent the Radiant party and the Dire party respectively. Then if there are n senators, the size of the given string will be n.\nThe round-based procedure starts from the first senator to the last senator in the given order. This procedure will last until the end of voting. All the senators who have lost their rights will be skipped during the procedure.\nSuppose every senator is smart enough and will play the best strategy for his own party, you need to predict which party will finally announce the victory and make the change in the Dota2 game. The output should be Radiant or Dire.\n", "solutions": ["class Solution {\n    public String predictPartyVictory(String senate) {\n        Queue<Integer> queue = new LinkedList();\n        int[] people = new int[]{0, 0};\n        int[] bans = new int[]{0, 0};\n        for (char person: senate.toCharArray()) {\n            int x = person == 'R' ? 1 : 0;\n            people[x]++;\n            queue.add(x);\n        }\n        while (people[0] > 0 && people[1] > 0) {\n            int x = queue.poll();\n            if (bans[x] > 0) {\n                bans[x]--;\n                people[x]--;\n            } else {\n                bans[x^1]++;\n                queue.add(x);\n            }\n        }\n        return people[1] > 0 ? \"Radiant\" : \"Dire\";\n    }\n}\n"]}
{"number": 650, "statement": "Initially on a notepad only one character 'A' is present. You can perform two operations on this notepad for each step:\nCopy All: You can copy all the characters present on the notepad (partial copy is not allowed).\nPaste: You can paste the characters which are copied last time.\nGiven a number n. You have to get exactly n 'A' on the notepad by performing the minimum number of steps permitted. Output the minimum number of steps to get n 'A'.\n", "solutions": ["class Solution {\n    public int minSteps(int n) {\n        int ans = 0, d = 2;\n        while (n > 1) {\n            while (n % d == 0) {\n                ans += d;\n                n /= d;\n            }\n            d++;\n        }\n        return ans;\n    }\n}\n"]}
{"number": 651, "statement": "Imagine you have a special keyboard with the following keys: \nKey 1: (A):  Print one 'A' on screen.\nKey 2: (Ctrl-A): Select the whole screen.\nKey 3: (Ctrl-C): Copy selection to buffer.\nKey 4: (Ctrl-V): Print buffer on screen appending it after what has already been printed. \nNow, you can only press the keyboard for N times (with the above four keys), find out the maximum numbers of 'A' you can print on screen.\n", "solutions": ["class Solution {\n    public int maxA(int N) {\n        int[] best = new int[N+1];\n        for (int k = 1; k <= N; ++k) {\n            best[k] = best[k-1] + 1;\n            for (int x = 0; x < k-1; ++x)\n                best[k] = Math.max(best[k], best[x] * (k-x-1));\n        }\n        return best[N];\n    }\n}\n", "class Solution {\n    public int maxA(int N) {\n        int[] best = new int[]{0, 1, 2, 3, 4, 5, 6, 9, 12,\n                               16, 20, 27, 36, 48, 64, 81};\n        int q = N > 15 ? (N - 11) / 5 : 0;\n        return best[N - 5*q] << 2 * q;\n    }\n}\n"]}
{"number": 652, "statement": "Given a binary tree, return all duplicate subtrees. For each kind of duplicate subtrees, you only need to return the root node of any one of them.\nTwo trees are duplicate if they have the same structure with same node values.\n", "solutions": ["class Solution {\n    Map<String, Integer> count;\n    List<TreeNode> ans;\n    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {\n        count = new HashMap();\n        ans = new ArrayList();\n        collect(root);\n        return ans;\n    }\n    public String collect(TreeNode node) {\n        if (node == null) return \"#\";\n        String serial = node.val + \",\" + collect(node.left) + \",\" + collect(node.right);\n        count.put(serial, count.getOrDefault(serial, 0) + 1);\n        if (count.get(serial) == 2)\n            ans.add(node);\n        return serial;\n    }\n}\n", "class Solution {\n    int t;\n    Map<String, Integer> trees;\n    Map<Integer, Integer> count;\n    List<TreeNode> ans;\n    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {\n        t = 1;\n        trees = new HashMap();\n        count = new HashMap();\n        ans = new ArrayList();\n        lookup(root);\n        return ans;\n    }\n    public int lookup(TreeNode node) {\n        if (node == null) return 0;\n        String serial = node.val + \",\" + lookup(node.left) + \",\" + lookup(node.right);\n        int uid = trees.computeIfAbsent(serial, x-> t++);\n        count.put(uid, count.getOrDefault(uid, 0) + 1);\n        if (count.get(uid) == 2)\n            ans.add(node);\n        return uid;\n    }\n}\n"]}
{"number": 653, "statement": "Given a Binary Search Tree and a target number, return true if there exist two elements in the BST such that their sum is equal to the given target.\n", "solutions": ["public class Solution {\n    public boolean findTarget(TreeNode root, int k) {\n        Set < Integer > set = new HashSet();\n        return find(root, k, set);\n    }\n    public boolean find(TreeNode root, int k, Set < Integer > set) {\n        if (root == null)\n            return false;\n        if (set.contains(k - root.val))\n            return true;\n        set.add(root.val);\n        return find(root.left, k, set) || find(root.right, k, set);\n    }\n}\n", "public class Solution {\n    public boolean findTarget(TreeNode root, int k) {\n        Set < Integer > set = new HashSet();\n        Queue < TreeNode > queue = new LinkedList();\n        queue.add(root);\n        while (!queue.isEmpty()) {\n            if (queue.peek() != null) {\n                TreeNode node = queue.remove();\n                if (set.contains(k - node.val))\n                    return true;\n                set.add(node.val);\n                queue.add(node.right);\n                queue.add(node.left);\n            } else\n                queue.remove();\n        }\n        return false;\n    }\n}\n", "public class Solution {\n    public boolean findTarget(TreeNode root, int k) {\n        List < Integer > list = new ArrayList();\n        inorder(root, list);\n        int l = 0, r = list.size() - 1;\n        while (l < r) {\n            int sum = list.get(l) + list.get(r);\n            if (sum == k)\n                return true;\n            if (sum < k)\n                l++;\n            else\n                r--;\n        }\n        return false;\n    }\n    public void inorder(TreeNode root, List < Integer > list) {\n        if (root == null)\n            return;\n        inorder(root.left, list);\n        list.add(root.val);\n        inorder(root.right, list);\n    }\n}\n"]}
{"number": 654, "statement": "Given an integer array with no duplicates. A maximum tree building on this array is defined as follow:\nThe root is the maximum number in the array. \nThe left subtree is the maximum tree constructed from left part subarray divided by the maximum number.\nThe right subtree is the maximum tree constructed from right part subarray divided by the maximum number. \nConstruct the maximum tree by the given array and output the root node of this tree.\n", "solutions": ["public class Solution {\n    public TreeNode constructMaximumBinaryTree(int[] nums) {\n        return construct(nums, 0, nums.length);\n    }\n    public TreeNode construct(int[] nums, int l, int r) {\n        if (l == r)\n            return null;\n        int max_i = max(nums, l, r);\n        TreeNode root = new TreeNode(nums[max_i]);\n        root.left = construct(nums, l, max_i);\n        root.right = construct(nums, max_i + 1, r);\n        return root;\n    }\n    public int max(int[] nums, int l, int r) {\n        int max_i = l;\n        for (int i = l; i < r; i++) {\n            if (nums[max_i] < nums[i])\n                max_i = i;\n        }\n        return max_i;\n    }\n}\n"]}
{"number": 655, "statement": "Print a binary tree in an m*n 2D string array following these rules: \nThe row number m should be equal to the height of the given binary tree.\nThe column number n should always be an odd number.\nThe root node's value (in string format) should be put in the exactly middle of the first row it can be put. The column and the row where the root node belongs will separate the rest space into two parts (left-bottom part and right-bottom part). You should print the left subtree in the left-bottom part and print the right subtree in the right-bottom part. The left-bottom part and the right-bottom part should have the same size. Even if one subtree is none while the other is not, you don't need to print anything for the none subtree but still need to leave the space as large as that for the other subtree. However, if two subtrees are none, then you don't need to leave space for both of them. \nEach unused space should contain an empty string \"\".\nPrint the subtrees following the same rules.\n", "solutions": ["public class Solution {\n    public List<List<String>> printTree(TreeNode root) {\n        int height = getHeight(root);\n        String[][] res = new String[height][(1 << height) - 1];\n        for(String[] arr:res)\n            Arrays.fill(arr,\"\");\n        List<List<String>> ans = new ArrayList<>();\n        fill(res, root, 0, 0, res[0].length);\n        for(String[] arr:res)\n            ans.add(Arrays.asList(arr));\n        return ans;\n    }\n    public void fill(String[][] res, TreeNode root, int i, int l, int r) {\n        if (root == null)\n            return;\n        res[i][(l + r) / 2] = \"\" + root.val;\n        fill(res, root.left, i + 1, l, (l + r) / 2);\n        fill(res, root.right, i + 1, (l + r + 1) / 2, r);\n    }\n    public int getHeight(TreeNode root) {\n        if (root == null)\n            return 0;\n        return 1 + Math.max(getHeight(root.left), getHeight(root.right));\n    }\n}\n", "public class Solution\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    class Params {\n        Params(TreeNode n, int ii, int ll, int rr) {\n            root = n;\n            i = ii;\n            l = ll;\n            r = rr;\n        }\n        TreeNode root;\n        int i, l, r;\n    }\n    public List < List < String >> printTree(TreeNode root) {\n        int height = getHeight(root);\n        System.out.println(height);\n        String[][] res = new String[height][(1 << height) - 1];\n        for (String[] arr: res)\n            Arrays.fill(arr, \"\");\n        List < List < String >> ans = new ArrayList < > ();\n        fill(res, root, 0, 0, res[0].length);\n        for (String[] arr: res)\n            ans.add(Arrays.asList(arr));\n        return ans;\n    }\n    public void fill(String[][] res, TreeNode root, int i, int l, int r) {\n        Queue < Params > queue = new LinkedList();\n        queue.add(new Params(root, 0, 0, res[0].length));\n        while (!queue.isEmpty()) {\n            Params p = queue.remove();\n            res[p.i][(p.l + p.r) / 2] = \"\" + p.root.val;\n            if (p.root.left != null)\n                queue.add(new Params(p.root.left, p.i + 1, p.l, (p.l + p.r) / 2));\n            if (p.root.right != null)\n                queue.add(new Params(p.root.right, p.i + 1, (p.l + p.r + 1) / 2, p.r));\n        }\n    }\n    public int getHeight(TreeNode root) {\n        Queue < TreeNode > queue = new LinkedList();\n        queue.add(root);\n        int height = 0;\n        while (!queue.isEmpty()) {\n            height++;\n            Queue < TreeNode > temp = new LinkedList();\n            while (!queue.isEmpty()) {\n                TreeNode node = queue.remove();\n                if (node.left != null)\n                    temp.add(node.left);\n                if (node.right != null)\n                    temp.add(node.right);\n            }\n            queue = temp;\n        }\n        return height;\n    }\n}\n"]}
{"number": 656, "statement": "Given an array A (index starts at 1) consisting of N integers: A1, A2, ..., ANand an integer B. The integer B denotes that from any place (suppose the index is i) in the array A, you can jump to any one of the place in the array A indexed i+1, i+2, \u2026, i+B if this place can be jumped to. Also, if you step on the index i, you have to pay Aicoins. If Aiis -1, it means you can\u2019t jump to the place indexed i in the array.\nNow, you start from the place indexed 1 in the array A, and your aim is to reach the place indexed N using the minimum coins. You need to return the path of indexes (starting from 1 to N) in the array you should take to get to the place indexed N using minimum coins.\nIf there are multiple paths with the same cost, return the lexicographically smallest such path.\nIf it's not possible to reach the place indexed N then you need to return an empty array.\n", "solutions": ["public class Solution {\n    public List < Integer > cheapestJump(int[] A, int B) {\n        int[] next = new int[A.length];\n        Arrays.fill(next, -1);\n        jump(A, B, 0, next);\n        List < Integer > res = new ArrayList();\n        int i;\n        for (i = 0; i < A.length && next[i] > 0; i = next[i])\n            res.add(i + 1);\n        if (i == A.length - 1 && A[i]>= 0)\n            res.add(A.length);\n        else\n            return new ArrayList < Integer > ();\n        return res;\n    }\n    public long jump(int[] A, int B, int i, int[] next) {\n        if (i == A.length - 1 && A[i] >= 0)\n            return A[i];\n        long min_cost = Integer.MAX_VALUE;\n        for (int j = i + 1; j <= i + B && j < A.length; j++) {\n            if (A[j] >= 0) {\n                long cost = A[i] + jump(A, B, j, next);\n                if (cost < min_cost) {\n                    min_cost = cost;\n                    next[i] = j;\n                }\n            }\n        }\n        return min_cost;\n    }\n}\n", "public class Solution {\n    public List < Integer > cheapestJump(int[] A, int B) {\n        int[] next = new int[A.length];\n        Arrays.fill(next, -1);\n        long[] memo = new long[A.length];\n        jump(A, B, 0, next, memo);\n        List < Integer > res = new ArrayList();\n        int i;\n        for (i = 0; i < A.length && next[i] > 0; i = next[i])\n            res.add(i + 1);\n        if (i == A.length - 1 && A[i] >= 0)\n            res.add(A.length);\n        else\n            return new ArrayList < Integer > ();\n        return res;\n    }\n    public long jump(int[] A, int B, int i, int[] next, long[] memo) {\n        if (memo[i] > 0)\n            return memo[i];\n        if (i == A.length - 1 && A[i] >= 0)\n            return A[i];\n        long min_cost = Integer.MAX_VALUE;\n        for (int j = i + 1; j <= i + B && j < A.length; j++) {\n            if (A[j] >= 0) {\n                long cost = A[i] + jump(A, B, j, next, memo);\n                if (cost < min_cost) {\n                    min_cost = cost;\n                    next[i] = j;\n                }\n            }\n        }\n        memo[i] = min_cost;\n        return min_cost;\n    }\n}\n", "public class Solution {\n    public List < Integer > cheapestJump(int[] A, int B) {\n        int[] next = new int[A.length];\n        long[] dp = new long[A.length];\n        Arrays.fill(next, -1);\n        List < Integer > res = new ArrayList();\n        for (int i = A.length - 2; i >= 0; i--) {\n            long min_cost = Integer.MAX_VALUE;\n            for (int j = i + 1; j <= i + B && j < A.length; j++) {\n                if (A[j] >= 0) {\n                    long cost = A[i] + dp[j];\n                    if (cost < min_cost) {\n                        min_cost = cost;\n                        next[i] = j;\n                    }\n                }\n            }\n            dp[i] = min_cost;\n        }\n        int i;\n        for (i = 0; i < A.length && next[i] > 0; i = next[i])\n            res.add(i + 1);\n        if (i == A.length - 1 && A[i] >= 0)\n            res.add(A.length);\n        else\n            return new ArrayList < Integer > ();\n        return res;\n    }\n}\n"]}
{"number": 657, "statement": "There is a robot starting at position (0, 0), the origin, on a 2D plane. Given a sequence of its moves, judge if this robot ends up at (0, 0) after it completes its moves.\nThe move sequence is represented by a string, and the character moves[i] represents its ith move. Valid moves are R (right), L (left), U (up), and D (down). If the robot returns to the origin after it finishes all of its moves, return true. Otherwise, return false.\nNote: The way that the robot is \"facing\" is irrelevant. \"R\" will always make the robot move to the right once, \"L\" will always make it move left, etc. Also, assume that the magnitude of the robot's movement is the same for each move.\n", "solutions": ["class Solution {\n    public boolean judgeCircle(String moves) {\n        int x = 0, y = 0;\n        for (char move: moves.toCharArray()) {\n            if (move == 'U') y--;\n            else if (move == 'D') y++;\n            else if (move == 'L') x--;\n            else if (move == 'R') x++;\n        }\n        return x == 0 && y == 0;\n    }\n}\n"]}
{"number": 658, "statement": "Given a sorted array arr, two integers k and x, find the k closest elements to x in the array. The result should also be sorted in ascending order. If there is a tie, the smaller elements are always preferred.\n", "solutions": ["public List<Integer> findClosestElements(List<Integer> arr, int k, int x) {\n     Collections.sort(arr, (a,b) -> a == b ? a - b : Math.abs(a-x) - Math.abs(b-x));\n     arr = arr.subList(0, k);\n     Collections.sort(arr);\n     return arr;\n}\n", "public class Solution {\n    public List<Integer> findClosestElements(List<Integer> arr, int k, int x) {\n        int n = arr.size();\n        if (x <= arr.get(0)) {\n            return arr.subList(0, k);\n        } else if (arr.get(n - 1) <= x) {\n            return arr.subList(n - k, n);\n        } else {\n            int index = Collections.binarySearch(arr, x);\n            if (index < 0)\n                index = -index - 1;\n            int low = Math.max(0, index - k - 1), high = Math.min(arr.size() - 1, index + k - 1);\n            while (high - low > k - 1) {\n                if (low < 0 || (x - arr.get(low)) <= (arr.get(high) - x))\n                    high--;\n                else if (high > arr.size() - 1 || (x - arr.get(low)) > (arr.get(high) - x))\n                    low++;\n                else\n                    System.out.println(\"unhandled case: \" + low + \" \" + high);\n            }\n            return arr.subList(low, high + 1);\n        }\n    }\n}\n"]}
{"number": 659, "statement": "Given an array numssorted in ascending order, return true if and only if you can split it into 1 or more subsequences such that each subsequence consists of consecutive integersand has length at least 3.\n", "solutions": ["class Solution {\n    public boolean isPossible(int[] nums) {\n        Integer prev = null;\n        int prevCount = 0;\n        Queue<Integer> starts = new LinkedList();\n        int anchor = 0;\n        for (int i = 0; i < nums.length; ++i) {\n            int t = nums[i];\n            if (i == nums.length - 1 || nums[i+1] != t) {\n                int count = i - anchor + 1;\n                if (prev != null && t - prev != 1) {\n                    while (prevCount-- > 0)\n                        if (prev < starts.poll() + 2) return false;\n                    prev = null;\n                }\n                if (prev == null || t - prev == 1) {\n                    while (prevCount > count) {\n                        prevCount--;\n                        if (t-1 < starts.poll() + 2)\n                            return false;\n                    }\n                    while (prevCount++ < count)\n                        starts.add(t);\n                }\n                prev = t;\n                prevCount = count;\n                anchor = i+1;\n            }\n        }\n        while (prevCount-- > 0)\n            if (nums[nums.length - 1] < starts.poll() + 2)\n                return false;\n        return true;\n    }\n}\n", "class Solution {\n    public boolean isPossible(int[] nums) {\n        Counter count = new Counter();\n        Counter tails = new Counter();\n        for (int x: nums) count.add(x, 1);\n        for (int x: nums) {\n            if (count.get(x) == 0) {\n                continue;\n            } else if (tails.get(x) > 0) {\n                tails.add(x, -1);\n                tails.add(x+1, 1);\n            } else if (count.get(x+1) > 0 && count.get(x+2) > 0) {\n                count.add(x+1, -1);\n                count.add(x+2, -1);\n                tails.add(x+3, 1);\n            } else {\n                return false;\n            }\n            count.add(x, -1);\n        }\n        return true;\n    }\n}\nclass Counter extends HashMap<Integer, Integer> {\n    public int get(int k) {\n        return containsKey(k) ? super.get(k) : 0;\n    }\n    public void add(int k, int v) {\n        put(k, get(k) + v);\n    }\n}\n"]}
{"number": 660, "statement": "Start from integer 1, remove any integer that contains 9 such as 9, 19, 29... \nSo now, you will have a new integer sequence: 1, 2, 3, 4, 5, 6, 7, 8, 10, 11, ...\nGiven a positive integer n, you need to return the n-th integer after removing. Note that 1 will be the first integer.\n", "solutions": ["class Solution {\n    public int newInteger(int n) {\n        return Integer.parseInt(Integer.toString(n, 9));\n    }\n}\n"]}
{"number": 661, "statement": "Given a 2D integer matrix M representing the gray scale of an image, you need to design a smoother to make the gray scale of each cell becomes the average gray scale (rounding down) of all the 8 surrounding cells and itself.  If a cell has less than 8 surrounding cells, then use as many as you can.\n", "solutions": ["class Solution {\n    public int[][] imageSmoother(int[][] M) {\n        int R = M.length, C = M[0].length;\n        int[][] ans = new int[R][C];\n        for (int r = 0; r < R; ++r)\n            for (int c = 0; c < C; ++c) {\n                int count = 0;\n                for (int nr = r-1; nr <= r+1; ++nr)\n                    for (int nc = c-1; nc <= c+1; ++nc) {\n                        if (0 <= nr && nr < R && 0 <= nc && nc < C) {\n                            ans[r][c] += M[nr][nc];\n                            count++;\n                        }\n                    }\n                ans[r][c] /= count;\n            }\n        return ans;\n    }\n}\n"]}
{"number": 662, "statement": "Given a binary tree, write a function to get the maximum width of the given tree. The width of a tree is the maximum width among all levels. The binary tree has the same structure as a full binary tree, but some nodes are null.\nThe width of one level is defined as the length between the end-nodes (the leftmost and right most non-null nodes in the level, where the null nodes between the end-nodes are also counted into the length calculation.\n", "solutions": ["class Solution {\n    public int widthOfBinaryTree(TreeNode root) {\n        Queue<AnnotatedNode> queue = new LinkedList();\n        queue.add(new AnnotatedNode(root, 0, 0));\n        int curDepth = 0, left = 0, ans = 0;\n        while (!queue.isEmpty()) {\n            AnnotatedNode a = queue.poll();\n            if (a.node != null) {\n                queue.add(new AnnotatedNode(a.node.left, a.depth + 1, a.pos * 2));\n                queue.add(new AnnotatedNode(a.node.right, a.depth + 1, a.pos * 2 + 1));\n                if (curDepth != a.depth) {\n                    curDepth = a.depth;\n                    left = a.pos;\n                }\n                ans = Math.max(ans, a.pos - left + 1);\n            }\n        }\n        return ans;\n    }\n}\nclass AnnotatedNode {\n    TreeNode node;\n    int depth, pos;\n    AnnotatedNode(TreeNode n, int d, int p) {\n        node = n;\n        depth = d;\n        pos = p;\n    }\n}\n", "class Solution {\n    int ans;\n    Map<Integer, Integer> left;\n    public int widthOfBinaryTree(TreeNode root) {\n        ans = 0;\n        left = new HashMap();\n        dfs(root, 0, 0);\n        return ans;\n    }\n    public void dfs(TreeNode root, int depth, int pos) {\n        if (root == null) return;\n        left.computeIfAbsent(depth, x-> pos);\n        ans = Math.max(ans, pos - left.get(depth) + 1);\n        dfs(root.left, depth + 1, 2 * pos);\n        dfs(root.right, depth + 1, 2 * pos + 1);\n    }\n}\n"]}
{"number": 663, "statement": "Given a binary tree with n nodes, your task is to check if it's possible to partition the tree to two trees which have the equal sum of values after removing exactly one edge on the original tree.\n", "solutions": ["class Solution {\n    Stack<Integer> seen;\n    public boolean checkEqualTree(TreeNode root) {\n        seen = new Stack();\n        int total = sum(root);\n        seen.pop();\n        if (total % 2 == 0)\n            for (int s: seen)\n                if (s == total / 2)\n                    return true;\n        return false;\n    }\n    public int sum(TreeNode node) {\n        if (node == null) return 0;\n        seen.push(sum(node.left) + sum(node.right) + node.val);\n        return seen.peek();\n    }\n}\n"]}
{"number": 664, "statement": "There is a strange printer with the following two special requirements:\nThe printer can only print a sequence of the same character each time.\nAt each turn, the printer can print new characters starting from and ending at any places, and will cover the original existing characters.\nGiven a string consists of lower English letters only, your job is to count the minimum number of turns the printer needed in order to print it.\n", "solutions": ["class Solution {\n    int[][] memo;\n    public int strangePrinter(String s) {\n        int N = s.length();\n        memo = new int[N][N];\n        return dp(s, 0, N - 1);\n    }\n    public int dp(String s, int i, int j) {\n        if (i > j) return 0;\n        if (memo[i][j] == 0) {\n            int ans = dp(s, i+1, j) + 1;\n            for (int k = i+1; k <= j; ++k)\n                if (s.charAt(k) == s.charAt(i))\n                    ans = Math.min(ans, dp(s, i, k-1) + dp(s, k+1, j));\n            memo[i][j] = ans;\n        }\n        return memo[i][j];\n    }\n}\n"]}
{"number": 665, "statement": "Given an array nums with n integers, your task is to check if it could become non-decreasing by modifying at most 1 element.\nWe define an array is non-decreasing if nums[i] = nums[i + 1] holds for every i(0-based) such that (0= i = n - 2).\n", "solutions": ["class Solution(object):\n    def checkPossibility(self, A):\n        def monotone_increasing(arr):\n            for i in range(len(arr) - 1):\n                if arr[i] > arr[i+1]:\n                    return False\n            return True\n        new = A[:]\n        for i in xrange(len(A)):\n            old_ai = A[i]\n            new[i] = new[i-1] if i > 0 else float('-inf')\n            if monotone_increasing(new):\n                return True\n            new[i] = old_ai\n        return False\n", "class Solution(object):\n    def checkPossibility(self, A):\n        def brute_force(A):\n            #Same as in approach 1\n        i, j = 0, len(A) - 1\n        while i+2 < len(A) and A[i] <= A[i+1] <= A[i+2]:\n            i += 1\n        while j-2 >= 0 and A[j-2] <= A[j-1] <= A[j]:\n            j -= 1\n        if j - i + 1 <= 2:\n            return True\n        if j - i + 1 >= 5:\n            return False\n        return brute_force(A[i: j+1])\n", "class Solution(object):\n    def checkPossibility(self, A):\n        p = None\n        for i in xrange(len(A) - 1):\n            if A[i] > A[i+1]:\n                if p is not None:\n                    return False\n                p = i\n        return (p is None or p == 0 or p == len(A)-2 or\n                A[p-1] <= A[p+1] or A[p] <= A[p+2])\n"]}
{"number": 666, "statement": "If the depth of a tree is smaller than 5, then this tree can be represented by a list of three-digits integers.\nFor each integer in this list:\nThe hundreds digit represents the depth D of this node, 1 = D = 4.\nThe tens digit represents the position P of this node in the level it belongs to, 1 = P = 8. The position is the same as that in a full binary tree.\nThe units digit represents the value V of this node, 0 = V = 9.\nGiven a list of ascending three-digits integers representing a binary tree with the depth smaller than 5, you need to return the sum of all paths from the root towards the leaves.\nIt's guaranteed that the given list represents a valid connected binary tree.\n", "solutions": ["class Solution {\n    int ans = 0;\n    public int pathSum(int[] nums) {\n        Node root = new Node(nums[0] % 10);\n        for (int num: nums) {\n            if (num == nums[0]) continue;\n            int depth = num / 100, pos = num / 10 % 10, val = num % 10;\n            pos--;\n            Node cur = root;\n            for (int d = depth - 2; d >= 0; --d) {\n                if (pos < 1<<d) {\n                    if (cur.left == null) cur.left = new Node(val);\n                    cur = cur.left;\n                } else {\n                    if (cur.right == null) cur.right = new Node(val);\n                    cur = cur.right;\n                }\n                pos %= 1<<d;\n            }\n        }\n        dfs(root, 0);\n        return ans;\n    }\n    public void dfs(Node node, int sum) {\n        if (node == null) return;\n        sum += node.val;\n        if (node.left == null && node.right == null) {\n            ans += sum;\n        } else {\n            dfs(node.left, sum);\n            dfs(node.right, sum);\n        }\n    }\n}\nclass Node {\n    Node left, right;\n    int val;\n    Node(int v) {val = v;}\n}\n", "class Solution {\n    int ans = 0;\n    Map<Integer, Integer> values;\n    public int pathSum(int[] nums) {\n        values = new HashMap();\n        for (int num: nums)\n            values.put(num / 10, num % 10);\n        dfs(nums[0] / 10, 0);\n        return ans;\n    }\n    public void dfs(int node, int sum) {\n        if (!values.containsKey(node)) return;\n        sum += values.get(node);\n        int depth = node / 10, pos = node % 10;\n        int left = (depth + 1) * 10 + 2 * pos - 1;\n        int right = left + 1;\n        if (!values.containsKey(left) && !values.containsKey(right)) {\n            ans += sum;\n        } else {\n            dfs(left, sum);\n            dfs(right, sum);\n        }\n    }\n}\n"]}
{"number": 667, "statement": "Given two integers n and k, you need to construct a list which contains n different positive integers ranging from 1 to n and obeys the following requirement: \nSuppose this list is [a1, a2, a3, ... , an], then the list [|a1 - a2|, |a2 - a3|, |a3 - a4|, ... , |an-1 - an|] has exactly k distinct integers.\nIf there are multiple answers, print any of them.\n", "solutions": ["class Solution {\n    private ArrayList<ArrayList<Integer>> permutations(int[] nums) {\n        ArrayList<ArrayList<Integer>> ans = new ArrayList<ArrayList<Integer>>();\n        permute(ans, nums, 0);\n        return ans;\n    }\n    private void permute(ArrayList<ArrayList<Integer>> ans, int[] nums, int start) {\n        if (start >= nums.length) {\n            ArrayList<Integer> cur = new ArrayList<Integer>();\n            for (int x : nums) cur.add(x);\n            ans.add(cur);\n        } else {\n            for (int i = start; i < nums.length; i++) {\n                swap(nums, start, i);\n                permute(ans, nums, start+1);\n                swap(nums, start, i);\n            }\n        }\n    }\n    private void swap(int[] nums, int i, int j) {\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }\n    private int numUniqueDiffs(ArrayList<Integer> arr) {\n        boolean[] seen = new boolean[arr.size()];\n        int ans = 0;\n        for (int i = 0; i < arr.size() - 1; i++) {\n            int delta = Math.abs(arr.get(i) - arr.get(i+1));\n            if (!seen[delta]) {\n                ans++;\n                seen[delta] = true;\n            }\n        }\n        return ans;\n    }\n    public int[] constructArray(int n, int k) {\n        int[] nums = new int[n];\n        for (int i = 0; i < n; i++) {\n            nums[i] = i+1;\n        }\n        for (ArrayList<Integer> cand : permutations(nums)) {\n            if (numUniqueDiffs(cand) == k) {\n                int[] ans = new int[n];\n                int i = 0;\n                for (int x : cand) ans[i++] = x;\n                return ans;\n            }\n        }\n        return null;\n    }\n}\n", "class Solution {\n    public int[] constructArray(int n, int k) {\n        int[] ans = new int[n];\n        int c = 0;\n        for (int v = 1; v < n-k; v++) {\n            ans[c++] = v;\n        }\n        for (int i = 0; i <= k; i++) {\n            ans[c++] = (i%2 == 0) ? (n-k + i/2) : (n - i/2);\n        }\n        return ans;\n    }\n}\n"]}
{"number": 668, "statement": "Nearly every one have used the Multiplication Table. But could you find out the k-th smallest number quickly from the multiplication table?\nGiven the height m and the length n of a m * n Multiplication Table, and a positive integer k, you need to return the k-th smallest number in this table.\n", "solutions": ["class Solution {\n    public int findKthNumber(int m, int n, int k) {\n        int[] table = new int[m*n];\n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                table[(i - 1) * n + j - 1] = i * j;\n            }\n        }\n        Arrays.sort(table);\n        return table[k-1];\n    }\n}\n", "class Solution {\n    public int findKthNumber(int m, int n, int k) {\n        PriorityQueue<Node> heap = new PriorityQueue<Node>(m,\n            Comparator.<Node> comparingInt(node -> node.val));\n        for (int i = 1; i <= m; i++) {\n            heap.offer(new Node(i, i));\n        }\n        Node node = null;\n        for (int i = 0; i < k; i++) {\n            node = heap.poll();\n            int nxt = node.val + node.root;\n            if (nxt <= node.root * n) {\n                heap.offer(new Node(nxt, node.root));\n            }\n        }\n        return node.val;\n    }\n}\nclass Node {\n    int val;\n    int root;\n    public Node(int v, int r) {\n        val = v;\n        root = r;\n    }\n}\n", "class Solution {\n    public boolean enough(int x, int m, int n, int k) {\n        int count = 0;\n        for (int i = 1; i <= m; i++) {\n            count += Math.min(x / i, n);\n        }\n        return count >= k;\n    }\n    public int findKthNumber(int m, int n, int k) {\n        int lo = 1, hi = m * n;\n        while (lo < hi) {\n            int mi = lo + (hi - lo) / 2;\n            if (!enough(mi, m, n, k)) lo = mi + 1;\n            else hi = mi;\n        }\n        return lo;\n    }\n}\n"]}
{"number": 669, "statement": "Given a binary search tree and the lowest and highest boundaries as L and R, trim the tree so that all its elements lies in [L, R] (R = L). You might need to change the root of the tree, so the result should return the new root of the trimmed binary search tree.\n", "solutions": ["class Solution {\n    public TreeNode trimBST(TreeNode root, int L, int R) {\n        if (root == null) return root;\n        if (root.val > R) return trimBST(root.left, L, R);\n        if (root.val < L) return trimBST(root.right, L, R);\n        root.left = trimBST(root.left, L, R);\n        root.right = trimBST(root.right, L, R);\n        return root;\n    }\n}\n"]}
{"number": 670, "statement": "Given a non-negative integer, you could swap two digits at most once to get the maximum valued number. Return the maximum valued number you could get.\n", "solutions": ["class Solution {\n    public int maximumSwap(int num) {\n        char[] A = Integer.toString(num).toCharArray();\n        char[] ans = Arrays.copyOf(A, A.length);\n        for (int i = 0; i < A.length; i++) {\n            for (int j = i+1; j < A.length; j++) {\n                char tmp = A[i];\n                A[i] = A[j];\n                A[j] = tmp;\n                for (int k = 0; k < A.length; k++){\n                    if (A[k] != ans[k]){\n                        if (A[k] > ans[k]) {\n                            ans = Arrays.copyOf(A, A.length);\n                        }\n                        break;\n                    }\n                }\n                A[j] = A[i];\n                A[i] = tmp;\n            }\n        }\n        return Integer.valueOf(new String(ans));\n    }\n}\n", "class Solution {\n    public int maximumSwap(int num) {\n        char[] A = Integer.toString(num).toCharArray();\n        int[] last = new int[10];\n        for (int i = 0; i < A.length; i++) {\n            last[A[i] - '0'] = i;\n        }\n        for (int i = 0; i < A.length; i++) {\n            for (int d = 9; d > A[i] - '0'; d--) {\n                if (last[d] > i) {\n                    char tmp = A[i];\n                    A[i] = A[last[d]];\n                    A[last[d]] = tmp;\n                    return Integer.valueOf(new String(A));\n                }\n            }\n        }\n        return num;\n    }\n}\n"]}
{"number": 671, "statement": "Given a non-empty special binary tree consisting of nodes with the non-negative value, where each node in this tree has exactly two or zero sub-node. If the node has two sub-nodes, then this node's value is the smaller value among its two sub-nodes. More formally, the propertyroot.val = min(root.left.val, root.right.val)always holds.\nGiven such a binary tree, you need to output the second minimum value in the set made of all the nodes' value in the whole tree.\nIf no such second minimum value exists, output -1 instead.\n", "solutions": ["class Solution {\n    public void dfs(TreeNode root, Set<Integer> uniques) {\n        if (root != null) {\n            uniques.add(root.val);\n            dfs(root.left, uniques);\n            dfs(root.right, uniques);\n        }\n    }\n    public int findSecondMinimumValue(TreeNode root) {\n        Set<Integer> uniques = new HashSet<Integer>();\n        dfs(root, uniques);\n        int min1 = root.val;\n        long ans = Long.MAX_VALUE;\n        for (int v : uniques) {\n            if (min1 < v && v < ans) ans = v;\n        }\n        return ans < Long.MAX_VALUE ? (int) ans : -1;\n    }\n}\n", "class Solution {\n    int min1;\n    long ans = Long.MAX_VALUE;\n    public void dfs(TreeNode root) {\n        if (root != null) {\n            if (min1 < root.val && root.val < ans) {\n                ans = root.val;\n            } else if (min1 == root.val) {\n                dfs(root.left);\n                dfs(root.right);\n            }\n        }\n    }\n    public int findSecondMinimumValue(TreeNode root) {\n        min1 = root.val;\n        dfs(root);\n        return ans < Long.MAX_VALUE ? (int) ans : -1;\n    }\n}\n"]}
{"number": 672, "statement": "There is a room with n lights which are turned on initially and 4 buttons on the wall. After performing exactly m unknown operations towards buttons, you need to return how many different kinds of status of the n lights could be.\nSuppose n lights are labeled as number [1, 2, 3 ..., n], function of these 4 buttons are given below:\nFlip all the lights.\nFlip lights with even numbers.\nFlip lights with odd numbers.\nFlip lights with (3k + 1) numbers, k = 0, 1, 2, ...\n", "solutions": ["class Solution {\n    public int flipLights(int n, int m) {\n        Set<Integer> seen = new HashSet();\n        n = Math.min(n, 6);\n        int shift = Math.max(0, 6-n);\n        for (int cand = 0; cand < 16; ++cand) {\n            int bcount = Integer.bitCount(cand);\n            if (bcount % 2 == m % 2 && bcount <= m) {\n                int lights = 0;\n                if (((cand >> 0) & 1) > 0) lights ^= 0b111111 >> shift;\n                if (((cand >> 1) & 1) > 0) lights ^= 0b010101 >> shift;\n                if (((cand >> 2) & 1) > 0) lights ^= 0b101010 >> shift;\n                if (((cand >> 3) & 1) > 0) lights ^= 0b100100 >> shift;\n                seen.add(lights);\n            }\n        }\n        return seen.size();\n    }\n}\n", "class Solution {\n    public int flipLights(int n, int m) {\n        n = Math.min(n, 3);\n        if (m == 0) return 1;\n        if (m == 1) return n == 1 ? 2 : n == 2 ? 3 : 4;\n        if (m == 2) return n == 1 ? 2 : n == 2 ? 4 : 7;\n        return n == 1 ? 2 : n == 2 ? 4 : 8;\n    }\n}\n"]}
{"number": 673, "statement": "Given an unsorted array of integers, find the number of longest increasing subsequence.\n", "solutions": ["class Solution {\n    public int findNumberOfLIS(int[] nums) {\n        int N = nums.length;\n        if (N <= 1) return N;\n        int[] lengths = new int[N]; //lengths[i] = length of longest ending in nums[i]\n        int[] counts = new int[N]; //count[i] = number of longest ending in nums[i]\n        Arrays.fill(counts, 1);\n        for (int j = 0; j < N; ++j) {\n            for (int i = 0; i < j; ++i) if (nums[i] < nums[j]) {\n                if (lengths[i] >= lengths[j]) {\n                    lengths[j] = lengths[i] + 1;\n                    counts[j] = counts[i];\n                } else if (lengths[i] + 1 == lengths[j]) {\n                    counts[j] += counts[i];\n                }\n            }\n        }\n        int longest = 0, ans = 0;\n        for (int length: lengths) {\n            longest = Math.max(longest, length);\n        }\n        for (int i = 0; i < N; ++i) {\n            if (lengths[i] == longest) {\n                ans += counts[i];\n            }\n        }\n        return ans;\n    }\n}\n", "class Solution {\n    public Value merge(Value v1, Value v2) {\n        if (v1.length == v2.length) {\n            if (v1.length == 0) return new Value(0, 1);\n            return new Value(v1.length, v1.count + v2.count);\n        }\n        return v1.length > v2.length ? v1 : v2;\n    }\n    public void insert(Node node, int key, Value val) {\n        if (node.range_left == node.range_right) {\n            node.val = merge(val, node.val);\n            return;\n        } else if (key <= node.getRangeMid()) {\n            insert(node.getLeft(), key, val);\n        } else {\n            insert(node.getRight(), key, val);\n        }\n        node.val = merge(node.getLeft().val, node.getRight().val);\n    }\n    public Value query(Node node, int key) {\n        if (node.range_right <= key) return node.val;\n        else if (node.range_left > key) return new Value(0, 1);\n        else return merge(query(node.getLeft(), key), query(node.getRight(), key));\n    }\n    public int findNumberOfLIS(int[] nums) {\n        if (nums.length == 0) return 0;\n        int min = nums[0], max = nums[0];\n        for (int num: nums) {\n            min = Math.min(min, num);\n            max = Math.max(max, num);\n        }\n        Node root = new Node(min, max);\n        for (int num: nums) {\n            Value v = query(root, num-1);\n            insert(root, num, new Value(v.length + 1, v.count));\n        }\n        return root.val.count;\n    }\n}\nclass Node {\n    int range_left, range_right;\n    Node left, right;\n    Value val;\n    public Node(int start, int end) {\n        range_left = start;\n        range_right = end;\n        left = null;\n        right = null;\n        val = new Value(0, 1);\n    }\n    public int getRangeMid() {\n        return range_left + (range_right - range_left) / 2;\n    }\n    public Node getLeft() {\n        if (left == null) left = new Node(range_left, getRangeMid());\n        return left;\n    }\n    public Node getRight() {\n        if (right == null) right = new Node(getRangeMid() + 1, range_right);\n        return right;\n    }\n}\nclass Value {\n    int length;\n    int count;\n    public Value(int len, int ct) {\n        length = len;\n        count = ct;\n    }\n}\n"]}
{"number": 674, "statement": "Given an unsorted array of integers, find the length of longest continuous increasing subsequence (subarray).\n", "solutions": ["class Solution {\n    public int findLengthOfLCIS(int[] nums) {\n        int ans = 0, anchor = 0;\n        for (int i = 0; i < nums.length; ++i) {\n            if (i > 0 && nums[i-1] >= nums[i]) anchor = i;\n            ans = Math.max(ans, i - anchor + 1);\n        }\n        return ans;\n    }\n}\n"]}
{"number": 677, "statement": "Implement a MapSum class with insert, and sum methods.\nFor the method insert, you'll be given a pair of (string, integer). The string represents the key and the integer represents the value. If the key already existed, then the original key-value pair will be overridden to the new one.\nFor the method sum, you'll be given a string representing the prefix, and you need to return the sum of all the pairs' value whose key starts with the prefix.\n", "solutions": ["class MapSum {\n    HashMap<String, Integer> map;\n    public MapSum() {\n        map = new HashMap<>();\n    }\n    public void insert(String key, int val) {\n        map.put(key, val);\n    }\n    public int sum(String prefix) {\n        int ans = 0;\n        for (String key: map.keySet()) {\n            if (key.startsWith(prefix)) {\n                ans += map.get(key);\n            }\n        }\n        return ans;\n    }\n}\n", "class MapSum {\n    Map<String, Integer> map;\n    Map<String, Integer> score;\n    public MapSum() {\n        map = new HashMap();\n        score = new HashMap();\n    }\n    public void insert(String key, int val) {\n        int delta = val - map.getOrDefault(key, 0);\n        map.put(key, val);\n        String prefix = \"\";\n        for (char c: key.toCharArray()) {\n            prefix += c;\n            score.put(prefix, score.getOrDefault(prefix, 0) + delta);\n        }\n    }\n    public int sum(String prefix) {\n        return score.getOrDefault(prefix, 0);\n    }\n}\n", "class MapSum {\n    HashMap<String, Integer> map;\n    TrieNode root;\n    public MapSum() {\n        map = new HashMap();\n        root = new TrieNode();\n    }\n    public void insert(String key, int val) {\n        int delta = val - map.getOrDefault(key, 0);\n        map.put(key, val);\n        TrieNode cur = root;\n        cur.score += delta;\n        for (char c: key.toCharArray()) {\n            cur.children.putIfAbsent(c, new TrieNode());\n            cur = cur.children.get(c);\n            cur.score += delta;\n        }\n    }\n    public int sum(String prefix) {\n        TrieNode cur = root;\n        for (char c: prefix.toCharArray()) {\n            cur = cur.children.get(c);\n            if (cur == null) return 0;\n        }\n        return cur.score;\n    }\n}\nclass TrieNode {\n    Map<Character, TrieNode> children = new HashMap();\n    int score;\n}\n"]}
{"number": 678, "statement": "Given a string containing only three types of characters: '(', ')' and '*', write a function to check whether this string is valid. We define the validity of a string by these rules:\nAny left parenthesis '(' must have a corresponding right parenthesis ')'.\nAny right parenthesis ')' must have a corresponding left parenthesis '('.\nLeft parenthesis '(' must go before the corresponding right parenthesis ')'.\n'*' could be treated as a single right parenthesis ')' or a single left parenthesis '(' or an empty string.\nAn empty string is also valid.\n", "solutions": ["class Solution {\n    boolean ans = false;\n    public boolean checkValidString(String s) {\n        solve(new StringBuilder(s), 0);\n        return ans;\n    }\n    public void solve(StringBuilder sb, int i) {\n        if (i == sb.length()) {\n            ans |= valid(sb);\n        } else if (sb.charAt(i) == '*') {\n            for (char c: \"() \".toCharArray()) {\n                sb.setCharAt(i, c);\n                solve(sb, i+1);\n                if (ans) return;\n            }\n            sb.setCharAt(i, '*');\n        } else\n            solve(sb, i + 1);\n    }\n    public boolean valid(StringBuilder sb) {\n        int bal = 0;\n        for (int i = 0; i < sb.length(); i++) {\n            char c = sb.charAt(i);\n            if (c == '(') bal++;\n            if (c == ')') bal--;\n            if (bal < 0) break;\n        }\n        return bal == 0;\n    }\n}\n", "class Solution {\n    public boolean checkValidString(String s) {\n        int n = s.length();\n        if (n == 0) return true;\n        boolean[][] dp = new boolean[n][n];\n        for (int i = 0; i < n; i++) {\n            if (s.charAt(i) == '*') dp[i][i] = true;\n            if (i < n-1 &&\n                    (s.charAt(i) == '(' || s.charAt(i) == '*') &&\n                    (s.charAt(i+1) == ')' || s.charAt(i+1) == '*')) {\n                dp[i][i+1] = true;\n            }\n        }\n        for (int size = 2; size < n; size++) {\n            for (int i = 0; i + size < n; i++) {\n                if (s.charAt(i) == '*' && dp[i+1][i+size] == true) {\n                    dp[i][i+size] = true;\n                } else if (s.charAt(i) == '(' || s.charAt(i) == '*') {\n                    for (int k = i+1; k <= i+size; k++) {\n                        if ((s.charAt(k) == ')' || s.charAt(k) == '*') &&\n                                (k == i+1 || dp[i+1][k-1]) &&\n                                (k == i+size || dp[k+1][i+size])) {\n                            dp[i][i+size] = true;\n                        }\n                    }\n                }\n            }\n        }\n        return dp[0][n-1];\n    }\n}\n", "class Solution {\n    public boolean checkValidString(String s) {\n       int lo = 0, hi = 0;\n       for (char c: s.toCharArray()) {\n           lo += c == '(' ? 1 : -1;\n           hi += c != ')' ? 1 : -1;\n           if (hi < 0) break;\n           lo = Math.max(lo, 0);\n       }\n       return lo == 0;\n    }\n}\n"]}
{"number": 679, "statement": "You have 4 cards each containing a number from 1 to 9.  You need to judge whether they could operated through *, /, +, -, (, ) to get the value of 24.\n", "solutions": ["class Solution {\n    public boolean judgePoint24(int[] nums) {\n        ArrayList A = new ArrayList<Double>();\n        for (int v: nums) A.add((double) v);\n        return solve(A);\n    }\n    private boolean solve(ArrayList<Double> nums) {\n        if (nums.size() == 0) return false;\n        if (nums.size() == 1) return Math.abs(nums.get(0) - 24) < 1e-6;\n        for (int i = 0; i < nums.size(); i++) {\n            for (int j = 0; j < nums.size(); j++) {\n                if (i != j) {\n                    ArrayList<Double> nums2 = new ArrayList<Double>();\n                    for (int k = 0; k < nums.size(); k++) if (k != i && k != j) {\n                        nums2.add(nums.get(k));\n                    }\n                    for (int k = 0; k < 4; k++) {\n                        if (k < 2 && j > i) continue;\n                        if (k == 0) nums2.add(nums.get(i) + nums.get(j));\n                        if (k == 1) nums2.add(nums.get(i) * nums.get(j));\n                        if (k == 2) nums2.add(nums.get(i) - nums.get(j));\n                        if (k == 3) {\n                            if (nums.get(j) != 0) {\n                                nums2.add(nums.get(i) / nums.get(j));\n                            } else {\n                                continue;\n                            }\n                        }\n                        if (solve(nums2)) return true;\n                        nums2.remove(nums2.size() - 1);\n                    }\n                }\n            }\n        }\n        return false;\n    }\n}\n"]}
{"number": 680, "statement": "Given a non-empty string s, you may delete at most one character.  Judge whether you can make it a palindrome.\n", "solutions": ["class Solution {\n    public boolean isPalindrome(CharSequence s) {\n        for (int i = 0; i < s.length() / 2; i++) {\n            if (s.charAt(i) != s.charAt(s.length() - 1 - i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    public boolean validPalindrome(String s) {\n        StringBuilder sb = new StringBuilder(s);\n        for (int i = 0; i < s.length(); i++) {\n            char c = sb.charAt(i);\n            sb.deleteCharAt(i);\n            if (isPalindrome(sb)) return true;\n            sb.insert(i, c);\n        }\n        return isPalindrome(s);\n    }\n}\n", "class Solution {\n    public boolean isPalindromeRange(String s, int i, int j) {\n        for (int k = i; k <= i + (j - i) / 2; k++) {\n            if (s.charAt(k) != s.charAt(j - k + i)) return false;\n        }\n        return true;\n    }\n    public boolean validPalindrome(String s) {\n        for (int i = 0; i < s.length() / 2; i++) {\n            if (s.charAt(i) != s.charAt(s.length() - 1 - i)) {\n                int j = s.length() - 1 - i;\n                return (isPalindromeRange(s, i+1, j) ||\n                        isPalindromeRange(s, i, j-1));\n            }\n        }\n        return true;\n    }\n}\n"]}
{"number": 681, "statement": "Given a time represented in the format \"HH:MM\", form the next closest time by reusing the current digits. There is no limit on how many times a digit can be reused.\nYou may assume the given input string is always valid. For example, \"01:34\", \"12:09\" are all valid. \"1:34\", \"12:9\" are all invalid.\n", "solutions": ["class Solution {\n    public String nextClosestTime(String time) {\n        int cur = 60 * Integer.parseInt(time.substring(0, 2));\n        cur += Integer.parseInt(time.substring(3));\n        Set<Integer> allowed = new HashSet();\n        for (char c: time.toCharArray()) if (c != ':') {\n            allowed.add(c - '0');\n        }\n        while (true) {\n            cur = (cur + 1) % (24 * 60);\n            int[] digits = new int[]{cur / 60 / 10, cur / 60 % 10, cur % 60 / 10, cur % 60 % 10};\n            search : {\n                for (int d: digits) if (!allowed.contains(d)) break search;\n                return String.format(\"%02d:%02d\", cur / 60, cur % 60);\n            }\n        }\n    }\n}\n", "class Solution {\n    public String nextClosestTime(String time) {\n        int start = 60 * Integer.parseInt(time.substring(0, 2));\n        start += Integer.parseInt(time.substring(3));\n        int ans = start;\n        int elapsed = 24 * 60;\n        Set<Integer> allowed = new HashSet();\n        for (char c: time.toCharArray()) if (c != ':') {\n            allowed.add(c - '0');\n        }\n        for (int h1: allowed) for (int h2: allowed) if (h1 * 10 + h2 < 24) {\n            for (int m1: allowed) for (int m2: allowed) if (m1 * 10 + m2 < 60) {\n                int cur = 60 * (h1 * 10 + h2) + (m1 * 10 + m2);\n                int candElapsed = Math.floorMod(cur - start, 24 * 60);\n                if (0 < candElapsed && candElapsed < elapsed) {\n                    ans = cur;\n                    elapsed = candElapsed;\n                }\n            }\n        }\n        return String.format(\"%02d:%02d\", ans / 60, ans % 60);\n    }\n}\n"]}
{"number": 682, "statement": "You're now a baseball game point recorder.\nGiven a list of strings, each string can be one of the 4 following types:\nInteger (one round's score): Directly represents the number of points you get in this round.\n\"+\" (one round's score): Represents that the points you get in this round are the sum of the last two valid round's points.\n\"D\" (one round's score): Represents that the points you get in this round are the doubled data of the last valid round's points.\n\"C\" (an operation, which isn't a round's score): Represents the last valid round's points you get were invalid and should be removed.\nEach round's operation is permanent and could have an impact on the round before and the round after.\nYou need to return the sum of the points you could get in all the rounds.\n", "solutions": ["class Solution {\n    public int calPoints(String[] ops) {\n        Stack<Integer> stack = new Stack();\n        for(String op : ops) {\n            if (op.equals(\"+\")) {\n                int top = stack.pop();\n                int newtop = top + stack.peek();\n                stack.push(top);\n                stack.push(newtop);\n            } else if (op.equals(\"C\")) {\n                stack.pop();\n            } else if (op.equals(\"D\")) {\n                stack.push(2 * stack.peek());\n            } else {\n                stack.push(Integer.valueOf(op));\n            }\n        }\n        int ans = 0;\n        for(int score : stack) ans += score;\n        return ans;\n    }\n}\n"]}
{"number": 683, "statement": "You have N bulbs in a row numbered from 1 to N. Initially, all the bulbs are turned off. We turn on exactly one bulb everyday until all bulbs are on after N days.\nYou are given an array bulbsof length Nwhere bulbs[i] = x means that on the (i+1)th day, we will turn on the bulb at position xwhereiis0-indexedandxis1-indexed.\nGiven an integer K, find out the minimum day number such that there exists two turned on bulbs that have exactlyK bulbs between them that are all turned off.\nIf there isn't such day, return -1.\n", "solutions": ["class Solution {\n    public int kEmptySlots(int[] flowers, int k) {\n        TreeSet<Integer> active = new TreeSet();\n        int day = 0;\n        for (int flower: flowers) {\n            day++;\n            active.add(flower);\n            Integer lower = active.lower(flower)\n            Integer higher = active.higher(flower);\n            if (lower != null && flower - lower - 1 == k ||\n                    higher != null && higher - flower - 1 == k)\n                return day;\n        }\n        return -1;\n    }\n}\n", "class Solution {\n    public int kEmptySlots(int[] flowers, int k) {\n        int[] days = new int[flowers.length];\n        for (int i = 0; i < flowers.length; i++) {\n            days[flowers[i] - 1] = i + 1;\n        }\n        MinQueue<Integer> window = new MinQueue();\n        int ans = days.length;\n        for (int i = 0; i < days.length; i++) {\n            int day = days[i];\n            window.addLast(day);\n            if (k <= i && i < days.length - 1) {\n                window.pollFirst();\n                if (k == 0 || days[i-k] < window.min() && days[i+1] < window.min()) {\n                    ans = Math.min(ans, Math.max(days[i-k], days[i+1]));\n                }\n            }\n        }\n        return ans < days.length ? ans : -1;\n    }\n}\nclass MinQueue<E extends Comparable<E>> extends ArrayDeque<E> {\n    Deque<E> mins;\n    public MinQueue() {\n        mins = new ArrayDeque<E>();\n    }\n    @Override\n    public void addLast(E x) {\n        super.addLast(x);\n        while (mins.peekLast() != null &&\n                x.compareTo(mins.peekLast()) < 0) {\n            mins.pollLast();\n        }\n        mins.addLast(x);\n    }\n    @Override\n    public E pollFirst() {\n        E x = super.pollFirst();\n        if (x == mins.peekFirst()) mins.pollFirst();\n        return x;\n    }\n    public E min() {\n        return mins.peekFirst();\n    }\n}\n", "class Solution {\n    public int kEmptySlots(int[] flowers, int k) {\n        int[] days = new int[flowers.length];\n        for (int i = 0; i < flowers.length; i++) {\n            days[flowers[i] - 1] = i + 1;\n        }\n        int ans = Integer.MAX_VALUE;\n        int left = 0, right = k+1;\n        search: while (right < days.length) {\n            for (int i = left+1; i < right; ++i) {\n                if (days[i] < days[left] || days[i] < days[right]) {\n                    left = i;\n                    right = i + k + 1;\n                    continue search;\n                }\n            }\n            ans = Math.min(ans, Math.max(days[left], days[right]));\n            left = right;\n            right = left + k + 1;\n        }\n        return ans < Integer.MAX_VALUE ? ans : -1;\n    }\n}\n"]}
{"number": 684, "statement": "In this problem, a tree is an undirected graph that is connected and has no cycles.\nThe given input is a graph that started as a tree with N nodes (with distinct values 1, 2, ..., N), with one additional edge added.  The added edge has two different vertices chosen from 1 to N, and was not an edge that already existed.\nThe resulting graph is given as a 2D-array of edges.  Each element of edges is a pair [u, v] with u  v, that represents an undirected edge connecting nodes u and v.\nReturn an edge that can be removed so that the resulting graph is a tree of N nodes.  If there are multiple answers, return the answer that occurs last in the given 2D-array.  The answer edge [u, v] should be in the same format, with u  v.\n", "solutions": ["class Solution {\n    Set<Integer> seen = new HashSet();\n    int MAX_EDGE_VAL = 1000;\n    public int[] findRedundantConnection(int[][] edges) {\n        ArrayList<Integer>[] graph = new ArrayList[MAX_EDGE_VAL + 1];\n        for (int i = 0; i <= MAX_EDGE_VAL; i++) {\n            graph[i] = new ArrayList();\n        }\n        for (int[] edge: edges) {\n            seen.clear();\n            if (!graph[edge[0]].isEmpty() && !graph[edge[1]].isEmpty() &&\n                    dfs(graph, edge[0], edge[1])) {\n                return edge;\n            }\n            graph[edge[0]].add(edge[1]);\n            graph[edge[1]].add(edge[0]);\n        }\n        throw new AssertionError();\n    }\n    public boolean dfs(ArrayList<Integer>[] graph, int source, int target) {\n        if (!seen.contains(source)) {\n            seen.add(source);\n            if (source == target) return true;\n            for (int nei: graph[source]) {\n                if (dfs(graph, nei, target)) return true;\n            }\n        }\n        return false;\n    }\n}\n", "# parent initialized as (x -> x)\nfunction find(x):\n    while parent[x] != x: #While x isn't the leader\n        x = parent[x]\n    return x\nfunction union(x, y):\n    parent[find(x)] = find(y)\n", "class DSU(object):\n    def __init__(self):\n        self.par = range(1001)\n        self.rnk = [0] * 1001\n    def find(self, x):\n        if self.par[x] != x:\n            self.par[x] = self.find(self.par[x])\n        return self.par[x]\n    def union(self, x, y):\n        xr, yr = self.find(x), self.find(y)\n        if xr == yr:\n            return False\n        elif self.rnk[xr] < self.rnk[yr]:\n            self.par[xr] = yr\n        elif self.rnk[xr] > self.rnk[yr]:\n            self.par[yr] = xr\n        else:\n            self.par[yr] = xr\n            self.rnk[xr] += 1\n        return True\nclass Solution(object):\n    def findRedundantConnection(self, edges):\n        dsu = DSU()\n        for edge in edges:\n            if not dsu.union(*edge):\n                return edge\n", "class DSU:\n    def __init__(self):\n        self.par = range(1001)\n    def find(self, x):\n        if self.par[x] != x:\n            self.par[x] = self.find(self.par[x])\n        return self.par[x]\n    def union(self, x, y):\n        self.par[self.find(x)] = self.find(y)\n", "class Solution {\n    int MAX_EDGE_VAL = 1000;\n    public int[] findRedundantConnection(int[][] edges) {\n        DSU dsu = new DSU(MAX_EDGE_VAL + 1);\n        for (int[] edge: edges) {\n            if (!dsu.union(edge[0], edge[1])) return edge;\n        }\n        throw new AssertionError();\n    }\n}\nclass DSU {\n    int[] parent;\n    int[] rank;\n    public DSU(int size) {\n        parent = new int[size];\n        for (int i = 0; i < size; i++) parent[i] = i;\n        rank = new int[size];\n    }\n    public int find(int x) {\n        if (parent[x] != x) parent[x] = find(parent[x]);\n        return parent[x];\n    }\n    public boolean union(int x, int y) {\n        int xr = find(x), yr = find(y);\n        if (xr == yr) {\n            return false;\n        } else if (rank[xr] < rank[yr]) {\n            parent[xr] = yr;\n        } else if (rank[xr] > rank[yr]) {\n            parent[yr] = xr;\n        } else {\n            parent[yr] = xr;\n            rank[xr]++;\n        }\n        return true;\n    }\n}\n"]}
{"number": 685, "statement": "In this problem, a rooted tree is a directed graph such that, there is exactly one node (the root) for which all other nodes are descendants of this node, plus every node has exactly one parent, except for the root node which has no parents.\nThe given input is a directed graph that started as a rooted tree with N nodes (with distinct values 1, 2, ..., N), with one additional directed edge added.  The added edge has two different vertices chosen from 1 to N, and was not an edge that already existed.\nThe resulting graph is given as a 2D-array of edges.  Each element of edges is a pair [u, v] that represents a directed edge connecting nodes u and v, where u is a parent of child v.\nReturn an edge that can be removed so that the resulting graph is a rooted tree of N nodes.  If there are multiple answers, return the answer that occurs last in the given 2D-array.\n", "solutions": ["class Solution {\n    public int[] findRedundantDirectedConnection(int[][] edges) {\n        int N = edges.length;\n        Map<Integer, Integer> parent = new HashMap();\n        List<int[]> candidates = new ArrayList();\n        for (int[] edge: edges) {\n            if (parent.containsKey(edge[1])) {\n                candidates.add(new int[]{parent.get(edge[1]), edge[1]});\n                candidates.add(edge);\n            } else {\n                parent.put(edge[1], edge[0]);\n            }\n        }\n        int root = orbit(1, parent).node;\n        if (candidates.isEmpty()) {\n            Set<Integer> cycle = orbit(root, parent).seen;\n            int[] ans = new int[]{0, 0};\n            for (int[] edge: edges) {\n                if (cycle.contains(edge[0]) && cycle.contains(edge[1])) {\n                    ans = edge;\n                }\n            }\n            return ans;\n        }\n        Map<Integer, List<Integer>> children = new HashMap();\n        for (int v: parent.keySet()) {\n            int pv = parent.get(v);\n            if (!children.containsKey(pv))\n                children.put(pv, new ArrayList<Integer>());\n            children.get(pv).add(v);\n        }\n        boolean[] seen = new boolean[N+1];\n        seen[0] = true;\n        Stack<Integer> stack = new Stack();\n        stack.add(root);\n        while (!stack.isEmpty()) {\n            int node = stack.pop();\n            if (!seen[node]) {\n                seen[node] = true;\n                if (children.containsKey(node)) {\n                    for (int c: children.get(node))\n                        stack.push(c);\n                }\n            }\n        }\n        for (boolean b: seen) if (!b)\n            return candidates.get(0);\n        return candidates.get(1);\n    }\n    public OrbitResult orbit(int node, Map<Integer, Integer> parent) {\n        Set<Integer> seen = new HashSet();\n        while (parent.containsKey(node) && !seen.contains(node)) {\n            seen.add(node);\n            node = parent.get(node);\n        }\n        return new OrbitResult(node, seen);\n    }\n}\nclass OrbitResult {\n    int node;\n    Set<Integer> seen;\n    OrbitResult(int n, Set<Integer> s) {\n        node = n;\n        seen = s;\n    }\n}\n"]}
{"number": 686, "statement": "Given two strings A and B, find the minimum number of times A has to be repeated such that B is a substring of it. If no such solution, return -1.\nFor example, with A = \"abcd\" and B = \"cdabcdab\".\nReturn 3, because by repeating A three times (\u201cabcdabcdabcd\u201d), B is a substring of it; and B is not a substring of A repeated two times (\"abcdabcd\").\nNote:\nThe length of A and B will be between 1 and 10000.\n", "solutions": ["class Solution {\n    public int repeatedStringMatch(String A, String B) {\n        int q = 1;\n        StringBuilder S = new StringBuilder(A);\n        for (; S.length() < B.length(); q++) S.append(A);\n        if (S.indexOf(B) >= 0) return q;\n        if (S.append(A).indexOf(B) >= 0) return q+1;\n        return -1;\n    }\n}\n", "import java.math.BigInteger;\nclass Solution {\n    public boolean check(int index, String A, String B) {\n        for (int i = 0; i < B.length(); i++) {\n            if (A.charAt((i + index) % A.length()) != B.charAt(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    public int repeatedStringMatch(String A, String B) {\n        int q = (B.length() - 1) / A.length() + 1;\n        int p = 113, MOD = 1_000_000_007;\n        int pInv = BigInteger.valueOf(p).modInverse(BigInteger.valueOf(MOD)).intValue();\n        long bHash = 0, power = 1;\n        for (int i = 0; i < B.length(); i++) {\n            bHash += power * B.codePointAt(i);\n            bHash %= MOD;\n            power = (power * p) % MOD;\n        }\n        long aHash = 0; power = 1;\n        for (int i = 0; i < B.length(); i++) {\n            aHash += power * A.codePointAt(i % A.length());\n            aHash %= MOD;\n            power = (power * p) % MOD;\n        }\n        if (aHash == bHash && check(0, A, B)) return q;\n        power = (power * pInv) % MOD;\n        for (int i = B.length(); i < (q + 1) * A.length(); i++) {\n            aHash -= A.codePointAt((i - B.length()) % A.length());\n            aHash *= pInv;\n            aHash += power * A.codePointAt(i % A.length());\n            aHash %= MOD;\n            if (aHash == bHash && check(i - B.length() + 1, A, B)) {\n                return i < q * A.length() ? q : q + 1;\n            }\n        }\n        return -1;\n    }\n}\n"]}
{"number": 687, "statement": "Given a binary tree, find the length of the longest path where each node in the path has the same value. This path may or may not pass through the root.\nThe length of path between two nodes is represented by the number of edges between them.\n", "solutions": ["class Solution {\n    int ans;\n    public int longestUnivaluePath(TreeNode root) {\n        ans = 0;\n        arrowLength(root);\n        return ans;\n    }\n    public int arrowLength(TreeNode node) {\n        if (node == null) return 0;\n        int left = arrowLength(node.left)\n        int right = arrowLength(node.right);\n        int arrowLeft = 0, arrowRight = 0;\n        if (node.left != null && node.left.val == node.val) {\n            arrowLeft += left + 1;\n        }\n        if (node.right != null && node.right.val == node.val) {\n            arrowRight += right + 1;\n        }\n        ans = Math.max(ans, arrowLeft + arrowRight);\n        return Math.max(arrowLeft, arrowRight);\n    }\n}\n"]}
{"number": 688, "statement": "On an NxN chessboard, a knight starts at the r-th row and c-th column and attempts to make exactly K moves. The rows and columns are 0 indexed, so the top-left square is (0, 0), and the bottom-right square is (N-1, N-1).\nA chess knight has 8 possible moves it can make, as illustrated below. Each move is two squares in a cardinal direction, then one square in an orthogonal direction.\nEach time the knight is to move, it chooses one of eight possible moves uniformly at random (even if the piece would go off the chessboard) and moves there.\nThe knight continues moving until it has made exactly K moves or has moved off the chessboard. Return the probability that the knight remains on the board after it has stopped moving.\n", "solutions": ["class Solution {\n    public double knightProbability(int N, int K, int sr, int sc) {\n        double[][] dp = new double[N][N];\n        int[] dr = new int[]{2, 2, 1, 1, -1, -1, -2, -2};\n        int[] dc = new int[]{1, -1, 2, -2, 2, -2, 1, -1};\n        dp[sr][sc] = 1;\n        for (; K > 0; K--) {\n            double[][] dp2 = new double[N][N];\n            for (int r = 0; r < N; r++) {\n                for (int c = 0; c < N; c++) {\n                    for (int k = 0; k < 8; k++) {\n                        int cr = r + dr[k];\n                        int cc = c + dc[k];\n                        if (0 <= cr && cr < N && 0 <= cc && cc < N) {\n                            dp2[cr][cc] += dp[r][c] / 8.0;\n                        }\n                    }\n                }\n            }\n            dp = dp2;\n        }\n        double ans = 0.0;\n        for (double[] row: dp) {\n            for (double x: row) ans += x;\n        }\n        return ans;\n    }\n}\n", "class Solution {\n    public double knightProbability(int N, int K, int sr, int sc) {\n        int[] dr = new int[]{-1, -1, 1, 1, -2, -2, 2, 2};\n        int[] dc = new int[]{2, -2, 2, -2, 1, -1, 1, -1};\n        int[] index = new int[N * N];\n        int t = 0;\n        for (int r = 0; r < N; r++) {\n            for (int c = 0; c < N; c++) {\n                if (r * N + c == canonical(r, c, N)) {\n                    index[r * N + c] = t;\n                    t++;\n                } else {\n                    index[r * N + c] = index[canonical(r, c, N)];\n                }\n            }\n        }\n        double[][] T = new double[t][t];\n        int curRow = 0;\n        for (int r = 0; r < N; r++) {\n            for (int c = 0; c < N; c++) {\n                if (r * N + c == canonical(r, c, N)) {\n                    for (int k = 0; k < 8; k++) {\n                        int cr = r + dr[k], cc = c + dc[k];\n                        if (0 <= cr && cr < N && 0 <= cc && cc < N) {\n                            T[curRow][index[canonical(cr, cc, N)]] += 0.125;\n                        }\n                    }\n                    curRow++;\n                }\n            }\n        }\n        double[] row = matrixExpo(T, K)[index[sr*N + sc]];\n        double ans = 0.0;\n        for (double x: row) ans += x;\n        return ans;\n    }\n    public int canonical(int r, int c, int N) {\n        if (2*r > N) r = N-1-r;\n        if (2*c > N) c = N-1-c;\n        if (r > c) {\n            int t = r;\n            r = c;\n            c = t;\n        }\n        return r * N + c;\n    }\n    public double[][] matrixMult(double[][] A, double[][] B) {\n        double[][] ans = new double[A.length][A.length];\n        for (int i = 0; i < A.length; i++) {\n            for (int j = 0; j < B[0].length; j++) {\n                for (int k = 0; k < B.length; k++) {\n                    ans[i][j] += A[i][k] * B[k][j];\n                }\n            }\n        }\n        return ans;\n    }\n    public double[][] matrixExpo(double[][] A, int pow) {\n        double[][] ans = new double[A.length][A.length];\n        for (int i = 0; i < A.length; i++) ans[i][i] = 1;\n        if (pow == 0) return ans;\n        if (pow == 1) return A;\n        if (pow % 2 == 1) return matrixMult(matrixExpo(A, pow-1), A);\n        double[][] B = matrixExpo(A, pow / 2);\n        return matrixMult(B, B);\n    }\n}\n"]}
{"number": 689, "statement": "In a given array nums of positive integers, find three non-overlapping subarrays with maximum sum.\nEach subarray will be of size k, and we want to maximize the sum of all 3*k entries.\nReturn the result as a list of indices representing the starting position of each interval (0-indexed). If there are multiple answers, return the lexicographically smallest one.\n", "solutions": ["class Solution {\n    public int[] maxSumOfThreeSubarrays(int[] nums, int k) {\n        // W is an array of sums of windows\n        int[] W = new int[nums.length - k + 1];\n        int currSum = 0;\n        for (int i = 0; i < nums.length; i++) {\n            currSum += nums[i];\n            if (i >= k) {\n                currSum -= nums[i - k];\n            }\n            if (i >= k - 1) {\n                W[i - k + 1] = currSum;\n            }\n        }\n        int[] left = new int[W.length];\n        int best = 0;\n        for (int i = 0; i < W.length; i++) {\n            if (W[i] > W[best]) best = i;\n            left[i] = best;\n        }\n        int[] right = new int[W.length];\n        best = W.length - 1;\n        for (int i = W.length - 1; i >= 0; i--) {\n            if (W[i] >= W[best]) {\n                best = i;\n            }\n            right[i] = best;\n        }\n        \n        int[] ans = new int[]{-1, -1, -1};\n        for (int j = k; j < W.length - k; j++) {\n            int i = left[j - k], l = right[j + k];\n            if (ans[0] == -1 || W[i] + W[j] + W[l] > W[ans[0]] + W[ans[1]] + W[ans[2]]) {\n                ans[0] = i;\n                ans[1] = j;\n                ans[2] = l;\n            }\n        }\n        return ans;\n    }\n}\n"]}
{"number": 690, "statement": "You are given a data structure of employee information, which includes the employee's unique id, his importance value and his direct subordinates' id.\nFor example, employee 1 is the leader of employee 2, and employee 2 is the leader of employee 3. They have importance value 15, 10 and 5, respectively. Then employee 1 has a data structure like [1, 15, [2]], and employee 2 has [2, 10, [3]], and employee 3 has [3, 5, []]. Note that although employee 3 is also a subordinate of employee 1, the relationship is not direct.\nNow given the employee information of a company, and an employee id, you need to return the total importance value of this employee and all his subordinates.\n", "solutions": ["class Solution {\n    Map<Integer, Employee> emap;\n    public int getImportance(List<Employee> employees, int queryid) {\n        emap = new HashMap();\n        for (Employee e: employees) emap.put(e.id, e);\n        return dfs(queryid);\n    }\n    public int dfs(int eid) {\n        Employee employee = emap.get(eid);\n        int ans = employee.importance;\n        for (Integer subid: employee.subordinates)\n            ans += dfs(subid);\n        return ans;\n    }\n}\n"]}
{"number": 691, "statement": "We are given N different types of stickers.  Each sticker has a lowercase English word on it.\nYou would like to spell out the given target string by cutting individual letters from your collection of stickers and rearranging them.\nYou can use each sticker more than once if you want, and you have infinite quantities of each sticker.\nWhat is the minimum number of stickers that you need to spell out the target?  If the task is impossible, return -1.\n", "solutions": ["class Solution {\n    int best;\n    int[][] stickersCount;\n    int[] targetCount;\n    public void search(int ans, int row) {\n        if (ans >= best) return;\n        if (row == stickersCount.length) {\n            for (int c: targetCount) if (c > 0) return;\n            best = ans;\n            return;\n        }\n        int used = 0;\n        for (int i = 0; i < stickersCount[row].length; i++) {\n            if (targetCount[i] > 0 && stickersCount[row][i] > 0) {\n                used = Math.max(used, (targetCount[i] - 1) / stickersCount[row][i] + 1);\n            }\n        }\n        for (int i = 0; i < stickersCount[row].length; i++) {\n            targetCount[i] -= used * stickersCount[row][i];\n        }\n        search(ans + used, row + 1);\n        while (used > 0) {\n            for (int i = 0; i < stickersCount[row].length; i++) {\n                targetCount[i] += stickersCount[row][i];\n            }\n            used--;\n            search(ans + used, row + 1);\n        }\n    }\n    public int minStickers(String[] stickers, String target) {\n        int[] targetNaiveCount = new int[26];\n        for (char c: target.toCharArray()) targetNaiveCount[c - 'a']++;\n        int[] index = new int[26];\n        int t = 0;\n        for (int i = 0; i < 26; i++) {\n            if (targetNaiveCount[i] > 0) {\n                index[i] = t++;\n            } else {\n                index[i] = -1;\n            }\n        }\n        targetCount = new int[t];\n        t = 0;\n        for (int c: targetNaiveCount) if (c > 0) {\n            targetCount[t++] = c;\n        }\n        stickersCount = new int[stickers.length][t];\n        for (int i = 0; i < stickers.length; i++) {\n            for (char c: stickers[i].toCharArray()) {\n                int j = index[c - 'a'];\n                if (j >= 0) stickersCount[i][j]++;\n            }\n        }\n        int anchor = 0;\n        for (int i = 0; i < stickers.length; i++) {\n            for (int j = anchor; j < stickers.length; j++) if (j != i) {\n                boolean dominated = true;\n                for (int k = 0; k < t; k++) {\n                    if (stickersCount[i][k] > stickersCount[j][k]) {\n                        dominated = false;\n                        break;\n                    }\n                }\n                if (dominated) {\n                    int[] tmp = stickersCount[i];\n                    stickersCount[i] = stickersCount[anchor];\n                    stickersCount[anchor++] = tmp;\n                    break;\n                }\n            }\n        }\n        best = target.length() + 1;\n        search(0, anchor);\n        return best <= target.length() ? best : -1;\n    }\n}\n", "class Solution {\n    public int minStickers(String[] stickers, String target) {\n        int N = target.length();\n        int[] dp = new int[1 << N];\n        for (int i = 1; i < 1 << N; i++) dp[i] = -1;\n        for (int state = 0; state < 1 << N; state++) {\n            if (dp[state] == -1) continue;\n            for (String sticker: stickers) {\n                int now = state;\n                for (char letter: sticker.toCharArray()) {\n                    for (int i = 0; i < N; i++) {\n                        if (((now >> i) & 1) == 1) continue;\n                        if (target.charAt(i) == letter) {\n                            now |= 1 << i;\n                            break;\n                        }\n                    }\n                }\n                if (dp[now] == -1 || dp[now] > dp[state] + 1) {\n                    dp[now] = dp[state] + 1;\n                }\n            }\n        }\n        return dp[(1 << N) - 1];\n    }\n}\n"]}
{"number": 693, "statement": "Given a positive integer, check whether it has alternating bits: namely, if two adjacent bits will always have different values.\n", "solutions": ["class Solution {\n    public boolean hasAlternatingBits(int n) {\n        String bits = Integer.toBinaryString(n);\n        for (int i = 0; i < bits.length() - 1; i++) {\n            if (bits.charAt(i) == bits.charAt(i+1)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n", "class Solution {\n    public boolean hasAlternatingBits(int n) {\n        int cur = n % 2;\n        n /= 2;\n        while (n > 0) {\n            if (cur == n % 2) return false;\n            cur = n % 2;\n            n /= 2;\n        }\n        return true;\n    }\n}\n"]}
{"number": 694, "statement": "Given a non-empty 2D array grid of 0's and 1's, an island is a group of 1's (representing land) connected 4-directionally (horizontal or vertical.)  You may assume all four edges of the grid are surrounded by water.\nCount the number of distinct islands.  An island is considered to be the same as another if and only if one island can be translated (and not rotated or reflected) to equal the other.\n", "solutions": ["class Solution {\n    int[][] grid;\n    boolean[][] seen;\n    Set<Integer> shape;\n    \n    public void explore(int r, int c, int r0, int c0) {\n        if (0 <= r && r < grid.length && 0 <= c && c < grid[0].length &&\n                grid[r][c] == 1 && !seen[r][c]) {\n            seen[r][c] = true;\n            shape.add((r - r0) * 2 * grid[0].length + (c - c0));\n            explore(r+1, c, r0, c0);\n            explore(r-1, c, r0, c0);\n            explore(r, c+1, r0, c0);\n            explore(r, c-1, r0, c0);\n        }\n    }\n    public int numDistinctIslands(int[][] grid) {\n        this.grid = grid;\n        seen = new boolean[grid.length][grid[0].length];\n        Set shapes = new HashSet<HashSet<Integer>>();\n        for (int r = 0; r < grid.length; r++) {\n            for (int c = 0; c < grid[0].length; c++) {\n                shape = new HashSet<Integer>();\n                explore(r, c, r, c);\n                if (!shape.isEmpty()) {\n                    shapes.add(shape);\n                }\n            }\n        }\n        return shapes.size();\n    }\n}\n", "class Solution {\n    int[][] grid;\n    boolean[][] seen;\n    ArrayList<Integer> shape;\n    public void explore(int r, int c, int di) {\n        if (0 <= r && r < grid.length && 0 <= c && c < grid[0].length &&\n                grid[r][c] == 1 && !seen[r][c]) {\n            seen[r][c] = true;\n            shape.add(di);\n            explore(r+1, c, 1);\n            explore(r-1, c, 2);\n            explore(r, c+1, 3);\n            explore(r, c-1, 4);\n            shape.add(0);\n        }\n    }\n    public int numDistinctIslands(int[][] grid) {\n        this.grid = grid;\n        seen = new boolean[grid.length][grid[0].length];\n        Set shapes = new HashSet<ArrayList<Integer>>();\n        for (int r = 0; r < grid.length; r++) {\n            for (int c = 0; c < grid[0].length; c++) {\n                shape = new ArrayList<Integer>();\n                explore(r, c, 0);\n                if (!shape.isEmpty()) {\n                    shapes.add(shape);\n                }\n            }\n        }\n        return shapes.size();\n    }\n}\n"]}
{"number": 695, "statement": "Given a non-empty 2D array grid of 0's and 1's, an island is a group of 1's (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.\nFind the maximum area of an island in the given 2D array. (If there is no island, the maximum area is 0.)\n", "solutions": ["class Solution {\n    int[][] grid;\n    boolean[][] seen;\n    public int area(int r, int c) {\n        if (r < 0 || r >= grid.length || c < 0 || c >= grid[0].length ||\n                seen[r][c] || grid[r][c] == 0)\n            return 0;\n        seen[r][c] = true;\n        return (1 + area(r+1, c) + area(r-1, c)\n                  + area(r, c-1) + area(r, c+1));\n    }\n    public int maxAreaOfIsland(int[][] grid) {\n        this.grid = grid;\n        seen = new boolean[grid.length][grid[0].length];\n        int ans = 0;\n        for (int r = 0; r < grid.length; r++) {\n            for (int c = 0; c < grid[0].length; c++) {\n                ans = Math.max(ans, area(r, c));\n            }\n        }\n        return ans;\n    }\n}\n", "class Solution {\n    public int maxAreaOfIsland(int[][] grid) {\n        boolean[][] seen = new boolean[grid.length][grid[0].length];\n        int[] dr = new int[]{1, -1, 0, 0};\n        int[] dc = new int[]{0, 0, 1, -1};\n        int ans = 0;\n        for (int r0 = 0; r0 < grid.length; r0++) {\n            for (int c0 = 0; c0 < grid[0].length; c0++) {\n                if (grid[r0][c0] == 1 && !seen[r0][c0]) {\n                    int shape = 0;\n                    Stack<int[]> stack = new Stack();\n                    stack.push(new int[]{r0, c0});\n                    seen[r0][c0] = true;\n                    while (!stack.empty()) {\n                        int[] node = stack.pop();\n                        int r = node[0], c = node[1];\n                        shape++;\n                        for (int k = 0; k < 4; k++) {\n                            int nr = r + dr[k];\n                            int nc = c + dc[k];\n                            if (0 <= nr && nr < grid.length &&\n                                    0 <= nc && nc < grid[0].length &&\n                                    grid[nr][nc] == 1 && !seen[nr][nc]) {\n                                stack.push(new int[]{nr, nc});\n                                seen[nr][nc] = true;\n                            }\n                        }\n                    }\n                    ans = Math.max(ans, shape);\n                }\n            }\n        }\n        return ans;\n    }\n}\n"]}
{"number": 699, "statement": "On an infinite number line (x-axis), we drop given squares in the order they are given.\nThe i-th square dropped (positions[i] = (left, side_length)) is a square with the left-most point being positions[i][0] and sidelength positions[i][1].\nThe square is dropped with the bottom edge parallel to the number line, and from a higher height than all currently landed squares. We wait for each square to stick before dropping the next.\nThe squares are infinitely sticky on their bottom edge, and will remain fixed to any positive length surface they touch (either the number line or another square). Squares dropped adjacent to each other will not stick together prematurely.\nReturn a list ans of heights. Each height ans[i] represents the current highest height of any square we have dropped, after dropping squares represented by positions[0], positions[1], ..., positions[i].\n", "solutions": ["Set<Integer> coords = new HashSet();\nfor (int[] pos: positions) {\n    coords.add(pos[0]);\n    coords.add(pos[0] + pos[1] - 1);\n}\nList<Integer> sortedCoords = new ArrayList(coords);\nCollections.sort(sortedCoords);\nMap<Integer, Integer> index = new HashMap();\nint t = 0;\nfor (int coord: sortedCoords) index.put(coord, t++);\n", "class Solution {\n    public List<Integer> fallingSquares(int[][] positions) {\n        int[] qans = new int[positions.length];\n        for (int i = 0; i < positions.length; i++) {\n            int left = positions[i][0];\n            int size = positions[i][1];\n            int right = left + size;\n            qans[i] += size;\n            for (int j = i+1; j < positions.length; j++) {\n                int left2 = positions[j][0];\n                int size2 = positions[j][1];\n                int right2 = left2 + size2;\n                if (left2 < right && left < right2) { //intersect\n                    qans[j] = Math.max(qans[j], qans[i]);\n                }\n            }\n        }\n        List<Integer> ans = new ArrayList();\n        int cur = -1;\n        for (int x: qans) {\n            cur = Math.max(cur, x);\n            ans.add(cur);\n        }\n        return ans;\n    }\n}\n", "class Solution {\n    int[] heights;\n    public int query(int L, int R) {\n        int ans = 0;\n        for (int i = L; i <= R; i++) {\n            ans = Math.max(ans, heights[i]);\n        }\n        return ans;\n    }\n    public void update(int L, int R, int h) {\n        for (int i = L; i <= R; i++) {\n            heights[i] = Math.max(heights[i], h);\n        }\n    }\n    public List<Integer> fallingSquares(int[][] positions) {\n        //Coordinate Compression\n        //HashMap<Integer, Integer> index = ...;\n        //int t = ...;\n        heights = new int[t];\n        int best = 0;\n        List<Integer> ans = new ArrayList();\n        for (int[] pos: positions) {\n            int L = index.get(pos[0]);\n            int R = index.get(pos[0] + pos[1] - 1);\n            int h = query(L, R) + pos[1];\n            update(L, R, h);\n            best = Math.max(best, h);\n            ans.add(best);\n        }\n        return ans;\n    }\n}\n", "class Solution {\n    int[] heights;\n    int[] blocks;\n    int[] blocks_read;\n    int B;\n    public int query(int left, int right) {\n        int ans = 0;\n        while (left % B > 0 && left <= right) {\n            ans = Math.max(ans, heights[left]);\n            ans = Math.max(ans, blocks[left / B]);\n            left++;\n        }\n        while (right % B != B - 1 && left <= right) {\n            ans = Math.max(ans, heights[right]);\n            ans = Math.max(ans, blocks[right / B]);\n            right--;\n        }\n        while (left <= right) {\n            ans = Math.max(ans, blocks[left / B]);\n            ans = Math.max(ans, blocks_read[left / B]);\n            left += B;\n        }\n        return ans;\n    }\n    public void update(int left, int right, int h) {\n        while (left % B > 0 && left <= right) {\n            heights[left] = Math.max(heights[left], h);\n            blocks_read[left / B] = Math.max(blocks_read[left / B], h);\n            left++;\n        }\n        while (right % B != B - 1 && left <= right) {\n            heights[right] = Math.max(heights[right], h);\n            blocks_read[right / B] = Math.max(blocks_read[right / B], h);\n            right--;\n        }\n        while (left <= right) {\n            blocks[left / B] = Math.max(blocks[left / B], h);\n            left += B;\n        }\n    }\n    public List<Integer> fallingSquares(int[][] positions) {\n        //Coordinate Compression\n        //HashMap<Integer, Integer> index = ...;\n        //int t = ...;\n        heights = new int[t];\n        B = (int) Math.sqrt(t);\n        blocks = new int[B+2];\n        blocks_read = new int[B+2];\n        int best = 0;\n        List<Integer> ans = new ArrayList();\n        for (int[] pos: positions) {\n            int L = index.get(pos[0]);\n            int R = index.get(pos[0] + pos[1] - 1);\n            int h = query(L, R) + pos[1];\n            update(L, R, h);\n            best = Math.max(best, h);\n            ans.add(best);\n        }\n        return ans;\n    }\n}\n", "class Solution {\n    public List<Integer> fallingSquares(int[][] positions) {\n        //Coordinate Compression\n        //HashMap<Integer, Integer> index = ...;\n        SegmentTree tree = new SegmentTree(sortedCoords.size());\n        int best = 0;\n        List<Integer> ans = new ArrayList();\n        for (int[] pos: positions) {\n            int L = index.get(pos[0]);\n            int R = index.get(pos[0] + pos[1] - 1);\n            int h = tree.query(L, R) + pos[1];\n            tree.update(L, R, h);\n            best = Math.max(best, h);\n            ans.add(best);\n        }\n        return ans;\n    }\n}\nclass SegmentTree {\n    int N, H;\n    int[] tree, lazy;\n    SegmentTree(int N) {\n        this.N = N;\n        H = 1;\n        while ((1 << H) < N) H++;\n        tree = new int[2 * N];\n        lazy = new int[N];\n    }\n    private void apply(int x, int val) {\n        tree[x] = Math.max(tree[x], val);\n        if (x < N) lazy[x] = Math.max(lazy[x], val);\n    }\n    private void pull(int x) {\n        while (x > 1) {\n            x >>= 1;\n            tree[x] = Math.max(tree[x * 2], tree[x * 2 + 1]);\n            tree[x] = Math.max(tree[x], lazy[x]);\n        }\n    }\n    private void push(int x) {\n        for (int h = H; h > 0; h--) {\n            int y = x >> h;\n            if (lazy[y] > 0) {\n                apply(y * 2, lazy[y]);\n                apply(y * 2 + 1, lazy[y]);\n                lazy[y] = 0;\n            }\n        }\n    }\n    public void update(int L, int R, int h) {\n        L += N; R += N;\n        int L0 = L, R0 = R, ans = 0;\n        while (L <= R) {\n            if ((L & 1) == 1) apply(L++, h);\n            if ((R & 1) == 0) apply(R--, h);\n            L >>= 1; R >>= 1;\n        }\n        pull(L0); pull(R0);\n    }\n    public int query(int L, int R) {\n        L += N; R += N;\n        int ans = 0;\n        push(L); push(R);\n        while (L <= R) {\n            if ((L & 1) == 1) ans = Math.max(ans, tree[L++]);\n            if ((R & 1) == 0) ans = Math.max(ans, tree[R--]);\n            L >>= 1; R >>= 1;\n        }\n        return ans;\n    }\n}\n"]}
{"number": 700, "statement": "Given the root node of a binary search tree (BST) and a value. You need to find the node in the BST that the node's value equals the given value. Return the subtree rooted with that node. If such node doesn't exist, you should return NULL.\nFor example,\nGiven the tree:\n        4\n       / \\\n      2   7\n     / \\\n    1   3\nAnd the value to search: 2\nYou should return this subtree:\n      2     \n     / \\   \n    1   3\nIn the example above, if we want to search the value 5, since there is no node with value 5, we should return NULL.\nNote that an empty tree is represented by NULL, therefore you would see the expected output (serialized tree format) as[], not null.\n", "solutions": ["class Solution {\n  public TreeNode searchBST(TreeNode root, int val) {\n    if (root == null || val == root.val) return root;\n    return val < root.val ? searchBST(root.left, val) : searchBST(root.right, val);\n  }\n}\n", "class Solution {\n  public TreeNode searchBST(TreeNode root, int val) {\n    while (root != null && val != root.val)\n      root = val < root.val ? root.left : root.right;\n    return root;\n  }\n}\n"]}
{"number": 701, "statement": "Given the root node of a binary search tree (BST) and a value to be inserted into the tree,insert the value into the BST. Return the root node of the BST after the insertion. It is guaranteed that the new value does not exist in the original BST.\nNote that there may existmultiple valid ways for theinsertion, as long as the tree remains a BST after insertion. You can return any of them.\nFor example,\nGiven the tree:\n        4\n       / \\\n      2   7\n     / \\\n    1   3\nAnd the value to insert: 5\nYou can return this binary search tree:\n         4\n       /   \\\n      2     7\n     / \\   /\n    1   3 5\nThis tree is also valid:\n         5\n       /   \\\n      2     7\n     / \\   \n    1   3\n         \\\n          4\nConstraints:\nThe number of nodes in the given tree will be between 0 and 10^4.\nEach node will have a unique integer value from 0to -10^8, inclusive.\n-10^8 = val = 10^8\nIt's guaranteed that val does not exist in the original BST.\n", "solutions": ["class Solution {\n  public TreeNode insertIntoBST(TreeNode root, int val) {\n    if (root == null) return new TreeNode(val);\n    // insert into the right subtree\n    if (val > root.val) root.right = insertIntoBST(root.right, val);\n    // insert into the left subtree\n    else root.left = insertIntoBST(root.left, val);\n    return root;\n  }\n}\n", "class Solution {\n  public TreeNode insertIntoBST(TreeNode root, int val) {\n    TreeNode node = root;\n    while (node != null) {\n      // insert into the right subtree\n      if (val > node.val) {\n        // insert right now\n        if (node.right == null) {\n          node.right = new TreeNode(val);\n          return root;\n        }\n        else node = node.right;\n      }\n      // insert into the left subtree\n      else {\n        // insert right now\n        if (node.left == null) {\n          node.left = new TreeNode(val);\n          return root;\n        }\n        else node = node.left;\n      }\n    }\n    return new TreeNode(val);\n  }\n}\n"]}
{"number": 702, "statement": "Given aninteger array sorted in ascending order, write a function to search target in nums. If target exists, then return its index, otherwise return -1. However, the array size is unknown to you. You may only access the array using an ArrayReaderinterface, whereArrayReader.get(k) returns the element of the array at index k(0-indexed).\nYou may assume all integers in the array are less than10000, and if you access the array out of bounds, ArrayReader.get will return 2147483647.\n", "solutions": ["class ArrayReader;\nclass Solution {\n  public:\n  int search(const ArrayReader& reader, int target) {\n    if (reader.get(0) == target) return 0;\n    // search boundaries\n    int left = 0, right = 1;\n    while (reader.get(right) < target) {\n      left = right;\n      right <<= 1;\n    }\n    // binary search\n    int pivot, num;\n    while (left <= right) {\n      pivot = left + ((right - left) >> 1);\n      num = reader.get(pivot);\n      if (num == target) return pivot;\n      if (num > target) right = pivot - 1;\n      else left = pivot + 1;\n    }\n    // there is no target element\n    return -1;\n  }\n};\n"]}
{"number": 704, "statement": "Given a sorted (in ascending order) integer array nums of n elements and a target value, write a function to search target in nums. If target exists, then return its index, otherwise return -1.\n", "solutions": ["class Solution {\n  public:\n  int search(vector<int>& nums, int target) {\n    int pivot, left = 0, right = nums.size() - 1;\n    while (left <= right) {\n      pivot = left + (right - left) / 2;\n      if (nums[pivot] == target) return pivot;\n      if (target < nums[pivot]) right = pivot - 1;\n      else left = pivot + 1;\n    }\n    return -1;\n  }\n};\n"]}
{"number": 705, "statement": "Design a HashSetwithout using any built-in hash table libraries.\nTo be specific, your design should include these functions:\nadd(value):Insert a value into the HashSet.\ncontains(value) : Return whether the value exists in the HashSet or not.\nremove(value): Remove a value inthe HashSet. If the value does not exist in the HashSet, do nothing.\n", "solutions": ["class MyHashSet {\n  private Bucket[] bucketArray;\n  private int keyRange;\n  /** Initialize your data structure here. */\n  public MyHashSet() {\n    this.keyRange = 769;\n    this.bucketArray = new Bucket[this.keyRange];\n    for (int i = 0; i < this.keyRange; ++i)\n      this.bucketArray[i] = new Bucket();\n  }\n  protected int _hash(int key) {\n    return (key % this.keyRange);\n  }\n  public void add(int key) {\n    int bucketIndex = this._hash(key);\n    this.bucketArray[bucketIndex].insert(key);\n  }\n  public void remove(int key) {\n    int bucketIndex = this._hash(key);\n    this.bucketArray[bucketIndex].delete(key);\n  }\n  /** Returns true if this set contains the specified element */\n  public boolean contains(int key) {\n    int bucketIndex = this._hash(key);\n    return this.bucketArray[bucketIndex].exists(key);\n  }\n}\nclass Bucket {\n  private LinkedList<Integer> container;\n  public Bucket() {\n    container = new LinkedList<Integer>();\n  }\n  public void insert(Integer key) {\n    int index = this.container.indexOf(key);\n    if (index == -1) {\n      this.container.addFirst(key);\n    }\n  }\n  public void delete(Integer key) {\n    this.container.remove(key);\n  }\n  public boolean exists(Integer key) {\n    int index = this.container.indexOf(key);\n    return (index != -1);\n  }\n}\n/**\n * Your MyHashSet object will be instantiated and called as such:\n * MyHashSet obj = new MyHashSet();\n * obj.add(key);\n * obj.remove(key);\n * boolean param_3 = obj.contains(key);\n */\n", "class MyHashSet {\n  private Bucket[] bucketArray;\n  private int keyRange;\n  /** Initialize your data structure here. */\n  public MyHashSet() {\n    this.keyRange = 769;\n    this.bucketArray = new Bucket[this.keyRange];\n    for (int i = 0; i < this.keyRange; ++i)\n      this.bucketArray[i] = new Bucket();\n  }\n  protected int _hash(int key) {\n    return (key % this.keyRange);\n  }\n  public void add(int key) {\n    int bucketIndex = this._hash(key);\n    this.bucketArray[bucketIndex].insert(key);\n  }\n  public void remove(int key) {\n    int bucketIndex = this._hash(key);\n    this.bucketArray[bucketIndex].delete(key);\n  }\n  /** Returns true if this set contains the specified element */\n  public boolean contains(int key) {\n    int bucketIndex = this._hash(key);\n    return this.bucketArray[bucketIndex].exists(key);\n  }\n}\nclass Bucket {\n  private BSTree tree;\n  public Bucket() {\n    tree = new BSTree();\n  }\n  public void insert(Integer key) {\n    this.tree.root = this.tree.insertIntoBST(this.tree.root, key);\n  }\n  public void delete(Integer key) {\n    this.tree.root = this.tree.deleteNode(this.tree.root, key);\n  }\n  public boolean exists(Integer key) {\n    TreeNode node = this.tree.searchBST(this.tree.root, key);\n    return (node != null);\n  }\n}\npublic class TreeNode {\n  int val;\n  TreeNode left;\n  TreeNode right;\n  TreeNode(int x) {\n    val = x;\n  }\n}\nclass BSTree {\n  TreeNode root = null;\n  public TreeNode searchBST(TreeNode root, int val) {\n    if (root == null || val == root.val)\n      return root;\n    return val < root.val ? searchBST(root.left, val) : searchBST(root.right, val);\n  }\n  public TreeNode insertIntoBST(TreeNode root, int val) {\n    if (root == null)\n      return new TreeNode(val);\n    if (val > root.val)\n      // insert into the right subtree\n      root.right = insertIntoBST(root.right, val);\n    else if (val == root.val)\n      // skip the insertion\n      return root;\n    else\n      // insert into the left subtree\n      root.left = insertIntoBST(root.left, val);\n    return root;\n  }\n  /*\n   * One step right and then always left\n   */\n  public int successor(TreeNode root) {\n    root = root.right;\n    while (root.left != null)\n      root = root.left;\n    return root.val;\n  }\n  /*\n   * One step left and then always right\n   */\n  public int predecessor(TreeNode root) {\n    root = root.left;\n    while (root.right != null)\n      root = root.right;\n    return root.val;\n  }\n  public TreeNode deleteNode(TreeNode root, int key) {\n    if (root == null)\n      return null;\n    // delete from the right subtree\n    if (key > root.val)\n      root.right = deleteNode(root.right, key);\n    // delete from the left subtree\n    else if (key < root.val)\n      root.left = deleteNode(root.left, key);\n    // delete the current node\n    else {\n      // the node is a leaf\n      if (root.left == null && root.right == null)\n        root = null;\n      // the node is not a leaf and has a right child\n      else if (root.right != null) {\n        root.val = successor(root);\n        root.right = deleteNode(root.right, root.val);\n      }\n      // the node is not a leaf, has no right child, and has a left child\n      else {\n        root.val = predecessor(root);\n        root.left = deleteNode(root.left, root.val);\n      }\n    }\n    return root;\n  }\n}\n/**\n * Your MyHashSet object will be instantiated and called as such:\n * MyHashSet obj = new MyHashSet();\n * obj.add(key);\n * obj.remove(key);\n * boolean param_3 = obj.contains(key);\n */\n"]}
{"number": 706, "statement": "Design a HashMapwithout using any built-in hash table libraries.\nTo be specific, your design should include these functions:\nput(key, value) :Insert a (key, value) pair into the HashMap. If the value already exists in the HashMap, update the value.\nget(key): Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key.\nremove(key) :Remove the mapping for the value key if this map contains the mapping for the key.\n", "solutions": ["class Pair<U, V> {\n  public U first;\n  public V second;\n  public Pair(U first, V second) {\n    this.first = first;\n    this.second = second;\n  }\n}\nclass Bucket {\n  private List<Pair<Integer, Integer>> bucket;\n  public Bucket() {\n    this.bucket = new LinkedList<Pair<Integer, Integer>>();\n  }\n  public Integer get(Integer key) {\n    for (Pair<Integer, Integer> pair : this.bucket) {\n      if (pair.first.equals(key))\n        return pair.second;\n    }\n    return -1;\n  }\n  public void update(Integer key, Integer value) {\n    boolean found = false;\n    for (Pair<Integer, Integer> pair : this.bucket) {\n      if (pair.first.equals(key)) {\n        pair.second = value;\n        found = true;\n      }\n    }\n    if (!found)\n      this.bucket.add(new Pair<Integer, Integer>(key, value));\n  }\n  public void remove(Integer key) {\n    for (Pair<Integer, Integer> pair : this.bucket) {\n      if (pair.first.equals(key)) {\n        this.bucket.remove(pair);\n        break;\n      }\n    }\n  }\n}\nclass MyHashMap {\n  private int key_space;\n  private List<Bucket> hash_table;\n  /** Initialize your data structure here. */\n  public MyHashMap() {\n    this.key_space = 2069;\n    this.hash_table = new ArrayList<Bucket>();\n    for (int i = 0; i < this.key_space; ++i) {\n      this.hash_table.add(new Bucket());\n    }\n  }\n  /** value will always be non-negative. */\n  public void put(int key, int value) {\n    int hash_key = key % this.key_space;\n    this.hash_table.get(hash_key).update(key, value);\n  }\n  /**\n   * Returns the value to which the specified key is mapped, or -1 if this map contains no mapping\n   * for the key\n   */\n  public int get(int key) {\n    int hash_key = key % this.key_space;\n    return this.hash_table.get(hash_key).get(key);\n  }\n  /** Removes the mapping of the specified value key if this map contains a mapping for the key */\n  public void remove(int key) {\n    int hash_key = key % this.key_space;\n    this.hash_table.get(hash_key).remove(key);\n  }\n}\n/**\n * Your MyHashMap object will be instantiated and called as such: MyHashMap obj = new MyHashMap();\n * obj.put(key,value); int param_2 = obj.get(key); obj.remove(key);\n */\n"]}
{"number": 707, "statement": "Design yourimplementation of the linked list. You can choose to use the singly linked list or the doubly linked list. A node in a singlylinked list should have two attributes: valand next. val is the value of the current node, and nextisapointer/reference to the next node. If you want to use the doubly linked list,you will needone more attribute prev to indicate the previous node in the linked list. Assume all nodes in the linked list are 0-indexed.\nImplement these functions in your linked list class:\nget(index) : Get the value ofthe index-thnode in the linked list. If the index is invalid, return -1.\naddAtHead(val) : Add a node of value valbefore the first element of the linked list. After the insertion, the new node will be the first node of the linked list.\naddAtTail(val) : Append a node of value valto the last element of the linked list.\naddAtIndex(index, val) : Add a node of value valbefore the index-thnode in the linked list.If indexequalsto the length oflinked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted.\ndeleteAtIndex(index) : Deletethe index-thnode in the linked list, if the index is valid.\n", "solutions": ["class MyLinkedList {\n  int size;\n  ListNode head;  // sentinel node as pseudo-head\n  public MyLinkedList() {\n    size = 0;\n    head = new ListNode(0);\n  }\n}\n", "public class ListNode {\n  int val;\n  ListNode next;\n  ListNode(int x) { val = x; }\n}\n", "toAdd.next = pred.next;\npred.next = toAdd;\n", "// delete pred.next \npred.next = pred.next.next;\n", "// index steps needed \n// to move from sentinel node to wanted index\nfor(int i = 0; i < index + 1; ++i) curr = curr.next;\nreturn curr.val;\n", "public class ListNode {\n  int val;\n  ListNode next;\n  ListNode(int x) { val = x; }\n}\nclass MyLinkedList {\n  int size;\n  ListNode head;  // sentinel node as pseudo-head\n  public MyLinkedList() {\n    size = 0;\n    head = new ListNode(0);\n  }\n  /** Get the value of the index-th node in the linked list. If the index is invalid, return -1. */\n  public int get(int index) {\n    // if index is invalid\n    if (index < 0 || index >= size) return -1;\n    ListNode curr = head;\n    // index steps needed \n    // to move from sentinel node to wanted index\n    for(int i = 0; i < index + 1; ++i) curr = curr.next;\n    return curr.val;\n  }\n  /** Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. */\n  public void addAtHead(int val) {\n    addAtIndex(0, val);\n  }\n  /** Append a node of value val to the last element of the linked list. */\n  public void addAtTail(int val) {\n    addAtIndex(size, val);\n  }\n  /** Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. */\n  public void addAtIndex(int index, int val) {\n    // If index is greater than the length, \n    // the node will not be inserted.\n    if (index > size) return;\n    // [so weird] If index is negative, \n    // the node will be inserted at the head of the list.\n    if (index < 0) index = 0;\n    ++size;\n    // find predecessor of the node to be added\n    ListNode pred = head;\n    for(int i = 0; i < index; ++i) pred = pred.next;\n    // node to be added\n    ListNode toAdd = new ListNode(val);\n    // insertion itself\n    toAdd.next = pred.next;\n    pred.next = toAdd;\n  }\n  /** Delete the index-th node in the linked list, if the index is valid. */\n  public void deleteAtIndex(int index) {\n    // if the index is invalid, do nothing\n    if (index < 0 || index >= size) return;\n    size--;\n    // find predecessor of the node to be deleted\n    ListNode pred = head;\n    for(int i = 0; i < index; ++i) pred = pred.next;\n    // delete pred.next \n    pred.next = pred.next.next;\n  }\n}\n", "class MyLinkedList {\n  int size;\n  // sentinel nodes as pseudo-head and pseudo-tail\n  ListNode head, tail;\n  public MyLinkedList() {\n    size = 0;\n    head = new ListNode(0);\n    tail = new ListNode(0);\n    head.next = tail;\n    tail.prev = head;\n  }\n}\n", "public class ListNode {\n  int val;\n  ListNode next;\n  ListNode prev;\n  ListNode(int x) { val = x; }\n}\n", "toAdd.prev = pred\ntoAdd.next = succ\npred.next = toAdd\nsucc.prev = toAdd\n", "pred.next = succ\nsucc.prev = pred\n", "// choose the fastest way: to move from the head\n// or to move from the tail\nListNode curr = head;\nif (index + 1 < size - index)\n  for(int i = 0; i < index + 1; ++i) curr = curr.next;\nelse {\n  curr = tail;\n  for(int i = 0; i < size - index; ++i) curr = curr.prev;\n}\n", "public class ListNode {\n  int val;\n  ListNode next;\n  ListNode prev;\n  ListNode(int x) { val = x; }\n}\nclass MyLinkedList {\n  int size;\n  // sentinel nodes as pseudo-head and pseudo-tail\n  ListNode head, tail;\n  public MyLinkedList() {\n    size = 0;\n    head = new ListNode(0);\n    tail = new ListNode(0);\n    head.next = tail;\n    tail.prev = head;\n  }\n  /** Get the value of the index-th node in the linked list. If the index is invalid, return -1. */\n  public int get(int index) {\n    // if index is invalid\n    if (index < 0 || index >= size) return -1;\n    // choose the fastest way: to move from the head\n    // or to move from the tail\n    ListNode curr = head;\n    if (index + 1 < size - index)\n      for(int i = 0; i < index + 1; ++i) curr = curr.next;\n    else {\n      curr = tail;\n      for(int i = 0; i < size - index; ++i) curr = curr.prev;\n    }\n    return curr.val;\n  }\n  /** Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. */\n  public void addAtHead(int val) {\n    ListNode pred = head, succ = head.next;\n    ++size;\n    ListNode toAdd = new ListNode(val);\n    toAdd.prev = pred;\n    toAdd.next = succ;\n    pred.next = toAdd;\n    succ.prev = toAdd;\n  }\n  /** Append a node of value val to the last element of the linked list. */\n  public void addAtTail(int val) {\n    ListNode succ = tail, pred = tail.prev;\n    ++size;\n    ListNode toAdd = new ListNode(val);\n    toAdd.prev = pred;\n    toAdd.next = succ;\n    pred.next = toAdd;\n    succ.prev = toAdd;\n  }\n  /** Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. */\n  public void addAtIndex(int index, int val) {\n    // If index is greater than the length, \n    // the node will not be inserted.\n    if (index > size) return;\n    // [so weird] If index is negative, \n    // the node will be inserted at the head of the list.\n    if (index < 0) index = 0;\n    // find predecessor and successor of the node to be added\n    ListNode pred, succ;\n    if (index < size - index) {\n      pred = head;\n      for(int i = 0; i < index; ++i) pred = pred.next;\n      succ = pred.next;\n    }\n    else {\n      succ = tail;\n      for (int i = 0; i < size - index; ++i) succ = succ.prev;\n      pred = succ.prev;\n    }\n    // insertion itself\n    ++size;\n    ListNode toAdd = new ListNode(val);\n    toAdd.prev = pred;\n    toAdd.next = succ;\n    pred.next = toAdd;\n    succ.prev = toAdd;\n  }\n  /** Delete the index-th node in the linked list, if the index is valid. */\n  public void deleteAtIndex(int index) {\n    // if the index is invalid, do nothing\n    if (index < 0 || index >= size) return;\n    // find predecessor and successor of the node to be deleted\n    ListNode pred, succ;\n    if (index < size - index) {\n      pred = head;\n      for(int i = 0; i < index; ++i) pred = pred.next;\n      succ = pred.next.next;\n    }\n    else {\n      succ = tail;\n      for (int i = 0; i < size - index - 1; ++i) succ = succ.prev;\n      pred = succ.prev.prev;\n    }\n    // delete pred.next \n    --size;\n    pred.next = succ;\n    succ.prev = pred;\n  }\n}\n"]}
{"number": 708, "statement": "Given a node from a Circular Linked List which is sorted in ascending order,write a function to insert a valueinsertVal into the list such that it remains asorted circular list. The given node can be a reference to any single node in the list, and may not be necessarily the smallest value in the circularlist.\nIf there are multiple suitable places for insertion, you may choose any place to insert the new value. After the insertion, the circular list should remain sorted.\nIf the list is empty (i.e., given node is null), you should create a new single circular list and return the reference to that single node. Otherwise, you should return the original given node.\n", "solutions": ["class Solution {\n  public Node insert(Node head, int insertVal) {\n    if (head == null) {\n      Node newNode = new Node(insertVal, null);\n      newNode.next = newNode;\n      return newNode;\n    }\n    Node prev = head;\n    Node curr = head.next;\n    boolean toInsert = false;\n    do {\n      if (prev.val <= insertVal && insertVal <= curr.val) {\n        // Case 1).\n        toInsert = true;\n      } else if (prev.val > curr.val) {\n        // Case 2).\n        if (insertVal >= prev.val || insertVal <= curr.val)\n          toInsert = true;\n      }\n      if (toInsert) {\n        prev.next = new Node(insertVal, curr);\n        return head;\n      }\n      prev = curr;\n      curr = curr.next;\n    } while (prev != head);\n    // Case 3).\n    prev.next = new Node(insertVal, curr);\n    return head;\n  }\n}\n"]}
{"number": 709, "statement": "Implement function ToLowerCase() that has a string parameter str, and returns the same string in lowercase.\n", "solutions": ["class Solution {\n  public String toLowerCase(String str) {\n    return str.toLowerCase();\n  }\n}\n", "class Solution {\n  public String toLowerCase(String str) {\n    Map<Character, Character> h = new HashMap();\n    String upper = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    String lower = \"abcdefghijklmnopqrstuvwxyz\";\n    for (int i = 0; i < 26; ++i) {\n      h.put(upper.charAt(i), lower.charAt(i));\n    }\n    StringBuilder sb = new StringBuilder();\n    for (char x : str.toCharArray()) {\n      sb.append(h.containsKey(x) ? h.get(x) : x);\n    }\n    return sb.toString();\n  }\n}\n", "class Solution {\n  public boolean isUpper(char x) {\n    return 'A' <= x && x <= 'Z';\n  }\n  public char toLower(char x) {\n    return (char) ((int)x | 32);\n  }\n  public String toLowerCase(String str) {\n    StringBuilder sb = new StringBuilder();\n    for (char x : str.toCharArray()) {\n      sb.append(isUpper(x) ? toLower(x) : x);\n    }\n    return sb.toString();\n  }\n}\n"]}
{"number": 710, "statement": "Given a blacklistB containing unique integersfrom [0, N), write a function to return a uniform random integer from [0, N) which is NOTin B.\nOptimize it such that it minimizes the call to system\u2019s Math.random().\nNote:\n1 = N = 1000000000\n0 = B.length  min(100000, N)\n[0, N)does NOT include N. See interval notation.\n", "solutions": ["class Solution {\npublic:\n    vector<int> w;\n    Solution(int n, vector<int> blacklist) {\n        unordered_set<int> W;\n        for (int i = 0; i < n; i++) W.insert(i);\n        for (int x : blacklist) W.erase(x);\n        for (auto it = W.begin(); it != W.end(); it++) w.push_back(*it);\n    }\n    int pick() {\n        return w[rand() % w.size()];\n    }\n};\n", "class Solution {\n    int n;\n    vector<int> b;\npublic:\n    Solution(int N, vector<int> blacklist) {\n        n = N;\n        sort(blacklist.begin(), blacklist.end());\n        b = blacklist;\n    }\n    int pick() {\n        int k = rand() % (n - b.size());\n        int lo = 0;\n        int hi = b.size() - 1;\n        while (lo < hi) {\n            int i = (lo + hi + 1) / 2;\n            if (b[i] - i > k) hi = i - 1;\n            else lo = i;\n        }\n        return lo == hi && b[lo] - lo <= k ? k + lo + 1 : k;\n    }\n};\n"]}
{"number": 716, "statement": "Design a max stack that supports push, pop, top, peekMax and popMax.\npush(x) -- Push element x onto stack.\npop() -- Remove the element on top of the stack and return it.\ntop() -- Get the element on the top.\npeekMax() -- Retrieve the maximum element in the stack.\npopMax() -- Retrieve the maximum element in the stack, and remove it. If you find more than one maximum elements, only remove the top-most one.\n", "solutions": ["class MaxStack {\n    Stack<Integer> stack;\n    Stack<Integer> maxStack;\n    public MaxStack() {\n        stack = new Stack();\n        maxStack = new Stack();\n    }\n    public void push(int x) {\n        int max = maxStack.isEmpty() ? x : maxStack.peek();\n        maxStack.push(max > x ? max : x);\n        stack.push(x);\n    }\n    public int pop() {\n        maxStack.pop();\n        return stack.pop();\n    }\n    public int top() {\n        return stack.peek();\n    }\n    public int peekMax() {\n        return maxStack.peek();\n    }\n    public int popMax() {\n        int max = peekMax();\n        Stack<Integer> buffer = new Stack();\n        while (top() != max) buffer.push(pop());\n        pop();\n        while (!buffer.isEmpty()) push(buffer.pop());\n        return max;\n    }\n}\n", "class MaxStack {\n    TreeMap<Integer, List<Node>> map;\n    DoubleLinkedList dll;\n    public MaxStack() {\n        map = new TreeMap();\n        dll = new DoubleLinkedList();\n    }\n    public void push(int x) {\n        Node node = dll.add(x);\n        if(!map.containsKey(x))\n            map.put(x, new ArrayList<Node>());\n        map.get(x).add(node);\n    }\n    public int pop() {\n        int val = dll.pop();\n        List<Node> L = map.get(val);\n        L.remove(L.size() - 1);\n        if (L.isEmpty()) map.remove(val);\n        return val;\n    }\n    public int top() {\n        return dll.peek();\n    }\n    public int peekMax() {\n        return map.lastKey();\n    }\n    public int popMax() {\n        int max = peekMax();\n        List<Node> L = map.get(max);\n        Node node = L.remove(L.size() - 1);\n        dll.unlink(node);\n        if (L.isEmpty()) map.remove(max);\n        return max;\n    }\n}\nclass DoubleLinkedList {\n    Node head, tail;\n    public DoubleLinkedList() {\n        head = new Node(0);\n        tail = new Node(0);\n        head.next = tail;\n        tail.prev = head;\n    }\n    public Node add(int val) {\n        Node x = new Node(val);\n        x.next = tail;\n        x.prev = tail.prev;\n        tail.prev = tail.prev.next = x;\n        return x;\n    }\n    public int pop() {\n        return unlink(tail.prev).val;\n    }\n    public int peek() {\n        return tail.prev.val;\n    }\n    public Node unlink(Node node) {\n        node.prev.next = node.next;\n        node.next.prev = node.prev;\n        return node;\n    }\n}\nclass Node {\n    int val;\n    Node prev, next;\n    public Node(int v) {val = v;}\n}\n"]}
{"number": 719, "statement": "Given an integer array, return the k-th smallest distance among all the pairs. The distance of a pair (A, B) is defined as the absolute difference between A and B. \n", "solutions": ["class Solution {\n    public int smallestDistancePair(int[] nums, int k) {\n        Arrays.sort(nums);\n        PriorityQueue<Node> heap = new PriorityQueue<Node>(nums.length,\n            Comparator.<Node> comparingInt(node -> nums[node.nei] - nums[node.root]));\n        for (int i = 0; i + 1 < nums.length; ++i) {\n            heap.offer(new Node(i, i+1));\n        }\n        Node node = null;\n        for (; k > 0; --k) {\n            node = heap.poll();\n            if (node.nei + 1 < nums.length) {\n                heap.offer(new Node(node.root, node.nei + 1));\n            }\n        }\n        return nums[node.nei] - nums[node.root];\n    }\n}\nclass Node {\n    int root;\n    int nei;\n    Node(int r, int n) {\n        root = r;\n        nei = n;\n    }\n}\n", "class Solution {\n    public int smallestDistancePair(int[] nums, int k) {\n        Arrays.sort(nums);\n        int WIDTH = 2 * nums[nums.length - 1];\n        //multiplicity[i] = number of nums[j] == nums[i] (j < i)\n        int[] multiplicity = new int[nums.length];\n        for (int i = 1; i < nums.length; ++i) {\n            if (nums[i] == nums[i-1]) {\n                multiplicity[i] = 1 + multiplicity[i - 1];\n            }\n        }\n        //prefix[v] = number of values <= v\n        int[] prefix = new int[WIDTH];\n        int left = 0;\n        for (int i = 0; i < WIDTH; ++i) {\n            while (left < nums.length && nums[left] == i) left++;\n            prefix[i] = left;\n        }\n        int lo = 0;\n        int hi = nums[nums.length - 1] - nums[0];\n        while (lo < hi) {\n            int mi = (lo + hi) / 2;\n            int count = 0;\n            for (int i = 0; i < nums.length; ++i) {\n                count += prefix[nums[i] + mi] - prefix[nums[i]] + multiplicity[i];\n            }\n            //count = number of pairs with distance <= mi\n            if (count >= k) hi = mi;\n            else lo = mi + 1;\n        }\n        return lo;\n    }\n}\n", "class Solution {\n    public int smallestDistancePair(int[] nums, int k) {\n        Arrays.sort(nums);\n        int lo = 0;\n        int hi = nums[nums.length - 1] - nums[0];\n        while (lo < hi) {\n            int mi = (lo + hi) / 2;\n            int count = 0, left = 0;\n            for (int right = 0; right < nums.length; ++right) {\n                while (nums[right] - nums[left] > mi) left++;\n                count += right - left;\n            }\n            //count = number of pairs with distance <= mi\n            if (count >= k) hi = mi;\n            else lo = mi + 1;\n        }\n        return lo;\n    }\n}\n"]}
{"number": 723, "statement": "This question is about implementing a basic elimination algorithm for Candy Crush.\nGiven a 2D integer array board representing the grid of candy, different positive integers board[i][j] represent different types of candies. A value of board[i][j] = 0 represents that the cell at position (i, j) is empty. The given board represents the state of the game following the player's move. Now, you need to restore the board to a stable state by crushing candies according to the following rules:\nIf three or more candies of the same type are adjacent vertically or horizontally, \"crush\" them all at the same time - these positions become empty.\nAfter crushing all candies simultaneously, if an empty space on the board has candies on top of itself, then these candies will drop until they hit a candy or bottom at the same time. (No new candies will drop outside the top boundary.)\nAfter the above steps, there may exist more candies that can be crushed. If so, you need to repeat the above steps.\nIf there does not exist more candies that can be crushed (ie. the board is stable), then return the current board.\nYou need to perform the above rules until the board becomes stable, then return the current board.\n", "solutions": ["class Solution {\n    public int[][] candyCrush(int[][] board) {\n        int R = board.length, C = board[0].length;\n        boolean todo = false;\n        for (int r = 0; r < R; ++r) {\n            for (int c = 0; c + 2 < C; ++c) {\n                int v = Math.abs(board[r][c]);\n                if (v != 0 && v == Math.abs(board[r][c+1]) && v == Math.abs(board[r][c+2])) {\n                    board[r][c] = board[r][c+1] = board[r][c+2] = -v;\n                    todo = true;\n                }\n            }\n        }\n        for (int r = 0; r + 2 < R; ++r) {\n            for (int c = 0; c < C; ++c) {\n                int v = Math.abs(board[r][c]);\n                if (v != 0 && v == Math.abs(board[r+1][c]) && v == Math.abs(board[r+2][c])) {\n                    board[r][c] = board[r+1][c] = board[r+2][c] = -v;\n                    todo = true;\n                }\n            }\n        }\n        for (int c = 0; c < C; ++c) {\n            int wr = R - 1;\n            for (int r = R-1; r >= 0; --r)\n                if (board[r][c] > 0)\n                    board[wr--][c] = board[r][c];\n            while (wr >= 0)\n                board[wr--][c] = 0;\n        }\n        return todo ? candyCrush(board) : board;\n    }\n}\n"]}
{"number": 724, "statement": "Given an array of integers nums, write a method that returns the \"pivot\" index of this array.\nWe define the pivot index as the index where the sum of the numbers to the left of the index is equal to the sum of the numbers to the right of the index.\nIf no such index exists, we should return -1. If there are multiple pivot indexes, you should return the left-most pivot index.\n", "solutions": ["class Solution {\n    public int pivotIndex(int[] nums) {\n        int sum = 0, leftsum = 0;\n        for (int x: nums) sum += x;\n        for (int i = 0; i < nums.length; ++i) {\n            if (leftsum == sum - leftsum - nums[i]) return i;\n            leftsum += nums[i];\n        }\n        return -1;\n    }\n}\n"]}
{"number": 725, "statement": "Given a (singly) linked list with head node root, write a function to split the linked list into k consecutive linked list \"parts\".\nThe length of each part should be as equal as possible: no two parts should have a size differing by more than 1.  This may lead to some parts being null.\nThe parts should be in order of occurrence in the input list, and parts occurring earlier should always have a size greater than or equal parts occurring later.\nReturn a List of ListNode's representing the linked list parts that are formed.\n", "solutions": ["class Solution {\n    public ListNode[] splitListToParts(ListNode root, int k) {\n        ListNode cur = root;\n        int N = 0;\n        while (cur != null) {\n            cur = cur.next;\n            N++;\n        }\n        int width = N / k, rem = N % k;\n        ListNode[] ans = new ListNode[k];\n        cur = root;\n        for (int i = 0; i < k; ++i) {\n            ListNode head = new ListNode(0), write = head;\n            for (int j = 0; j < width + (i < rem ? 1 : 0); ++j) {\n                write = write.next = new ListNode(cur.val);\n                if (cur != null) cur = cur.next;\n            }\n            ans[i] = head.next;\n        }\n        return ans;\n    }\n}\n", "class Solution {\n    public ListNode[] splitListToParts(ListNode root, int k) {\n        ListNode cur = root;\n        int N = 0;\n        while (cur != null) {\n            cur = cur.next;\n            N++;\n        }\n        int width = N / k, rem = N % k;\n        ListNode[] ans = new ListNode[k];\n        cur = root;\n        for (int i = 0; i < k; ++i) {\n            ListNode head = cur;\n            for (int j = 0; j < width + (i < rem ? 1 : 0) - 1; ++j) {\n                if (cur != null) cur = cur.next;\n            }\n            if (cur != null) {\n                ListNode prev = cur;\n                cur = cur.next;\n                prev.next = null;\n            }\n            ans[i] = head;\n        }\n        return ans;\n    }\n}\n"]}
{"number": 726, "statement": "Given a chemical formula (given as a string), return the count of each atom.\nAn atomic element always starts with an uppercase character, then zero or more lowercase letters, representing the name.\n1 or more digits representing the count of that element may follow if the count is greater than 1.  If the count is 1, no digits will follow.  For example, H2O and H2O2 are possible, but H1O2 is impossible.\nTwo formulas concatenated together produce another formula.  For example, H2O2He3Mg4 is also a formula.  \nA formula placed in parentheses, and a count (optionally added) is also a formula.  For example, (H2O2) and (H2O2)3 are formulas.\nGiven a formula, output the count of all elements as a string in the following form: the first name (in sorted order), followed by its count (if that count is more than 1), followed by the second name (in sorted order), followed by its count (if that count is more than 1), and so on.\n", "solutions": ["class Solution {\n    int i;\n    public String countOfAtoms(String formula) {\n        StringBuilder ans = new StringBuilder();\n        i = 0;\n        Map<String, Integer> count = parse(formula);\n        for (String name: count.keySet()) {\n            ans.append(name);\n            int multiplicity = count.get(name);\n            if (multiplicity > 1) ans.append(\"\" + multiplicity);\n        }\n        return new String(ans);\n    }\n    public Map<String, Integer> parse(String formula) {\n        int N = formula.length();\n        Map<String, Integer> count = new TreeMap();\n        while (i < N && formula.charAt(i) != ')') {\n            if (formula.charAt(i) == '(') {\n                i++;\n                for (Map.Entry<String, Integer> entry: parse(formula).entrySet()) {\n                    count.put(entry.getKey(), count.getOrDefault(entry.getKey(), 0) + entry.getValue());\n                }\n            } else {\n                int iStart = i++;\n                while (i < N && Character.isLowerCase(formula.charAt(i))) i++;\n                String name = formula.substring(iStart, i);\n                iStart = i;\n                while (i < N && Character.isDigit(formula.charAt(i))) i++;\n                int multiplicity = iStart < i ? Integer.parseInt(formula.substring(iStart, i)) : 1;\n                count.put(name, count.getOrDefault(name, 0) + multiplicity);\n            }\n        }\n        int iStart = ++i;\n        while (i < N && Character.isDigit(formula.charAt(i))) i++;\n        if (iStart < i) {\n            int multiplicity = Integer.parseInt(formula.substring(iStart, i));\n            for (String key: count.keySet()) {\n                count.put(key, count.get(key) * multiplicity);\n            }\n        }\n        return count;\n    }\n}\n", "class Solution {\n    public String countOfAtoms(String formula) {\n        int N = formula.length();\n        Stack<Map<String, Integer>> stack = new Stack();\n        stack.push(new TreeMap());\n        for (int i = 0; i < N;) {\n            if (formula.charAt(i) == '(') {\n                stack.push(new TreeMap());\n                i++;\n            } else if (formula.charAt(i) == ')') {\n                Map<String, Integer> top = stack.pop();\n                int iStart = ++i, multiplicity = 1;\n                while (i < N && Character.isDigit(formula.charAt(i))) i++;\n                if (i > iStart) multiplicity = Integer.parseInt(formula.substring(iStart, i));\n                for (String c: top.keySet()) {\n                    int v = top.get(c);\n                    stack.peek().put(c, stack.peek().getOrDefault(c, 0) + v * multiplicity);\n                }\n            } else {\n                int iStart = i++;\n                while (i < N && Character.isLowerCase(formula.charAt(i))) i++;\n                String name = formula.substring(iStart, i);\n                iStart = i;\n                while (i < N && Character.isDigit(formula.charAt(i))) i++;\n                int multiplicity = i > iStart ? Integer.parseInt(formula.substring(iStart, i)) : 1;\n                stack.peek().put(name, stack.peek().getOrDefault(name, 0) + multiplicity);\n            }\n        }\n        StringBuilder ans = new StringBuilder();\n        for (String name: stack.peek().keySet()) {\n            ans.append(name);\n            int multiplicity = stack.peek().get(name);\n            if (multiplicity > 1) ans.append(\"\" + multiplicity);\n        }\n        return new String(ans);\n    }\n}\n", "import java.util.regex.*;\nclass Solution {\n    public String countOfAtoms(String formula) {\n        Matcher matcher = Pattern.compile(\"([A-Z][a-z]*)(\\\\d*)|(\\\\()|(\\\\))(\\\\d*)\").matcher(formula);\n        Stack<Map<String, Integer>> stack = new Stack();\n        stack.push(new TreeMap());\n        while (matcher.find()) {\n            String match = matcher.group();\n            if (match.equals(\"(\")) {\n                stack.push(new TreeMap());\n            } else if (match.startsWith(\")\")) {\n                Map<String, Integer> top = stack.pop();\n                int multiplicity = match.length() > 1 ? Integer.parseInt(match.substring(1, match.length())) : 1;\n                for (String name: top.keySet()) {\n                    stack.peek().put(name, stack.peek().getOrDefault(name, 0) + top.get(name) * multiplicity);\n                }\n            } else {\n                int i = 1;\n                while (i < match.length() && Character.isLowerCase(match.charAt(i))) {\n                    i++;\n                }\n                String name = match.substring(0, i);\n                int multiplicity = i < match.length() ? Integer.parseInt(match.substring(i, match.length())) : 1;\n                stack.peek().put(name, stack.peek().getOrDefault(name, 0) + multiplicity);\n            }\n        }\n        StringBuilder ans = new StringBuilder();\n        for (String name: stack.peek().keySet()) {\n            ans.append(name);\n            final int count = stack.peek().get(name);\n            if (count > 1) ans.append(String.valueOf(count));\n        }\n        return ans.toString();\n    }\n}\n"]}
{"number": 727, "statement": "Given strings S and T, find the minimum (contiguous) substring W of S, so that T is a subsequence of W.\nIf there is no such window in S that covers all characters in T, return the empty string \"\". If there are multiple such minimum-length windows, return the one with the left-most starting index.\n", "solutions": ["class Solution {\n    public String minWindow(String S, String T) {\n        int[][] dp = new int[2][S.length()];\n        for (int i = 0; i < S.length(); ++i)\n            dp[0][i] = S.charAt(i) == T.charAt(0) ? i : -1;\n        /*At time j when considering T[:j+1],\n          the smallest window [s, e] where S[e] == T[j]\n          is represented by dp[j & 1][e] = s, and the\n          previous information of the smallest window\n          [s, e] where S[e] == T[j-1] is stored as\n          dp[~j & 1][e] = s.\n        */\n        for (int j = 1; j < T.length(); ++j) {\n            int last = -1;\n            Arrays.fill(dp[j & 1], -1);\n            //Now we would like to calculate the candidate windows\n            //\"dp[j & 1]\" for T[:j+1].  'last' is the last window seen.\n            for (int i = 0; i < S.length(); ++i) {\n                if (last >= 0 && S.charAt(i) == T.charAt(j))\n                    dp[j & 1][i] = last;\n                if (dp[~j & 1][i] >= 0)\n                    last = dp[~j & 1][i];\n            }\n        }\n        //Looking at the window data dp[~T.length & 1],\n        //choose the smallest length window [s, e].\n        int start = 0, end = S.length();\n        for (int e = 0; e < S.length(); ++e) {\n            int s = dp[~T.length() & 1][e];\n            if (s >= 0 && e - s < end - start) {\n                start = s;\n                end = e;\n            }\n        }\n        return end < S.length() ? S.substring(start, end+1) : \"\";\n    }\n}\n", "class Solution {\n    public String minWindow(String S, String T) {\n        int N = S.length();\n        int[] last = new int[26];\n        int[][] nxt = new int[N][26];\n        Arrays.fill(last, -1);\n        for (int i = N - 1; i >= 0; --i) {\n            last[S.charAt(i) - 'a'] = i;\n            for (int k = 0; k < 26; ++k) {\n                nxt[i][k] = last[k];\n            }\n        }\n        List<int[]> windows = new ArrayList();\n        for (int i = 0; i < N; ++i) {\n            if (S.charAt(i) == T.charAt(0))\n                windows.add(new int[]{i, i});\n        }\n        for (int j = 1; j < T.length(); ++j) {\n            int letterIndex = T.charAt(j) - 'a';\n            for (int[] window: windows) {\n                if (window[1] < N-1 && nxt[window[1]+1][letterIndex] >= 0) {\n                    window[1] = nxt[window[1]+1][letterIndex];\n                }\n                else {\n                    window[0] = window[1] = -1;\n                    break;\n                }\n            }\n        }\n        int[] ans = {-1, S.length()};\n        for (int[] window: windows) {\n            if (window[0] == -1) break;\n            if (window[1] - window[0] < ans[1] - ans[0]) {\n                ans = window;\n            }\n        }\n        return ans[0] >= 0 ? S.substring(ans[0], ans[1] + 1) : \"\";\n    }\n}\n"]}
{"number": 728, "statement": "A self-dividing number is a number that is divisible by every digit it contains.\nFor example, 128 is a self-dividing number because 128 % 1 == 0, 128 % 2 == 0, and 128 % 8 == 0.\nAlso, a self-dividing number is not allowed to contain the digit zero.\nGiven a lower and upper number bound, output a list of every possible self dividing number, including the bounds if possible.\n", "solutions": ["class Solution {\n    public List<Integer> selfDividingNumbers(int left, int right) {\n        List<Integer> ans = new ArrayList();\n        for (int n = left; n <= right; ++n) {\n            if (selfDividing(n)) ans.add(n);\n        }\n        return ans;\n    }\n    public boolean selfDividing(int n) {\n        for (char c: String.valueOf(n).toCharArray()) {\n            if (c == '0' || (n % (c - '0') > 0))\n                return false;\n        }\n        return true;\n    }\n    /*\n    Alternate implementation of selfDividing:\n    public boolean selfDividing(int n) {\n        int x = n;\n        while (x > 0) {\n            int d = x % 10;\n            x /= 10;\n            if (d == 0 || (n % d) > 0) return false;\n        }\n        return true;\n    */\n}\n"]}
{"number": 729, "statement": "Implement a MyCalendar class to store your events. A new event can be added if adding the event will not cause a double booking.\nYour class will have the method, book(int start, int end). Formally, this represents a booking on the half open interval [start, end), the range of real numbers x such that start = x  end.\nA double booking happens when two events have some non-empty intersection (ie., there is some time that is common to both events.)\nFor each call to the method MyCalendar.book, return true if the event can be added to the calendar successfully without causing a double booking. Otherwise, return false and do not add the event to the calendar.\nYour class will be called like this: MyCalendar cal = new MyCalendar(); MyCalendar.book(start, end)\n", "solutions": ["public class MyCalendar {\n    List<int[]> calendar;\n    MyCalendar() {\n        calendar = new ArrayList();\n    }\n    public boolean book(int start, int end) {\n        for (int[] iv: calendar) {\n            if (iv[0] < end && start < iv[1]) return false;\n        }\n        calendar.add(new int[]{start, end});\n        return true;\n    }\n}\n", "class MyCalendar {\n    TreeMap<Integer, Integer> calendar;\n    MyCalendar() {\n        calendar = new TreeMap();\n    }\n    public boolean book(int start, int end) {\n        Integer prev = calendar.floorKey(start),\n                next = calendar.ceilingKey(start);\n        if ((prev == null || calendar.get(prev) <= start) &&\n                (next == null || end <= next)) {\n            calendar.put(start, end);\n            return true;\n        }\n        return false;\n    }\n}\n"]}
{"number": 730, "statement": "Given a string S, find the number of different non-empty palindromic subsequences in S, and return that number modulo 10^9 + 7.\nA subsequence of a string S is obtained by deleting 0 or more characters from S.\nA sequence is palindromic if it is equal to the sequence reversed.\nTwo sequences A_1, A_2, ... and B_1, B_2, ... are different if there is some i for which A_i != B_i.\n", "solutions": ["class Solution {\npublic:\n  int countPalindromicSubsequences(string S) {\n    int n = S.size();\n    int mod = 1000000007;\n    auto dp_ptr = new vector<vector<vector<int>>>(4, vector<vector<int>>(n, vector<int>(n)));\n    auto& dp = *dp_ptr;\n    for (int i = n-1; i >= 0; --i) {\n      for (int j = i; j < n; ++j) {\n        for (int k = 0; k < 4; ++k) {\n          char c = 'a' + k;\n          if (j == i) {\n            if (S[i] == c) dp[k][i][j] = 1;\n            else dp[k][i][j] = 0;\n          } else { // j > i\n            if (S[i] != c) dp[k][i][j] = dp[k][i+1][j];\n            else if (S[j] != c) dp[k][i][j] = dp[k][i][j-1];\n            else { // S[i] == S[j] == c\n              if (j == i+1) dp[k][i][j] = 2; // \"aa\" : {\"a\", \"aa\"}\n              else { // length is > 2\n                dp[k][i][j] = 2;\n                for (int m = 0; m < 4; ++m) { // count each one within subwindows [i+1][j-1]\n                  dp[k][i][j] += dp[m][i+1][j-1];\n                  dp[k][i][j] %= mod;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    int ans = 0;\n    for (int k = 0; k < 4; ++k) {\n      ans += dp[k][0][n-1];\n      ans %= mod;\n    }\n    return ans;\n  }\n};\n", "class Solution {\n    int[][] memo, prv, nxt;\n    byte[] A;\n    int MOD = 1_000_000_007;\n    public int countPalindromicSubsequences(String S) {\n        int N = S.length();\n        prv = new int[N][4];\n        nxt = new int[N][4];\n        memo = new int[N][N];\n        for (int[] row: prv) Arrays.fill(row, -1);\n        for (int[] row: nxt) Arrays.fill(row, -1);\n        A = new byte[N];\n        int ix = 0;\n        for (char c: S.toCharArray()) {\n            A[ix++] = (byte) (c - 'a');\n        }\n        int[] last = new int[4];\n        Arrays.fill(last, -1);\n        for (int i = 0; i < N; ++i) {\n            last[A[i]] = i;\n            for (int k = 0; k < 4; ++k)\n                prv[i][k] = last[k];\n        }\n        Arrays.fill(last, -1);\n        for (int i = N-1; i >= 0; --i) {\n            last[A[i]] = i;\n            for (int k = 0; k < 4; ++k)\n                nxt[i][k] = last[k];\n        }\n        return dp(0, N-1) - 1;\n    }\n    public int dp(int i, int j) {\n        if (memo[i][j] > 0) return memo[i][j];\n        int ans = 1;\n        if (i <= j) {\n            for (int k = 0; k < 4; ++k) {\n                int i0 = nxt[i][k];\n                int j0 = prv[j][k];\n                if (i <= i0 && i0 <= j) ans++;\n                if (-1 < i0 && i0 < j0) ans += dp(i0 + 1, j0 - 1);\n                if (ans >= MOD) ans -= MOD;\n            }\n        }\n        memo[i][j] = ans;\n        return ans;\n    }\n}\n"]}
{"number": 731, "statement": "Implement a MyCalendarTwo class to store your events. A new event can be added if adding the event will not cause a triple booking.\nYour class will have one method, book(int start, int end). Formally, this represents a booking on the half open interval [start, end), the range of real numbers x such that start = x  end.\nA triple booking happens when three events have some non-empty intersection (ie., there is some time that is common to all 3 events.)\nFor each call to the method MyCalendar.book, return true if the event can be added to the calendar successfully without causing a triple booking. Otherwise, return false and do not add the event to the calendar.\nYour class will be called like this: MyCalendar cal = new MyCalendar(); MyCalendar.book(start, end)\n", "solutions": ["public class MyCalendarTwo {\n    List<int[]> calendar;\n    List<int[]> overlaps;\n    MyCalendarTwo() {\n        calendar = new ArrayList();\n    }\n    public boolean book(int start, int end) {\n        for (int[] iv: overlaps) {\n            if (iv[0] < end && start < iv[1]) return false;\n        }\n        for (int[] iv: calendar) {\n            if (iv[0] < end && start < iv[1])\n                overlaps.add(new int[]{Math.max(start, iv[0]), Math.min(end, iv[1])});\n        }\n        calendar.add(new int[]{start, end});\n        return true;\n    }\n}\n"]}
{"number": 732, "statement": "Implement a MyCalendarThree class to store your events. A new event can always be added.\nYour class will have one method, book(int start, int end). Formally, this represents a booking on the half open interval [start, end), the range of real numbers x such that start = x  end.\nA K-booking happens when K events have some non-empty intersection (ie., there is some time that is common to all K events.)\nFor each call to the method MyCalendar.book, return an integer K representing the largest integer such that there exists a K-booking in the calendar.\nYour class will be called like this: MyCalendarThree cal = new MyCalendarThree(); MyCalendarThree.book(start, end)\n", "solutions": ["class MyCalendarThree {\n    TreeMap<Integer, Integer> delta;\n    public MyCalendarThree() {\n        delta = new TreeMap();\n    }\n    public int book(int start, int end) {\n        delta.put(start, delta.getOrDefault(start, 0) + 1);\n        delta.put(end, delta.getOrDefault(end, 0) - 1);\n        int active = 0, ans = 0;\n        for (int d: delta.values()) {\n            active += d;\n            if (active > ans) ans = active;\n        }\n        return ans;\n    }\n}\n"]}
{"number": 733, "statement": "An image is represented by a 2-D array of integers, each integer representing the pixel value of the image (from 0 to 65535).\nGiven a coordinate (sr, sc) representing the starting pixel (row and column) of the flood fill, and a pixel value newColor, \"flood fill\" the image.\nTo perform a \"flood fill\", consider the starting pixel, plus any pixels connected 4-directionally to the starting pixel of the same color as the starting pixel, plus any pixels connected 4-directionally to those pixels (also with the same color as the starting pixel), and so on.  Replace the color of all of the aforementioned pixels with the newColor.\nAt the end, return the modified image.\n", "solutions": ["class Solution {\n    public int[][] floodFill(int[][] image, int sr, int sc, int newColor) {\n        int color = image[sr][sc];\n        if (color != newColor) dfs(image, sr, sc, color, newColor);\n        return image;\n    }\n    public void dfs(int[][] image, int r, int c, int color, int newColor) {\n        if (image[r][c] == color) {\n            image[r][c] = newColor;\n            if (r >= 1) dfs(image, r-1, c, color, newColor);\n            if (c >= 1) dfs(image, r, c-1, color, newColor);\n            if (r+1 < image.length) dfs(image, r+1, c, color, newColor);\n            if (c+1 < image[0].length) dfs(image, r, c+1, color, newColor);\n        }\n    }\n}\n"]}
{"number": 734, "statement": "Given two sentences words1, words2 (each represented as an array of strings), and a list of similar word pairs pairs, determine if two sentences are similar.\nFor example, \"great acting skills\" and \"fine drama talent\" are similar, if the similar word pairs are pairs = [[\"great\", \"fine\"], [\"acting\",\"drama\"], [\"skills\",\"talent\"]].\nNote that the similarity relation is not transitive. For example, if \"great\" and \"fine\" are similar, and \"fine\" and \"good\" are similar, \"great\" and \"good\" are not necessarily similar.\nHowever, similarity is symmetric. For example, \"great\" and \"fine\" being similar is the same as \"fine\" and \"great\" being similar.\nAlso, a word is always similar with itself. For example, the sentences words1 = [\"great\"], words2 = [\"great\"], pairs = [] are similar, even though there are no specified similar word pairs.\nFinally, sentences can only be similar if they have the same number of words. So a sentence like words1 = [\"great\"] can never be similar to words2 = [\"doubleplus\",\"good\"].\nNote:\nThe length of words1 and words2 will not exceed 1000.\nThe length of pairs will not exceed 2000.\nThe length of each pairs[i] will be 2.\nThe length of each words[i] and pairs[i][j] will be in the range [1, 20].\n", "solutions": ["class Solution {\n    public boolean areSentencesSimilar(\n            String[] words1, String[] words2, String[][] pairs) {\n        if (words1.length != words2.length) return false;\n        Set<String> pairset = new HashSet();\n        for (String[] pair: pairs)\n            pairset.add(pair[0] + \"#\" + pair[1]);\n        for (int i = 0; i < words1.length; ++i) {\n            if (!words1[i].equals(words2[i]) &&\n                    !pairset.contains(words1[i] + \"#\" + words2[i]) &&\n                    !pairset.contains(words2[i] + \"#\" + words1[i]))\n                return false;\n        }\n        return true;\n    }\n}\n"]}
{"number": 735, "statement": "We are given an array asteroids of integers representing asteroids in a row.\nFor each asteroid, the absolute value represents its size, and the sign represents its direction (positive meaning right, negative meaning left).  Each asteroid moves at the same speed.\nFind out the state of the asteroids after all collisions.  If two asteroids meet, the smaller one will explode.  If both are the same size, both will explode.  Two asteroids moving in the same direction will never meet.\n", "solutions": ["class Solution {\n    public int[] asteroidCollision(int[] asteroids) {\n        Stack<Integer> stack = new Stack();\n        for (int ast: asteroids) {\n            collision: {\n                while (!stack.isEmpty() && ast < 0 && 0 < stack.peek()) {\n                    if (stack.peek() < -ast) {\n                        stack.pop();\n                        continue;\n                    } else if (stack.peek() == -ast) {\n                        stack.pop();\n                    }\n                    break collision;\n                }\n                stack.push(ast);\n            }\n        }\n        int[] ans = new int[stack.size()];\n        for (int t = ans.length - 1; t >= 0; --t) {\n            ans[t] = stack.pop();\n        }\n        return ans;\n    }\n}\n"]}
{"number": 736, "statement": "You are given a string expression representing a Lisp-like expression to return the integer value of.\nThe syntax for these expressions is given as follows.\nAn expression is either an integer, a let-expression, an add-expression, a mult-expression, or an assigned variable.  Expressions always evaluate to a single integer.\n(An integer could be positive or negative.)\nA let-expression takes the form (let v1 e1 v2 e2 ... vn en expr), where let is always the string \"let\", then there are 1 or more pairs of alternating variables and expressions, meaning that the first variable v1 is assigned the value of the expression e1, the second variable v2 is assigned the value of the expression e2, and so on sequentially; and then the value of this let-expression is the value of the expression expr.\nAn add-expression takes the form (add e1 e2) where add is always the string \"add\", there are always two expressions e1, e2, and this expression evaluates to the addition of the evaluation of e1 and the evaluation of e2.\nA mult-expression takes the form (mult e1 e2) where mult is always the string \"mult\", there are always two expressions e1, e2, and this expression evaluates to the multiplication of the evaluation of e1 and the evaluation of e2.\nFor the purposes of this question, we will use a smaller subset of variable names.  A variable starts with a lowercase letter, then zero or more lowercase letters or digits.  Additionally for your convenience, the names \"add\", \"let\", or \"mult\" are protected and will never be used as variable names.\nFinally, there is the concept of scope.  When an expression of a variable name is evaluated, within the context of that evaluation, the innermost scope (in terms of parentheses) is checked first for the value of that variable, and then outer scopes are checked sequentially.  It is guaranteed that every expression is legal.  Please see the examples for more details on scope.\nEvaluation \n", "solutions": ["class Solution {\n    ArrayList<Map<String, Integer>> scope;\n    public Solution() {\n        scope = new ArrayList();\n        scope.add(new HashMap());\n    }\n    public int evaluate(String expression) {\n        scope.add(new HashMap());\n        int ans = evaluate_inner(expression);\n        scope.remove(scope.size() - 1);\n        return ans;\n    }\n    public int evaluate_inner(String expression) {\n        if (expression.charAt(0) != '(') {\n            if (Character.isDigit(expression.charAt(0)) || expression.charAt(0) == '-')\n                return Integer.parseInt(expression);\n            for (int i = scope.size() - 1; i >= 0; --i) {\n                if (scope.get(i).containsKey(expression))\n                    return scope.get(i).get(expression);\n            }\n        }\n        List<String> tokens = parse(expression.substring(\n                expression.charAt(1) == 'm' ? 6 : 5, expression.length() - 1));\n        if (expression.startsWith(\"add\", 1)) {\n            return evaluate(tokens.get(0)) + evaluate(tokens.get(1));\n        } else if (expression.startsWith(\"mult\", 1)) {\n            return evaluate(tokens.get(0)) * evaluate(tokens.get(1));\n        } else {\n            for (int j = 1; j < tokens.size(); j += 2) {\n                scope.get(scope.size() - 1).put(tokens.get(j-1), evaluate(tokens.get(j)));\n            }\n            return evaluate(tokens.get(tokens.size() - 1));\n        }\n    }\n    public List<String> parse(String expression) {\n        List<String> ans = new ArrayList();\n        int bal = 0;\n        StringBuilder buf = new StringBuilder();\n        for (String token: expression.split(\" \")) {\n            for (char c: token.toCharArray()) {\n                if (c == '(') bal++;\n                if (c == ')') bal--;\n            }\n            if (buf.length() > 0) buf.append(\" \");\n            buf.append(token);\n            if (bal == 0) {\n                ans.add(new String(buf));\n                buf = new StringBuilder();\n            }\n        }\n        if (buf.length() > 0)\n            ans.add(new String(buf));\n        return ans;\n    }\n}\n"]}
{"number": 737, "statement": "Given two sentences words1, words2 (each represented as an array of strings), and a list of similar word pairs pairs, determine if two sentences are similar.\nFor example, words1 = [\"great\", \"acting\", \"skills\"] and words2 = [\"fine\", \"drama\", \"talent\"] are similar, if the similar word pairs are pairs = [[\"great\", \"good\"], [\"fine\", \"good\"], [\"acting\",\"drama\"], [\"skills\",\"talent\"]].\nNote that the similarity relation is transitive. For example, if \"great\" and \"good\" are similar, and \"fine\" and \"good\" are similar, then \"great\" and \"fine\" are similar.\nSimilarity is also symmetric. For example, \"great\" and \"fine\" being similar is the same as \"fine\" and \"great\" being similar.\nAlso, a word is always similar with itself. For example, the sentences words1 = [\"great\"], words2 = [\"great\"], pairs = [] are similar, even though there are no specified similar word pairs.\nFinally, sentences can only be similar if they have the same number of words. So a sentence like words1 = [\"great\"] can never be similar to words2 = [\"doubleplus\",\"good\"].\nNote:\nThe length of words1 and words2 will not exceed 1000.\nThe length of pairs will not exceed 2000.\nThe length of each pairs[i] will be 2.\nThe length of each words[i] and pairs[i][j] will be in the range [1, 20].\n", "solutions": ["class Solution {\n    public boolean areSentencesSimilarTwo(\n            String[] words1, String[] words2, String[][] pairs) {\n        if (words1.length != words2.length) return false;\n        Map<String, List<String>> graph = new HashMap();\n        for (String[] pair: pairs) {\n            for (String p: pair) if (!graph.containsKey(p)) {\n                graph.put(p, new ArrayList());\n            }\n            graph.get(pair[0]).add(pair[1]);\n            graph.get(pair[1]).add(pair[0]);\n        }\n        for (int i = 0; i < words1.length; ++i) {\n            String w1 = words1[i], w2 = words2[i];\n            Stack<String> stack = new Stack();\n            Set<String> seen = new HashSet();\n            stack.push(w1);\n            seen.add(w1);\n            search: {\n                while (!stack.isEmpty()) {\n                    String word = stack.pop();\n                    if (word.equals(w2)) break search;\n                    if (graph.containsKey(word)) {\n                        for (String nei: graph.get(word)) {\n                            if (!seen.contains(nei)) {\n                                stack.push(nei);\n                                seen.add(nei);\n                            }\n                        }\n                    }\n                }\n                return false;\n            }\n        }\n        return true;\n    }\n}\n", "class Solution {\n    public boolean areSentencesSimilarTwo(String[] words1, String[] words2, String[][] pairs) {\n        if (words1.length != words2.length) return false;\n        Map<String, Integer> index = new HashMap();\n        int count = 0;\n        DSU dsu = new DSU(2 * pairs.length);\n        for (String[] pair: pairs) {\n            for (String p: pair) if (!index.containsKey(p)) {\n                index.put(p, count++);\n            }\n            dsu.union(index.get(pair[0]), index.get(pair[1]));\n        }\n        for (int i = 0; i < words1.length; ++i) {\n            String w1 = words1[i], w2 = words2[i];\n            if (w1.equals(w2)) continue;\n            if (!index.containsKey(w1) || !index.containsKey(w2) ||\n                    dsu.find(index.get(w1)) != dsu.find(index.get(w2)))\n                return false;\n        }\n        return true;\n    }\n}\nclass DSU {\n    int[] parent;\n    public DSU(int N) {\n        parent = new int[N];\n        for (int i = 0; i < N; ++i)\n            parent[i] = i;\n    }\n    public int find(int x) {\n        if (parent[x] != x) parent[x] = find(parent[x]);\n        return parent[x];\n    }\n    public void union(int x, int y) {\n        parent[find(x)] = find(y);\n    }\n}\n"]}
{"number": 738, "statement": "Given a non-negative integer N, find the largest number that is less than or equal to N with monotone increasing digits.\n(Recall that an integer has monotone increasing digits if and only if each pair of adjacent digits x and y satisfy x = y.)\n", "solutions": ["class Solution {\n    public int monotoneIncreasingDigits(int N) {\n        String S = String.valueOf(N);\n        String ans = \"\";\n        search: for (int i = 0; i < S.length(); ++i) {\n            for (char d = '1'; d <= '9'; ++d) {\n                if (S.compareTo(ans + repeat(d, S.length() - i)) < 0) {\n                    ans += (char) (d - 1);\n                    continue search;\n                }\n            }\n            ans += '9';\n        }\n        return Integer.parseInt(ans);\n    }\n    public String repeat(char c, int count) {\n        StringBuilder sb = new StringBuilder(count);\n        for (int i = 0; i < count; ++i) sb.append(c);\n        return sb.toString();\n    }\n}\n", "class Solution {\n    public int monotoneIncreasingDigits(int N) {\n        char[] S = String.valueOf(N).toCharArray();\n        int i = 1;\n        while (i < S.length && S[i-1] <= S[i]) i++;\n        while (0 < i && i < S.length && S[i-1] > S[i]) S[--i]--;\n        for (int j = i+1; j < S.length; ++j) S[j] = '9';\n        return Integer.parseInt(String.valueOf(S));\n    }\n}\n"]}
{"number": 739, "statement": "Given a list of daily temperatures T, return a list such that, for each day in the input, tells you how many days you would have to wait until a warmer temperature.  If there is no future day for which this is possible, put 0 instead.\nFor example, given the list of temperatures T = [73, 74, 75, 71, 69, 72, 76, 73], your output should be [1, 1, 4, 2, 1, 1, 0, 0].\nNote:\nThe length of temperatures will be in the range [1, 30000].\nEach temperature will be an integer in the range [30, 100].\n", "solutions": ["class Solution {\n    public int[] dailyTemperatures(int[] T) {\n        int[] ans = new int[T.length];\n        int[] next = new int[101];\n        Arrays.fill(next, Integer.MAX_VALUE);\n        for (int i = T.length - 1; i >= 0; --i) {\n            int warmer_index = Integer.MAX_VALUE;\n            for (int t = T[i] + 1; t <= 100; ++t) {\n                if (next[t] < warmer_index)\n                    warmer_index = next[t];\n            }\n            if (warmer_index < Integer.MAX_VALUE)\n                ans[i] = warmer_index - i;\n            next[T[i]] = i;\n        }\n        return ans;\n    }\n}\n", "class Solution {\n    public int[] dailyTemperatures(int[] T) {\n        int[] ans = new int[T.length];\n        Stack<Integer> stack = new Stack();\n        for (int i = T.length - 1; i >= 0; --i) {\n            while (!stack.isEmpty() && T[i] >= T[stack.peek()]) stack.pop();\n            ans[i] = stack.isEmpty() ? 0 : stack.peek() - i;\n            stack.push(i);\n        }\n        return ans;\n    }\n}\n"]}
{"number": 740, "statement": "Given an array nums of integers, you can perform operations on the array.\nIn each operation, you pick any nums[i] and delete it to earn nums[i] points. After, you must delete every element equal to nums[i] - 1 or nums[i] + 1.\nYou start with 0 points. Return the maximum number of points you can earn by applying such operations.\n", "solutions": ["class Solution {\n    public int deleteAndEarn(int[] nums) {\n        int[] count = new int[10001];\n        for (int x: nums) count[x]++;\n        int avoid = 0, using = 0, prev = -1;\n        for (int k = 0; k <= 10000; ++k) if (count[k] > 0) {\n            int m = Math.max(avoid, using);\n            if (k - 1 != prev) {\n                using = k * count[k] + m;\n                avoid = m;\n            } else {\n                using = k * count[k] + avoid;\n                avoid = m;\n            }\n            prev = k;\n        }\n        return Math.max(avoid, using);\n    }\n}\n"]}
{"number": 741, "statement": "In a N x N grid representing a field of cherries, each cell is one of three possible integers.\n0 means the cell is empty, so you can pass through;\n1 means the cell contains a cherry, that you can pick up and pass through;\n-1 means the cell contains a thorn that blocks your way.\nYour task is to collect maximum number of cherries possible by following the rules below:\nStarting at the position (0, 0) and reaching (N-1, N-1) by moving right or down through valid path cells (cells with value 0 or 1);\nAfter reaching (N-1, N-1), returning to (0, 0) by moving left or up through valid path cells;\nWhen passing through a path cell containing a cherry, you pick it up and the cell becomes an empty cell (0);\nIf there is no valid path between (0, 0) and (N-1, N-1), then no cherries can be collected.\n", "solutions": ["class Solution {\n    public int cherryPickup(int[][] grid) {\n        int ans = 0;\n        int[][] path = bestPath(grid);\n        if (path == null) return 0;\n        for (int[] step: path) {\n            ans += grid[step[0]][step[1]];\n            grid[step[0]][step[1]] = 0;\n        }\n        for (int[] step: bestPath(grid))\n            ans += grid[step[0]][step[1]];\n        return ans;\n    }\n    public int[][] bestPath(int[][] grid) {\n        int N = grid.length;\n        int[][] dp = new int[N][N];\n        for (int[] row: dp) Arrays.fill(row, Integer.MIN_VALUE);\n        dp[N-1][N-1] = grid[N-1][N-1];\n        for (int i = N-1; i >= 0; --i) {\n            for (int j = N-1; j >= 0; --j) {\n                if (grid[i][j] >= 0 && (i != N-1 || j != N-1)) {\n                    dp[i][j] = Math.max(i+1 < N ? dp[i+1][j] : Integer.MIN_VALUE,\n                                        j+1 < N ? dp[i][j+1] : Integer.MIN_VALUE);\n                    dp[i][j] += grid[i][j];\n                }\n            }\n        }\n        if (dp[0][0] < 0) return null;\n        int[][] ans = new int[2*N - 1][2];\n        int i = 0, j = 0, t = 0;\n        while (i != N-1 || j != N-1) {\n            if (j+1 == N || i+1 < N && dp[i+1][j] >= dp[i][j+1]) i++;\n            else j++;\n            ans[t][0] = i;\n            ans[t][1] = j;\n            t++;\n        }\n        return ans;\n    }\n}\n", "class Solution {\n    int[][][] memo;\n    int[][] grid;\n    int N;\n    public int cherryPickup(int[][] grid) {\n        this.grid = grid;\n        N = grid.length;\n        memo = new int[N][N][N];\n        for (int[][] layer: memo)\n            for (int[] row: layer)\n                Arrays.fill(row, Integer.MIN_VALUE);\n        return Math.max(0, dp(0, 0, 0));\n    }\n    public int dp(int r1, int c1, int c2) {\n        int r2 = r1 + c1 - c2;\n        if (N == r1 || N == r2 || N == c1 || N == c2 ||\n                grid[r1][c1] == -1 || grid[r2][c2] == -1) {\n            return -999999;        \n        } else if (r1 == N-1 && c1 == N-1) {\n            return grid[r1][c1];\n        } else if (memo[r1][c1][c2] != Integer.MIN_VALUE) {\n            return memo[r1][c1][c2];\n        } else {\n            int ans = grid[r1][c1];\n            if (c1 != c2) ans += grid[r2][c2];\n            ans += Math.max(Math.max(dp(r1, c1+1, c2+1), dp(r1+1, c1, c2+1)),\n                            Math.max(dp(r1, c1+1, c2), dp(r1+1, c1, c2)));\n            memo[r1][c1][c2] = ans;\n            return ans;\n        }\n    }\n}\n", "class Solution {\n    public int cherryPickup(int[][] grid) {\n        int N = grid.length;\n        int[][] dp = new int[N][N];\n        for (int[] row: dp) Arrays.fill(row, Integer.MIN_VALUE);\n        dp[0][0] = grid[0][0];\n        for (int t = 1; t <= 2*N - 2; ++t) {\n            int[][] dp2 = new int[N][N];\n            for (int[] row: dp2) Arrays.fill(row, Integer.MIN_VALUE);\n            for (int i = Math.max(0, t-(N-1)); i <= Math.min(N-1, t); ++i) {\n                for (int j = Math.max(0, t-(N-1)); j <= Math.min(N-1, t); ++j) {\n                    if (grid[i][t-i] == -1 || grid[j][t-j] == -1) continue;\n                    int val = grid[i][t-i];\n                    if (i != j) val += grid[j][t-j];\n                    for (int pi = i-1; pi <= i; ++pi)\n                        for (int pj = j-1; pj <= j; ++pj)\n                            if (pi >= 0 && pj >= 0)\n                                dp2[i][j] = Math.max(dp2[i][j], dp[pi][pj] + val);\n                }\n            }\n            dp = dp2;\n        }\n        return Math.max(0, dp[N-1][N-1]);\n    }\n}\n"]}
{"number": 742, "statement": "Given a binary tree where every node has a unique value, and a target key k, find the value of the nearest leaf node to target k in the tree.\nHere, nearest to a leaf means the least number of edges travelled on the binary tree to reach any leaf of the tree.  Also, a node is called a leaf if it has no children.\nIn the following examples, the input tree is represented in flattened form row by row.\nThe actual root tree given will be a TreeNode object.\n", "solutions": ["class Solution {\n    public int findClosestLeaf(TreeNode root, int k) {\n        Map<TreeNode, List<TreeNode>> graph = new HashMap();\n        dfs(graph, root, null);\n        Queue<TreeNode> queue = new LinkedList();\n        Set<TreeNode> seen = new HashSet();\n        for (TreeNode node: graph.keySet()) {\n            if (node != null && node.val == k) {\n                queue.add(node);\n                seen.add(node);\n            }\n        }\n        while (!queue.isEmpty()) {\n            TreeNode node = queue.poll();\n            if (node != null) {\n                if (graph.get(node).size() <= 1)\n                    return node.val;\n                for (TreeNode nei: graph.get(node)) {\n                    if (!seen.contains(nei)) {\n                        seen.add(nei);\n                        queue.add(nei);\n                    }\n                }\n            }\n        }\n        throw null;\n    }\n    public void dfs(Map<TreeNode, List<TreeNode>> graph, TreeNode node, TreeNode parent) {\n        if (node != null) {\n            if (!graph.containsKey(node)) graph.put(node, new LinkedList<TreeNode>());\n            if (!graph.containsKey(parent)) graph.put(parent, new LinkedList<TreeNode>());\n            graph.get(node).add(parent);\n            graph.get(parent).add(node);\n            dfs(graph, node.left, node);\n            dfs(graph, node.right, node);\n        }\n    }\n}\n", "class Solution {\n    List<TreeNode> path;\n    Map<TreeNode, LeafResult> annotation;\n    public int findClosestLeaf(TreeNode root, int k) {\n        path = new ArrayList();\n        annotation = new HashMap();\n        dfs(root, k);\n        int distanceFromTarget = path.size() - 1;\n        int dist = Integer.MAX_VALUE;\n        TreeNode leaf = null;\n        for (TreeNode node: path) {\n            LeafResult lr = closestLeaf(node);\n            if (lr.dist + distanceFromTarget < dist) {\n                dist = lr.dist + distanceFromTarget;\n                leaf = lr.node;\n            }\n            distanceFromTarget--;\n        }\n        return leaf.val;\n    }\n    public boolean dfs(TreeNode node, int k) {\n        if (node == null) {\n            return false;\n        } else if (node.val == k) {\n            path.add(node);\n            return true;\n        } else {\n            path.add(node);\n            boolean ans = dfs(node.left, k);\n            if (ans) return true;\n            ans = dfs(node.right, k);\n            if (ans) return true;\n            path.remove(path.size() - 1);\n            return false;\n        }\n    }\n    public LeafResult closestLeaf(TreeNode root) {\n        if (root == null) {\n            return new LeafResult(null, Integer.MAX_VALUE);\n        } else if (root.left == null && root.right == null) {\n            return new LeafResult(root, 0);\n        } else if (annotation.containsKey(root)) {\n            return annotation.get(root);\n        } else {\n            LeafResult r1 = closestLeaf(root.left);\n            LeafResult r2 = closestLeaf(root.right);\n            LeafResult ans = new LeafResult(r1.dist < r2.dist ? r1.node : r2.node,\n                                            Math.min(r1.dist, r2.dist) + 1);\n            annotation.put(root, ans);\n            return ans;\n        }\n    }\n}\nclass LeafResult {\n    TreeNode node;\n    int dist;\n    LeafResult(TreeNode n, int d) {\n        node = n;\n        dist = d;\n    }\n}\n"]}
{"number": 743, "statement": "There are N network nodes, labelled 1 to N.\nGiven times, a list of travel times as directed edges times[i] = (u, v, w), where u is the source node, v is the target node, and w is the time it takes for a signal to travel from source to target.\nNow, we send a signal from a certain node K. How long will it take for all nodes to receive the signal? If it is impossible, return -1.\n", "solutions": ["class Solution {\n    Map<Integer, Integer> dist;\n    public int networkDelayTime(int[][] times, int N, int K) {\n        Map<Integer, List<int[]>> graph = new HashMap();\n        for (int[] edge: times) {\n            if (!graph.containsKey(edge[0]))\n                graph.put(edge[0], new ArrayList<int[]>());\n            graph.get(edge[0]).add(new int[]{edge[2], edge[1]});\n        }\n        for (int node: graph.keySet()) {\n            Collections.sort(graph.get(node), (a, b) -> a[0] - b[0]);\n        }\n        dist = new HashMap();\n        for (int node = 1; node <= N; ++node)\n            dist.put(node, Integer.MAX_VALUE);\n        dfs(graph, K, 0);\n        int ans = 0;\n        for (int cand: dist.values()) {\n            if (cand == Integer.MAX_VALUE) return -1;\n            ans = Math.max(ans, cand);\n        }\n        return ans;\n    }\n    public void dfs(Map<Integer, List<int[]>> graph, int node, int elapsed) {\n        if (elapsed >= dist.get(node)) return;\n        dist.put(node, elapsed);\n        if (graph.containsKey(node))\n            for (int[] info: graph.get(node))\n                dfs(graph, info[1], elapsed + info[0]);\n    }\n}\n", "class Solution {\n    Map<Integer, Integer> dist;\n    public int networkDelayTime(int[][] times, int N, int K) {\n        Map<Integer, List<int[]>> graph = new HashMap();\n        for (int[] edge: times) {\n            if (!graph.containsKey(edge[0]))\n                graph.put(edge[0], new ArrayList<int[]>());\n            graph.get(edge[0]).add(new int[]{edge[1], edge[2]});\n        }\n        dist = new HashMap();\n        for (int node = 1; node <= N; ++node)\n            dist.put(node, Integer.MAX_VALUE);\n        dist.put(K, 0);\n        boolean[] seen = new boolean[N+1];\n        while (true) {\n            int candNode = -1;\n            int candDist = Integer.MAX_VALUE;\n            for (int i = 1; i <= N; ++i) {\n                if (!seen[i] && dist.get(i) < candDist) {\n                    candDist = dist.get(i);\n                    candNode = i;\n                }\n            }\n            if (candNode < 0) break;\n            seen[candNode] = true;\n            if (graph.containsKey(candNode))\n                for (int[] info: graph.get(candNode))\n                    dist.put(info[0],\n                             Math.min(dist.get(info[0]), dist.get(candNode) + info[1]));\n        }\n        int ans = 0;\n        for (int cand: dist.values()) {\n            if (cand == Integer.MAX_VALUE) return -1;\n            ans = Math.max(ans, cand);\n        }\n        return ans;\n    }\n}\n", "class Solution {\n    public int networkDelayTime(int[][] times, int N, int K) {\n        Map<Integer, List<int[]>> graph = new HashMap();\n        for (int[] edge: times) {\n            if (!graph.containsKey(edge[0]))\n                graph.put(edge[0], new ArrayList<int[]>());\n            graph.get(edge[0]).add(new int[]{edge[1], edge[2]});\n        }\n        PriorityQueue<int[]> heap = new PriorityQueue<int[]>(\n                (info1, info2) -> info1[0] - info2[0]);\n        heap.offer(new int[]{0, K});\n        Map<Integer, Integer> dist = new HashMap();\n        while (!heap.isEmpty()) {\n            int[] info = heap.poll();\n            int d = info[0], node = info[1];\n            if (dist.containsKey(node)) continue;\n            dist.put(node, d);\n            if (graph.containsKey(node))\n                for (int[] edge: graph.get(node)) {\n                    int nei = edge[0], d2 = edge[1];\n                    if (!dist.containsKey(nei))\n                        heap.offer(new int[]{d+d2, nei});\n                }\n        }\n        if (dist.size() != N) return -1;\n        int ans = 0;\n        for (int cand: dist.values())\n            ans = Math.max(ans, cand);\n        return ans;\n    }\n}\n"]}
{"number": 744, "statement": "Given a list of sorted characters letters containing only lowercase letters, and given a target letter target, find the smallest element in the list that is larger than the given target.\nLetters also wrap around.  For example, if the target is target = 'z' and letters = ['a', 'b'], the answer is 'a'.\n", "solutions": ["class Solution {\n    public char nextGreatestLetter(char[] letters, char target) {\n        boolean[] seen = new boolean[26];\n        for (char c: letters)\n            seen[c - 'a'] = true;\n        while (true) {\n            target++;\n            if (target > 'z') target = 'a';\n            if (seen[target - 'a']) return target;\n        }\n    }\n}\n", "class Solution {\n    public char nextGreatestLetter(char[] letters, char target) {\n        for (char c: letters)\n            if (c > target) return c;\n        return letters[0];\n    }\n}\n", "class Solution {\n    public char nextGreatestLetter(char[] letters, char target) {\n        int lo = 0, hi = letters.length;\n        while (lo < hi) {\n            int mi = lo + (hi - lo) / 2;\n            if (letters[mi] <= target) lo = mi + 1;\n            else hi = mi;\n        }\n        return letters[lo % letters.length];\n    }\n}\n"]}
{"number": 745, "statement": "Given many words, words[i] has weight i.\nDesign a class WordFilter that supports one function, WordFilter.f(String prefix, String suffix). It will return the word with given prefix and suffix with maximum weight. If no word exists, return -1.\n", "solutions": ["class WordFilter {\n    TrieNode trie1, trie2;\n    public WordFilter(String[] words) {\n        trie1 = new TrieNode();\n        trie2 = new TrieNode();\n        int wt = 0;\n        for (String word: words) {\n            char[] ca = word.toCharArray();\n            TrieNode cur = trie1;\n            cur.weight.add(wt);\n            for (char letter: ca) {\n                if (cur.children[letter - 'a'] == null)\n                    cur.children[letter - 'a'] = new TrieNode();\n                cur = cur.children[letter - 'a'];\n                cur.weight.add(wt);\n            }\n            cur = trie2;\n            cur.weight.add(wt);\n            for (int j = ca.length - 1; j >= 0; --j) {\n                char letter = ca[j];\n                if (cur.children[letter - 'a'] == null)\n                    cur.children[letter - 'a'] = new TrieNode();\n                cur = cur.children[letter - 'a'];\n                cur.weight.add(wt);\n            }\n            wt++;\n        }\n    }\n    public int f(String prefix, String suffix) {\n        TrieNode cur1 = trie1, cur2 = trie2;\n        for (char letter: prefix.toCharArray()) {\n            if (cur1.children[letter - 'a'] == null) return -1;\n            cur1 = cur1.children[letter - 'a'];\n        }\n        char[] ca = suffix.toCharArray();\n        for (int j = ca.length - 1; j >= 0; --j) {\n            char letter = ca[j];\n            if (cur2.children[letter - 'a'] == null) return -1;\n            cur2 = cur2.children[letter - 'a'];\n        }\n        int ans = -1;\n        for (int w1: cur1.weight)\n            if (w1 > ans && cur2.weight.contains(w1))\n                ans = w1;\n        return ans;\n    }\n}\nclass TrieNode {\n    TrieNode[] children;\n    Set<Integer> weight;\n    public TrieNode() {\n        children = new TrieNode[26];\n        weight = new HashSet();\n    }\n}\n", "class WordFilter {\n    TrieNode trie;\n    public WordFilter(String[] words) {\n        trie = new TrieNode();\n        int wt = 0;\n        for (String word: words) {\n            TrieNode cur = trie;\n            cur.weight = wt;\n            int L = word.length();\n            char[] chars = word.toCharArray();\n            for (int i = 0; i < L; ++i) {\n                TrieNode tmp = cur;\n                for (int j = i; j < L; ++j) {\n                    int code = (chars[j] - '`') * 27;\n                    if (tmp.children.get(code) == null)\n                        tmp.children.put(code, new TrieNode());\n                    tmp = tmp.children.get(code);\n                    tmp.weight = wt;\n                }\n                tmp = cur;\n                for (int k = L - 1 - i; k >= 0; --k) {\n                    int code = (chars[k] - '`');\n                    if (tmp.children.get(code) == null)\n                        tmp.children.put(code, new TrieNode());\n                    tmp = tmp.children.get(code);\n                    tmp.weight = wt;\n                }\n                int code = (chars[i] - '`') * 27 + (chars[L - 1 - i] - '`');\n                if (cur.children.get(code) == null)\n                    cur.children.put(code, new TrieNode());\n                cur = cur.children.get(code);\n                cur.weight = wt;\n            }\n            wt++;\n        }\n    }\n    public int f(String prefix, String suffix) {\n        TrieNode cur = trie;\n        int i = 0, j = suffix.length() - 1;\n        while (i < prefix.length() || j >= 0) {\n            char c1 = i < prefix.length() ? prefix.charAt(i) : '`';\n            char c2 = j >= 0 ? suffix.charAt(j) : '`';\n            int code = (c1 - '`') * 27 + (c2 - '`');\n            cur = cur.children.get(code);\n            if (cur == null) return -1;\n            i++; j--;\n        }\n        return cur.weight;\n    }\n}\nclass TrieNode {\n    Map<Integer, TrieNode> children;\n    int weight;\n    public TrieNode() {\n        children = new HashMap();\n        weight = 0;\n    }\n}\n", "class WordFilter {\n    TrieNode trie;\n    public WordFilter(String[] words) {\n        trie = new TrieNode();\n        for (int weight = 0; weight < words.length; ++weight) {\n            String word = words[weight] + \"{\";\n            for (int i = 0; i < word.length(); ++i) {\n                TrieNode cur = trie;\n                cur.weight = weight;\n                for (int j = i; j < 2 * word.length() - 1; ++j) {\n                    int k = word.charAt(j % word.length()) - 'a';\n                    if (cur.children[k] == null)\n                        cur.children[k] = new TrieNode();\n                    cur = cur.children[k];\n                    cur.weight = weight;\n                }\n            }\n        }\n    }\n    public int f(String prefix, String suffix) {\n        TrieNode cur = trie;\n        for (char letter: (suffix + '{' + prefix).toCharArray()) {\n            if (cur.children[letter - 'a'] == null) return -1;\n            cur = cur.children[letter - 'a'];\n        }\n        return cur.weight;\n    }\n}\nclass TrieNode {\n    TrieNode[] children;\n    int weight;\n    public TrieNode() {\n        children = new TrieNode[27];\n        weight = 0;\n    }\n}\n"]}
{"number": 746, "statement": "On a staircase, the i-th step has some non-negative cost cost[i] assigned (0 indexed).\nOnce you pay the cost, you can either climb one or two steps. You need to find minimum cost to reach the top of the floor, and you can either start from the step with index 0, or the step with index 1.\n", "solutions": ["class Solution {\n    public int minCostClimbingStairs(int[] cost) {\n        int f1 = 0, f2 = 0;\n        for (int i = cost.length - 1; i >= 0; --i) {\n            int f0 = cost[i] + Math.min(f1, f2);\n            f2 = f1;\n            f1 = f0;\n        }\n        return Math.min(f1, f2);\n    }\n}\n"]}
{"number": 747, "statement": "In a given integer array nums, there is always exactly one largest element.\nFind whether the largest element in the array is at least twice as much as every other number in the array.\nIf it is, return the index of the largest element, otherwise return -1.\n", "solutions": ["class Solution {\n    public int dominantIndex(int[] nums) {\n        int maxIndex = 0;\n        for (int i = 0; i < nums.length; ++i) {\n            if (nums[i] > nums[maxIndex])\n                maxIndex = i;\n        }\n        for (int i = 0; i < nums.length; ++i) {\n            if (maxIndex != i && nums[maxIndex] < 2 * nums[i])\n                return -1;\n        }\n        return maxIndex;\n    }\n}\n"]}
{"number": 748, "statement": "Find the minimum length word from a given dictionary words, which has all the letters from the string licensePlate.  Such a word is said to complete the given string licensePlate\nHere, for letters we ignore case.  For example, \"P\" on the licensePlate still matches \"p\" on the word.\nIt is guaranteed an answer exists.  If there are multiple answers, return the one that occurs first in the array.\nThe license plate might have the same letter occurring multiple times.  For example, given a licensePlate of \"PP\", the word \"pair\" does not complete the licensePlate, but the word \"supper\" does.\n", "solutions": ["class Solution {\n    public String shortestCompletingWord(String licensePlate, String[] words) {\n        int[] target = count(licensePlate);\n        String ans = \"\";\n        for (String word: words)\n            if ((word.length() < ans.length() || ans.length() == 0) &&\n                    dominates(count(word.toLowerCase()), target))\n                ans = word;\n        return ans;\n    }\n    public boolean dominates(int[] count1, int[] count2) {\n        for (int i = 0; i < 26; ++i)\n            if (count1[i] < count2[i])\n                return false;\n        return true;\n    }\n    public int[] count(String word) {\n        int[] ans = new int[26];\n        for (char letter: word.toCharArray()){\n            int index = Character.toLowerCase(letter) - 'a';\n            if (0 <= index && index < 26)\n                ans[index]++;\n        }\n        return ans;\n    }\n}\n"]}
{"number": 749, "statement": "A virus is spreading rapidly, and your task is to quarantine the infected area by installing walls.\nThe world is modeled as a 2-D array of cells, where 0 represents uninfected cells, and 1 represents cells contaminated with the virus.  A wall (and only one wall) can be installed between any two 4-directionally adjacent cells, on the shared boundary.\nEvery night, the virus spreads to all neighboring cells in all four directions unless blocked by a wall.\nResources are limited. Each day, you can install walls around only one region -- the affected area (continuous block of infected cells) that threatens the most uninfected cells the following night. There will never be a tie.\nCan you save the day? If so, what is the number of walls required? If not, and the world becomes fully infected, return the number of walls used.\n", "solutions": ["class Solution {\n    Set<Integer> seen;\n    List<Set<Integer>> regions;\n    List<Set<Integer>> frontiers;\n    List<Integer> perimeters;\n    int[][] grid;\n    int R, C;\n    int[] dr = new int[]{-1, 1, 0, 0};\n    int[] dc = new int[]{0, 0, -1, 1};\n    public int containVirus(int[][] grid) {\n        this.grid = grid;\n        R = grid.length;\n        C = grid[0].length;\n        int ans = 0;\n        while (true) {\n            seen = new HashSet();\n            regions = new ArrayList();\n            frontiers = new ArrayList();\n            perimeters = new ArrayList();\n            for (int r = 0; r < R; ++r) {\n                for (int c = 0; c < C; ++c) {\n                    if (grid[r][c] == 1 && !seen.contains(r*C + c)) {\n                        regions.add(new HashSet());\n                        frontiers.add(new HashSet());\n                        perimeters.add(0);\n                        dfs(r, c);\n                    }\n                }\n            }\n            if (regions.isEmpty()) break;\n            int triageIndex = 0;\n            for (int i = 0; i < frontiers.size(); ++i) {\n                if (frontiers.get(triageIndex).size() < frontiers.get(i).size())\n                    triageIndex = i;\n            }\n            ans += perimeters.get(triageIndex);\n            for (int i = 0; i < regions.size(); ++i) {\n                if (i == triageIndex) {\n                    for (int code: regions.get(i))\n                        grid[code / C][code % C] = -1;\n                } else {\n                    for (int code: regions.get(i)) {\n                        int r = code / C, c = code % C;\n                        for (int k = 0; k < 4; ++k) {\n                            int nr = r + dr[k], nc = c + dc[k];\n                            if (nr >= 0 && nr < R && nc >= 0 && nc < C && grid[nr][nc] == 0)\n                                grid[nr][nc] = 1;\n                        }\n                    }\n                }\n            }\n        }\n        return ans;\n    }\n    public void dfs(int r, int c) {\n        if (!seen.contains(r*C + c)) {\n            seen.add(r*C + c);\n            int N = regions.size()\n            regions.get(N - 1).add(r*C + c);\n            for (int k = 0; k < 4; ++k) {\n                int nr = r + dr[k], nc = c + dc[k];\n                if (nr >= 0 && nr < R && nc >= 0 && nc < C) {\n                    if (grid[nr][nc] == 1) {\n                        dfs(nr, nc);\n                    } else if (grid[nr][nc] == 0){\n                        frontiers.get(N - 1).add(nr*C + nc);\n                        perimeters.set(N - 1, perimeters.get(N - 1) + 1);\n                    }\n                }\n            }\n        }\n    }\n}\n"]}
{"number": 750, "statement": "Given a grid where each entry is only 0 or 1, find the number of corner rectangles.\nA corner rectangle is 4 distinct 1s on the grid that form an axis-aligned rectangle. Note that only the corners need to have the value 1. Also, all four 1s used must be distinct.\n", "solutions": ["class Solution {\n    public int countCornerRectangles(int[][] grid) {\n        Map<Integer, Integer> count = new HashMap();\n        int ans = 0;\n        for (int[] row: grid) {\n            for (int c1 = 0; c1 < row.length; ++c1) if (row[c1] == 1) {\n                for (int c2 = c1+1; c2 < row.length; ++c2) if (row[c2] == 1) {\n                    int pos = c1 * 200 + c2;\n                    int c = count.getOrDefault(pos, 0);\n                    ans += c;\n                    count.put(pos, c+1);\n                }\n            }\n        }\n        return ans;\n    }\n}\n", "class Solution {\n    public int countCornerRectangles(int[][] grid) {\n        List<List<Integer>> rows = new ArrayList();\n        int N = 0;\n        for (int r = 0; r < grid.length; ++r) {\n            rows.add(new ArrayList());\n            for (int c = 0; c < grid[r].length; ++c)\n                if (grid[r][c] == 1) {\n                    rows.get(r).add(c);\n                    N++;\n                }\n        }\n        int sqrtN = (int) Math.sqrt(N);\n        int ans = 0;\n        Map<Integer, Integer> count = new HashMap();\n        for (int r = 0; r < grid.length; ++r) {\n            if (rows.get(r).size() >= sqrtN) {\n                Set<Integer> target = new HashSet(rows.get(r));\n                for (int r2 = 0; r2 < grid.length; ++r2) {\n                    if (r2 <= r && rows.get(r2).size() >= sqrtN)\n                        continue;\n                    int found = 0;\n                    for (int c2: rows.get(r2))\n                        if (target.contains(c2))\n                            found++;\n                    ans += found * (found - 1) / 2;\n                }\n            } else {\n                for (int i1 = 0; i1 < rows.get(r).size(); ++i1) {\n                    int c1 = rows.get(r).get(i1);\n                    for (int i2 = i1 + 1; i2 < rows.get(r).size(); ++i2) {\n                        int c2 = rows.get(r).get(i2);\n                        int ct = count.getOrDefault(200*c1 + c2, 0);\n                        ans += ct;\n                        count.put(200*c1 + c2, ct + 1);\n                    }\n                }\n            }\n        }\n        return ans;\n    }\n}\n"]}
{"number": 751, "statement": "Given a start IP address ip and a number of ips we need to cover n, return a representation of the range as a list (of smallest possible length) of CIDR blocks.\nA CIDR block is a string consisting of an IP, followed by a slash, and then the prefix length.  For example: \"123.45.67.89/20\".  That prefix length \"20\" represents the number of common prefix bits in the specified range.\n", "solutions": ["class Solution {\n    public List<String> ipToCIDR(String ip, int n) {\n        long start = ipToLong(ip);\n        List<String> ans = new ArrayList();\n        while (n > 0) {\n            int mask = Math.max(33 - bitLength(Long.lowestOneBit(start)),\n                                33 - bitLength(n));\n            ans.add(longToIP(start) + \"/\" + mask);\n            start += 1 << (32 - mask);\n            n -= 1 << (32 - mask);\n        }\n        return ans;\n    }\n    private long ipToLong(String ip) {\n        long ans = 0;\n        for (String x: ip.split(\"\\\\.\")) {\n            ans = 256 * ans + Integer.valueOf(x);\n        }\n        return ans;\n    }\n    private String longToIP(long x) {\n        return String.format(\"%s.%s.%s.%s\",\n            x >> 24, (x >> 16) % 256, (x >> 8) % 256, x % 256);\n    }\n    private int bitLength(long x) {\n        if (x == 0) return 1;\n        int ans = 0;\n        while (x > 0) {\n            x >>= 1;\n            ans++;\n        }\n        return ans;\n    }\n}\n"]}
{"number": 752, "statement": "You have a lock in front of you with 4 circular wheels.  Each wheel has 10 slots: '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'.  The wheels can rotate freely and wrap around: for example we can turn '9' to be '0', or '0' to be '9'.  Each move consists of turning one wheel one slot.\nThe lock initially starts at '0000', a string representing the state of the 4 wheels.\nYou are given a list of deadends dead ends, meaning if the lock displays any of these codes, the wheels of the lock will stop turning and you will be unable to open it.\nGiven a target representing the value of the wheels that will unlock the lock, return the minimum total number of turns required to open the lock, or -1 if it is impossible.\n", "solutions": ["class Solution {\n    public int openLock(String[] deadends, String target) {\n        Set<String> dead = new HashSet();\n        for (String d: deadends) dead.add(d);\n        Queue<String> queue = new LinkedList();\n        queue.offer(\"0000\");\n        queue.offer(null);\n        Set<String> seen = new HashSet();\n        seen.add(\"0000\");\n        int depth = 0;\n        while (!queue.isEmpty()) {\n            String node = queue.poll();\n            if (node == null) {\n                depth++;\n                if (queue.peek() != null)\n                    queue.offer(null);\n            } else if (node.equals(target)) {\n                return depth;\n            } else if (!dead.contains(node)) {\n                for (int i = 0; i < 4; ++i) {\n                    for (int d = -1; d <= 1; d += 2) {\n                        int y = ((node.charAt(i) - '0') + d + 10) % 10;\n                        String nei = node.substring(0, i) + (\"\" + y) + node.substring(i+1);\n                        if (!seen.contains(nei)) {\n                            seen.add(nei);\n                            queue.offer(nei);\n                        }\n                    }\n                }\n            }\n        }\n        return -1;\n    }\n}\n"]}
{"number": 753, "statement": "There is a box protected by a password. The password is a sequence ofn digitswhere each digit can be one of the first k digits 0, 1, ..., k-1.\nWhile entering a password,the last n digits entered will automatically be matched against the correct password.\nFor example, assuming the correct password is \"345\",if you type \"012345\", the box will open because the correct password matches the suffix of the entered password.\nReturn any password of minimum length that is guaranteed to open the box at some point of entering it.\n", "solutions": ["class Solution {\n    Set<String> seen;\n    StringBuilder ans;\n    public String crackSafe(int n, int k) {\n        if (n == 1 && k == 1) return \"0\";\n        seen = new HashSet();\n        ans = new StringBuilder();\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < n-1; ++i)\n            sb.append(\"0\");\n        String start = sb.toString();\n        dfs(start, k);\n        ans.append(start);\n        return new String(ans);\n    }\n    public void dfs(String node, int k) {\n        for (int x = 0; x < k; ++x) {\n            String nei = node + x;\n            if (!seen.contains(nei)) {\n                seen.add(nei);\n                dfs(nei.substring(1), k);\n                ans.append(x);\n            }\n        }\n    }\n}\n", "class Solution {\n    public String crackSafe(int n, int k) {\n        int M = (int) Math.pow(k, n-1);\n        int[] P = new int[M * k];\n        for (int i = 0; i < k; ++i)\n            for (int q = 0; q < M; ++q)\n                P[i*M + q] = q*k + i;\n        StringBuilder ans = new StringBuilder();\n        for (int i = 0; i < M*k; ++i) {\n            int j = i;\n            while (P[j] >= 0) {\n                ans.append(String.valueOf(j / M));\n                int v = P[j];\n                P[j] = -1;\n                j = v;\n            }\n        }\n        for (int i = 0; i < n-1; ++i)\n            ans.append(\"0\");\n        return new String(ans);\n    }\n}\n"]}
{"number": 754, "statement": "You are standing at position 0 on an infinite number line.  There is a goal at position target.\nOn each move, you can either go left or right.  During the n-th move (starting from 1), you take n steps.\nReturn the minimum number of steps required to reach the destination.\n", "solutions": ["class Solution {\n    public int reachNumber(int target) {\n        target = Math.abs(target);\n        int k = 0;\n        while (target > 0)\n            target -= ++k;\n        return target % 2 == 0 ? k : k + 1 + k%2;\n    }\n}\n"]}
{"number": 755, "statement": "We are given an elevation map, heights[i] representing the height of the terrain at that index.  The width at each index is 1.  After V units of water fall at index K, how much water is at each index?\nWater first drops at index K and rests on top of the highest terrain or water at that index.  Then, it flows according to the following rules:\nIf the droplet would eventually fall by moving left, then move left.\nOtherwise, if the droplet would eventually fall by moving right, then move right.\nOtherwise, rise at it's current position.\nHere, \"eventually fall\" means that the droplet will eventually be at a lower level if it moves in that direction.\nAlso, \"level\" means the height of the terrain plus any water in that column.\nWe can assume there's infinitely high terrain on the two sides out of bounds of the array.  Also, there could not be partial water being spread out evenly on more than 1 grid block - each unit of water has to be in exactly one block.\n", "solutions": ["class Solution {\n    public int[] pourWater(int[] H, int V, int K) {\n        while (V-- > 0) droplet: {\n            for (int d = -1; d <= 1; d += 2) {\n                int i = K, best = K;\n                while (0 <= i+d && i+d < H.length && H[i+d] <= H[i]) {\n                    if (H[i+d] < H[i]) best = i + d;\n                    i += d;\n                }\n                if (H[best] < H[K]) {\n                    H[best]++;\n                    break droplet;\n                }\n            }\n            H[K]++;\n        }\n        return H;\n    }\n}\n"]}
{"number": 756, "statement": "We are stacking blocks to form a pyramid. Each block has a color which is a one letter string.\nWe are allowed to place any color block C on top of two adjacent blocks of colors A and B, if and only if ABC is an allowed triple.\nWe start with a bottom row of bottom, represented as a single string. We also start with a list of allowed triples allowed. Each allowed triple is represented as a string of length 3.\nReturn true if we can build the pyramid all the way to the top, otherwise false.\n", "solutions": ["class Solution {\n    public boolean pyramidTransition(String bottom, List<String> allowed) {\n        int[][] T = new int[1 << 7][1 << 7];\n        for (String triple: allowed) {\n            int u = 1 << (triple.charAt(0) - 'A');\n            int v = 1 << (triple.charAt(1) - 'A');\n            int w = 1 << (triple.charAt(2) - 'A');\n            for (int b1 = 0; b1 < (1 << 7); ++b1) if ((u & b1) > 0)\n                for (int b2 = 0; b2 < (1 << 7); ++b2) if ((v & b2) > 0)\n                    T[b1][b2] |= w;\n        }\n        int[] state = new int[bottom.length()];\n        int t = 0;\n        for (char c: bottom.toCharArray())\n            state[t++] = 1 << (c - 'A');\n        while (t-- > 1)\n            for (int i = 0; i < t; ++i)\n                state[i] = T[state[i]][state[i+1]];\n        return state[0] > 0;\n    }\n}\n", "class Solution {\n    int[][] T;\n    Set<Long> seen;\n    public boolean pyramidTransition(String bottom, List<String> allowed) {\n        T = new int[7][7];\n        for (String a: allowed)\n            T[a.charAt(0) - 'A'][a.charAt(1) - 'A'] |= 1 << (a.charAt(2) - 'A');\n        seen = new HashSet();\n        int N = bottom.length();\n        int[][] A = new int[N][N];\n        int t = 0;\n        for (char c: bottom.toCharArray())\n            A[N-1][t++] = c - 'A';\n        return solve(A, 0, N-1, 0);\n    }\n    //A[i] - the ith row of the pyramid\n    //R - integer representing the current row of the pyramid\n    //N - length of current row we are calculating\n    //i - index of how far in the current row we are calculating\n    //Returns true iff pyramid can be built\n    public boolean solve(int[][] A, long R, int N, int i) {\n        if (N == 1 && i == 1) { // If successfully placed entire pyramid\n            return true;\n        } else if (i == N) {\n            if (seen.contains(R)) return false; // If we've already tried this row, give up\n            seen.add(R); // Add row to cache\n            return solve(A, 0, N-1, 0); // Calculate next row\n        } else {\n            // w's jth bit is true iff block #j could be\n            // a parent of A[N][i] and A[N][i+1]\n            int w = T[A[N][i]][A[N][i+1]];\n            // for each set bit in w...\n            for (int b = 0; b < 7; ++b) if (((w >> b) & 1) != 0) {\n                A[N-1][i] = b; //set parent to be equal to block #b\n                //If rest of pyramid can be built, return true\n                //R represents current row, now with ith bit set to b+1\n                // in base 8.\n                if (solve(A, R * 8 + (b+1), N, i+1)) return true;\n            }\n            return false;\n        }\n    }\n}\n"]}
{"number": 757, "statement": "An integer interval [a, b] (for integers a  b) is a set of all consecutive integers from a to b, including a and b.\nFind the minimum size of a set S such that for every integer interval A in intervals, the intersection of S with A has size at least 2.\n", "solutions": ["class Solution {\n    public int intersectionSizeTwo(int[][] intervals) {\n        Arrays.sort(intervals, (a, b) ->\n                    a[0] != b[0] ? a[0]-b[0] : b[1]-a[1]);\n        int[] todo = new int[intervals.length];\n        Arrays.fill(todo, 2);\n        int ans = 0, t = intervals.length;\n        while (--t >= 0) {\n            int s = intervals[t][0];\n            int e = intervals[t][1];\n            int m = todo[t];\n            for (int p = s; p < s+m; ++p) {\n                for (int i = 0; i <= t; ++i)\n                    if (todo[i] > 0 && p <= intervals[i][1])\n                        todo[i]--;\n                ans++;\n            }\n        }\n        return ans;\n    }\n}\n"]}
{"number": 758, "statement": "Given a set of keywords words and a string S, make all appearances of all keywords in S bold. Any letters between b and /b tags become bold.\nThe returned string should use the least number of tags possible, and of course the tags should form a valid combination.\nFor example, given that words = [\"ab\", \"bc\"] and S = \"aabcd\", we should return \"ababc/bd\". Note that returning \"ababb/bc/bd\" would use more tags, so it is incorrect.\nConstraints:\nwords has length in range [0, 50].\nwords[i] has length in range [1, 10].\nS has length in range [0, 500].\nAll characters in words[i] and S are lowercase letters.\nNote: This question is the same as 616:https://leetcode.com/problems/add-bold-tag-in-string/\n", "solutions": ["class Solution {\n    public String boldWords(String[] words, String S) {\n        int N = S.length();\n        boolean[] mask = new boolean[N];\n        for (int i = 0; i < N; ++i)\n            for (String word: words) search: {\n                for (int k = 0; k < word.length(); ++k)\n                    if (k+i >= S.length() || S.charAt(k+i) != word.charAt(k))\n                        break search;\n                for (int j = i; j < i+word.length(); ++j)\n                    mask[j] = true;\n            }\n        StringBuilder ans = new StringBuilder();\n        int anchor = 0;\n        for (int i = 0; i < N; ++i) {\n            if (mask[i] && (i == 0 || !mask[i-1]))\n                ans.append(\"<b>\");\n            ans.append(S.charAt(i));\n            if (mask[i] && (i == N-1 || !mask[i+1]))\n                ans.append(\"</b>\");\n        }\n        return ans.toString();\n    }\n    public boolean match(String S, int i, int j, String T) {\n        for (int k = i; k < j; ++k)\n            if (k >= S.length() || S.charAt(k) != T.charAt(k-i))\n                return false;\n        return true;\n    }\n}\n"]}
{"number": 759, "statement": "We are given a list schedule of employees, which represents the working time for each employee.\nEach employee has a list of non-overlapping Intervals, and these intervals are in sorted order.\nReturn the list of finite intervals representing common, positive-length free time for all employees, also in sorted order.\n(Even though we are representing Intervals in the form [x, y], the objects inside are Intervals, not lists or arrays. For example, schedule[0][0].start = 1, schedule[0][0].end = 2, and schedule[0][0][0] is not defined). Also, we wouldn't include intervals like [5, 5] in our answer, as they have zero length.\n", "solutions": ["class Solution {\n    public List<Interval> employeeFreeTime(List<List<Interval>> avails) {\n        int OPEN = 0, CLOSE = 1;\n        List<int[]> events = new ArrayList();\n        for (List<Interval> employee: avails)\n            for (Interval iv: employee) {\n                events.add(new int[]{iv.start, OPEN});\n                events.add(new int[]{iv.end, CLOSE});\n            }\n        Collections.sort(events, (a, b) -> a[0] != b[0] ? a[0]-b[0] : a[1]-b[1]);\n        List<Interval> ans = new ArrayList();\n        int prev = -1, bal = 0;\n        for (int[] event: events) {\n            // event[0] = time, event[1] = command\n            if (bal == 0 && prev >= 0)\n                ans.add(new Interval(prev, event[0]));\n            bal += event[1] == OPEN ? 1 : -1;\n            prev = event[0];\n        }\n        return ans;\n    }\n}\n", "class Solution {\n    public List<Interval> employeeFreeTime(List<List<Interval>> avails) {\n        List<Interval> ans = new ArrayList();\n        PriorityQueue<Job> pq = new PriorityQueue<Job>((a, b) ->\n            avails.get(a.eid).get(a.index).start -\n            avails.get(b.eid).get(b.index).start);\n        int ei = 0, anchor = Integer.MAX_VALUE;\n        for (List<Interval> employee: avails) {\n            pq.offer(new Job(ei++, 0));\n            anchor = Math.min(anchor, employee.get(0).start);\n        }\n        while (!pq.isEmpty()) {\n            Job job = pq.poll();\n            Interval iv = avails.get(job.eid).get(job.index);\n            if (anchor < iv.start)\n                ans.add(new Interval(anchor, iv.start));\n            anchor = Math.max(anchor, iv.end);\n            if (++job.index < avails.get(job.eid).size())\n                pq.offer(job);\n        }\n        return ans;\n    }\n}\nclass Job {\n    int eid, index;\n    Job(int e, int i) {\n        eid = e;\n        index = i;\n    }\n}\n"]}
{"number": 760, "statement": "Given two lists Aand B, and B is an anagram of A. B is an anagram of A means B is made by randomizing the order of the elements in A.\nWe want to find an index mapping P, from A to B. A mapping P[i] = j means the ith element in A appears in B at index j.\nThese lists A and B may contain duplicates.  If there are multiple answers, output any of them.\nFor example, given\nA = [12, 28, 46, 32, 50]\nB = [50, 12, 32, 46, 28]\nWe should return\n[1, 4, 3, 2, 0]\nas P[0] = 1 because the 0th element of A appears at B[1],\nand P[1] = 4 because the 1st element of A appears at B[4],\nand so on.\nNote:\nA, B have equal lengths in range [1, 100].\nA[i], B[i] are integers in range [0, 10^5].\n", "solutions": ["class Solution {\n    public int[] anagramMappings(int[] A, int[] B) {\n        Map<Integer, Integer> D = new HashMap();\n        for (int i = 0; i < B.length; ++i)\n            D.put(B[i], i);\n        int[] ans = new int[A.length];\n        int t = 0;\n        for (int x: A)\n            ans[t++] = D.get(x);\n        return ans;\n    }\n}\n"]}
{"number": 761, "statement": "Special binary strings are binary strings with the following two properties:\nThe number of 0's is equal to the number of 1's.\nEvery prefix of the binary string has at least as many 1's as 0's.\nGiven a special string S, a move consists of choosing two consecutive, non-empty, special substrings of S, and swapping them.  (Two strings are consecutive if the last character of the first string is exactly one index before the first character of the second string.)\nAt the end of any number of moves, what is the lexicographically largest resulting string possible?\n", "solutions": ["class Solution {\n    public String makeLargestSpecial(String S) {\n        if (S.length() == 0) return S;\n        int anchor = 0, bal = 0;\n        List<String> mountains = new ArrayList();\n        for (int i = 0; i < S.length(); ++i) {\n            bal += S.charAt(i) == '1' ? 1 : -1;\n            if (bal == 0) {\n                mountains.add(\"1\" + makeLargestSpecial(S.substring(anchor+1, i)) + \"0\");\n                anchor = i+1;\n            }\n        }\n        Collections.sort(mountains, Collections.reverseOrder());\n        StringBuilder ans = new StringBuilder();\n        for (String mtn: mountains)\n            ans.append(mtn);\n        return ans.toString();\n    }\n}\n"]}
{"number": 762, "statement": "Given two integers L and R, find the count of numbers in the range [L, R] (inclusive) having a prime number of set bits in their binary representation.\n(Recall that the number of set bits an integer has is the number of 1s present when written in binary.  For example, 21 written in binary is 10101 which has 3 set bits.  Also, 1 is not a prime.)\n", "solutions": ["class Solution {\n    public int countPrimeSetBits(int L, int R) {\n        int ans = 0;\n        for (int x = L; x <= R; ++x)\n            if (isSmallPrime(Integer.bitCount(x)))\n                ans++;\n        return ans;\n    }\n    public boolean isSmallPrime(int x) {\n        return (x == 2 || x == 3 || x == 5 || x == 7 ||\n                x == 11 || x == 13 || x == 17 || x == 19);\n    }\n}\n"]}
{"number": 763, "statement": "A string S of lowercase letters is given.  We want to partition this string into as many parts as possible so that each letter appears in at most one part, and return a list of integers representing the size of these parts.\n", "solutions": ["class Solution {\n    public List<Integer> partitionLabels(String S) {\n        int[] last = new int[26];\n        for (int i = 0; i < S.length(); ++i)\n            last[S.charAt(i) - 'a'] = i;\n        \n        int j = 0, anchor = 0;\n        List<Integer> ans = new ArrayList();\n        for (int i = 0; i < S.length(); ++i) {\n            j = Math.max(j, last[S.charAt(i) - 'a']);\n            if (i == j) {\n                ans.add(i - anchor + 1);\n                anchor = i + 1;\n            }\n        }\n        return ans;\n    }\n}\n"]}
{"number": 764, "statement": "In a 2D grid from (0, 0) to (N-1, N-1), every cell contains a 1, except those cells in the given list mines which are 0.  What is the largest axis-aligned plus sign of 1s contained in the grid?  Return the order of the plus sign.  If there is none, return 0.\nAn \"axis-aligned plus sign of 1s of order k\" has some center grid[x][y] = 1 along with 4 arms of length k-1 going up, down, left, and right, and made of 1s.  This is demonstrated in the diagrams below.  Note that there could be 0s or 1s beyond the arms of the plus sign, only the relevant area of the plus sign is checked for 1s.\n", "solutions": ["class Solution {\n    public int orderOfLargestPlusSign(int N, int[][] mines) {\n        Set<Integer> banned = new HashSet();\n        for (int[] mine: mines)\n            banned.add(mine[0] * N + mine[1]);\n            \n        int ans = 0;\n        for (int r = 0; r < N; ++r) for (int c = 0; c < N; ++c) {\n            int k = 0;\n            while (k <= r && r < N-k && k <= c && c < N-k &&\n                    !banned.contains((r-k)*N + c) &&\n                    !banned.contains((r+k)*N + c) &&\n                    !banned.contains(r*N + c-k) &&\n                    !banned.contains(r*N + c+k))\n                k++;\n            \n            ans = Math.max(ans, k);\n        }\n        return ans;\n    }\n}\n", "class Solution {\n    public int orderOfLargestPlusSign(int N, int[][] mines) {\n        Set<Integer> banned = new HashSet();\n        int[][] dp = new int[N][N];\n        \n        for (int[] mine: mines)\n            banned.add(mine[0] * N + mine[1]);\n        int ans = 0, count;\n        \n        for (int r = 0; r < N; ++r) {\n            count = 0;\n            for (int c = 0; c < N; ++c) {\n                count = banned.contains(r*N + c) ? 0 : count + 1;\n                dp[r][c] = count;\n            }\n            \n            count = 0;\n            for (int c = N-1; c >= 0; --c) {\n                count = banned.contains(r*N + c) ? 0 : count + 1;\n                dp[r][c] = Math.min(dp[r][c], count);\n            }\n        }\n        \n        for (int c = 0; c < N; ++c) {\n            count = 0;\n            for (int r = 0; r < N; ++r) {\n                count = banned.contains(r*N + c) ? 0 : count + 1;\n                dp[r][c] = Math.min(dp[r][c], count);\n            }\n            \n            count = 0;\n            for (int r = N-1; r >= 0; --r) {\n                count = banned.contains(r*N + c) ? 0 : count + 1;\n                dp[r][c] = Math.min(dp[r][c], count);\n                ans = Math.max(ans, dp[r][c]);\n            }\n        }\n        \n        return ans;\n    }\n}\n"]}
{"number": 765, "statement": "N couples sit in 2N seats arranged in a row and want to hold hands.  We want to know the minimum number of swaps so that every couple is sitting side by side.  A swap consists of choosing any two people, then they stand up and switch seats. \nThe people and seats are represented by an integer from 0 to 2N-1, the couples are numbered in order, the first couple being (0, 1), the second couple being (2, 3), and so on with the last couple being (2N-2, 2N-1).\nThe couples' initial seating is given by row[i] being the value of the person who is initially sitting in the i-th seat.\n", "solutions": ["class Solution {\n    int N;\n    int[][] pairs;\n    public int minSwapsCouples(int[] row) {\n        N = row.length / 2;\n        pairs = new int[N][2];\n        for (int i = 0; i < N; ++i) {\n            pairs[i][0] = row[2*i] / 2;\n            pairs[i][1] = row[2*i+1] / 2;\n        }\n        return solve(0);\n    }\n    public void swap(int a, int b, int c, int d) {\n        int t = pairs[a][b];\n        pairs[a][b] = pairs[c][d];\n        pairs[c][d] = t;\n    }\n    public int solve(int i) {\n        if (i == N) return 0;\n        int x = pairs[i][0], y = pairs[i][1];\n        if (x == y) return solve(i+1);\n        int jx=0, kx=0, jy=0, ky=0; // Always gets set later\n        for (int j = i+1; j < N; ++j) {\n            for (int k = 0; k <= 1; ++k) {\n                if (pairs[j][k] == x) {jx = j; kx = k;}\n                if (pairs[j][k] == y) {jy = j; ky = k;}\n            }\n        }\n        swap(i, 1, jx, kx);\n        int ans1 = 1 + solve(i+1);\n        swap(i, 1, jx, kx);\n        swap(i, 0, jy, ky);\n        int ans2 = 1 + solve(i+1);\n        swap(i, 0, jy, ky);\n        return Math.min(ans1, ans2);\n    }\n}\n", "class Solution {\n    public int minSwapsCouples(int[] row) {\n        int N = row.length / 2;\n        //couples[x] = {i, j} means that\n        //couple #x is at couches i and j (1 indexed)\n        int[][] couples = new int[N][2];\n        for (int i = 0; i < row.length; ++i)\n            add(couples[row[i]/2], i/2 + 1);\n        //adj[x] = {i, j} means that\n        //x-th couch connected to couches i, j (all 1 indexed) by couples\n        int[][] adj = new int[N+1][2];\n        for (int[] couple: couples) {\n            add(adj[couple[0]], couple[1]);\n            add(adj[couple[1]], couple[0]);\n        }\n        // The answer will be N minus the number of cycles in adj.\n        int ans = N;\n        // For each couch (1 indexed)\n        for (int r = 1; r <= N; ++r) {\n            // If this couch has no people needing to be paired, continue\n            if (adj[r][0] == 0 && adj[r][1] == 0)\n                continue;\n            // Otherwise, there is a cycle starting at couch r.\n            // We will use two pointers x, y with y faster than x by one turn.\n            ans--;\n            int x = r, y = pop(adj[r]);\n            // When y reaches the start 'r', we've reached the end of the cycle.\n            while (y != r) {\n                // We are at some couch with edges going to 'x' and 'new'.\n                // We remove the previous edge, since we came from x.\n                rem(adj[y], x);\n                // We update x, y appropriately: y becomes new and x becomes y.\n                x = y;\n                y = pop(adj[y]);\n            }\n        }\n        return ans;\n    }\n    // Replace the next zero element with x.\n    public void add(int[] pair, int x) {\n        pair[pair[0] == 0 ? 0 : 1] = x;\n    }\n    // Remove x from pair, replacing it with zero.\n    public void rem(int[] pair, int x) {\n        pair[pair[0] == x ? 0 : 1] = 0;\n    }\n    // Remove the next non-zero element from pair, replacing it with zero.\n    public int pop(int[] pair) {\n        int x = pair[0];\n        if (x != 0) {\n            pair[0] = 0;\n        } else {\n            x = pair[1];\n            pair[1] = 0;\n        }\n        return x;\n    }\n}\n", "class Solution {\n    public int minSwapsCouples(int[] row) {\n        int ans = 0;\n        for (int i = 0; i < row.length; i += 2) {\n            int x = row[i];\n            if (row[i+1] == (x ^ 1)) continue;\n            ans++;\n            for (int j = i+1; j < row.length; ++j) {\n                if (row[j] == (x^1)) {\n                    row[j] = row[i+1];\n                    row[i+1] = x^1;\n                    break;\n                }\n            }\n        }\n        return ans;\n    }\n}\n"]}
{"number": 766, "statement": "A matrix is Toeplitz if every diagonal from top-left to bottom-right has the same element.\nNow given an M x N matrix, returnTrueif and only if the matrix is Toeplitz.\n", "solutions": ["class Solution {\n    public boolean isToeplitzMatrix(int[][] matrix) {\n        Map<Integer, Integer> groups = new HashMap();\n        for (int r = 0; r < matrix.length; ++r) {\n            for (int c = 0; c < matrix[0].length; ++c) {\n                if (!groups.containsKey(r-c))\n                    groups.put(r-c, matrix[r][c]);\n                else if (groups.get(r-c) != matrix[r][c])\n                    return False;\n            }\n        }\n        return True;\n    }\n}\n", "class Solution {\n    public boolean isToeplitzMatrix(int[][] matrix) {\n        for (int r = 0; r < matrix.length; ++r)\n            for (int c = 0; c < matrix[0].length; ++c)\n                if (r > 0 && c > 0 && matrix[r-1][c-1] != matrix[r][c])\n                    return false;\n        return true;\n    }\n}\n"]}
{"number": 767, "statement": "Given a string S, check if the letters can be rearranged so that two characters that are adjacent to each other are not the same.\nIf possible, output any possible result. If not possible, return the empty string.\n", "solutions": ["class Solution {\n    public String reorganizeString(String S) {\n        int N = S.length();\n        int[] counts = new int[26];\n        for (char c: S.toCharArray()) counts[c-'a'] += 100;\n        for (int i = 0; i < 26; ++i) counts[i] += i;\n        //Encoded counts[i] = 100*(actual count) + (i)\n        Arrays.sort(counts);\n        char[] ans = new char[N];\n        int t = 1;\n        for (int code: counts) {\n            int ct = code / 100;\n            char ch = (char) ('a' + (code % 100));\n            if (ct > (N+1) / 2) return \"\";\n            for (int i = 0; i < ct; ++i) {\n                if (t >= N) t = 0;\n                ans[t] = ch;\n                t += 2;\n            }\n        }\n        return String.valueOf(ans);\n    }\n}\n", "class Solution {\n    public String reorganizeString(String S) {\n        int N = S.length();\n        int[] count = new int[26];\n        for (char c: S.toCharArray()) count[c-'a']++;\n        PriorityQueue<MultiChar> pq = new PriorityQueue<MultiChar>((a, b) ->\n            a.count == b.count ? a.letter - b.letter : b.count - a.count);\n        for (int i = 0; i < 26; ++i) if (count[i] > 0) {\n            if (count[i] > (N + 1) / 2) return \"\";\n            pq.add(new MultiChar(count[i], (char) ('a' + i)));\n        }\n        StringBuilder ans = new StringBuilder();\n        while (pq.size() >= 2) {\n            MultiChar mc1 = pq.poll();\n            MultiChar mc2 = pq.poll();\n            /*This code turns out to be superfluous, but explains what is happening\n            if (ans.length() == 0 || mc1.letter != ans.charAt(ans.length() - 1)) {\n                ans.append(mc1.letter);\n                ans.append(mc2.letter);\n            } else {\n                ans.append(mc2.letter);\n                ans.append(mc1.letter);\n            }*/\n            ans.append(mc1.letter);\n            ans.append(mc2.letter);\n            if (--mc1.count > 0) pq.add(mc1);\n            if (--mc2.count > 0) pq.add(mc2);\n            }\n        }\n        if (pq.size() > 0) ans.append(pq.poll().letter);\n        return ans.toString();\n    }\n}\nclass MultiChar {\n    int count;\n    char letter;\n    MultiChar(int ct, char ch) {\n        count = ct;\n        letter = ch;\n    }\n}\n"]}
{"number": 768, "statement": "This question is the same as \"Max Chunks to Make Sorted\" except the integers of the given array are not necessarily distinct, the input array could be up to length 2000, and the elements could be up to 10**8.\nGiven an array arr of integers (not necessarily distinct), we split the array into some number of \"chunks\" (partitions), and individually sort each chunk. After concatenating them,the result equals the sorted array.\nWhat is the most number of chunks we could have made?\n", "solutions": ["class Solution {\n    public int maxChunksToSorted(int[] arr) {\n        Map<Integer, Integer> count = new HashMap();\n        int ans = 0, nonzero = 0;\n        int[] expect = arr.clone();\n        Arrays.sort(expect);\n        for (int i = 0; i < arr.length; ++i) {\n            int x = arr[i], y = expect[i];\n            count.put(x, count.getOrDefault(x, 0) + 1);\n            if (count.get(x) == 0) nonzero--;\n            if (count.get(x) == 1) nonzero++;\n            count.put(y, count.getOrDefault(y, 0) - 1);\n            if (count.get(y) == -1) nonzero++;\n            if (count.get(y) == 0) nonzero--;\n            if (nonzero == 0) ans++;\n        }\n        return ans;\n    }\n}\n", "class Solution {\n    public int maxChunksToSorted(int[] arr) {\n        Map<Integer, Integer> count = new HashMap();\n        List<Pair> counted = new ArrayList();\n        for (int x: arr) {\n            count.put(x, count.getOrDefault(x, 0) + 1);\n            counted.add(new Pair(x, count.get(x)));\n        }\n        List<Pair> expect = new ArrayList(counted);\n        Collections.sort(expect, (a, b) -> a.compare(b));\n        Pair cur = counted.get(0);\n        int ans = 0;\n        for (int i = 0; i < arr.length; ++i) {\n            Pair X = counted.get(i), Y = expect.get(i);\n            if (X.compare(cur) > 0) cur = X;\n            if (cur.compare(Y) == 0) ans++;\n        }\n        return ans;\n    }\n}\nclass Pair {\n    int val, count;\n    Pair(int v, int c) {\n        val = v; count = c;\n    }\n    int compare(Pair that) {\n        return this.val != that.val ? this.val - that.val : this.count - that.count;\n    }\n}\n"]}
{"number": 769, "statement": "Given an array arr that is a permutation of [0, 1, ..., arr.length - 1], we split the array into some number of \"chunks\" (partitions), and individually sort each chunk. After concatenating them,the result equals the sorted array.\nWhat is the most number of chunks we could have made?\n", "solutions": ["class Solution {\n    public int maxChunksToSorted(int[] arr) {\n        int ans = 0, max = 0;\n        for (int i = 0; i < arr.length; ++i) {\n            max = Math.max(max, arr[i]);\n            if (max == i) ans++;\n        }\n        return ans;\n    }\n}\n"]}
{"number": 770, "statement": "Given an expressionsuch as expression = \"e + 8 - a + 5\" and an evaluation map such as {\"e\": 1} (given in terms of evalvars = [\"e\"] and evalints = [1]), return a list of tokens representing the simplified expression, such as [\"-1*a\",\"14\"]\nAn expression alternates chunks and symbols, with a space separating each chunk and symbol.\nA chunk is either an expression in parentheses, a variable, or a non-negative integer.\nA variable is a string of lowercase letters (not including digits.) Note that variables can be multiple letters, and note that variables never have a leading coefficient or unary operator like \"2x\" or \"-x\".\nExpressions are evaluated in the usual order: brackets first, then multiplication, then addition and subtraction. For example, expression = \"1 + 2 * 3\" has an answer of [\"7\"].\nThe format of the output is as follows:\nFor each term of free variables with non-zero coefficient, we write the free variables within a term in sorted order lexicographically. For example, we would never write a term like \"b*a*c\", only \"a*b*c\".\nTerms have degree equal to the number of free variables being multiplied, counting multiplicity. (For example, \"a*a*b*c\" has degree 4.) We write the largest degree terms of our answer first, breaking ties by lexicographic order ignoring the leading coefficient of the term.\nThe leading coefficient of the term is placed directly to the left with an asterisk separating it from the variables (if they exist.) A leading coefficient of 1 is still printed.\nAn example of a well formatted answer is [\"-2*a*a*a\", \"3*a*a*b\", \"3*b*b\", \"4*a\", \"5*c\", \"-6\"]\nTerms (including constant terms) with coefficient 0 are not included. For example, an expression of \"0\" has an output of [].\n", "solutions": ["class Solution {\n    public List<String> basicCalculatorIV(String expression, String[] evalVars, int[] evalInts) {\n        Map<String, Integer> evalMap = new HashMap();\n        for (int i = 0; i < evalVars.length; ++i)\n            evalMap.put(evalVars[i], evalInts[i]);\n        return parse(expression).evaluate(evalMap).toList();\n    }\n    public Poly make(String expr) {\n        Poly ans = new Poly();\n        List<String> list = new ArrayList();\n        if (Character.isDigit(expr.charAt(0))) {\n            ans.update(list, Integer.valueOf(expr));\n        } else {\n            list.add(expr);\n            ans.update(list, 1);\n        }\n        return ans;\n    }\n    public Poly combine(Poly left, Poly right, char symbol) {\n        if (symbol == '+') return left.add(right);\n        if (symbol == '-') return left.sub(right);\n        if (symbol == '*') return left.mul(right);\n        throw null;\n    }\n    public Poly parse(String expr) {\n        List<Poly> bucket = new ArrayList();\n        List<Character> symbols = new ArrayList();\n        int i = 0;\n        while (i < expr.length()) {\n            if (expr.charAt(i) == '(') {\n                int bal = 0, j = i;\n                for (; j < expr.length(); ++j) {\n                    if (expr.charAt(j) == '(') bal++;\n                    if (expr.charAt(j) == ')') bal--;\n                    if (bal == 0) break;\n                }\n                bucket.add(parse(expr.substring(i+1, j)));\n                i = j;\n            } else if (Character.isLetterOrDigit(expr.charAt(i))) {\n                int j = i;\n                search : {\n                    for (; j < expr.length(); ++j)\n                        if (expr.charAt(j) == ' ') {\n                            bucket.add(make(expr.substring(i, j)));\n                            break search;\n                        }\n                    bucket.add(make(expr.substring(i)));\n                }\n                i = j;\n            } else if (expr.charAt(i) != ' ') {\n                symbols.add(expr.charAt(i));\n            }\n            i++;\n        }\n        for (int j = symbols.size() - 1; j >= 0; --j)\n            if (symbols.get(j) == '*')\n                bucket.set(j, combine(bucket.get(j), bucket.remove(j+1), symbols.remove(j)));\n        if (bucket.isEmpty()) return new Poly();\n        Poly ans = bucket.get(0);\n        for (int j = 0; j < symbols.size(); ++j)\n            ans = combine(ans, bucket.get(j+1), symbols.get(j));\n        return ans;\n    }\n}\nclass Poly {\n    HashMap<List<String>, Integer> count;\n    Poly() {count = new HashMap();}\n    void update(List<String> key, int val) {\n        this.count.put(key, this.count.getOrDefault(key, 0) + val);\n    }\n    Poly add(Poly that) {\n        Poly ans = new Poly();\n        for (List<String> k: this.count.keySet())\n            ans.update(k, this.count.get(k));\n        for (List<String> k: that.count.keySet())\n            ans.update(k, that.count.get(k));\n        return ans;\n    }\n    Poly sub(Poly that) {\n        Poly ans = new Poly();\n        for (List<String> k: this.count.keySet())\n            ans.update(k, this.count.get(k));\n        for (List<String> k: that.count.keySet())\n            ans.update(k, -that.count.get(k));\n        return ans;\n    }\n    Poly mul(Poly that) {\n        Poly ans = new Poly();\n        for (List<String> k1: this.count.keySet())\n            for (List<String> k2: that.count.keySet()) {\n                List<String> kNew = new ArrayList();\n                for (String x: k1) kNew.add(x);\n                for (String x: k2) kNew.add(x);\n                Collections.sort(kNew);\n                ans.update(kNew, this.count.get(k1) * that.count.get(k2));\n            }\n        return ans;\n    }\n    Poly evaluate(Map<String, Integer> evalMap) {\n        Poly ans = new Poly();\n        for (List<String> k: this.count.keySet()) {\n            int c = this.count.get(k);\n            List<String> free = new ArrayList();\n            for (String token: k) {\n                if (evalMap.containsKey(token))\n                    c *= evalMap.get(token);\n                else\n                    free.add(token);\n            }\n            ans.update(free, c);\n        }\n        return ans;\n    }\n    int compareList(List<String> A, List<String> B) {\n        int i = 0;\n        for (String x: A) {\n            String y = B.get(i++);\n            if (x.compareTo(y) != 0) return x.compareTo(y);\n        }\n        return 0;\n    }\n    List<String> toList() {\n        List<String> ans = new ArrayList();\n        List<List<String>> keys = new ArrayList(this.count.keySet());\n        Collections.sort(keys, (a, b) ->\n            a.size() != b.size() ? b.size() - a.size() : compareList(a, b));\n        for (List<String> key: keys) {\n            int v = this.count.get(key);\n            if (v == 0) continue;\n            StringBuilder word = new StringBuilder();\n            word.append(\"\" + v);\n            for (String token: key) {\n                word.append('*');\n                word.append(token);\n            }\n            ans.add(word.toString());\n        }\n        return ans;\n    }\n}\n"]}
{"number": 771, "statement": "You're given strings J representing the types of stones that are jewels, and S representing the stones you have. Each character in S is a type of stone you have. You want to know how many of the stones you have are also jewels.\nThe letters in J are guaranteed distinct, and all characters in J and S are letters. Letters are case sensitive, so \"a\" is considered a different type of stone from \"A\".\n", "solutions": ["class Solution {\n    public int numJewelsInStones(String J, String S) {\n        int ans = 0;\n        for (char s: S.toCharArray()) // For each stone...\n            for (char j: J.toCharArray()) // For each jewel...\n                if (j == s) {  // If the stone is a jewel...\n                    ans++;\n                    break; // Stop searching whether this stone 's' is a jewel\n                }\n        return ans;\n    }\n}\n", "class Solution {\n    public int numJewelsInStones(String J, String S) {\n        Set<Character> Jset = new HashSet();\n        for (char j: J.toCharArray())\n            Jset.add(j);\n        int ans = 0;\n        for (char s: S.toCharArray())\n            if (Jset.contains(s))\n                ans++;\n        return ans;\n    }\n}\n"]}
{"number": 773, "statement": "On a 2x3 board, there are 5 tiles represented by the integers 1 through 5, and an empty square represented by 0.\nA move consists of choosing 0and a 4-directionally adjacent number and swapping it.\nThe state of the board is solved if and only if the board is [[1,2,3],[4,5,0]].\nGiven a puzzle board, return the least number of moves required so that the state of the board is solved. If it is impossible for the state of the board to be solved, return -1.\n", "solutions": ["class Solution {\n    public int slidingPuzzle(int[][] board) {\n        int R = board.length, C = board[0].length;\n        int sr = 0, sc = 0;\n        search:\n            for (sr = 0; sr < R; sr++)\n                for (sc = 0; sc < C; sc++)\n                    if (board[sr][sc] == 0)\n                        break search;\n        int[][] directions = new int[][]{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\n        Queue<Node> queue = new ArrayDeque();\n        Node start = new Node(board, sr, sc, 0);\n        queue.add(start);\n        Set<String> seen = new HashSet();\n        seen.add(start.boardstring);\n        String target = Arrays.deepToString(new int[][]{{1,2,3}, {4,5,0}});\n        while (!queue.isEmpty()) {\n            Node node = queue.remove();\n            if (node.boardstring.equals(target))\n                return node.depth;\n            for (int[] di: directions) {\n                int nei_r = di[0] + node.zero_r;\n                int nei_c = di[1] + node.zero_c;\n                if ((Math.abs(nei_r - node.zero_r) + Math.abs(nei_c - node.zero_c) != 1) ||\n                        nei_r < 0 || nei_r >= R || nei_c < 0 || nei_c >= C)\n                    continue;\n                int[][] newboard = new int[R][C];\n                int t = 0;\n                for (int[] row: node.board)\n                    newboard[t++] = row.clone();\n                newboard[node.zero_r][node.zero_c] = newboard[nei_r][nei_c];\n                newboard[nei_r][nei_c] = 0;\n                Node nei = new Node(newboard, nei_r, nei_c, node.depth+1);\n                if (seen.contains(nei.boardstring))\n                    continue;\n                queue.add(nei);\n                seen.add(nei.boardstring);\n            }\n        }\n        return -1;\n    }\n}\nclass Node {\n    int[][] board;\n    String boardstring;\n    int zero_r;\n    int zero_c;\n    int depth;\n    Node(int[][] B, int r, int c, int d) {\n        board = B;\n        boardstring = Arrays.deepToString(board);\n        zero_r = r;\n        zero_c = c;\n        depth = d;\n    }\n}\n", "class Solution {\n    public int slidingPuzzle(int[][] board) {\n        int R = board.length, C = board[0].length;\n        int sr = 0, sc = 0;\n        //Find sr, sc\n        search:\n            for (sr = 0; sr < R; sr++)\n                for (sc = 0; sc < C; sc++)\n                    if (board[sr][sc] == 0)\n                        break search;\n        int[][] directions = new int[][]{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\n        PriorityQueue<Node> heap = new PriorityQueue<Node>((a, b) ->\n            (a.heuristic + a.depth) - (b.heuristic + b.depth));\n        Node start = new Node(board, sr, sc, 0);\n        heap.add(start);\n        Map<String, Integer> cost = new HashMap();\n        cost.put(start.boardstring, 9999999);\n        String target = Arrays.deepToString(new int[][]{{1,2,3}, {4,5,0}});\n        String targetWrong = Arrays.deepToString(new int[][]{{1,2,3}, {5,4,0}});\n        while (!heap.isEmpty()) {\n            Node node = heap.poll();\n            if (node.boardstring.equals(target))\n                return node.depth;\n            if (node.boardstring.equals(targetWrong))\n                return -1;\n            if (node.depth + node.heuristic > cost.get(node.boardstring))\n                continue;\n            for (int[] di: directions) {\n                int nei_r = di[0] + node.zero_r;\n                int nei_c = di[1] + node.zero_c;\n                // If the neighbor is not on the board or wraps incorrectly around rows/cols\n                if ((Math.abs(nei_r - node.zero_r) + Math.abs(nei_c - node.zero_c) != 1) ||\n                        nei_r < 0 || nei_r >= R || nei_c < 0 || nei_c >= C)\n                    continue;\n                int[][] newboard = new int[R][C];\n                int t = 0;\n                for (int[] row: node.board)\n                    newboard[t++] = row.clone();\n                // Swap the elements on the new board\n                newboard[node.zero_r][node.zero_c] = newboard[nei_r][nei_c];\n                newboard[nei_r][nei_c] = 0;\n                Node nei = new Node(newboard, nei_r, nei_c, node.depth+1);\n                if (nei.depth + nei.heuristic >= cost.getOrDefault(nei.boardstring, 9999999))\n                    continue;\n                heap.add(nei);\n                cost.put(nei.boardstring, nei.depth + nei.heuristic);\n            }\n        }\n        return -1;\n    }\n}\nclass Node {\n    int[][] board;\n    String boardstring;\n    int heuristic;\n    int zero_r;\n    int zero_c;\n    int depth;\n    Node(int[][] B, int zr, int zc, int d) {\n        board = B;\n        boardstring = Arrays.deepToString(board);\n        //Calculate heuristic\n        heuristic = 0;\n        int R = B.length, C = B[0].length;\n        for (int r = 0; r < R; ++r)\n            for (int c = 0; c < C; ++c) {\n                if (board[r][c] == 0) continue;\n                int v = (board[r][c] + R*C - 1) % (R*C);\n                // v/C, v%C: where board[r][c] should go in a solved puzzle\n                heuristic += Math.abs(r - v/C) + Math.abs(c - v%C);\n            }\n        heuristic /= 2;\n        zero_r = zr;\n        zero_c = zc;\n        depth = d;\n    }\n}\n"]}
{"number": 774, "statement": "On a horizontal number line, we have gas stations at positions stations[0], stations[1], ..., stations[N-1], where N = stations.length.\nNow, we add K more gas stations so that D, the maximum distance between adjacent gas stations, is minimized.\nReturn the smallest possible value of D.\n", "solutions": ["class Solution {\n    public double minmaxGasDist(int[] stations, int K) {\n        int N = stations.length;\n        double[] deltas = new double[N-1];\n        for (int i = 0; i < N-1; ++i)\n            deltas[i] = stations[i+1] - stations[i];\n        double[][] dp = new double[N-1][K+1];\n        //dp[i][j] = answer for deltas[:i+1] when adding j gas stations\n        for (int i = 0; i <= K; ++i)\n            dp[0][i] = deltas[0] / (i+1);\n        for (int p = 1; p < N-1; ++p)\n            for (int k = 0; k <= K; ++k) {\n                double bns = 999999999;\n                for (int x = 0; x <= k; ++x)\n                    bns = Math.min(bns, Math.max(deltas[p] / (x+1), dp[p-1][k-x]));\n                dp[p][k] = bns;\n            }\n        return dp[N-2][K];\n    }\n}\n", "class Solution {\n    public double minmaxGasDist(int[] stations, int K) {\n        int N = stations.length;\n        double[] deltas = new double[N-1];\n        for (int i = 0; i < N-1; ++i)\n            deltas[i] = stations[i+1] - stations[i];\n        int[] count = new int[N-1];\n        Arrays.fill(count, 1);\n        for (int k = 0; k < K; ++k) {\n            // Find interval with largest part\n            int best = 0;\n            for (int i = 0; i < N-1; ++i)\n                if (deltas[i] / count[i] > deltas[best] / count[best])\n                    best = i;\n            // Add gas station to best interval\n            count[best]++;\n        }\n        double ans = 0;\n        for (int i = 0; i < N-1; ++i)\n            ans = Math.max(ans, deltas[i] / count[i]);\n        return ans;\n    }\n}\n", "class Solution {\n    public double minmaxGasDist(int[] stations, int K) {\n        int N = stations.length;\n        PriorityQueue<int[]> pq = new PriorityQueue<int[]>((a, b) ->\n            (double)b[0]/b[1] < (double)a[0]/a[1] ? -1 : 1);\n        for (int i = 0; i < N-1; ++i)\n            pq.add(new int[]{stations[i+1] - stations[i], 1});\n        for (int k = 0; k < K; ++k) {\n            int[] node = pq.poll();\n            node[1]++;\n            pq.add(node);\n        }\n        int[] node = pq.poll();\n        return (double)node[0] / node[1];\n    }\n}\n", "class Solution {\n    public double minmaxGasDist(int[] stations, int K) {\n        double lo = 0, hi = 1e8;\n        while (hi - lo > 1e-6) {\n            double mi = (lo + hi) / 2.0;\n            if (possible(mi, stations, K))\n                hi = mi;\n            else\n                lo = mi;\n        }\n        return lo;\n    }\n    public boolean possible(double D, int[] stations, int K) {\n        int used = 0;\n        for (int i = 0; i < stations.length - 1; ++i)\n            used += (int) ((stations[i+1] - stations[i]) / D);\n        return used <= K;\n    }\n}\n"]}
{"number": 775, "statement": "We have some permutation A of [0, 1, ..., N - 1], where N is the length of A.\nThe number of (global) inversions is the number of i  j with 0 = i  j  N and A[i]  A[j].\nThe number of local inversions is the number of i with 0 = i  N and A[i]  A[i+1].\nReturn trueif and only if the number of global inversions is equal to the number of local inversions.\n", "solutions": ["class Solution {\n    public boolean isIdealPermutation(int[] A) {\n        int N = A.length;\n        for (int i = 0; i < N; ++i)\n            for (int j = i+2; j < N; ++j)\n                if (A[i] > A[j]) return false;\n        return true;\n    }\n}\n", "class Solution {\n    public boolean isIdealPermutation(int[] A) {\n        int N = A.length;\n        int floor = N;\n        for (int i=N-1; i>=2; --i) {\n            floor = Math.min(floor, A[i]);\n            if (A[i-2] > floor) return false;\n        }\n        return true;\n    }\n}\n", "class Solution {\n    public boolean isIdealPermutation(int[] A) {\n        for (int i = 0; i < A.length; ++i)\n            if (Math.abs(A[i] - i) > 1)\n                return false;\n        return true;\n    }\n}\n"]}
{"number": 776, "statement": "Given a Binary Search Tree (BST) with root node root, and a target value V, split the tree into two subtreeswhere one subtree has nodes that are all smaller or equal to the target value, while the other subtree has all nodes that are greater than the target value. It's not necessarily the case that the tree contains a node with value V.\nAdditionally, most of the structure of the original tree should remain. Formally, for any child C with parent P in the original tree, if they are both in the same subtree after the split, then node C should still have the parent P.\nYou should output the root TreeNode ofboth subtrees after splitting, in any order.\n", "solutions": ["class Solution {\n    public TreeNode[] splitBST(TreeNode root, int V) {\n        if (root == null)\n            return new TreeNode[]{null, null};\n        else if (root.val <= V) {\n            TreeNode[] bns = splitBST(root.right, V);\n            root.right = bns[0];\n            bns[0] = root;\n            return bns;\n        } else {\n            TreeNode[] bns = splitBST(root.left, V);\n            root.left = bns[1];\n            bns[1] = root;\n            return bns;\n        }\n    }\n}\n"]}
{"number": 777, "statement": "In a string composed of 'L', 'R', and 'X' characters, like \"RXXLRXRXL\", a move consists of either replacing one occurrence of \"XL\" with \"LX\", or replacing one occurrence of \"RX\" with \"XR\". Given the starting string start and the ending string end, return True if and only if there exists a sequence of moves to transform one string to the other.\n", "solutions": ["class Solution {\n    public boolean canTransform(String start, String end) {\n        if (!start.replace(\"X\", \"\").equals(end.replace(\"X\", \"\")))\n            return false;\n        int t = 0;\n        for (int i = 0; i < start.length(); ++i)\n            if (start.charAt(i) == 'L') {\n                while (end.charAt(t) != 'L') t++;\n                if (i < t++) return false;\n            }\n        t = 0;\n        for (int i = 0; i < start.length(); ++i)\n            if (start.charAt(i) == 'R') {\n                while (end.charAt(t) != 'R') t++;\n                if (i > t++) return false;\n            }\n        return true;\n    }\n}\n", "class Solution {\n    public boolean canTransform(String start, String end) {\n        int N = start.length();\n        char[] S = start.toCharArray(), T = end.toCharArray();\n        int i = -1, j = -1;\n        while (++i < N && ++j < N) {\n            while (i < N && S[i] == 'X') i++;\n            while (j < N && T[j] == 'X') j++;\n            /* At this point, i == N or S[i] != 'X',\n               and j == N or T[j] != 'X'.  i and j\n               are the indices representing the next\n               occurrences of non-X characters in S and T.\n            */\n            // If only one of i < N and j < N, then it isn't solid-\n            // there's more people in one of the strings.\n            if ((i < N) ^ (j < N)) return false;\n            if (i < N && j < N) {\n                // If the person isn't the same, it isn't solid.\n                // Or, if the person moved backwards, it isn't accessible.\n                if (S[i] != T[j] || (S[i] == 'L' && i < j) ||\n                        (S[i] == 'R' && i > j) )\n                    return false;\n            }\n        }\n        return true;\n    }\n}\n"]}
{"number": 778, "statement": "On an N x N grid, each square grid[i][j] represents the elevation at that point (i,j).\nNow rain starts to fall. At time t, the depth of the water everywhere is t. You can swim from a square to another 4-directionally adjacent square if and only if the elevation of both squares individually areat mostt. You can swim infinite distance in zero time. Of course, you must stay within the boundaries of the grid during your swim.\nYou start at the top left square (0, 0). What is the least time until you can reach the bottom right square (N-1, N-1)?\n", "solutions": ["class Solution {\n    public int swimInWater(int[][] grid) {\n        int N = grid.length;\n        Set<Integer> seen = new HashSet();\n        PriorityQueue<Integer> pq = new PriorityQueue<Integer>((k1, k2) ->\n                grid[k1 / N][k1 % N] - grid[k2 / N][k2 % N]);\n        pq.offer(0);\n        int ans = 0;\n        int[] dr = new int[]{1, -1, 0, 0};\n        int[] dc = new int[]{0, 0, 1, -1};\n        while (!pq.isEmpty()) {\n            int k = pq.poll();\n            int r = k / N, c = k % N;\n            ans = Math.max(ans, grid[r][c]);\n            if (r == N-1 && c == N-1) return ans;\n            for (int i = 0; i < 4; ++i) {\n                int cr = r + dr[i], cc = c + dc[i];\n                int ck = cr * N + cc;\n                if (0 <= cr && cr < N && 0 <= cc && cc < N && !seen.contains(ck)) {\n                    pq.offer(ck);\n                    seen.add(ck);\n                }\n            }\n        }\n        throw null;\n    }\n}\n", "class Solution {\n    public int swimInWater(int[][] grid) {\n        int N = grid.length;\n        int lo = grid[0][0], hi = N * N;\n        while (lo < hi) {\n            int mi = lo + (hi - lo) / 2;\n            if (!possible(mi, grid)) {\n                lo = mi + 1;\n            } else {\n                hi = mi;\n            }\n        }\n        return lo;\n    }\n    public boolean possible(int T, int[][] grid) {\n        int N = grid.length;\n        Set<Integer> seen = new HashSet();\n        seen.add(0);\n        int[] dr = new int[]{1, -1, 0, 0};\n        int[] dc = new int[]{0, 0, 1, -1};\n        Stack<Integer> stack = new Stack();\n        stack.add(0);\n        while (!stack.empty()) {\n            int k = stack.pop();\n            int r = k / N, c = k % N;\n            if (r == N-1 && c == N-1) return true;\n            for (int i = 0; i < 4; ++i) {\n                int cr = r + dr[i], cc = c + dc[i];\n                int ck = cr * N + cc;\n                if (0 <= cr && cr < N && 0 <= cc && cc < N\n                        && !seen.contains(ck) && grid[cr][cc] <= T) {\n                    stack.add(ck);\n                    seen.add(ck);\n                }\n            }\n        }\n        return false;\n    }\n}\n"]}
{"number": 779, "statement": "On the first row, we write a 0. Now in every subsequent row, we look at the previous row and replace each occurrence of 0 with 01, and each occurrence of 1 with 10.\nGiven row N and index K, return the K-th indexed symbol in row N. (The values of K are 1-indexed.) (1 indexed).\n", "solutions": ["class Solution {\n    public int kthGrammar(int N, int K) {\n        int[] lastrow = new int[1 << N];\n        for (int i = 1; i < N; ++i) {\n            for (int j = (1 << (i-1)) - 1; j >= 0; --j) {\n                lastrow[2*j] = lastrow[j];\n                lastrow[2*j+1] = 1 - lastrow[j];\n            }\n        }\n        return lastrow[K-1];\n    }\n}\n", "class Solution {\n    public int kthGrammar(int N, int K) {\n        if (N == 1) return 0;\n        return (~K & 1) ^ kthGrammar(N-1, (K+1)/2);\n    }\n}\n"]}
{"number": 780, "statement": "A move consists of taking a point (x, y) and transforming it to either (x, x+y) or (x+y, y).\nGiven a starting point (sx, sy) and a target point (tx, ty), return True if and only if a sequence of moves exists to transform the point (sx, sy) to (tx, ty). Otherwise, return False.\n", "solutions": ["class Solution {\n    public boolean reachingPoints(int sx, int sy, int tx, int ty) {\n        if (sx > tx || sy > ty) return false;\n        if (sx == tx && sy == ty) return true;\n        return reachingPoints(sx+sy, sy, tx, ty) || reachingPoints(sx, sx+sy, tx, ty);\n    }\n}\n", "import java.awt.Point;\nclass Solution {\n    Set<Point> seen;\n    int tx, ty;\n    public boolean reachingPoints(int sx, int sy, int tx, int ty) {\n        seen = new HashSet();\n        this.tx = tx;\n        this.ty = ty;\n        search(new Point(sx, sy));\n        return seen.contains(new Point(tx, ty));\n    }\n    public void search(Point P) {\n        if (seen.contains(P)) return;\n        if (P.x > tx || P.y > ty) return;\n        seen.add(P);\n        search(new Point(P.x + P.y, P.y));\n        search(new Point(P.x, P.x + P.y));\n    }\n}\n"]}
{"number": 781, "statement": "In a forest, each rabbit has some color. Some subset of rabbits (possibly all of them) tell you how many other rabbits have the same color as them. Those answers are placed in an array.\nReturn the minimum number of rabbits that could be in the forest.\n", "solutions": ["class Solution {\n    public int numRabbits(int[] answers) {\n        int[] count = new int[1000];\n        for (int x: answers) count[x]++;\n        int ans = 0;\n        for (int k = 0; k < 1000; ++k)\n            ans += Math.floorMod(-count[k], k+1) + count[k];\n        return ans;\n    }\n}\n"]}
{"number": 782, "statement": "An N x N board contains only 0s and 1s. In each move, you can swap any 2 rows with each other, or any 2 columns with each other.\nWhat is the minimum number of moves to transform the board into a \"chessboard\" - a board where no 0s and no 1s are 4-directionally adjacent? If the task is impossible, return -1.\n", "solutions": ["class Solution {\n    public int movesToChessboard(int[][] board) {\n        int N = board.length;\n        // count[code] = v, where code is an integer\n        // that represents the row in binary, and v\n        // is the number of occurrences of that row\n        Map<Integer, Integer> count = new HashMap();\n        for (int[] row: board) {\n            int code = 0;\n            for (int x: row)\n                code = 2 * code + x;\n            count.put(code, count.getOrDefault(code, 0) + 1);\n        }\n        int k1 = analyzeCount(count, N);\n        if (k1 == -1) return -1;\n        // count[code], as before except with columns\n        count = new HashMap();\n        for (int c = 0; c < N; ++c) {\n            int code = 0;\n            for (int r = 0; r < N; ++r)\n                code = 2 * code + board[r][c];\n            count.put(code, count.getOrDefault(code, 0) + 1);\n        }\n        int k2 = analyzeCount(count, N);\n        return k2 >= 0 ? k1 + k2 : -1;\n    }\n    public int analyzeCount(Map<Integer, Integer> count, int N) {\n        // Return -1 if count is invalid\n        // Otherwise, return number of swaps required\n        if (count.size() != 2) return -1;\n        List<Integer> keys = new ArrayList(count.keySet());\n        int k1 = keys.get(0), k2 = keys.get(1);\n        // If lines aren't in the right quantity\n        if (!(count.get(k1) == N/2 && count.get(k2) == (N+1)/2) &&\n                !(count.get(k2) == N/2 && count.get(k1) == (N+1)/2))\n            return -1;\n        // If lines aren't opposite\n        if ((k1 ^ k2) != (1<<N) - 1)\n            return -1;\n        int Nones = (1 << N) - 1;\n        int ones = Integer.bitCount(k1 & Nones);\n        int cand = Integer.MAX_VALUE;\n        if (N%2 == 0 || ones * 2 < N) // zero start\n            cand = Math.min(cand, Integer.bitCount(k1 ^ 0xAAAAAAAA & Nones) / 2);\n        if (N%2 == 0 || ones * 2 > N) // ones start\n            cand = Math.min(cand, Integer.bitCount(k1 ^ 0x55555555 & Nones) / 2);\n        return cand;\n    }\n}\n"]}
{"number": 783, "statement": "Given a Binary Search Tree (BST) with the root node root, returnthe minimum difference between the values of any two different nodes in the tree.\n", "solutions": ["class Solution {\n    List<Integer> vals;\n    public int minDiffInBST(TreeNode root) {\n        vals = new ArrayList();\n        dfs(root);\n        Collections.sort(vals);\n        int ans = Integer.MAX_VALUE;\n        for (int i = 0; i < vals.size() - 1; ++i)\n            ans = Math.min(ans, vals.get(i+1) - vals.get(i));\n        return ans;\n    }\n    public void dfs(TreeNode node) {\n        if (node == null) return;\n        vals.add(node.val);\n        dfs(node.left);\n        dfs(node.right);\n    }\n}\n", "class Solution {\n    Integer prev, ans;\n    public int minDiffInBST(TreeNode root) {\n        prev = null;\n        ans = Integer.MAX_VALUE;\n        dfs(root);\n        return ans;\n    }\n    public void dfs(TreeNode node) {\n        if (node == null) return;\n        dfs(node.left);\n        if (prev != null)\n            ans = Math.min(ans, node.val - prev);\n        prev = node.val;\n        dfs(node.right);\n    }\n}\n"]}
{"number": 784, "statement": "Given a string S, we can transform every letter individuallyto be lowercase or uppercase to create another string. Return a list of all possible strings we could create.\n", "solutions": ["class Solution {\n    public List<String> letterCasePermutation(String S) {\n        List<StringBuilder> ans = new ArrayList();\n        ans.add(new StringBuilder());\n        for (char c: S.toCharArray()) {\n            int n = ans.size();\n            if (Character.isLetter(c)) {\n                for (int i = 0; i < n; ++i) {\n                    ans.add(new StringBuilder(ans.get(i)));\n                    ans.get(i).append(Character.toLowerCase(c));\n                    ans.get(n+i).append(Character.toUpperCase(c));\n                }\n            } else {\n                for (int i = 0; i < n; ++i)\n                    ans.get(i).append(c);\n            }\n        }\n        List<String> finalans = new ArrayList();\n        for (StringBuilder sb: ans)\n            finalans.add(sb.toString());\n        return finalans;\n    }\n}\n", "class Solution {\n    public List<String> letterCasePermutation(String S) {\n        int B = 0;\n        for (char c: S.toCharArray())\n            if (Character.isLetter(c))\n                B++;\n        List<String> ans = new ArrayList();\n        for (int bits = 0; bits < 1<<B; bits++) {\n            int b = 0;\n            StringBuilder word = new StringBuilder();\n            for (char letter: S.toCharArray()) {\n                if (Character.isLetter(letter)) {\n                    if (((bits >> b++) & 1) == 1)\n                        word.append(Character.toLowerCase(letter));\n                    else\n                        word.append(Character.toUpperCase(letter));\n                } else {\n                    word.append(letter);\n                }\n            }\n            ans.add(word.toString());\n        }\n        return ans;\n    }\n}\n"]}
{"number": 785, "statement": "Given an undirectedgraph, return true if and only if it is bipartite.\nRecall that a graph is bipartite if we can split it's set of nodes into two independentsubsets A and B such that every edge in the graph has one node in A and another node in B.\nThe graph is given in the following form: graph[i] is a list of indexes j for which the edge between nodes i and j exists. Each node is an integer between 0 and graph.length - 1. There are no self edges or parallel edges: graph[i] does not contain i, and it doesn't contain any element twice.\n", "solutions": ["class Solution {\n    public boolean isBipartite(int[][] graph) {\n        int n = graph.length;\n        int[] color = new int[n];\n        Arrays.fill(color, -1);\n        for (int start = 0; start < n; ++start) {\n            if (color[start] == -1) {\n                Stack<Integer> stack = new Stack();\n                stack.push(start);\n                color[start] = 0;\n                while (!stack.empty()) {\n                    Integer node = stack.pop();\n                    for (int nei: graph[node]) {\n                        if (color[nei] == -1) {\n                            stack.push(nei);\n                            color[nei] = color[node] ^ 1;\n                        } else if (color[nei] == color[node]) {\n                            return false;\n                        }\n                    }\n                }\n            }\n        }\n        return true;\n    }\n}\n"]}
{"number": 786, "statement": "A sorted list A contains 1, plus some number of primes. Then, for every p  q in the list, we consider the fraction p/q.\nWhat is the K-th smallest fraction considered? Return your answer as an array of ints, where answer[0] = p and answer[1] = q.\n", "solutions": ["class Solution {\n    public int[] kthSmallestPrimeFraction(int[] primes, int K) {\n        double lo = 0, hi = 1;\n        int[] ans = new int[]{0, 1};\n        while (hi - lo > 1e-9) {\n            double mi = lo + (hi - lo) / 2.0;\n            int[] res = under(mi, primes);\n            if (res[0] < K) {\n                lo = mi;\n            } else {\n                ans[0] = res[1];\n                ans[1] = res[2];\n                hi = mi;\n            }\n        }\n        return ans;\n    }\n    public int[] under(double x, int[] primes) {\n        // Returns {count, numerator, denominator}\n        int numer = 0, denom = 1, count = 0, i = -1;\n        for (int j = 1; j < primes.length; ++j) {\n            // For each j, find the largest i so that primes[i] / primes[j] < x\n            // It has to be at least as big as the previous i, so reuse it (\"two pointer\")\n            while (primes[i+1] < primes[j] * x) ++i;\n            // There are i+1 fractions: (primes[0], primes[j]),\n            // (primes[1], primes[j]), ..., (primes[i], primes[j])\n            count += i+1;\n            if (i >= 0 && numer * primes[j] < denom * primes[i]) {\n                numer = primes[i];\n                denom = primes[j];\n            }\n        }\n        return new int[]{count, numer, denom};\n    }\n}\n", "class Solution {\n    public int[] kthSmallestPrimeFraction(int[] A, int K) {\n        PriorityQueue<int[]> pq = new PriorityQueue<int[]>((a, b) ->\n                A[a[0]] * A[b[1]] - A[a[1]] * A[b[0]]);\n        for (int i = 1; i < A.length; ++i)\n            pq.add(new int[]{0, i});\n        while (--K > 0) {\n            int[] frac = pq.poll();\n            if (frac[0]++ < frac[1])\n                pq.offer(frac);\n        }\n        int[] ans = pq.poll();\n        return new int[]{A[ans[0]], A[ans[1]]};\n    }\n}\n"]}
{"number": 787, "statement": "There are n cities connected bym flights. Each flight starts from cityu and arrives atv with a price w.\nNow given all the cities and flights, together with starting city src and the destinationdst, your task is to find the cheapest price from src to dst with up to k stops. If there is no such route, output -1.\n", "solutions": ["class Solution {\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int K) {\n        int[][] dist = new int[2][n];\n        int INF = Integer.MAX_VALUE / 2;\n        Arrays.fill(dist[0], INF);\n        Arrays.fill(dist[1], INF);\n        dist[0][src] = dist[1][src] = 0;\n        for (int i = 0; i <= K; ++i)\n            for (int[] edge: flights)\n                dist[i&1][edge[1]] = Math.min(dist[i&1][edge[1]], dist[~i&1][edge[0]] + edge[2]);\n        return dist[K&1][dst] < INF ? dist[K&1][dst] : -1;\n    }\n}\n", "class Solution {\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int K) {\n        int[][] graph = new int[n][n];\n        for (int[] flight: flights)\n            graph[flight[0]][flight[1]] = flight[2];\n        Map<Integer, Integer> best = new HashMap();\n        PriorityQueue<int[]> pq = new PriorityQueue<int[]>((a, b) -> a[0] - b[0]);\n        pq.offer(new int[]{0, 0, src});\n        while (!pq.isEmpty()) {\n            int[] info = pq.poll();\n            int cost = info[0], k = info[1], place = info[2];\n            if (k > K+1 || cost > best.getOrDefault(k * 1000 + place, Integer.MAX_VALUE))\n                continue;\n            if (place == dst)\n                return cost;\n            for (int nei = 0; nei < n; ++nei) if (graph[place][nei] > 0) {\n                int newcost = cost + graph[place][nei];\n                if (newcost < best.getOrDefault((k+1) * 1000 + nei, Integer.MAX_VALUE)) {\n                    pq.offer(new int[]{newcost, k+1, nei});\n                    best.put((k+1) * 1000 + nei, newcost);\n                }\n            }\n        }\n        return -1;\n    }\n}\n"]}
{"number": 788, "statement": "X is a good number if after rotating each digit individually by 180 degrees, we get a valid number that is different from X. Each digit must be rotated - we cannot choose to leave it alone.\nA number is valid if each digit remains a digit after rotation. 0, 1, and 8 rotate to themselves; 2 and 5 rotate to each other (on this case they are rotated in a different direction, in other words 2 or 5 gets mirrored); 6 and 9 rotate to each other, and the rest of the numbers do not rotate to any other number and become invalid.\nNowgiven a positive number N, how many numbers X from 1 to N are good?\n", "solutions": ["class Solution {\n    public int rotatedDigits(int N) {\n        // Count how many n in [1, N] are good.\n        int ans = 0;\n        for (int n = 1; n <= N; ++n)\n            if (good(n, false)) ans++;\n        return ans;\n    }\n    // Return true if n is good.\n    // The flag is true iff we have an occurrence of 2, 5, 6, 9.\n    public boolean good(int n, boolean flag) {\n        if (n == 0) return flag;\n        int d = n % 10;\n        if (d == 3 || d == 4 || d == 7) return false;\n        if (d == 0 || d == 1 || d == 8) return good(n / 10, flag);\n        return good(n / 10, true);\n    }\n}\n", "class Solution {\n    public int rotatedDigits(int N) {\n        char[] A = String.valueOf(N).toCharArray();\n        int K = A.length;\n        int[][][] memo = new int[K+1][2][2];\n        memo[K][0][1] = memo[K][1][1] = 1;\n        for (int i = K - 1; i >= 0; --i) {\n            for (int eqf = 0; eqf <= 1; ++eqf)\n                for (int invf = 0; invf <= 1; ++invf) {\n                    // We will compute ans = memo[i][eqf][invf],\n                    // the number of good numbers with respect to N = A[i:].\n                    // If eqf is true, we must stay below N, otherwise\n                    // we can use any digits.\n                    // Invf becomes true when we write a 2569, and it\n                    // must be true by the end of our writing as all\n                    // good numbers have a digit in 2569.\n                    int ans = 0;\n                    for (char d = '0'; d <= (eqf == 1 ? A[i] : '9'); ++d) {\n                        if (d == '3' || d == '4' || d == '7') continue;\n                        boolean invo = (d == '2' || d == '5' || d == '6' || d == '9');\n                        ans += memo[i+1][d == A[i] ? eqf : 0][invo ? 1 : invf];\n                    }\n                    memo[i][eqf][invf] = ans;\n                }\n        }\n        return memo[0][1][0];\n    }\n}\n"]}
{"number": 789, "statement": "You are playing a simplified Pacman game. Youstart at the point (0, 0), and your destination is (target[0], target[1]). There are several ghosts on the map, the i-th ghost starts at (ghosts[i][0], ghosts[i][1]).\nEach turn, you and all ghosts simultaneously *may* move in one of 4 cardinal directions: north, east, west, or south, going from the previous point to a new point 1 unit of distance away.\nYou escape if and only if you can reach the target before any ghost reaches you (for any given moves the ghosts may take.) If you reach any square (including the target) at the same time as a ghost, it doesn't count as an escape.\nReturn True if and only if it is possible to escape.\n", "solutions": ["class Solution {\n    public boolean escapeGhosts(int[][] ghosts, int[] target) {\n        int[] source = new int[]{0, 0};\n        for (int[] ghost: ghosts)\n            if (taxi(ghost, target) <= taxi(source, target))\n                return false;\n        return true;\n    }\n    public int taxi(int[] P, int[] Q) {\n        return Math.abs(P[0] - Q[0]) + Math.abs(P[1] - Q[1]);\n    }\n}\n"]}
{"number": 790, "statement": "We have two types of tiles: a 2x1 domino shape, and an \"L\" tromino shape. These shapes may be rotated.\nXX  - domino\nXX  - \"L\" tromino\nX\nGiven N, how many ways are there to tile a 2 x N board? Return your answer modulo 10^9 + 7.\n(In a tiling, every square must be covered by a tile. Two tilings are different if and only if there are two 4-directionally adjacent cells on the board such that exactly one of the tilings has both squares occupied by a tile.)\n", "solutions": ["class Solution {\n    public int numTilings(int N) {\n        int MOD = 1_000_000_007;\n        long[] dp = new long[]{1, 0, 0, 0};\n        for (int i = 0; i < N; ++i) {\n            long[] ndp = new long[4];\n            ndp[0b00] = (dp[0b00] + dp[0b11]) % MOD;\n            ndp[0b01] = (dp[0b00] + dp[0b10]) % MOD;\n            ndp[0b10] = (dp[0b00] + dp[0b01]) % MOD;\n            ndp[0b11] = (dp[0b00] + dp[0b01] + dp[0b10]) % MOD;\n            dp = ndp;\n        }\n        return (int) dp[0];\n    }\n}\n", "class Solution {\n    int MOD = 1_000_000_007;\n    public int numTilings(int N) {\n        int[][] T = new int[][]{{1,0,0,1},{1,0,1,0},{1,1,0,0},{1,1,1,0}};\n        return matrixExpo(T, N)[0][0];\n    }\n    public int[][] matrixMult(int[][] A, int[][] B) {\n        int[][] ans = new int[A.length][A.length];\n        for (int i = 0; i < A.length; i++)\n            for (int j = 0; j < B[0].length; j++) {\n                long entry = 0;\n                for (int k = 0; k < B.length; k++)\n                    entry += (long) A[i][k] * (long) B[k][j] % MOD;\n                ans[i][j] = (int) (entry % MOD);\n            }\n        return ans;\n    }\n    public int[][] matrixExpo(int[][] A, int pow) {\n        int[][] ans = new int[A.length][A.length];\n        for (int i = 0; i < A.length; i++) ans[i][i] = 1;\n        if (pow == 0) return ans;\n        if (pow == 1) return A;\n        if (pow % 2 == 1) return matrixMult(matrixExpo(A, pow-1), A);\n        int[][] B = matrixExpo(A, pow / 2);\n        return matrixMult(B, B);\n    }\n}\n"]}
{"number": 791, "statement": "S and T are strings composed of lowercase letters. In S, no letter occurs more than once.\nS was sorted in some custom order previously. We want to permute the characters of T so that they match the order that S was sorted. More specifically, if x occurs before y in S, then x should occur before y in the returned string.\nReturn any permutation of T (as a string) that satisfies this property.\n", "solutions": ["class Solution {\n    public String customSortString(String S, String T) {\n        // count[char] = the number of occurrences of 'char' in T.\n        // This is offset so that count[0] = occurrences of 'a', etc.\n        // 'count' represents the current state of characters\n        // (with multiplicity) we need to write to our answer.\n        int[] count = new int[26];\n        for (char c: T.toCharArray())\n            count[c - 'a']++;\n        // ans will be our final answer.  We use StringBuilder to join\n        // the answer so that we more efficiently calculate a\n        // concatenation of strings.\n        StringBuilder ans = new StringBuilder();\n        // Write all characters that occur in S, in the order of S.\n        for (char c: S.toCharArray()) {\n            for (int i = 0; i < count[c - 'a']; ++i)\n                ans.append(c);\n            // Setting count[char] to zero to denote that we do\n            // not need to write 'char' into our answer anymore.\n            count[c - 'a'] = 0;\n        }\n        // Write all remaining characters that don't occur in S.\n        // That information is specified by 'count'.\n        for (char c = 'a'; c <= 'z'; ++c)\n            for (int i = 0; i < count[c - 'a']; ++i)\n                ans.append(c);\n        return ans.toString();\n    }\n}\n"]}
{"number": 792, "statement": "Given string S and adictionary of words words, find the number of words[i] that is a subsequence of S.\n", "solutions": ["class Solution {\n    char[] ca, cb;\n    public int numMatchingSubseq(String S, String[] words) {\n        int ans = 0;\n        ca = S.toCharArray();\n        for (String word: words)\n            if (subseq(word)) ans++;\n        return ans;\n    }\n    public boolean subseq(String word) {\n        int i = 0;\n        cb = word.toCharArray();\n        for (char c: ca) {\n            if (i < cb.length && c == cb[i]) i++;\n        }\n        return (i == cb.length);\n    }\n}\n", "class Solution {\n    public int numMatchingSubseq(String S, String[] words) {\n        int ans = 0;\n        ArrayList<Node>[] heads = new ArrayList[26];\n        for (int i = 0; i < 26; ++i)\n            heads[i] = new ArrayList<Node>();\n        for (String word: words)\n            heads[word.charAt(0) - 'a'].add(new Node(word, 0));\n        for (char c: S.toCharArray()) {\n            ArrayList<Node> old_bucket = heads[c - 'a'];\n            heads[c - 'a'] = new ArrayList<Node>();\n            for (Node node: old_bucket) {\n                node.index++;\n                if (node.index == node.word.length()) {\n                    ans++;\n                } else {\n                    heads[node.word.charAt(node.index) - 'a'].add(node);\n                }\n            }\n            old_bucket.clear();\n        }\n        return ans;\n    }\n}\nclass Node {\n    String word;\n    int index;\n    public Node(String w, int i) {\n        word = w;\n        index = i;\n    }\n}\n"]}
{"number": 793, "statement": "Let f(x) be the number of zeroes at the end of x!. (Recall that x! = 1 * 2 * 3 * ... * x, and by convention, 0! = 1.)\nFor example, f(3) = 0 because 3! = 6 has no zeroes at the end, while f(11) = 2 because 11! = 39916800 has 2 zeroes at the end. Given K, find how many non-negative integers x have the property that f(x) = K.\n", "solutions": ["class Solution {\n    public int preimageSizeFZF(int K) {\n        int lo = K, hi = 10*K + 1;\n        while (lo < hi) {\n            int mi = lo + (hi - lo) / 2;\n            int zmi = zeta(mi);\n            if (zmi == K) return 5;\n            else if (zmi < K) lo = mi + 1;\n            else hi = mi;\n        }\n        return 0;\n    }\n    public int zeta(int x) {\n        if (x == 0) return 0;\n        return x/5 + zeta(x/5);\n    }\n}\n"]}
{"number": 794, "statement": "A Tic-Tac-Toe board is given as a string array board. Return True if and only if it is possible to reach this board position during the course of a valid tic-tac-toe game.\nThe board is a 3 x 3 array, and consists of characters \" \", \"X\", and \"O\". The \" \" character represents an empty square.\nHere are the rules of Tic-Tac-Toe:\nPlayers take turns placing characters into empty squares (\" \").\nThe first player always places \"X\" characters, while the second player always places \"O\" characters.\n\"X\" and \"O\" characters are always placed into empty squares, never filled ones.\nThe game ends when there are 3 of the same (non-empty) character filling any row, column, or diagonal.\nThe game also ends if all squares are non-empty.\nNo more moves can be played if the game is over.\n", "solutions": ["class Solution {\n    public boolean validTicTacToe(String[] board) {\n        int xCount = 0, oCount = 0;\n        for (String row: board)\n            for (char c: row.toCharArray()) {\n                if (c == 'X') xCount++;\n                if (c == 'O') oCount++;\n            }\n        if (oCount != xCount && oCount != xCount - 1) return false;\n        if (win(board, 'X') && oCount != xCount - 1) return false;\n        if (win(board, 'O') && oCount != xCount) return false;\n        return true;\n    }\n    public boolean win(String[] B, char P) {\n        // B: board, P: player\n        for (int i = 0; i < 3; ++i) {\n            if (P == B[0].charAt(i) && P == B[1].charAt(i) && P == B[2].charAt(i))\n                return true;\n            if (P == B[i].charAt(0) && P == B[i].charAt(1) && P == B[i].charAt(2))\n                return true;\n        }\n        if (P == B[0].charAt(0) && P == B[1].charAt(1) && P == B[2].charAt(2))\n            return true;\n        if (P == B[0].charAt(2) && P == B[1].charAt(1) && P == B[2].charAt(0))\n            return true;\n        return false;\n    }\n}\n"]}
{"number": 795, "statement": "We are given an array A of positive integers, and two positive integers L and R (L = R).\nReturn the number of (contiguous, non-empty) subarrays such that the value of the maximum array element in that subarray is at least L and at most R.\n", "solutions": ["class Solution {\n    public int numSubarrayBoundedMax(int[] A, int L, int R) {\n        return count(A, R) - count(A, L-1);\n    }\n    public int count(int[] A, int bound) {\n        int ans = 0, cur = 0;\n        for (int x: A) {\n            cur = x <= bound ? cur + 1 : 0;\n            ans += cur;\n        }\n        return ans;\n    }\n}\n"]}
{"number": 796, "statement": "We are given two strings, A and B.\nA shift on A consists of taking string A and moving the leftmost character to the rightmost position. For example, if A = 'abcde', then it will be 'bcdea' after one shift on A. Return True if and only if A can become B after some number of shifts on A.\n", "solutions": ["class Solution {\n    public boolean rotateString(String A, String B) {\n        if (A.length() != B.length())\n            return false;\n        if (A.length() == 0)\n            return true;\n        search:\n            for (int s = 0; s < A.length(); ++s) {\n                for (int i = 0; i < A.length(); ++i) {\n                    if (A.charAt((s+i) % A.length()) != B.charAt(i))\n                        continue search;\n                }\n                return true;\n            }\n        return false;\n    }\n}\n", "class Solution {\n    public boolean rotateString(String A, String B) {\n        return A.length() == B.length() && (A + A).contains(B);\n    }\n}\n"]}
{"number": 797, "statement": "Given a directed, acyclic graph of N nodes. Find all possible paths from node 0 to node N-1, and return them in any order.\nThe graph is given as follows: the nodes are 0, 1, ..., graph.length - 1. graph[i] is a list of all nodes j for which the edge (i, j) exists.\n", "solutions": ["class Solution {\n    public List<List<Integer>> allPathsSourceTarget(int[][] graph) {\n        return solve(graph, 0);\n    }\n    public List<List<Integer>> solve(int[][] graph, int node) {\n        int N = graph.length;\n        List<List<Integer>> ans = new ArrayList();\n        if (node == N - 1) {\n            List<Integer> path = new ArrayList();\n            path.add(N-1);\n            ans.add(path);\n            return ans;\n        }\n        for (int nei: graph[node]) {\n            for (List<Integer> path: solve(graph, nei)) {\n                path.add(0, node);\n                ans.add(path);\n            }\n        }\n        return ans;\n    }\n}\n"]}
{"number": 798, "statement": "Given an array A, we may rotate it by a non-negative integer K so that the array becomes A[K], A[K+1], A{K+2], ... A[A.length - 1], A[0], A[1], ..., A[K-1]. Afterward, any entries that are less than or equal to their index are worth 1 point.\nFor example, if we have [2, 4, 1, 3, 0], and we rotate by K = 2, it becomes [1, 3, 0, 2, 4]. This is worth 3 points because 1  0 [no points], 3  1 [no points], 0 = 2 [one point], 2 = 3 [one point], 4 = 4 [one point].\nOver all possible rotations, return the rotation index K that corresponds to the highest score we could receive. If there are multiple answers, return the smallest such index K.\n", "solutions": ["class Solution {\n    public int bestRotation(int[] A) {\n        int N = A.length;\n        int[] bad = new int[N];\n        for (int i = 0; i < N; ++i) {\n            int left = (i - A[i] + 1 + N) % N;\n            int right = (i + 1) % N;\n            bad[left]--;\n            bad[right]++;\n            if (left > right)\n                bad[0]--;\n        }\n        int best = -N;\n        int ans = 0, cur = 0;\n        for (int i = 0; i < N; ++i) {\n            cur += bad[i];\n            if (cur > best) {\n                best = cur;\n                ans = i;\n            }\n        }\n        return ans;\n    }\n}\n"]}
{"number": 799, "statement": "We stack glasses in a pyramid, where the first row has 1 glass, the second row has 2 glasses, and so on until the 100th row. Each glass holds one cup (250ml) of champagne.\nThen, some champagne is poured in the first glass at the top. When the top most glass is full, any excess liquid poured will fall equally to the glass immediately to the left and right of it. When those glasses become full, any excess champagne will fall equally to the left and right of those glasses, and so on. (A glass at the bottom row has it's excess champagne fall on the floor.)\nFor example, after one cup of champagne is poured, the top most glass is full. After two cups of champagne are poured, the two glasses on the second row are half full. After three cups of champagne are poured, those two cups become full - there are 3 full glasses total now. After four cups of champagne are poured, the third row has the middle glass half full, and the two outside glasses are a quarter full, as pictured below.\nNow after pouring some non-negative integer cups of champagne, return how full the j-th glass in the i-th row is (both i and j are 0 indexed.)\n", "solutions": ["class Solution {\n    public double champagneTower(int poured, int query_row, int query_glass) {\n        double[][] A = new double[102][102];\n        A[0][0] = (double) poured;\n        for (int r = 0; r <= query_row; ++r) {\n            for (int c = 0; c <= r; ++c) {\n                double q = (A[r][c] - 1.0) / 2.0;\n                if (q > 0) {\n                    A[r+1][c] += q;\n                    A[r+1][c+1] += q;\n                }\n            }\n        }\n        return Math.min(1, A[query_row][query_glass]);\n    }\n}\n"]}
{"number": 800, "statement": "In the following, every capital letter represents some hexadecimal digit from 0 to f.\nThe red-green-blue color \"#AABBCC\"can be writtenas\"#ABC\" inshorthand. For example, \"#15c\" is shorthand for the color \"#1155cc\".\nNow, say the similarity between two colors \"#ABCDEF\" and \"#UVWXYZ\" is -(AB - UV)^2 -(CD - WX)^2 -(EF - YZ)^2.\nGiven the color \"#ABCDEF\", return a 7 character colorthat is most similar to #ABCDEF, and has a shorthand (that is, it can be represented as some \"#XYZ\"\n", "solutions": ["class Solution {\n    public String similarRGB(String color) {\n        int hex1 = Integer.parseInt(color.substring(1), 16);\n        int ans = 0;\n        for (int r = 0; r < 16; ++r)\n            for (int g = 0; g < 16; ++g)\n                for (int b = 0; b < 16; ++b) {\n                    int hex2 = 17 * r * (1 << 16) + 17 * g * (1 << 8) + 17 * b;\n                    if (similarity(hex1, hex2) > similarity(hex1, ans))\n                        ans = hex2;\n                }\n        return String.format(\"#%06x\", ans);\n    }\n    public int similarity(int hex1, int hex2) {\n        int ans = 0;\n        for (int shift = 16; shift >= 0; shift -= 8) {\n            int col1 = (hex1 >> shift) % 256;\n            int col2 = (hex2 >> shift) % 256;\n            ans -= (col1 - col2) * (col1 - col2);\n        }\n        return ans;\n    }\n}\n", "class Solution {\n    public String similarRGB(String color) {\n        return \"#\" + f(color.substring(1, 3)) + f(color.substring(3, 5)) + f(color.substring(5));\n    }\n    public String f(String comp) {\n        int q = Integer.parseInt(comp, 16);\n        q = q / 17 + (q % 17 > 8 ? 1 : 0);\n        return String.format(\"%02x\", 17 * q);\n    }\n}\n"]}
{"number": 801, "statement": "We have two integer sequences A and B of the same non-zero length.\nWe are allowed to swap elements A[i] and B[i]. Note that both elements are in the same index position in their respective sequences.\nAt the end of some number of swaps, A and B are both strictly increasing. (A sequence is strictly increasing if and only if A[0]  A[1]  A[2]  ...  A[A.length - 1].)\nGiven A and B, return the minimum number of swaps to make both sequences strictly increasing. It is guaranteed that the given input always makes it possible.\n", "solutions": ["class Solution {\n    public int minSwap(int[] A, int[] B) {\n        // n: natural, s: swapped\n        int n1 = 0, s1 = 1;\n        for (int i = 1; i < A.length; ++i) {\n            int n2 = Integer.MAX_VALUE, s2 = Integer.MAX_VALUE;\n            if (A[i-1] < A[i] && B[i-1] < B[i]) {\n                n2 = Math.min(n2, n1);\n                s2 = Math.min(s2, s1 + 1);\n            }\n            if (A[i-1] < B[i] && B[i-1] < A[i]) {\n                n2 = Math.min(n2, s1);\n                s2 = Math.min(s2, n1 + 1);\n            }\n            n1 = n2;\n            s1 = s2;\n        }\n        return Math.min(n1, s1);\n    }\n}\n"]}
{"number": 802, "statement": "In a directed graph, we start at some node and every turn, walk along a directed edge of the graph. If we reach a node that is terminal (that is, it has no outgoing directed edges), we stop.\nNow, say our starting node is eventually safeif and only if we must eventually walk to a terminal node. More specifically, there exists a natural number K so that for any choice of where to walk, we must have stopped at a terminal node in less than K steps.\nWhich nodes are eventually safe? Return them as an array in sorted order.\nThe directed graph has N nodes with labels 0, 1, ..., N-1, where N is the length of graph. Thegraph is given in the following form: graph[i] is a list of labels j such that (i, j) is a directed edge of the graph.\n", "solutions": ["class Solution {\n    public List<Integer> eventualSafeNodes(int[][] G) {\n        int N = G.length;\n        boolean[] safe = new boolean[N];\n        List<Set<Integer>> graph = new ArrayList();\n        List<Set<Integer>> rgraph = new ArrayList();\n        for (int i = 0; i < N; ++i) {\n            graph.add(new HashSet());\n            rgraph.add(new HashSet());\n        }\n        Queue<Integer> queue = new LinkedList();\n        for (int i = 0; i < N; ++i) {\n            if (G[i].length == 0)\n                queue.offer(i);\n            for (int j: G[i]) {\n                graph.get(i).add(j);\n                rgraph.get(j).add(i);\n            }\n        }\n        while (!queue.isEmpty()) {\n            int j = queue.poll();\n            safe[j] = true;\n            for (int i: rgraph.get(j)) {\n                graph.get(i).remove(j);\n                if (graph.get(i).isEmpty())\n                    queue.offer(i);\n            }\n        }\n        List<Integer> ans = new ArrayList();\n        for (int i = 0; i < N; ++i) if (safe[i])\n            ans.add(i);\n        return ans;\n    }\n}\n", "class Solution {\n    public List<Integer> eventualSafeNodes(int[][] graph) {\n        int N = graph.length;\n        int[] color = new int[N];\n        List<Integer> ans = new ArrayList();\n        for (int i = 0; i < N; ++i)\n            if (dfs(i, color, graph))\n                ans.add(i);\n        return ans;\n    }\n    // colors: WHITE 0, GRAY 1, BLACK 2;\n    public boolean dfs(int node, int[] color, int[][] graph) {\n        if (color[node] > 0)\n            return color[node] == 2;\n        color[node] = 1;\n        for (int nei: graph[node]) {\n            if (color[node] == 2)\n                continue;\n            if (color[nei] == 1 || !dfs(nei, color, graph))\n                return false;\n        }\n        color[node] = 2;\n        return true;\n    }\n}\n"]}
{"number": 803, "statement": "We have a grid of 1s and 0s; the 1s in a cell represent bricks. A brick will not drop if and only if it is directly connected to the top of the grid, or at least one of its (4-way) adjacent bricks will not drop.\nWe will do some erasuressequentially. Each time we want to do the erasure at the location (i, j), the brick (if it exists) on that location will disappear, and then some other bricks maydrop because of thaterasure.\nReturn an array representing the number of bricks that will drop after each erasure in sequence.\n", "solutions": ["class Solution {\n    public int[] hitBricks(int[][] grid, int[][] hits) {\n        int R = grid.length, C = grid[0].length;\n        int[] dr = {1, 0, -1, 0};\n        int[] dc = {0, 1, 0, -1};\n        int[][] A = new int[R][C];\n        for (int r = 0; r < R; ++r)\n            A[r] = grid[r].clone();\n        for (int[] hit: hits)\n            A[hit[0]][hit[1]] = 0;\n        DSU dsu = new DSU(R*C + 1);\n        for (int r = 0; r < R; ++r) {\n            for (int c = 0; c < C; ++c) {\n                if (A[r][c] == 1) {\n                    int i = r * C + c;\n                    if (r == 0)\n                        dsu.union(i, R*C);\n                    if (r > 0 && A[r-1][c] == 1)\n                        dsu.union(i, (r-1) *C + c);\n                    if (c > 0 && A[r][c-1] == 1)\n                        dsu.union(i, r * C + c-1);\n                }\n            }\n        }\n        int t = hits.length;\n        int[] ans = new int[t--];\n        while (t >= 0) {\n            int r = hits[t][0];\n            int c = hits[t][1];\n            int preRoof = dsu.top();\n            if (grid[r][c] == 0) {\n                t--;\n            } else {\n                int i = r * C + c;\n                for (int k = 0; k < 4; ++k) {\n                    int nr = r + dr[k];\n                    int nc = c + dc[k];\n                    if (0 <= nr && nr < R && 0 <= nc && nc < C && A[nr][nc] == 1)\n                        dsu.union(i, nr * C + nc);\n                }\n                if (r == 0)\n                    dsu.union(i, R*C);\n                A[r][c] = 1;\n                ans[t--] = Math.max(0, dsu.top() - preRoof - 1);\n            }\n        }\n        return ans;\n    }\n}\nclass DSU {\n    int[] parent;\n    int[] rank;\n    int[] sz;\n    public DSU(int N) {\n        parent = new int[N];\n        for (int i = 0; i < N; ++i)\n            parent[i] = i;\n        rank = new int[N];\n        sz = new int[N];\n        Arrays.fill(sz, 1);\n    }\n    public int find(int x) {\n        if (parent[x] != x) parent[x] = find(parent[x]);\n        return parent[x];\n    }\n    public void union(int x, int y) {\n        int xr = find(x), yr = find(y);\n        if (xr == yr) return;\n        if (rank[xr] < rank[yr]) {\n            int tmp = yr;\n            yr = xr;\n            xr = tmp;\n        }\n        if (rank[xr] == rank[yr])\n            rank[xr]++;\n        parent[yr] = xr;\n        sz[xr] += sz[yr];\n    }\n    public int size(int x) {\n        return sz[find(x)];\n    }\n    public int top() {\n        return size(sz.length - 1) - 1;\n    }\n}\n"]}
{"number": 804, "statement": "International Morse Code defines a standard encoding where each letter is mapped to a series of dots and dashes, as follows: \"a\" maps to \".-\", \"b\" maps to \"-...\", \"c\" maps to \"-.-.\", and so on.\nFor convenience, the full table for the 26 letters of the English alphabet is given below:\n[\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\nNow, given a list of words, each word can be written as a concatenation of the Morse code of each letter. For example, \"cba\" can be written as \"-.-..--...\", (which is the concatenation \"-.-.\" + \"-...\" + \".-\"). We'll call such a concatenation, the transformationof a word.\nReturn the number of different transformations among all words we have.\n", "solutions": ["class Solution {\n    public int uniqueMorseRepresentations(String[] words) {\n        String[] MORSE = new String[]{\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\n                         \"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\n                         \"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\n                         \"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\n        Set<String> seen = new HashSet();\n        for (String word: words) {\n            StringBuilder code = new StringBuilder();\n            for (char c: word.toCharArray())\n                code.append(MORSE[c - 'a']);\n            seen.add(code.toString());\n        }\n        return seen.size();\n    }\n}\n"]}
{"number": 805, "statement": "In a given integer array A, we must move every element of A to either list B or list C. (B and C initially start empty.)\nReturn true if and only if after such a move, it is possible that the average value of B is equal to the average value of C, and B and C are both non-empty.\n", "solutions": ["import java.awt.Point;\nclass Solution {\n    public boolean splitArraySameAverage(int[] A) {\n        int N = A.length;\n        int S = 0;\n        for (int x: A) S += x;\n        if (N == 1) return false;\n        int g = gcd(S, N);\n        Point mu = new Point(-(S/g), N/g);\n        // A[i] -> fracAdd(A[i], mu)\n        List<Point> A2 = new ArrayList();\n        for (int x: A)\n            A2.add(fracAdd(new Point(x, 1), mu));\n        Set<Point> left = new HashSet();\n        left.add(A2.get(0));\n        for (int i = 1; i < N/2; ++i) {\n            Set<Point> left2 = new HashSet();\n            Point z = A2.get(i);\n            left2.add(z);\n            for (Point p: left) {\n                left2.add(p);\n                left2.add(fracAdd(p, z));\n            }\n            left = left2;\n        }\n        if (left.contains(new Point(0, 1))) return true;\n        Set<Point> right = new HashSet();\n        right.add(A2.get(N-1));\n        for (int i = N/2; i < N-1; ++i) {\n            Set<Point> right2 = new HashSet();\n            Point z = A2.get(i);\n            right2.add(z);\n            for (Point p: right) {\n                right2.add(p);\n                right2.add(fracAdd(p, z));\n            }\n            right = right2;\n        }\n        if (right.contains(new Point(0, 1))) return true;\n        Point sleft = new Point(0, 1);\n        for (int i = 0; i < N/2; ++i)\n            sleft = fracAdd(sleft, A2.get(i));\n        Point sright = new Point(0, 1);\n        for (int i = N/2; i < N; ++i)\n            sright = fracAdd(sright, A2.get(i));\n        for (Point ha: left) {\n            Point ha2 = new Point(-ha.x, ha.y);\n            if (right.contains(ha2) && (!ha.equals(sleft) || !ha2.equals(sright)))\n                return true;\n        }\n        return false;\n    }\n    public Point fracAdd(Point A, Point B) {\n        int numer = A.x * B.y + B.x * A.y;\n        int denom = A.y * B.y;\n        int g = gcd(numer, denom);\n        numer /= g;\n        denom /= g;\n        if (denom < 0) {\n            numer *= -1;\n            denom *= -1;\n        }\n        return new Point(numer, denom);\n    }\n    public int gcd(int a, int b) {\n       if (b==0) return a;\n       return gcd(b, a%b);\n    }\n}\n"]}
{"number": 806, "statement": "We are to write the letters of a given string S, from left to right into lines. Each line has maximum width 100 units, and if writing a letter would cause the width of the line to exceed 100 units, it is written on the next line. We are given an arraywidths, an array where widths[0] is the width of 'a', widths[1] is the width of 'b', ..., and widths[25] is the width of 'z'.\nNow answer two questions: how many lines have at least one character from S, and what is the width used by the last such line? Return your answer as an integer list of length 2.\n", "solutions": ["class Solution {\n    public int[] numberOfLines(int[] widths, String S) {\n        int lines = 1, width = 0;\n        for (char c: S.toCharArray()) {\n            int w = widths[c - 'a'];\n            width += w;\n            if (width > 100) {\n                lines++;\n                width = w;\n            }\n        }\n        return new int[]{lines, width};\n    }\n}\n"]}
{"number": 807, "statement": "In a 2 dimensional array grid, each value grid[i][j] represents the height of a building located there. We are allowed to increase the height of any number of buildings, by any amount (the amountscan be different for different buildings). Height0 is considered to be abuildingas well.\nAt the end, the \"skyline\" when viewed from all four directionsof the grid, i.e.top, bottom, left, and right,must be the same as theskyline of the original grid. A city's skyline is the outer contour of the rectangles formed by all the buildings when viewed from a distance. Seethe following example.\nWhat is the maximum total sum that the height of the buildings can be increased?\n", "solutions": ["class Solution {\n    public int maxIncreaseKeepingSkyline(int[][] grid) {\n        int N = grid.length;\n        int[] rowMaxes = new int[N];\n        int[] colMaxes = new int[N];\n        for (int r = 0; r < N; ++r)\n            for (int c = 0; c < N; ++c) {\n                rowMaxes[r] = Math.max(rowMaxes[r], grid[r][c]);\n                colMaxes[c] = Math.max(colMaxes[c], grid[r][c]);\n        }\n        int ans = 0;\n        for (int r = 0; r < N; ++r)\n            for (int c = 0; c < N; ++c)\n                ans += Math.min(rowMaxes[r], colMaxes[c]) - grid[r][c];\n        return ans;\n    }\n}\n"]}
{"number": 808, "statement": "There are two types of soup: type A and type B. Initially we have N ml of each type of soup. There are four kinds of operations:\nServe100 ml of soup A and 0 ml of soup B\nServe75 ml of soup A and 25ml of soup B\nServe 50 ml of soup A and 50 ml of soup B\nServe 25ml of soup A and 75ml of soup B\nWhen we serve some soup, we give it to someone and we no longer have it. Each turn,we will choose from the four operations with equal probability 0.25. If the remaining volume of soup is not enough to complete the operation, we will serveas much as we can. We stop once we no longer have some quantity of both types of soup.\nNote that we do not have the operation where all 100 ml's of soup B are used first.\nReturn the probability that soup A will be emptyfirst, plus half the probability that A and B become empty at the same time.\n", "solutions": ["class Solution {\n    public double soupServings(int N) {\n        N = N/25 + (N%25 > 0 ? 1 : 0);\n        if (N >= 500) return 1.0;\n        double[][] memo = new double[N+1][N+1];\n        for (int s = 0; s <= 2*N; ++s) {\n            for (int i = 0; i <= N; ++i) {\n                int j = s-i;\n                if (j < 0 || j > N) continue;\n                double ans = 0.0;\n                if (i == 0) ans = 1.0;\n                if (i == 0 && j == 0) ans = 0.5;\n                if (i > 0 && j > 0) {\n                    ans = 0.25 * (memo[M(i-4)][j] + memo[M(i-3)][M(j-1)] +\n                                  memo[M(i-2)][M(j-2)] + memo[M(i-1)][M(j-3)]);\n                }\n                memo[i][j] = ans;\n            }\n        }\n        return memo[N][N];\n    }\n    public int M(int x) { return Math.max(0, x); }\n}\n"]}
{"number": 809, "statement": "Sometimes people repeat letters to represent extra feeling, such as \"hello\" - \"heeellooo\", \"hi\" - \"hiiii\". In these strings like \"heeellooo\", we have groups of adjacent letters that are all the same: \"h\", \"eee\", \"ll\", \"ooo\".\nFor some given string S, a query word is stretchy if it can be made to be equal to S by anynumber ofapplications of the following extension operation: choose a group consisting ofcharacters c, and add some number of characters c to the group so that the size of the group is 3 or more.\nFor example, starting with \"hello\", we could do an extension on the group \"o\" to get \"hellooo\", but we cannot get \"helloo\" since the group \"oo\" has size less than 3. Also, we could do another extension like \"ll\" - \"lllll\" to get \"helllllooo\". If S = \"helllllooo\", then the query word \"hello\" would be stretchy because of these two extension operations:query = \"hello\" - \"hellooo\" -\"helllllooo\" = S.\nGiven a list of query words, return the number of words that are stretchy.\n", "solutions": ["class Solution {\n    public int expressiveWords(String S, String[] words) {\n        RLE R = new RLE(S);\n        int ans = 0;\n        search: for (String word: words) {\n            RLE R2 = new RLE(word);\n            if (!R.key.equals(R2.key)) continue;\n            for (int i = 0; i < R.counts.size(); ++i) {\n                int c1 = R.counts.get(i);\n                int c2 = R2.counts.get(i);\n                if (c1 < 3 && c1 != c2 || c1 < c2)\n                    continue search;\n            }\n            ans++;\n        }\n        return ans;\n    }\n}\nclass RLE {\n    String key;\n    List<Integer> counts;\n    public RLE(String S) {\n        StringBuilder sb = new StringBuilder();\n        counts = new ArrayList();\n        char[] ca = S.toCharArray();\n        int N = ca.length;\n        int prev = -1;\n        for (int i = 0; i < N; ++i) {\n            if (i == N-1 || ca[i] != ca[i+1]) {\n                sb.append(ca[i]);\n                counts.add(i - prev);\n                prev = i;\n            }\n        }\n        key = sb.toString();\n    }\n}\n"]}
{"number": 810, "statement": "We are given non-negative integers nums[i] which are written on a chalkboard. Alice and Bob take turns erasing exactly one number from the chalkboard, with Alice starting first. If erasing a number causesthe bitwise XOR of all the elements of the chalkboard to become0, then that player loses. (Also, we'll say the bitwise XOR of one element is that element itself, and the bitwise XOR of no elements is 0.)\nAlso, if any player starts their turn with the bitwise XOR of all the elements of the chalkboard equal to 0, then that player wins.\nReturn True if and only if Alice wins the game, assuming both players play optimally.\n", "solutions": ["class Solution {\n    public boolean xorGame(int[] nums) {\n      int x = 0;\n      for (int v : nums) x ^= v;\n      return x == 0 || nums.length % 2 == 0;\n    }\n}\n"]}
{"number": 811, "statement": "A website domain like \"discuss.leetcode.com\" consists of various subdomains. At the top level, we have \"com\", at the next level, we have \"leetcode.com\", and at the lowest level, \"discuss.leetcode.com\". When we visit a domain like \"discuss.leetcode.com\", we will also visit the parent domains \"leetcode.com\" and \"com\" implicitly.\nNow, call a \"count-paired domain\" to be a count (representing the number of visits this domain received), followed by a space, followed by the address. An example of a count-paired domain might be \"9001 discuss.leetcode.com\".\nWe are given a list cpdomains of count-paired domains. We would like a list of count-paired domains, (in the same format as the input, and in any order), that explicitly counts the number of visits to each subdomain.\n", "solutions": ["class Solution {\n    public List<String> subdomainVisits(String[] cpdomains) {\n        Map<String, Integer> counts = new HashMap();\n        for (String domain: cpdomains) {\n            String[] cpinfo = domain.split(\"\\\\s+\");\n            String[] frags = cpinfo[1].split(\"\\\\.\");\n            int count = Integer.valueOf(cpinfo[0]);\n            String cur = \"\";\n            for (int i = frags.length - 1; i >= 0; --i) {\n                cur = frags[i] + (i < frags.length - 1 ? \".\" : \"\") + cur;\n                counts.put(cur, counts.getOrDefault(cur, 0) + count);\n            }\n        }\n        List<String> ans = new ArrayList();\n        for (String dom: counts.keySet())\n            ans.add(\"\" + counts.get(dom) + \" \" + dom);\n        return ans;\n    }\n}\n"]}
{"number": 812, "statement": "You have a list of points in the plane. Return the area of the largest triangle that can be formed by any 3 of the points.\n", "solutions": ["class Solution {\n    public double largestTriangleArea(int[][] points) {\n        int N = points.length;\n        double ans = 0;\n        for (int i = 0; i < N; ++i)\n            for (int j = i+1; j < N; ++j)\n                for (int k = j+1; k < N; ++k)\n                    ans = Math.max(ans, area(points[i], points[j], points[k]));\n        return ans;\n    }\n    public double area(int[] P, int[] Q, int[] R) {\n        return 0.5 * Math.abs(P[0]*Q[1] + Q[0]*R[1] + R[0]*P[1]\n                             -P[1]*Q[0] - Q[1]*R[0] - R[1]*P[0]);\n    }\n}\n"]}
{"number": 813, "statement": "We partition a row of numbers Ainto at most K adjacent (non-empty) groups, then our score is the sum of the average of each group. What is the largest score we can achieve?\nNote that our partition must use every number in A, and that scores are not necessarily integers.\n", "solutions": ["class Solution {\n    public double largestSumOfAverages(int[] A, int K) {\n        int N = A.length;\n        double[] P = new double[N+1];\n        for (int i = 0; i < N; ++i)\n            P[i+1] = P[i] + A[i];\n        double[] dp = new double[N];\n        for (int i = 0; i < N; ++i)\n            dp[i] = (P[N] - P[i]) / (N - i);\n        for (int k = 0; k < K-1; ++k)\n            for (int i = 0; i < N; ++i)\n                for (int j = i+1; j < N; ++j)\n                    dp[i] = Math.max(dp[i], (P[j]-P[i]) / (j-i) + dp[j]);\n        return dp[0];\n    }\n}\n"]}
{"number": 814, "statement": "We are given the head node rootof a binary tree, where additionally every node's value is either a 0 or a 1.\nReturn the same tree where every subtree (of the given tree) not containing a 1 has been removed.\n(Recall that the subtree of a node X is X, plus every node that is a descendant of X.)\n", "solutions": ["class Solution {\n    public TreeNode pruneTree(TreeNode root) {\n        return containsOne(root) ? root : null;\n    }\n    public boolean containsOne(TreeNode node) {\n        if (node == null) return false;\n        boolean a1 = containsOne(node.left);\n        boolean a2 = containsOne(node.right);\n        if (!a1) node.left = null;\n        if (!a2) node.right = null;\n        return node.val == 1 || a1 || a2;\n    }\n}\n"]}
{"number": 815, "statement": "We have a list of bus routes. Each routes[i] is a bus route that the i-th busrepeats forever. For example if routes[0] = [1, 5, 7], this means that the firstbus (0-th indexed) travels in the sequence 1-5-7-1-5-7-1-... forever.\nWe start at bus stop S (initially not on a bus), and we want to go to bus stop T. Travelling by buses only, what is the least number of buses we must take to reach our destination? Return -1 if it is not possible.\n", "solutions": ["import java.awt.Point;\nclass Solution {\n    public int numBusesToDestination(int[][] routes, int S, int T) {\n        if (S==T) return 0;\n        int N = routes.length;\n        List<List<Integer>> graph = new ArrayList();\n        for (int i = 0; i < N; ++i) {\n            Arrays.sort(routes[i]);\n            graph.add(new ArrayList());\n        }\n        Set<Integer> seen = new HashSet();\n        Set<Integer> targets = new HashSet();\n        Queue<Point> queue = new ArrayDeque();\n        // Build the graph.  Two buses are connected if\n        // they share at least one bus stop.\n        for (int i = 0; i < N; ++i)\n            for (int j = i+1; j < N; ++j)\n                if (intersect(routes[i], routes[j])) {\n                    graph.get(i).add(j);\n                    graph.get(j).add(i);\n                }\n        // Initialize seen, queue, targets.\n        // seen represents whether a node has ever been enqueued to queue.\n        // queue handles our breadth first search.\n        // targets is the set of goal states we have.\n        for (int i = 0; i < N; ++i) {\n            if (Arrays.binarySearch(routes[i], S) >= 0) {\n                seen.add(i);\n                queue.offer(new Point(i, 0));\n            }\n            if (Arrays.binarySearch(routes[i], T) >= 0)\n                targets.add(i);\n        }\n        while (!queue.isEmpty()) {\n            Point info = queue.poll();\n            int node = info.x, depth = info.y;\n            if (targets.contains(node)) return depth+1;\n            for (Integer nei: graph.get(node)) {\n                if (!seen.contains(nei)) {\n                    seen.add(nei);\n                    queue.offer(new Point(nei, depth+1));\n                }\n            }\n        }\n        return -1;\n    }\n    public boolean intersect(int[] A, int[] B) {\n        int i = 0, j = 0;\n        while (i < A.length && j < B.length) {\n            if (A[i] == B[j]) return true;\n            if (A[i] < B[j]) i++; else j++;\n        }\n        return false;\n    }\n}\n"]}
{"number": 816, "statement": "We had some 2-dimensional coordinates, like \"(1, 3)\" or \"(2, 0.5)\". Then, we removedall commas, decimal points, and spaces, and ended up with the stringS. Return a list of strings representingall possibilities for what our original coordinates could have been.\nOur original representation never had extraneous zeroes, so we never started with numbers like \"00\", \"0.0\", \"0.00\", \"1.0\", \"001\", \"00.01\", or any other number that can be represented withless digits. Also, a decimal point within a number never occurs without at least one digit occuring before it, so we never started with numbers like \".1\".\nThe final answer list can be returned in any order. Also note that all coordinates in the final answerhave exactly one space between them (occurring after the comma.)\n", "solutions": ["class Solution { //aw\n    public List<String> ambiguousCoordinates(String S) {\n        List<String> ans = new ArrayList();\n        for (int i = 2; i < S.length()-1; ++i)\n            for (String left: make(S, 1, i))\n                for (String right: make(S, i, S.length()-1))\n                    ans.add(\"(\" + left + \", \" + right + \")\");\n        return ans;\n    }\n    public List<String> make(String S, int i, int j) {\n        // Make on S.substring(i, j)\n        List<String> ans = new ArrayList();\n        for (int d = 1; d <= j-i; ++d) {\n            String left = S.substring(i, i+d);\n            String right = S.substring(i+d, j);\n            if ((!left.startsWith(\"0\") || left.equals(\"0\"))\n                    && !right.endsWith(\"0\"))\n                ans.add(left + (d < j-i ? \".\" : \"\") + right);\n        }\n        return ans;\n    }\n}\n"]}
{"number": 817, "statement": "We are givenhead,the head node of a linked list containingunique integer values.\nWe are also given the listG, a subset of the values in the linked list.\nReturn the number of connected components in G, where two values are connected if they appear consecutively in the linked list.\n", "solutions": ["class Solution {\n    public int numComponents(ListNode head, int[] G) {\n        Set<Integer> Gset = new HashSet();\n        for (int x: G) Gset.add(x);\n        ListNode cur = head;\n        int ans = 0;\n        while (cur != null) {\n            if (Gset.contains(cur.val) &&\n                    (cur.next == null || !Gset.contains(cur.next.val)))\n                ans++;\n            cur = cur.next;\n        }\n        return ans;\n    }\n}\n"]}
{"number": 818, "statement": "Your car starts at position 0 and speed +1 on an infinite number line. (Your car can go into negative positions.)\nYour car drives automatically according to a sequence of instructions A (accelerate) and R (reverse).\nWhen you get an instruction \"A\", your car does the following:position += speed, speed *= 2.\nWhen you get an instruction \"R\", your car does the following: if your speed is positive thenspeed = -1, otherwisespeed = 1. (Your position stays the same.)\nFor example, after commands \"AAR\", your car goes to positions 0-1-3-3, and your speed goes to 1-2-4--1.\nNow for some target position, say the length of the shortest sequence of instructions to get there.\n", "solutions": ["class Solution {\n    public int racecar(int target) {\n        int K = 33 - Integer.numberOfLeadingZeros(target - 1);\n        int barrier = 1 << K;\n        int[] dist = new int[2 * barrier + 1];\n        Arrays.fill(dist, Integer.MAX_VALUE);\n        dist[target] = 0;\n        PriorityQueue<Node> pq = new PriorityQueue<Node>(\n            (a, b) -> a.steps - b.steps);\n        pq.offer(new Node(0, target));\n        while (!pq.isEmpty()) {\n            Node node = pq.poll();\n            int steps = node.steps, targ1 = node.target;\n            if (dist[Math.floorMod(targ1, dist.length)] > steps) continue;\n            for (int k = 0; k <= K; ++k) {\n                int walk = (1 << k) - 1;\n                int targ2 = walk - targ1;\n                int steps2 = steps + k + (targ2 != 0 ? 1 : 0);\n                if (Math.abs(targ2) <= barrier && steps2 < dist[Math.floorMod(targ2, dist.length)]) {\n                    pq.offer(new Node(steps2, targ2));\n                    dist[Math.floorMod(targ2, dist.length)] = steps2;\n                }\n            }\n        }\n        return dist[0];\n    }\n}\nclass Node {\n    int steps, target;\n    Node(int s, int t) {\n        steps = s;\n        target = t;\n    }\n}\n", "class Solution {\n    public int racecar(int target) {\n        int[] dp = new int[target + 3];\n        Arrays.fill(dp, Integer.MAX_VALUE);\n        dp[0] = 0; dp[1] = 1; dp[2] = 4;\n        for (int t = 3; t <= target; ++t) {\n            int k = 32 - Integer.numberOfLeadingZeros(t);\n            if (t == (1<<k) - 1) {\n                dp[t] = k;\n                continue;\n            }\n            for (int j = 0; j < k-1; ++j)\n                dp[t] = Math.min(dp[t], dp[t - (1<<(k-1)) + (1<<j)] + k-1 + j + 2);\n            if ((1<<k) - 1 - t < t)\n                dp[t] = Math.min(dp[t], dp[(1<<k) - 1 - t] + k + 1);\n        }\n        return dp[target];  \n    }\n}\n"]}
{"number": 819, "statement": "Given a paragraphand a list of banned words, return the most frequent word that is not in the list of banned words. It is guaranteed there is at least one word that isn't banned, and that the answer is unique.\nWords in the list of banned words are given in lowercase, and free of punctuation. Words in the paragraph are not case sensitive. The answer is in lowercase.\n", "solutions": ["class Solution {\n    public String mostCommonWord(String paragraph, String[] banned) {\n        paragraph += \".\";\n        Set<String> banset = new HashSet();\n        for (String word: banned) banset.add(word);\n        Map<String, Integer> count = new HashMap();\n        String ans = \"\";\n        int ansfreq = 0;\n        StringBuilder word = new StringBuilder();\n        for (char c: paragraph.toCharArray()) {\n            if (Character.isLetter(c)) {\n                word.append(Character.toLowerCase(c));\n            } else if (word.length() > 0) {\n                String finalword = word.toString();\n                if (!banset.contains(finalword)) {\n                    count.put(finalword, count.getOrDefault(finalword, 0) + 1);\n                    if (count.get(finalword) > ansfreq) {\n                        ans = finalword;\n                        ansfreq = count.get(finalword);\n                    }\n                }\n                word = new StringBuilder();\n            }\n        }\n        return ans;\n    }\n}\n"]}
{"number": 820, "statement": "Given a list of words, we may encode it by writing a reference string S and a list of indexes A.\nFor example, if the list of words is [\"time\", \"me\", \"bell\"], we can write it as S = \"time#bell#\"and indexes = [0, 2, 5].\nThen for each index, we will recover the word by reading from the reference string from that index until we reach a \"#\" character.\nWhat is the length of the shortest reference string S possible that encodes the given words?\n", "solutions": ["class Solution {\n    public int minimumLengthEncoding(String[] words) {\n        TrieNode trie = new TrieNode();\n        Map<TrieNode, Integer> nodes = new HashMap();\n        for (int i = 0; i < words.length; ++i) {\n            String word = words[i];\n            TrieNode cur = trie;\n            for (int j = word.length() - 1; j >= 0; --j)\n                cur = cur.get(word.charAt(j));\n            nodes.put(cur, i);\n        }\n        int ans = 0;\n        for (TrieNode node: nodes.keySet()) {\n            if (node.count == 0)\n                ans += words[nodes.get(node)].length() + 1;\n        }\n        return ans;\n    }\n}\nclass TrieNode {\n    TrieNode[] children;\n    int count;\n    TrieNode() {\n        children = new TrieNode[26];\n        count = 0;\n    }\n    public TrieNode get(char c) {\n        if (children[c-'a'] == null) {\n            children[c-'a'] = new TrieNode();\n            count++;\n        }\n        return children[c - 'a'];\n    }\n}\n"]}
{"number": 821, "statement": "Given a string Sand a character C, return an array of integers representing the shortest distance from the character C in the string.\n", "solutions": ["class Solution {\n    public int[] shortestToChar(String S, char C) {\n        int N = S.length();\n        int[] ans = new int[N];\n        int prev = Integer.MIN_VALUE / 2;\n        for (int i = 0; i < N; ++i) {\n            if (S.charAt(i) == C) prev = i;\n            ans[i] = i - prev;\n        }\n        prev = Integer.MAX_VALUE / 2;\n        for (int i = N-1; i >= 0; --i) {\n            if (S.charAt(i) == C) prev = i;\n            ans[i] = Math.min(ans[i], prev - i);\n        }\n        return ans;\n    }\n}\n"]}
{"number": 822, "statement": "On a table are N cards, with a positive integer printed on the front and back of each card (possibly different).\nWe flip any number of cards, and after we choose onecard.\nIf the number X on the back of the chosencard is not on the front of any card, then this number X is good.\nWhat is the smallest number that is good? If no number is good, output 0.\nHere, fronts[i] and backs[i] represent the number on the front and back of card i.\nAflip swaps the front and back numbers, so the value on the front is now on the back and vice versa.\n", "solutions": ["class Solution {\n    public int flipgame(int[] fronts, int[] backs) {\n        Set<Integer> same = new HashSet();\n        for (int i = 0; i < fronts.length; ++i)\n            if (fronts[i] == backs[i])\n                same.add(fronts[i]);\n        int ans = 9999;\n        for (int x: fronts)\n            if (!same.contains(x))\n                ans = Math.min(ans, x);\n        for (int x: backs)\n            if (!same.contains(x))\n                ans = Math.min(ans, x);\n        return ans % 9999;\n    }\n}\n"]}
{"number": 824, "statement": "A sentence S is given, composed of words separated by spaces. Each word consists of lowercase and uppercase letters only.\nWe would like to convert the sentence to \"Goat Latin\"(a made-up language similar to Pig Latin.)\nThe rules of Goat Latin are as follows:\nIf a word begins with a vowel (a, e, i, o, or u), append \"ma\"to the end of the word.\nFor example, the word 'apple' becomes 'applema'.\nIf a word begins with a consonant (i.e. not a vowel), remove the first letter and append it to the end, then add \"ma\".\nFor example, the word \"goat\"becomes \"oatgma\".\nAdd one letter 'a'to the end of each word per its word index in the sentence, starting with 1.\nFor example,the first word gets \"a\" added to the end, the second word gets \"aa\" added to the end and so on.\nReturn thefinal sentence representing the conversion from Sto GoatLatin.\n", "solutions": ["class Solution {\n    public String toGoatLatin(String S) {\n        Set<Character> vowel = new HashSet();\n        for (char c: new char[]{'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'})\n            vowel.add(c);\n        int t = 1;\n        StringBuilder ans = new StringBuilder();\n        for (String word: S.split(\" \")) {\n            char first = word.charAt(0);\n            if (vowel.contains(first)) {\n                ans.append(word);\n            } else {\n                ans.append(word.substring(1));\n                ans.append(word.substring(0, 1));\n            }\n            ans.append(\"ma\");\n            for (int i = 0; i < t; i++)\n                ans.append(\"a\");\n            t++;\n            ans.append(\" \");\n        }\n        ans.deleteCharAt(ans.length() - 1);\n        return ans.toString();\n    }\n}\n"]}
{"number": 825, "statement": "Some people will make friend requests. Thelist of their ages is given andages[i]is the age of theith person.\nPerson A will NOT friend request person B (B != A) if any of the following conditions are true:\nage[B]= 0.5 * age[A]+ 7\nage[B] age[A]\nage[B] 100 age[A] 100\nOtherwise, A will friend request B.\nNote that ifA requests B, B does not necessarily request A. Also, people will not friend request themselves.\nHow many total friend requests are made?\n", "solutions": ["class Solution {\n    public int numFriendRequests(int[] ages) {\n        int[] count = new int[121];\n        for (int age: ages) count[age]++;\n        int ans = 0;\n        for (int ageA = 0; ageA <= 120; ageA++) {\n            int countA = count[ageA];\n            for (int ageB = 0; ageB <= 120; ageB++) {\n                int countB = count[ageB];\n                if (ageA * 0.5 + 7 >= ageB) continue;\n                if (ageA < ageB) continue;\n                if (ageA < 100 && 100 < ageB) continue;\n                ans += countA * countB;\n                if (ageA == ageB) ans -= countA;\n            }\n        }\n        return ans;\n    }\n}\n"]}
{"number": 826, "statement": "We have jobs: difficulty[i]is the difficulty of theith job, andprofit[i]is the profit of theith job.\nNow we have some workers.worker[i]is the ability of theith worker, which means that this worker can only complete a job with difficulty at mostworker[i].\nEvery worker can be assigned at most one job, but one jobcan be completed multiple times.\nFor example, if 3 people attempt the same job that pays $1, then the total profit will be $3. If a worker cannot complete any job, his profit is $0.\nWhat is the most profit we can make?\n", "solutions": ["import java.awt.Point;\nclass Solution {\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\n        int N = difficulty.length;\n        Point[] jobs = new Point[N];\n        for (int i = 0; i < N; ++i)\n            jobs[i] = new Point(difficulty[i], profit[i]);\n        Arrays.sort(jobs, (a, b) -> a.x - b.x);\n        Arrays.sort(worker);\n        int ans = 0, i = 0, best = 0;\n        for (int skill: worker) {\n            while (i < N && skill >= jobs[i].x)\n                best = Math.max(best, jobs[i++].y);\n            ans += best;\n        }\n        return ans;\n    }\n}\n"]}
{"number": 827, "statement": "In a 2D grid of 0s and 1s, we change at most one 0 to a 1.\nAfter, what is the size of the largest island?(An island is a 4-directionally connected group of 1s).\n", "solutions": ["class Solution {\n    int[] dr = new int[]{-1, 0, 1, 0};\n    int[] dc = new int[]{0, -1, 0, 1};\n    public int largestIsland(int[][] grid) {\n        int N = grid.length;\n        int ans = 0;\n        boolean hasZero = false;\n        for (int r = 0; r < N; ++r)\n            for (int c = 0; c < N; ++c)\n                if (grid[r][c] == 0) {\n                    hasZero = true;\n                    grid[r][c] = 1;\n                    ans = Math.max(ans, check(grid, r, c));\n                    grid[r][c] = 0;\n                }\n        return hasZero ? ans : N*N;\n    }\n    public int check(int[][] grid, int r0, int c0) {\n        int N = grid.length;\n        Stack<Integer> stack = new Stack();\n        Set<Integer> seen = new HashSet();\n        stack.push(r0 * N + c0);\n        seen.add(r0 * N + c0);\n        while (!stack.isEmpty()) {\n            int code = stack.pop();\n            int r = code / N, c = code % N;\n            for (int k = 0; k < 4; ++k) {\n                int nr = r + dr[k], nc = c + dc[k];\n                if (!seen.contains(nr * N + nc) && 0 <= nr && nr < N &&\n                        0 <= nc && nc < N && grid[nr][nc] == 1) {\n                    stack.push(nr * N + nc);\n                    seen.add(nr * N + nc);\n                }\n            }\n        }\n        return seen.size();\n    }\n}\n", "class Solution {\n    int[] dr = new int[]{-1, 0, 1, 0};\n    int[] dc = new int[]{0, -1, 0, 1};\n    int[][] grid;\n    int N;\n    public int largestIsland(int[][] grid) {\n        this.grid = grid;\n        N = grid.length;\n        int index = 2;\n        int[] area = new int[N*N + 2];\n        for (int r = 0; r < N; ++r)\n            for (int c = 0; c < N; ++c)\n                if (grid[r][c] == 1)\n                    area[index] = dfs(r, c, index++);\n        int ans = 0;\n        for (int x: area) ans = Math.max(ans, x);\n        for (int r = 0; r < N; ++r)\n            for (int c = 0; c < N; ++c)\n                if (grid[r][c] == 0) {\n                    Set<Integer> seen = new HashSet();\n                    for (Integer move: neighbors(r, c))\n                        if (grid[move / N][move % N] > 1)\n                            seen.add(grid[move / N][move % N]);\n                    int bns = 1;\n                    for (int i: seen) bns += area[i];\n                    ans = Math.max(ans, bns);\n                }\n        return ans;\n    }\n    public int dfs(int r, int c, int index) {\n        int ans = 1;\n        grid[r][c] = index;\n        for (Integer move: neighbors(r, c)) {\n            if (grid[move / N][move % N] == 1) {\n                grid[move / N][move % N] = index;\n                ans += dfs(move / N, move % N, index);\n            }\n        }\n        return ans;\n    }\n    public List<Integer> neighbors(int r, int c) {\n        List<Integer> ans = new ArrayList();\n        for (int k = 0; k < 4; ++k) {\n            int nr = r + dr[k];\n            int nc = c + dc[k];\n            if (0 <= nr && nr < N && 0 <= nc && nc < N)\n                ans.add(nr * N + nc);\n        }\n        return ans;\n    }\n}\n"]}
{"number": 828, "statement": "Let's define a function countUniqueChars(s)that returns the number of unique characters on s, for example if s = \"LEETCODE\"then \"L\", \"T\",\"C\",\"O\",\"D\" are the unique characters since they appear only once in s, thereforecountUniqueChars(s) = 5.\nOn this problem given a string s we need to return the sum ofcountUniqueChars(t)where t is a substring of s. Notice that some substrings can be repeated so on this case you have to count the repeated ones too.\nSince the answer can be very large, returnthe answermodulo10 ^ 9 + 7.\n", "solutions": ["class Solution {\n    Map<Character, List<Integer>> index;\n    int[] peek;\n    int N;\n    public int uniqueLetterString(String S) {\n        index = new HashMap();\n        peek = new int[26];\n        N = S.length();\n        for (int i = 0; i < S.length(); ++i) {\n            char c = S.charAt(i);\n            index.computeIfAbsent(c, x-> new ArrayList<Integer>()).add(i);\n        }\n        long cur = 0, ans = 0;\n        for (char c: index.keySet()) {\n            index.get(c).add(N);\n            index.get(c).add(N);\n            cur += get(c);\n        }\n        for (char c: S.toCharArray()) {\n            ans += cur;\n            long oldv = get(c);\n            peek[c - 'A']++;\n            cur += get(c) - oldv;\n        }\n        return (int) ans % 1_000_000_007;\n    }\n    public long get(char c) {\n        List<Integer> indexes = index.get(c);\n        int i = peek[c - 'A'];\n        return indexes.get(i+1) - indexes.get(i);\n    }\n}\n", "class Solution {\n    public int uniqueLetterString(String S) {\n        Map<Character, List<Integer>> index = new HashMap();\n        for (int i = 0; i < S.length(); ++i) {\n            char c = S.charAt(i);\n            index.computeIfAbsent(c, x-> new ArrayList<Integer>()).add(i);\n        }\n        long ans = 0;\n        for (List<Integer> A: index.values()) {\n            for (int i = 0; i < A.size(); ++i) {\n                long prev = i > 0 ? A.get(i-1) : -1;\n                long next = i < A.size() - 1 ? A.get(i+1) : S.length();\n                ans += (A.get(i) - prev) * (next - A.get(i));\n            }\n        }\n        return (int) ans % 1_000_000_007;\n    }\n}\n"]}
{"number": 829, "statement": "Given a positive integerN, how many ways can we write it as a sum ofconsecutive positive integers?\n", "solutions": ["class Solution {\n    public int consecutiveNumbersSum(int N) {\n        int ans = 0;\n        for (int start = 1; start <= N; ++start) {\n            int target = N, x = start;\n            while (target > 0)\n                target -= x++;\n            if (target == 0) ans++;\n        }\n        return ans;\n    }\n}\n", "class Solution {\n    public int consecutiveNumbersSum(int N) {\n        // 2N = k(2x + k + 1)\n        int ans = 0;\n        for (int k = 1; k <= 2*N; ++k)\n            if (2 * N % k == 0) {\n                int y = 2 * N / k - k - 1;\n                if (y % 2 == 0 && y >= 0)\n                    ans++;\n            }\n        return ans;\n    }\n}\n", "class Solution {\n    public int consecutiveNumbersSum(int N) {\n        while ((N & 1) == 0) N >>= 1;\n        int ans = 1, d = 3;\n        while (d * d <= N) {\n            int e = 0;\n            while (N % d == 0) {\n                N /= d;\n                e++;\n            }\n            ans *= e + 1;\n            d += 2;\n        }\n        if (N > 1) ans <<= 1;\n        return ans;\n    }\n}\n"]}
{"number": 830, "statement": "In a stringSof lowercase letters, these letters form consecutive groups of the same character.\nFor example, a string like S = \"abbxxxxzyy\" has the groups \"a\", \"bb\", \"xxxx\", \"z\" and\"yy\".\nCall a group large if it has 3 or more characters. We would like the starting and ending positions of every large group.\nThe final answer should be in lexicographic order.\n", "solutions": ["class Solution {\n    public List<List<Integer>> largeGroupPositions(String S) {\n        List<List<Integer>> ans = new ArrayList();\n        int i = 0, N = S.length(); // i is the start of each group\n        for (int j = 0; j < N; ++j) {\n            if (j == N-1 || S.charAt(j) != S.charAt(j+1)) {\n                // Here, [i, j] represents a group.\n                if (j-i+1 >= 3)\n                    ans.add(Arrays.asList(new Integer[]{i, j}));\n                i = j + 1;\n            }\n        }\n        return ans;\n    }\n}\n"]}
{"number": 831, "statement": "We are given apersonal information string S, which may representeither an email address or a phone number.\nWe would like to mask thispersonal information according to thefollowing rules:\n1. Email address:\nWe define aname to be a string of length \u2265 2 consistingof only lowercase lettersa-z or uppercaselettersA-Z.\nAn email address starts with a name, followed by thesymbol '@', followed by a name, followed by thedot'.'andfollowed by a name.\nAll email addresses areguaranteed to be valid and in the format of\"name1@name2.name3\".\nTo mask an email, all names must be converted to lowercase and all letters between the first and last letter of the first name must be replaced by 5 asterisks '*'.\n2. Phone number:\nA phone number is a string consisting ofonly the digits 0-9 or the characters from the set {'+', '-', '(', ')', ''}.You may assume a phonenumber contains10 to 13 digits.\nThe last 10 digits make up the localnumber, while the digits before those make up the country code. Note thatthe country code is optional. We want to expose only the last 4 digitsand mask all otherdigits.\nThe localnumbershould be formatted and masked as \"***-***-1111\",where 1 represents the exposed digits.\nTo mask a phone number with country code like \"+111 111 111 1111\", we write it in the form \"+***-***-***-1111\". The '+'sign and the first '-'sign before the local number should only exist if there is a country code. For example, a 12 digit phone number maskshould startwith \"+**-\".\nNote that extraneous characters like \"(\", \")\", \" \", as well asextra dashes or plus signs not part of the above formatting scheme should be removed.\nReturn the correct \"mask\" of the information provided.\n", "solutions": ["class Solution {\n    public String maskPII(String S) {\n        int atIndex = S.indexOf('@');\n        if (atIndex >= 0) { // email\n            return (S.substring(0, 1) + \"*****\" + S.substring(atIndex - 1)).toLowerCase();\n        } else { // phone\n            String digits = S.replaceAll(\"\\\\D+\", \"\");\n            String local = \"***-***-\" + digits.substring(digits.length() - 4);\n            if (digits.length() == 10) return local;\n            String ans = \"+\";\n            for (int i = 0; i < digits.length() - 10; ++i)\n                ans += \"*\";\n            return ans + \"-\" + local;\n        }\n    }\n}\n"]}
{"number": 832, "statement": "Given a binary matrix A, we want to flip the image horizontally, then invert it, and return the resulting image.\nTo flip an image horizontally means that each row of the image is reversed. For example, flipping[1, 1, 0]horizontally results in[0, 1, 1].\nTo invert an image meansthat each 0 is replaced by 1, and each 1 is replaced by 0.For example, inverting[0, 1, 1]results in[1, 0, 0].\n", "solutions": ["class Solution {\n    public int[][] flipAndInvertImage(int[][] A) {\n        int C = A[0].length;\n        for (int[] row: A)\n            for (int i = 0; i < (C + 1) / 2; ++i) {\n                int tmp = row[i] ^ 1;\n                row[i] = row[C - 1 - i] ^ 1;\n                row[C - 1 - i] = tmp;\n            }\n        return A;\n    }\n}\n"]}
{"number": 833, "statement": "To some string S, we will perform somereplacementoperations that replace groups of letters with new ones (not necessarily the same size).\nEach replacement operation has 3 parameters: a starting index i, a source wordxand a target wordy. The rule is that if xstarts at position iin the original string S, then we will replace that occurrence ofxwithy. If not, we do nothing.\nFor example, if we haveS = \"abcd\"and we have some replacement operationi = 2, x = \"cd\", y = \"ffff\", then because\"cd\"starts at position 2in the original string S, we will replace it with \"ffff\".\nUsing another example on S = \"abcd\", if we have both the replacement operation i = 0, x = \"ab\", y = \"eee\", as well as another replacement operationi = 2, x = \"ec\", y = \"ffff\", this second operation does nothing because in the original stringS[2] = 'c', which doesn't matchx[0] = 'e'.\nAll these operations occur simultaneously. It's guaranteed that there won't be any overlap in replacement: for example,S = \"abc\", indexes = [0, 1],sources = [\"ab\",\"bc\"] is not a valid test case.\n", "solutions": ["class Solution {\n    public String findReplaceString(String S, int[] indexes, String[] sources, String[] targets) {\n        int N = S.length();\n        int[] match = new int[N];\n        Arrays.fill(match, -1);\n        for (int i = 0; i < indexes.length; ++i) {\n            int ix = indexes[i];\n            if (S.substring(ix, ix + sources[i].length()).equals(sources[i]))\n                match[ix] = i;\n        }\n        StringBuilder ans = new StringBuilder();\n        int ix = 0;\n        while (ix < N) {\n            if (match[ix] >= 0) {\n                ans.append(targets[match[ix]]);\n                ix += sources[match[ix]].length();\n            } else {\n                ans.append(S.charAt(ix++));\n            }\n        }\n        return ans.toString();\n    }\n}\n"]}
{"number": 834, "statement": "An undirected, connectedtree with N nodes labelled 0...N-1 and N-1 edgesaregiven.\nThe ith edge connects nodesedges[i][0] andedges[i][1]together.\nReturn a list ans, where ans[i] is the sum of the distances between node i and all other nodes.\n", "solutions": ["class Solution {\n    int[] ans, count;\n    List<Set<Integer>> graph;\n    int N;\n    public int[] sumOfDistancesInTree(int N, int[][] edges) {\n        this.N = N;\n        graph = new ArrayList<Set<Integer>>();\n        ans = new int[N];\n        count = new int[N];\n        Arrays.fill(count, 1);\n        for (int i = 0; i < N; ++i)\n            graph.add(new HashSet<Integer>());\n        for (int[] edge: edges) {\n            graph.get(edge[0]).add(edge[1]);\n            graph.get(edge[1]).add(edge[0]);\n        }\n        dfs(0, -1);\n        dfs2(0, -1);\n        return ans;\n    }\n    public void dfs(int node, int parent) {\n        for (int child: graph.get(node))\n            if (child != parent) {\n                dfs(child, node);\n                count[node] += count[child];\n                ans[node] += ans[child] + count[child];\n            }\n    }\n    public void dfs2(int node, int parent) {\n        for (int child: graph.get(node))\n            if (child != parent) {\n                ans[child] = ans[node] - count[child] + N - count[child];\n                dfs2(child, node);\n            }\n    }\n}\n"]}
{"number": 835, "statement": "Two images A and B are given, represented asbinary, square matrices of the same size. (A binary matrix has only 0s and 1s as values.)\nWe translate one image however we choose (sliding it left, right, up, or down any number of units), and place it on top of the other image. After, the overlap of this translation is the number of positions that have a 1 in both images.\n(Note also that a translation does not include any kind of rotation.)\nWhat is the largest possible overlap?\n", "solutions": ["import java.awt.Point;\nclass Solution {\n    public int largestOverlap(int[][] A, int[][] B) {\n        int N = A.length;\n        List<Point> A2 = new ArrayList(), B2 = new ArrayList();\n        for (int i = 0; i < N*N; ++i) {\n            if (A[i/N][i%N] == 1) A2.add(new Point(i/N, i%N));\n            if (B[i/N][i%N] == 1) B2.add(new Point(i/N, i%N));\n        }\n        Set<Point> Bset = new HashSet(B2);\n        int ans = 0;\n        Set<Point> seen = new HashSet();\n        for (Point a: A2) for (Point b: B2) {\n            Point delta = new Point(b.x - a.x, b.y - a.y);\n            if (!seen.contains(delta)) {\n                seen.add(delta);\n                int cand = 0;\n                for (Point p: A2)\n                    if (Bset.contains(new Point(p.x + delta.x, p.y + delta.y)))\n                        cand++;\n                ans = Math.max(ans, cand);\n            }\n        }\n        return ans;\n    }\n}\n", "class Solution {\n    public int largestOverlap(int[][] A, int[][] B) {\n        int N = A.length;\n        int[][] count = new int[2*N+1][2*N+1];\n        for (int i = 0; i < N; ++i)\n            for (int j = 0; j < N; ++j)\n                if (A[i][j] == 1)\n                    for (int i2 = 0; i2 < N; ++i2)\n                        for (int j2 = 0; j2 < N; ++j2)\n                            if (B[i2][j2] == 1)\n                                count[i-i2 +N][j-j2 +N] += 1;\n        int ans = 0;\n        for (int[] row: count)\n            for (int v: row)\n                ans = Math.max(ans, v);\n        return ans;\n    }\n}\n"]}
{"number": 836, "statement": "A rectangle isrepresented as alist [x1, y1, x2, y2], where(x1, y1)are the coordinates of its bottom-left corner, and (x2,y2)are the coordinates of its top-right corner.\nTwo rectangles overlap if the area of their intersection is positive. To be clear, two rectangles that only touch at the corner or edges do not overlap.\nGiven two (axis-aligned) rectangles, return whetherthey overlap.\n", "solutions": ["class Solution {\n    public boolean isRectangleOverlap(int[] rec1, int[] rec2) {\n        return !(rec1[2] <= rec2[0] ||   // left\n                 rec1[3] <= rec2[1] ||   // bottom\n                 rec1[0] >= rec2[2] ||   // right\n                 rec1[1] >= rec2[3]);    // top\n    }\n}\n", "class Solution {\n    public boolean isRectangleOverlap(int[] rec1, int[] rec2) {\n        return (Math.min(rec1[2], rec2[2]) > Math.max(rec1[0], rec2[0]) && // width > 0\n                Math.min(rec1[3], rec2[3]) > Math.max(rec1[1], rec2[1]));  // height > 0\n    }\n}\n"]}
{"number": 837, "statement": "Alice plays the following game, loosely based on the card game \"21\".\nAlice starts with 0 points, and draws numbers while she has less than K points. During each draw, she gains an integer number of points randomly from the range [1, W], where W is an integer. Each draw is independent and the outcomes have equal probabilities.\nAlice stops drawing numbers when she gets K or more points. What is the probabilitythat she has N or less points?\n", "solutions": ["class Solution {\n    public double new21Game(int N, int K, int W) {\n        double[] dp = new double[N + W + 1];\n        // dp[x] = the answer when Alice has x points\n        for (int k = K; k <= N; ++k)\n            dp[k] = 1.0;\n        double S = Math.min(N - K + 1, W);\n        // S = dp[k+1] + dp[k+2] + ... + dp[k+W]\n        for (int k = K - 1; k >= 0; --k) {\n            dp[k] = S / W;\n            S += dp[k] - dp[k + W];\n        }\n        return dp[0];\n    }\n}\n"]}
{"number": 838, "statement": "There areN dominoes in a line, and we place each domino vertically upright.\nIn the beginning, we simultaneously pushsome of the dominoes either to the left or to the right.\nAfter each second, each domino that is falling to the left pushes the adjacent domino on the left.\nSimilarly, the dominoes falling to the right push their adjacent dominoes standing on the right.\nWhen a vertical domino has dominoes falling on it from both sides, it stays still due to the balance of the forces.\nFor the purposes of this question, we will consider that a falling dominoexpends no additional force to a falling or already fallen domino.\nGiven a string \"S\" representing the initial state.S[i] = 'L', if the i-th domino has been pushed to the left; S[i] = 'R', if the i-th domino has been pushed to the right; S[i] = '.',if the i-th domino has not been pushed.\nReturn a string representing the final state.\n", "solutions": ["class Solution {\n    public String pushDominoes(String dominoes) {\n        int N = dominoes.length();\n        int[] indexes = new int[N+2];\n        char[] symbols = new char[N+2];\n        int len = 1;\n        indexes[0] = -1;\n        symbols[0] = 'L';\n        for (int i = 0; i < N; ++i)\n            if (dominoes.charAt(i) != '.') {\n                indexes[len] = i;\n                symbols[len++] = dominoes.charAt(i);\n            }\n        indexes[len] = N;\n        symbols[len++] = 'R';\n        char[] ans = dominoes.toCharArray();\n        for (int index = 0; index < len - 1; ++index) {\n            int i = indexes[index], j = indexes[index+1];\n            char x = symbols[index], y = symbols[index+1];\n            char write;\n            if (x == y) {\n                for (int k = i+1; k < j; ++k)\n                    ans[k] = x;\n            } else if (x > y) { // RL\n                for (int k = i+1; k < j; ++k)\n                    ans[k] = k-i == j-k ? '.' : k-i < j-k ? 'R' : 'L';\n            }\n        }\n        return String.valueOf(ans);\n    }\n}\n", "class Solution {\n    public String pushDominoes(String S) {\n        char[] A = S.toCharArray();\n        int N = A.length;\n        int[] forces = new int[N];\n        // Populate forces going from left to right\n        int force = 0;\n        for (int i = 0; i < N; ++i) {\n            if (A[i] == 'R') force = N;\n            else if (A[i] == 'L') force = 0;\n            else force = Math.max(force - 1, 0);\n            forces[i] += force;\n        }\n        // Populate forces going from right to left\n        force = 0;\n        for (int i = N-1; i >= 0; --i) {\n            if (A[i] == 'L') force = N;\n            else if (A[i] == 'R') force = 0;\n            else force = Math.max(force - 1, 0);\n            forces[i] -= force;\n        }\n        StringBuilder ans = new StringBuilder();\n        for (int f: forces)\n            ans.append(f > 0 ? 'R' : f < 0 ? 'L' : '.');\n        return ans.toString();\n    }\n}\n"]}
{"number": 839, "statement": "Two strings Xand Yare similar if we can swap two letters (in different positions) of X, so thatit equals Y. Also two strings X and Y are similar if they are equal.\nFor example, \"tars\"and \"rats\"are similar (swapping at positions 0 and 2), and \"rats\" and \"arts\" are similar, but \"star\" is not similar to \"tars\", \"rats\", or \"arts\".\nTogether, these form two connected groups by similarity: {\"tars\", \"rats\", \"arts\"} and {\"star\"}. Notice that \"tars\" and \"arts\" are in the same group even though they are not similar. Formally, each group is such that a word is in the group if and only if it is similar to at least one other word in the group.\nWe are given a list A of strings. Every string in A is an anagram of every other string in A. How many groups are there?\n", "solutions": ["class Solution {\n    public int numSimilarGroups(String[] A) {\n        int N = A.length;\n        int W = A[0].length();\n        DSU dsu = new DSU(N);\n        if (N < W*W) { // If few words, then check for pairwise similarity: O(N^2 W)\n            for (int i = 0; i < N; ++i)\n                for (int j = i+1; j < N; ++j)\n                    if (similar(A[i], A[j]))\n                        dsu.union(i, j);\n        } else { // If short words, check all neighbors: O(N W^3)\n            Map<String, List<Integer>> buckets = new HashMap();\n            for (int i = 0; i < N; ++i) {\n                char[] L = A[i].toCharArray();\n                for (int j0 = 0; j0 < L.length; ++j0)\n                    for (int j1 = j0 + 1; j1 < L.length; ++j1) {\n                        swap(L, j0, j1);\n                        StringBuilder sb = new StringBuilder();\n                        for (char c: L) sb.append(c);\n                        buckets.computeIfAbsent(sb.toString(),\n                                x-> new ArrayList<Integer>()).add(i);\n                        swap(L, j0, j1);\n                    }\n            }\n            for (int i1 = 0; i1 < A.length; ++i1)\n                if (buckets.containsKey(A[i1]))\n                    for (int i2: buckets.get(A[i1]))\n                        dsu.union(i1, i2);\n        }\n        int ans = 0;\n        for (int i = 0; i < N; ++i)\n            if (dsu.parent[i] == i) ans++;\n        return ans;\n    }\n    public boolean similar(String word1, String word2) {\n        int diff = 0;\n        for (int i = 0; i < word1.length(); ++i)\n            if (word1.charAt(i) != word2.charAt(i))\n                diff++;\n        return diff <= 2;\n    }\n    public void swap(char[] A, int i, int j) {\n        char tmp = A[i];\n        A[i] = A[j];\n        A[j] = tmp;\n    }\n}\nclass DSU {\n    int[] parent;\n    public DSU(int N) {\n        parent = new int[N];\n        for (int i = 0; i < N; ++i)\n            parent[i] = i;\n    }\n    public int find(int x) {\n        if (parent[x] != x) parent[x] = find(parent[x]);\n        return parent[x];\n    }\n    public void union(int x, int y) {\n        parent[find(x)] = find(y);\n    }\n}\n"]}
{"number": 840, "statement": "A 3 x 3 magic square is a 3 x 3 grid filled with distinct numbers from 1 to 9 such that each row, column, and both diagonals all have the same sum.\nGiven an gridof integers, how many 3 x 3 \"magic square\" subgrids are there? (Each subgrid is contiguous).\n", "solutions": ["class Solution {\n    public int numMagicSquaresInside(int[][] grid) {\n        int R = grid.length, C = grid[0].length;\n        int ans = 0;\n        for (int r = 0; r < R-2; ++r)\n            for (int c = 0; c < C-2; ++c) {\n                if (grid[r+1][c+1] != 5) continue;  // optional skip\n                if (magic(grid[r][c], grid[r][c+1], grid[r][c+2],\n                          grid[r+1][c], grid[r+1][c+1], grid[r+1][c+2],\n                          grid[r+2][c], grid[r+2][c+1], grid[r+2][c+2]))\n                    ans++;\n            }\n        return ans;\n    }\n    public boolean magic(int... vals) {\n        int[] count = new int[16];\n        for (int v: vals) count[v]++;\n        for (int v = 1; v <= 9; ++v)\n            if (count[v] != 1)\n                return false;\n        return (vals[0] + vals[1] + vals[2] == 15 &&\n                vals[3] + vals[4] + vals[5] == 15 &&\n                vals[6] + vals[7] + vals[8] == 15 &&\n                vals[0] + vals[3] + vals[6] == 15 &&\n                vals[1] + vals[4] + vals[7] == 15 &&\n                vals[2] + vals[5] + vals[8] == 15 &&\n                vals[0] + vals[4] + vals[8] == 15 &&\n                vals[2] + vals[4] + vals[6] == 15);\n    }\n}\n"]}
{"number": 841, "statement": "There are N rooms and you start in room 0. Each room has a distinct number in 0, 1, 2, ..., N-1, and each room may havesome keys to access the next room.\nFormally, each room ihas a list of keys rooms[i], and each key rooms[i][j] is an integer in [0, 1, ..., N-1] where N = rooms.length. A key rooms[i][j] = vopens the room with number v.\nInitially, all the rooms start locked (except for room 0).\nYou can walk back and forth between rooms freely.\nReturn trueif and only if you can enterevery room.\n", "solutions": ["class Solution {\n    public boolean canVisitAllRooms(List<List<Integer>> rooms) {\n        boolean[] seen = new boolean[rooms.size()];\n        seen[0] = true;\n        Stack<Integer> stack = new Stack();\n        stack.push(0);\n        //At the beginning, we have a todo list \"stack\" of keys to use.\n        //'seen' represents at some point we have entered this room.\n        while (!stack.isEmpty()) { // While we have keys...\n            int node = stack.pop(); // Get the next key 'node'\n            for (int nei: rooms.get(node)) // For every key in room # 'node'...\n                if (!seen[nei]) { // ...that hasn't been used yet\n                    seen[nei] = true; // mark that we've entered the room\n                    stack.push(nei); // add the key to the todo list\n                }\n        }\n        for (boolean v: seen)  // if any room hasn't been visited, return false\n            if (!v) return false;\n        return true;\n    }\n}\n"]}
{"number": 842, "statement": "Given a string Sof digits, such as S = \"123456579\", we can split it into a Fibonacci-like sequence[123, 456, 579].\nFormally, a Fibonacci-like sequence is a listF of non-negative integers such that:\n0 = F[i] = 2^31 - 1, (that is,each integer fits a 32-bit signed integer type);\nF.length = 3;\nand F[i] + F[i+1] = F[i+2] for all 0 = i  F.length - 2.\nAlso, note that when splitting the string into pieces, each piece must not have extra leading zeroes, except if the piece is the number 0 itself.\nReturn any Fibonacci-like sequence split from S, or return [] if it cannot be done.\n", "solutions": ["class Solution {\n    public List<Integer> splitIntoFibonacci(String S) {\n        int N = S.length();\n        for (int i = 0; i < Math.min(10, N); ++i) {\n            if (S.charAt(0) == '0' && i > 0) break;\n            long a = Long.valueOf(S.substring(0, i+1));\n            if (a >= Integer.MAX_VALUE) break;\n            search: for (int j = i+1; j < Math.min(i+10, N); ++j) {\n                if (S.charAt(i+1) == '0' && j > i+1) break;\n                long b = Long.valueOf(S.substring(i+1, j+1));\n                if (b >= Integer.MAX_VALUE) break;\n                List<Integer> fib = new ArrayList();\n                fib.add((int) a);\n                fib.add((int) b);\n                int k = j + 1;\n                while (k < N) {\n                    long nxt = fib.get(fib.size() - 2) + fib.get(fib.size() - 1);\n                    String nxtS = String.valueOf(nxt);\n                    if (nxt <= Integer.MAX_VALUE && S.substring(k).startsWith(nxtS)) {\n                        k += nxtS.length();\n                        fib.add((int) nxt);\n                    }\n                    else continue search;\n                }\n                if (fib.size() >= 3) return fib;\n            }\n        }\n        return new ArrayList<Integer>();\n    }\n}\n"]}
{"number": 843, "statement": "This problem is aninteractive problemnew to the LeetCode platform.\nWe are given a word list of unique words, each word is 6 letters long, and one word in this list is chosen as secret.\nYou may call master.guess(word)to guess a word. The guessed word should havetype stringand must be from the original listwith 6 lowercase letters.\nThis function returns anintegertype, representingthe number of exact matches (value and position) of your guess to the secret word. Also, if your guess is not in the given wordlist, it will return -1 instead.\nFor each test case, you have 10 guesses to guess the word. At the end of any number of calls, if you have made 10 or less calls to master.guessand at least one of these guesses was the secret, you pass the testcase.\nBesides the example test case below, there will be 5additional test cases, each with 100 words in the word list. The letters of each word in those testcases were chosenindependently at random from 'a' to 'z', such that every word in the given word lists is unique.\n", "solutions": ["class Solution {\n    int[][] H;\n    public void findSecretWord(String[] wordlist, Master master) {\n        int N = wordlist.length;\n        H = new int[N][N];\n        for (int i = 0; i < N; ++i)\n            for (int j = i; j < N; ++j) {\n                int match = 0;\n                for (int k = 0; k < 6; ++k)\n                    if (wordlist[i].charAt(k) == wordlist[j].charAt(k))\n                        match++;\n                H[i][j] = H[j][i] = match;\n            }\n        List<Integer> possible = new ArrayList();\n        List<Integer> path = new ArrayList();\n        for (int i = 0; i < N; ++i) possible.add(i);\n        while (!possible.isEmpty()) {\n            int guess = solve(possible, path);\n            int matches = master.guess(wordlist[guess]);\n            if (matches == wordlist[0].length()) return;\n            List<Integer> possible2 = new ArrayList();\n            for (Integer j: possible) if (H[guess][j] == matches) possible2.add(j);\n            possible = possible2;\n            path.add(guess);\n        }\n    }\n    public int solve(List<Integer> possible, List<Integer> path) {\n        if (possible.size() <= 2) return possible.get(0);\n        List<Integer> ansgrp = possible;\n        int ansguess = -1;\n        for (int guess = 0; guess < H.length; ++guess) {\n            if (!path.contains(guess)) {\n                ArrayList<Integer>[] groups = new ArrayList[7];\n                for (int i = 0; i < 7; ++i) groups[i] = new ArrayList<Integer>();\n                for (Integer j: possible) if (j != guess) {\n                    groups[H[guess][j]].add(j);\n                }\n                ArrayList<Integer> maxgroup = groups[0];\n                for (int i = 0; i < 7; ++i)\n                    if (groups[i].size() > maxgroup.size())\n                        maxgroup = groups[i];\n                if (maxgroup.size() < ansgrp.size()) {\n                    ansgrp = maxgroup;\n                    ansguess = guess;\n                }\n            }\n        }\n        return ansguess;\n    }\n}\n"]}
{"number": 844, "statement": "Given twostringsSand T,return if they are equal when both are typed into empty text editors. # means a backspace character.\nNote that afterbackspacing an empty text, the text will continue empty.\n", "solutions": ["class Solution {\n    public boolean backspaceCompare(String S, String T) {\n        return build(S).equals(build(T));\n    }\n    public String build(String S) {\n        Stack<Character> ans = new Stack();\n        for (char c: S.toCharArray()) {\n            if (c != '#')\n                ans.push(c);\n            else if (!ans.empty())\n                ans.pop();\n        }\n        return String.valueOf(ans);\n    }\n}\n", "class Solution {\n    public boolean backspaceCompare(String S, String T) {\n        int i = S.length() - 1, j = T.length() - 1;\n        int skipS = 0, skipT = 0;\n        while (i >= 0 || j >= 0) { // While there may be chars in build(S) or build (T)\n            while (i >= 0) { // Find position of next possible char in build(S)\n                if (S.charAt(i) == '#') {skipS++; i--;}\n                else if (skipS > 0) {skipS--; i--;}\n                else break;\n            }\n            while (j >= 0) { // Find position of next possible char in build(T)\n                if (T.charAt(j) == '#') {skipT++; j--;}\n                else if (skipT > 0) {skipT--; j--;}\n                else break;\n            }\n            // If two actual characters are different\n            if (i >= 0 && j >= 0 && S.charAt(i) != T.charAt(j))\n                return false;\n            // If expecting to compare char vs nothing\n            if ((i >= 0) != (j >= 0))\n                return false;\n            i--; j--;\n        }\n        return true;\n    }\n}\n"]}
{"number": 845, "statement": "Let's call any (contiguous) subarray B (of A)a mountain if the following properties hold:\nB.length = 3\nThere exists some 0  i B.length - 1 such that B[0]  B[1]  ... B[i-1]  B[i]  B[i+1]  ...  B[B.length - 1]\n(Note that B could be any subarray of A, including the entire array A.)\nGiven an array Aof integers,return the length of the longestmountain.\nReturn 0 if there is no mountain.\n", "solutions": ["class Solution {\n    public int longestMountain(int[] A) {\n        int N = A.length;\n        int ans = 0, base = 0;\n        while (base < N) {\n            int end = base;\n            // if base is a left-boundary\n            if (end + 1 < N && A[end] < A[end + 1]) {\n                // set end to the peak of this potential mountain\n                while (end + 1 < N && A[end] < A[end + 1]) end++;\n                // if end is really a peak..\n                if (end + 1 < N && A[end] > A[end + 1]) {\n                    // set end to the right-boundary of mountain\n                    while (end + 1 < N && A[end] > A[end + 1]) end++;\n                    // record candidate answer\n                    ans = Math.max(ans, end - base + 1);\n                }\n            }\n            base = Math.max(end, base + 1);\n        }\n        return ans;\n    }\n}\n"]}
{"number": 846, "statement": "Alice has a hand of cards, given as an array of integers.\nNow she wants to rearrange the cards into groups so that each group is size W, and consists of W consecutive cards.\nReturn true if and only if she can.\n", "solutions": ["class Solution {\n    public boolean isNStraightHand(int[] hand, int W) {\n        TreeMap<Integer, Integer> count = new TreeMap();\n        for (int card: hand) {\n            if (!count.containsKey(card))\n                count.put(card, 1);\n            else\n                count.replace(card, count.get(card) + 1);\n        }\n        while (count.size() > 0) {\n            int first = count.firstKey();\n            for (int card = first; card < first + W; ++card) {\n                if (!count.containsKey(card)) return false;\n                int c = count.get(card);\n                if (c == 1) count.remove(card);\n                else count.replace(card, c - 1);\n            }\n        }\n        return true;\n    }\n}\n"]}
{"number": 847, "statement": "An undirected, connected graph of N nodes (labeled0, 1, 2, ..., N-1) is given as graph.\ngraph.length = N, and j != iis in the listgraph[i]exactly once, if and only if nodes i and j are connected.\nReturn the length of the shortest path that visits every node. You may start and stop at any node, you may revisit nodes multiple times, and you may reuse edges.\n", "solutions": ["class Solution {\n    public int shortestPathLength(int[][] graph) {\n        int N = graph.length;\n        Queue<State> queue = new LinkedList();\n        int[][] dist = new int[1<<N][N];\n        for (int[] row: dist) Arrays.fill(row, N*N);\n        for (int x = 0; x < N; ++x) {\n            queue.offer(new State(1<<x, x));\n            dist[1 << x][x] = 0;\n        }\n        while (!queue.isEmpty()) {\n            State node = queue.poll();\n            int d = dist[node.cover][node.head];\n            if (node.cover == (1<<N) - 1) return d;\n            for (int child: graph[node.head]) {\n                int cover2 = node.cover | (1 << child);\n                if (d + 1 < dist[cover2][child]) {\n                    dist[cover2][child] = d + 1;\n                    queue.offer(new State(cover2, child));\n                }\n            }\n        }\n        throw null;\n    }\n}\nclass State {\n    int cover, head;\n    State(int c, int h) {\n        cover = c;\n        head = h;\n    }\n}\n", "class Solution {\n    public int shortestPathLength(int[][] graph) {\n        int N = graph.length;\n        int dist[][] = new int[1 << N][N];\n        for (int[] row: dist) Arrays.fill(row, N*N);\n        for (int x = 0; x < N; ++x) dist[1<<x][x] = 0;\n        for (int cover = 0; cover < 1 << N; ++cover) {\n            boolean repeat = true;\n            while (repeat) {\n                repeat = false;\n                for (int head = 0; head < N; ++head) {\n                    int d = dist[cover][head];\n                    for (int next: graph[head]) {\n                        int cover2 = cover | (1 << next);\n                        if (d + 1 < dist[cover2][next]) {\n                            dist[cover2][next] = d+1;\n                            if (cover == cover2) repeat = true;\n                        }\n                    }\n                }\n            }\n        }\n        int ans = N*N;\n        for (int cand: dist[(1<<N) - 1])\n            ans = Math.min(cand, ans);\n        return ans;\n    }\n}\n"]}
{"number": 848, "statement": "We have a string S of lowercase letters, and an integer array shifts.\nCall the shift of a letter, the next letter in the alphabet, (wrapping around so that 'z' becomes 'a').\nFor example, shift('a') = 'b', shift('t') = 'u', and shift('z') = 'a'.\nNow for each shifts[i] = x, we want to shift the first i+1letters of S, x times.\nReturn the final stringafter all such shifts to S are applied.\n", "solutions": ["class Solution {\n    public String shiftingLetters(String S, int[] shifts) {\n        StringBuilder ans = new StringBuilder();\n        int X = 0;\n        for (int shift: shifts)\n            X = (X + shift) % 26;\n        for (int i = 0; i < S.length(); ++i) {\n            int index = S.charAt(i) - 'a';\n            ans.append((char) ((index + X) % 26 + 97));\n            X = Math.floorMod(X - shifts[i], 26);\n        }\n        return ans.toString();\n    }\n}\n"]}
{"number": 849, "statement": "In a row of seats, 1 represents a person sitting in that seat, and 0 represents that the seat is empty.\nThere is at least one empty seat, and at least one person sitting.\nAlex wants to sit in the seat such that the distance between him and the closest person to him is maximized.\nReturn that maximum distance to closest person.\n", "solutions": ["class Solution {\n    public int maxDistToClosest(int[] seats) {\n        int N = seats.length;\n        int[] left = new int[N], right = new int[N];\n        Arrays.fill(left, N);\n        Arrays.fill(right, N);\n        for (int i = 0; i < N; ++i) {\n            if (seats[i] == 1) left[i] = 0;\n            else if (i > 0) left[i] = left[i-1] + 1;\n        }\n        for (int i = N-1; i >= 0; --i) {\n            if (seats[i] == 1) right[i] = 0;\n            else if (i < N-1) right[i] = right[i+1] + 1;\n        }\n        int ans = 0;\n        for (int i = 0; i < N; ++i)\n            if (seats[i] == 0)\n                ans = Math.max(ans, Math.min(left[i], right[i]));\n        return ans;\n    }\n}\n", "class Solution {\n    public int maxDistToClosest(int[] seats) {\n        int N = seats.length;\n        int prev = -1, future = 0;\n        int ans = 0;\n        for (int i = 0; i < N; ++i) {\n            if (seats[i] == 1) {\n                prev = i;\n            } else {\n                while (future < N && seats[future] == 0 || future < i)\n                    future++;\n                int left = prev == -1 ? N : i - prev;\n                int right = future == N ? N : future - i;\n                ans = Math.max(ans, Math.min(left, right));\n            }\n        }\n        return ans;\n    }\n}\n", "class Solution {\n    public int maxDistToClosest(int[] seats) {\n        int N = seats.length;\n        int K = 0; //current longest group of empty seats\n        int ans = 0;\n        for (int i = 0; i < N; ++i) {\n            if (seats[i] == 1) {\n                K = 0;\n            } else {\n                K++;\n                ans = Math.max(ans, (K + 1) / 2);\n            }\n        }\n        for (int i = 0; i < N; ++i)  if (seats[i] == 1) {\n            ans = Math.max(ans, i);\n            break;\n        }\n        for (int i = N-1; i >= 0; --i)  if (seats[i] == 1) {\n            ans = Math.max(ans, N - 1 - i);\n            break;\n        }\n        return ans;\n    }\n}\n"]}
{"number": 850, "statement": "We are given a list of (axis-aligned)rectangles. Eachrectangle[i] = [x1, y1, x2, y2], where (x1, y1) are the coordinates of the bottom-left corner, and (x2, y2) are the coordinates of the top-right corner of the ith rectangle.\nFind the total area covered by all rectangles in the plane. Since the answermay be too large, return it modulo 10^9 + 7.\n", "solutions": ["class Solution {\n    public int rectangleArea(int[][] rectangles) {\n        int N = rectangles.length;\n        long ans = 0;\n        for (int subset = 1; subset < (1<<N); ++subset) {\n            int[] rec = new int[]{0, 0, 1_000_000_000, 1_000_000_000};\n            int parity = -1;\n            for (int bit = 0; bit < N; ++bit)\n                if (((subset >> bit) & 1) != 0) {\n                    rec = intersect(rec, rectangles[bit]);\n                    parity *= -1;\n                }\n            ans += parity * area(rec);\n        }\n        long MOD = 1_000_000_007;\n        ans %= MOD;\n        if (ans < 0) ans += MOD;\n        return (int) ans;\n    }\n    public long area(int[] rec) {\n        long dx = Math.max(0, rec[2] - rec[0]);\n        long dy = Math.max(0, rec[3] - rec[1]);\n        return dx * dy;\n    }\n    public int[] intersect(int[] rec1, int[] rec2) {\n        return new int[]{\n            Math.max(rec1[0], rec2[0]),\n            Math.max(rec1[1], rec2[1]),\n            Math.min(rec1[2], rec2[2]),\n            Math.min(rec1[3], rec2[3]),\n        };\n    }\n}\n", "class Solution {\n    public int rectangleArea(int[][] rectangles) {\n        int N = rectangles.length;\n        Set<Integer> Xvals = new HashSet();\n        Set<Integer> Yvals = new HashSet();\n        for (int[] rec: rectangles) {\n            Xvals.add(rec[0]);\n            Xvals.add(rec[2]);\n            Yvals.add(rec[1]);\n            Yvals.add(rec[3]);\n        }\n        Integer[] imapx = Xvals.toArray(new Integer[0]);\n        Arrays.sort(imapx);\n        Integer[] imapy = Yvals.toArray(new Integer[0]);\n        Arrays.sort(imapy);\n        Map<Integer, Integer> mapx = new HashMap();\n        Map<Integer, Integer> mapy = new HashMap();\n        for (int i = 0; i < imapx.length; ++i)\n            mapx.put(imapx[i], i);\n        for (int i = 0; i < imapy.length; ++i)\n            mapy.put(imapy[i], i);\n        boolean[][] grid = new boolean[imapx.length][imapy.length];\n        for (int[] rec: rectangles)\n            for (int x = mapx.get(rec[0]); x < mapx.get(rec[2]); ++x)\n                for (int y = mapy.get(rec[1]); y < mapy.get(rec[3]); ++y)\n                    grid[x][y] = true;\n        long ans = 0;\n        for (int x = 0; x < grid.length; ++x)\n            for (int y = 0; y < grid[0].length; ++y)\n                if (grid[x][y])\n                    ans += (long) (imapx[x+1] - imapx[x]) * (imapy[y+1] - imapy[y]);\n        ans %= 1_000_000_007;\n        return (int) ans;\n    }\n}\n", "class Solution {\n    public int rectangleArea(int[][] rectangles) {\n        int OPEN = 0, CLOSE = 1;\n        int[][] events = new int[rectangles.length * 2][];\n        int t = 0;\n        for (int[] rec: rectangles) {\n            events[t++] = new int[]{rec[1], OPEN, rec[0], rec[2]};\n            events[t++] = new int[]{rec[3], CLOSE, rec[0], rec[2]};\n        }\n        Arrays.sort(events, (a, b) -> Integer.compare(a[0], b[0]));\n        List<int[]> active = new ArrayList();\n        int cur_y = events[0][0];\n        long ans = 0;\n        for (int[] event: events) {\n            int y = event[0], typ = event[1], x1 = event[2], x2 = event[3];\n            // Calculate query\n            long query = 0;\n            int cur = -1;\n            for (int[] xs: active) {\n                cur = Math.max(cur, xs[0]);\n                query += Math.max(xs[1] - cur, 0);\n                cur = Math.max(cur, xs[1]);\n            }\n            ans += query * (y - cur_y);\n            if (typ == OPEN) {\n                active.add(new int[]{x1, x2});\n                Collections.sort(active, (a, b) -> Integer.compare(a[0], b[0]));\n            } else {\n                for (int i = 0; i < active.size(); ++i)\n                    if (active.get(i)[0] == x1 && active.get(i)[1] == x2) {\n                        active.remove(i);\n                        break;\n                    }\n            }\n            cur_y = y;\n        }\n        ans %= 1_000_000_007;\n        return (int) ans;\n    }\n}\n", "class Solution {\n    public int rectangleArea(int[][] rectangles) {\n        int OPEN = 1, CLOSE = -1;\n        int[][] events = new int[rectangles.length * 2][];\n        Set<Integer> Xvals = new HashSet();\n        int t = 0;\n        for (int[] rec: rectangles) {\n            events[t++] = new int[]{rec[1], OPEN, rec[0], rec[2]};\n            events[t++] = new int[]{rec[3], CLOSE, rec[0], rec[2]};\n            Xvals.add(rec[0]);\n            Xvals.add(rec[2]);\n        }\n        Arrays.sort(events, (a, b) -> Integer.compare(a[0], b[0]));\n        Integer[] X = Xvals.toArray(new Integer[0]);\n        Arrays.sort(X);\n        Map<Integer, Integer> Xi = new HashMap();\n        for (int i = 0; i < X.length; ++i)\n            Xi.put(X[i], i);\n        Node active = new Node(0, X.length - 1, X);\n        long ans = 0;\n        long cur_x_sum = 0;\n        int cur_y = events[0][0];\n        for (int[] event: events) {\n            int y = event[0], typ = event[1], x1 = event[2], x2 = event[3];\n            ans += cur_x_sum * (y - cur_y);\n            cur_x_sum = active.update(Xi.get(x1), Xi.get(x2), typ);\n            cur_y = y;\n        }\n        ans %= 1_000_000_007;\n        return (int) ans;\n    }\n}\nclass Node {\n    int start, end;\n    Integer[] X;\n    Node left, right;\n    int count;\n    long total;\n    public Node(int start, int end, Integer[] X) {\n        this.start = start;\n        this.end = end;\n        this.X = X;\n        left = null;\n        right = null;\n        count = 0;\n        total = 0;\n    }\n    public int getRangeMid() {\n        return start + (end - start) / 2;\n    }\n    public Node getLeft() {\n        if (left == null) left = new Node(start, getRangeMid(), X);\n        return left;\n    }\n    public Node getRight() {\n        if (right == null) right = new Node(getRangeMid(), end, X);\n        return right;\n    }\n    public long update(int i, int j, int val) {\n        if (i >= j) return 0;\n        if (start == i && end == j) {\n            count += val;\n        } else {\n            getLeft().update(i, Math.min(getRangeMid(), j), val);\n            getRight().update(Math.max(getRangeMid(), i), j, val);\n        }\n        if (count > 0) total = X[end] - X[start];\n        else total = getLeft().total + getRight().total;\n        return total;\n    }\n}\n"]}
{"number": 851, "statement": "In a group of N people (labelled 0, 1, 2, ..., N-1), each person has different amounts of money, and different levels of quietness.\nFor convenience, we'll call the person with label x, simply \"person x\".\nWe'll say that richer[i] = [x, y] if person xdefinitely has more money than persony. Note that richermay only be a subset of valid observations.\nAlso, we'll say quiet[x] = q if person xhas quietness q.\nNow, return answer, where answer[x] = y if y is the least quiet person (that is, the person y with the smallest value of quiet[y]), among all peoplewho definitely haveequal to or more money than person x.\n", "solutions": ["class Solution {\n    ArrayList<Integer>[] graph;\n    int[] answer;\n    int[] quiet;\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\n        int N = quiet.length;\n        graph = new ArrayList[N];\n        answer = new int[N];\n        this.quiet = quiet;\n        for (int node = 0; node < N; ++node)\n            graph[node] = new ArrayList<Integer>();\n        for (int[] edge: richer)\n            graph[edge[1]].add(edge[0]);\n        Arrays.fill(answer, -1);\n        for (int node = 0; node < N; ++node)\n            dfs(node);\n        return answer;\n    }\n    public int dfs(int node) {\n        if (answer[node] == -1) {\n            answer[node] = node;\n            for (int child: graph[node]) {\n                int cand = dfs(child);\n                if (quiet[cand] < quiet[answer[node]])\n                    answer[node] = cand;\n            }\n        }\n        return answer[node];\n    }\n}\n"]}
{"number": 852, "statement": "Let's call an array A a mountainif the following properties hold:\nA.length = 3\nThere exists some 0  i A.length - 1 such that A[0]  A[1]  ... A[i-1]  A[i]  A[i+1]  ...  A[A.length - 1]\nGiven an array that is definitely a mountain, return anyisuch thatA[0]  A[1]  ... A[i-1]  A[i]  A[i+1]  ...  A[A.length - 1].\n", "solutions": ["class Solution {\n    public int peakIndexInMountainArray(int[] A) {\n        int i = 0;\n        while (A[i] < A[i+1]) i++;\n        return i;\n    }\n}\n", "class Solution {\n    public int peakIndexInMountainArray(int[] A) {\n        int lo = 0, hi = A.length - 1;\n        while (lo < hi) {\n            int mi = lo + (hi - lo) / 2;\n            if (A[mi] < A[mi + 1])\n                lo = mi + 1;\n            else\n                hi = mi;\n        }\n        return lo;\n    }\n}\n"]}
{"number": 853, "statement": "N cars are going to the same destination along a one lane road. The destination is targetmiles away.\nEach car ihas a constant speed speed[i](in miles per hour), and initial position position[i]miles towards the target along the road.\nA car can never pass another car ahead of it, but it can catch up to it, and drive bumper to bumper at the same speed.\nThe distance between these two cars is ignored - they are assumed to have the same position.\nA car fleet is some non-empty set of cars drivingat the same position and same speed. Note that a single car is also a car fleet.\nIf a car catches up to a car fleet right at the destination point, it willstill beconsidered as one car fleet.\nHow many car fleets will arrive at the destination?\n", "solutions": ["class Solution {\n    public int carFleet(int target, int[] position, int[] speed) {\n        int N = position.length;\n        Car[] cars = new Car[N];\n        for (int i = 0; i < N; ++i)\n            cars[i] = new Car(position[i], (double) (target - position[i]) / speed[i]);\n        Arrays.sort(cars, (a, b) -> Integer.compare(a.position, b.position));\n        int ans = 0, t = N;\n        while (--t > 0) {\n            if (cars[t].time < cars[t-1].time) ans++; //if cars[t] arrives sooner, it can't be caught\n            else cars[t-1] = cars[t]; //else, cars[t-1] arrives at same time as cars[t]\n        }\n        return ans + (t == 0 ? 1 : 0); //lone car is fleet (if it exists)\n    }\n}\nclass Car {\n    int position;\n    double time;\n    Car(int p, double t) {\n        position = p;\n        time = t;\n    }\n}\n"]}
{"number": 854, "statement": "StringsA and B are K-similar (for some non-negative integer K) if we can swap the positions of two letters in A exactly Ktimes so that the resulting string equals B.\nGiven two anagrams A and B, return the smallest Kfor which A and B are K-similar.\n", "solutions": ["class Solution {\n    String[] alphabet = new String[]{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"};\n    Map<String, Integer> memo;\n    public int kSimilarity(String A, String B) {\n        if (A.equals(B)) return 0;\n        int N = A.length();\n        memo = new HashMap();\n        int ans = 0;\n        int[] count = new int[alphabet.length * alphabet.length];\n        for (int i = 0; i < N; ++i)\n            if (A.charAt(i) != B.charAt(i)) {\n                count[alphabet.length * (A.charAt(i) - 'a') + (B.charAt(i) - 'a')]++;\n                ans++;\n            }\n        List<int[]> possibles = new ArrayList();\n        // Enumerate over every cycle\n        for (int size = 2; size <= alphabet.length; ++size)\n            search: for (String cycle: permutations(alphabet, 0, size)) {\n                // Check if cycle is canonical\n                for (int i = 1; i < size; ++i)\n                    if (cycle.charAt(i) < cycle.charAt(0))\n                        continue search;\n                // Add count to possibles\n                int[] row = new int[count.length];\n                for (int i = 0; i < size; ++i) {\n                    int u = cycle.charAt(i) - 'a';\n                    int v = cycle.charAt((i+1) % size) - 'a';\n                    row[alphabet.length * u + v]++;\n                }\n                possibles.add(row);\n            }\n        int[] ZERO = new int[count.length];\n        memo.put(Arrays.toString(ZERO), 0);\n        return ans - numCycles(possibles, count);\n    }\n    public int numCycles(List<int[]> possibles, int[] count) {\n        String countS = Arrays.toString(count);\n        if (memo.containsKey(countS)) return memo.get(countS);\n        int ans = Integer.MIN_VALUE;\n        search: for (int[] row: possibles) {\n            int[] count2 = count.clone();\n            for (int i = 0; i < row.length; ++i) {\n                if (count2[i] >= row[i])\n                    count2[i] -= row[i];\n                else\n                    continue search;\n            }\n            ans = Math.max(ans, 1 + numCycles(possibles, count2));\n        }\n        memo.put(countS, ans);\n        return ans;\n    }\n    public List<String> permutations(String[] alphabet, int used, int size) {\n        List<String> ans = new ArrayList();\n        if (size == 0) {\n            ans.add(new String(\"\"));\n            return ans;\n        }\n        for (int b = 0; b < alphabet.length; ++b)\n            if (((used >> b) & 1) == 0)\n                for (String rest: permutations(alphabet, used | (1 << b), size - 1))\n                    ans.add(alphabet[b] + rest);\n        return ans;\n    }\n}\n", "class Solution {\n    public int kSimilarity(String A, String B) {\n        Queue<String> queue = new ArrayDeque();\n        queue.offer(A);\n        Map<String, Integer> dist = new HashMap();\n        dist.put(A, 0);\n        while (!queue.isEmpty()) {\n            String S = queue.poll();\n            if (S.equals(B)) return dist.get(S);\n            for (String T: neighbors(S, B)) {\n                if (!dist.containsKey(T)) {\n                    dist.put(T, dist.get(S) + 1);\n                    queue.offer(T);\n                }\n            }\n        }\n        throw null;\n    }\n    public List<String> neighbors(String S, String target) {\n        List<String> ans = new ArrayList();\n        int i = 0;\n        for (; i < S.length(); ++i) {\n            if (S.charAt(i) != target.charAt(i)) break;\n        }\n        char[] T = S.toCharArray();\n        for (int j = i+1; j < S.length(); ++j)\n            if (S.charAt(j) == target.charAt(i)) {\n                swap(T, i, j);\n                ans.add(new String(T));\n                swap(T, i, j);\n            }\n        return ans;\n    }\n    public void swap(char[] T, int i, int j) {\n        char tmp = T[i];\n        T[i] = T[j];\n        T[j] = tmp;\n    }\n}\n"]}
{"number": 855, "statement": "In an exam room, there are N seats in a single row, numbered 0, 1, 2, ..., N-1.\nWhen a student enters the room, they must sit in the seat that maximizes the distance to the closest person. If there are multiple such seats, they sit in the seat with the lowest number. (Also, if no one is in the room, then the student sits at seat number 0.)\nReturn a class ExamRoom(int N)that exposes two functions: ExamRoom.seat()returning an intrepresenting what seat the student sat in, and ExamRoom.leave(int p)representing that the student in seat number pnow leaves the room. It is guaranteed that any calls to ExamRoom.leave(p) have a student sitting in seat p.\n", "solutions": ["class ExamRoom {\n    int N;\n    TreeSet<Integer> students;\n    public ExamRoom(int N) {\n        this.N = N;\n        students = new TreeSet();\n    }\n    public int seat() {\n        //Let's determine student, the position of the next\n        //student to sit down.\n        int student = 0;\n        if (students.size() > 0) {\n            //Tenatively, dist is the distance to the closest student,\n            //which is achieved by sitting in the position 'student'.\n            //We start by considering the left-most seat.\n            int dist = students.first();\n            Integer prev = null;\n            for (Integer s: students) {\n                if (prev != null) {\n                    //For each pair of adjacent students in positions (prev, s),\n                    //d is the distance to the closest student;\n                    //achieved at position prev + d.\n                    int d = (s - prev) / 2;\n                    if (d > dist) {\n                        dist = d;\n                        student = prev + d;\n                    }\n                }\n                prev = s;\n            }\n            //Considering the right-most seat.\n            if (N - 1 - students.last() > dist)\n                student = N - 1;\n        }\n        //Add the student to our sorted TreeSet of positions.\n        students.add(student);\n        return student;\n    }\n    public void leave(int p) {\n        students.remove(p);\n    }\n}\n"]}
{"number": 856, "statement": "Given a balanced parentheses string S, compute the score of the string based on the following rule:\n() has score 1\nAB has score A + B, where A and B are balanced parentheses strings.\n(A) has score 2 * A, where A is a balanced parentheses string.\n", "solutions": ["class Solution {\n    public int scoreOfParentheses(String S) {\n        return F(S, 0, S.length());\n    }\n    public int F(String S, int i, int j) {\n        //Score of balanced string S[i:j]\n        int ans = 0, bal = 0;\n        // Split string into primitives\n        for (int k = i; k < j; ++k) {\n            bal += S.charAt(k) == '(' ? 1 : -1;\n            if (bal == 0) {\n                if (k - i == 1) ans++;\n                else ans += 2 * F(S, i+1, k);\n                i = k+1;\n            }\n        }\n        return ans;\n    }\n}\n", "public int scoreOfParentheses(String S) {\n    Stack<Integer> stack = new Stack();\n    stack.push(0); // The score of the current frame\n    for (char c: S.toCharArray()) {\n        if (c == '(')\n            stack.push(0);\n        else {\n            int v = stack.pop();\n            int w = stack.pop();\n            stack.push(w + Math.max(2 * v, 1));\n        }\n    }\n    return stack.pop();\n}\n", "class Solution {\n    public int scoreOfParentheses(String S) {\n        int ans = 0, bal = 0;\n        for (int i = 0; i < S.length(); ++i) {\n            if (S.charAt(i) == '(') {\n                bal++;\n            } else {\n                bal--;\n                if (S.charAt(i-1) == '(')\n                    ans += 1 << bal;\n            }\n        }\n        return ans;\n    }\n}\n"]}
{"number": 857, "statement": "There are N workers. The i-th worker has a quality[i] and a minimum wage expectation wage[i].\nNow we want to hire exactly Kworkers to form a paid group. When hiring a group of K workers, we must pay them according to the following rules:\nEvery worker in the paid group should be paid in the ratio of their quality compared to other workers in the paid group.\nEvery worker in the paid group must be paid at least their minimum wage expectation.\nReturn the least amount of money needed to form a paid group satisfying the above conditions.\n", "solutions": ["class Solution {\n    public double mincostToHireWorkers(int[] quality, int[] wage, int K) {\n        int N = quality.length;\n        double ans = 1e9;\n        for (int captain = 0; captain < N; ++captain) {\n            // Must pay at least wage[captain] / quality[captain] per qual\n            double factor = (double) wage[captain] / quality[captain];\n            double prices[] = new double[N];\n            int t = 0;\n            for (int worker = 0; worker < N; ++worker) {\n                double price = factor * quality[worker];\n                if (price < wage[worker]) continue;\n                prices[t++] = price;\n            }\n            if (t < K) continue;\n            Arrays.sort(prices, 0, t);\n            double cand = 0;\n            for (int i = 0; i < K; ++i)\n                cand += prices[i];\n            ans = Math.min(ans, cand);\n        }\n        return ans;\n    }\n}\n", "class Solution {\n    public double mincostToHireWorkers(int[] quality, int[] wage, int K) {\n        int N = quality.length;\n        Worker[] workers = new Worker[N];\n        for (int i = 0; i < N; ++i)\n            workers[i] = new Worker(quality[i], wage[i]);\n        Arrays.sort(workers);\n        double ans = 1e9;\n        int sumq = 0;\n        PriorityQueue<Integer> pool = new PriorityQueue();\n        for (Worker worker: workers) {\n            pool.offer(-worker.quality);\n            sumq += worker.quality;\n            if (pool.size() > K)\n                sumq += pool.poll();\n            if (pool.size() == K)\n                ans = Math.min(ans, sumq * worker.ratio());\n        }\n        return ans;\n    }\n}\nclass Worker implements Comparable<Worker> {\n    public int quality, wage;\n    public Worker(int q, int w) {\n        quality = q;\n        wage = w;\n    }\n    public double ratio() {\n        return (double) wage / quality;\n    }\n    public int compareTo(Worker other) {\n        return Double.compare(ratio(), other.ratio());\n    }\n}\n"]}
{"number": 858, "statement": "There isa special square room with mirrors on each of the fourwalls. Except for the southwestcorner, there are receptors on each of the remaining corners, numbered 0, 1, and 2.\nThe square room has walls of length p, and a laser ray from the southwest cornerfirst meets the east wall at a distance qfrom the 0th receptor.\nReturn the number of the receptor that the ray meets first. (It is guaranteed that the ray will meeta receptor eventually.)\n", "solutions": ["class Solution {\n    double EPS = 1e-6;\n    public int mirrorReflection(int p, int q) {\n        double x = 0, y = 0;\n        double rx = p, ry = q;    \n        // While it hasn't reached a receptor,...\n        while (!( close(x, p) && (close(y, 0) || close(y, p))\n                  || close(x, 0) && close (y, p) )) {\n            // Want smallest t so that some x + rx, y + ry is 0 or p\n            // x + rxt = 0, then t = -x/rx etc.\n            double t = 1e9;\n            if ((-x / rx) > EPS) t = Math.min(t, -x / rx);\n            if ((-y / ry) > EPS) t = Math.min(t, -y / ry);\n            if (((p-x) / rx) > EPS) t = Math.min(t, (p-x) / rx);\n            if (((p-y) / ry) > EPS) t = Math.min(t, (p-y) / ry);\n            x += rx * t;\n            y += ry * t;\n            if (close(x, p) || close(x, 0)) rx *= -1;\n            if (close(y, p) || close(y, 0)) ry *= -1;\n        }\n        if (close(x, p) && close(y, p)) return 1;\n        return close(x, p) ? 0 : 2;\n    }\n    public boolean close(double x, double y) {\n        return Math.abs(x - y) < EPS;\n    }\n}\n", "class Solution {\n    public int mirrorReflection(int p, int q) {\n        int g = gcd(p, q);\n        p /= g; p %= 2;\n        q /= g; q %= 2;\n        if (p == 1 && q == 1) return 1;\n        return p == 1 ? 0 : 2;\n    }\n    public int gcd(int a, int b) {\n        if (a == 0) return b;\n        return gcd(b % a, a);\n    }\n}\n"]}
{"number": 859, "statement": "Given two strings A and Bof lowercase letters, return true if and only if wecan swap two letters in A so that the result equals B.\n", "solutions": ["class Solution {\n    public boolean buddyStrings(String A, String B) {\n        if (A.length() != B.length()) return false;\n        if (A.equals(B)) {\n            int[] count = new int[26];\n            for (int i = 0; i < A.length(); ++i)\n                count[A.charAt(i) - 'a']++;\n            for (int c: count)\n                if (c > 1) return true;\n            return false;\n        } else {\n            int first = -1, second = -1;\n            for (int i = 0; i < A.length(); ++i) {\n                if (A.charAt(i) != B.charAt(i)) {\n                    if (first == -1)\n                        first = i;\n                    else if (second == -1)\n                        second = i;\n                    else\n                        return false;\n                }\n            }\n            return (second != -1 && A.charAt(first) == B.charAt(second) &&\n                    A.charAt(second) == B.charAt(first));\n        }\n    }\n}\n"]}
{"number": 860, "statement": "At a lemonade stand, each lemonade costs $5.\nCustomers are standing in a queue to buy from you, and order one at a time (in the order specified by bills).\nEach customer will only buy one lemonade andpay with either a $5, $10, or $20 bill. You must provide the correct change to each customer, so that the net transaction is that the customer pays $5.\nNote that you don't have any changein hand at first.\nReturn trueif and only if you can provide every customer with correct change.\n", "solutions": ["class Solution {\n    public boolean lemonadeChange(int[] bills) {\n        int five = 0, ten = 0;\n        for (int bill: bills) {\n            if (bill == 5)\n                five++;\n            else if (bill == 10) {\n                if (five == 0) return false;\n                five--;\n                ten++;\n            } else {\n                if (five > 0 && ten > 0) {\n                    five--;\n                    ten--;\n                } else if (five >= 3) {\n                    five -= 3;\n                } else {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n}\n"]}
{"number": 861, "statement": "We have a two dimensional matrixA where each value is 0 or 1.\nA move consists of choosing any row or column, and toggling each value in that row or column: changing all 0s to 1s, and all 1s to 0s.\nAfter making any number of moves, every row of this matrix is interpreted as a binary number, and the score of the matrix is the sum of these numbers.\nReturn the highest possiblescore.\n", "solutions": ["class Solution {\n    public int matrixScore(int[][] A) {\n        int R = A.length, C = A[0].length;\n        int[] colsums = new int[C];\n        for (int r = 0; r < R; ++r)\n            for (int c = 0; c < C; ++c)\n                colsums[c] += A[r][c];\n        int ans = 0;\n        for (int state = 0; state < (1<<R); ++state) {\n            // Toggle the rows so that after, 'state' represents\n            // the toggled rows.\n            if (state > 0) {\n                int trans = state ^ (state-1);\n                for (int r = 0; r < R; ++r) {\n                    if (((trans >> r) & 1) > 0) {\n                        for (int c = 0; c < C; ++c) {\n                            colsums[c] += A[r][c] == 1 ? -1 : 1;\n                            A[r][c] ^= 1;\n                        }\n                    }\n                }\n            }\n            // Calculate the score with the rows toggled by 'state'\n            int score = 0;\n            for (int c = 0; c < C; ++c)\n                score += Math.max(colsums[c], R - colsums[c]) * (1 << (C-1-c));\n            ans = Math.max(ans, score);\n        }\n        return ans;\n    }\n}\n", "class Solution {\n    public int matrixScore(int[][] A) {\n        int R = A.length, C = A[0].length;\n        int ans = 0;\n        for (int c = 0; c < C; ++c) {\n            int col = 0;\n            for (int r = 0; r < R; ++r)\n                col += A[r][c] ^ A[r][0];\n            ans += Math.max(col, R - col) * (1 << (C-1-c));\n        }\n        return ans;\n    }\n}\n"]}
{"number": 862, "statement": "Return the length of the shortest, non-empty, contiguoussubarray of A with sum at least K.\nIf there is no non-empty subarray with sum at least K, return -1.\n", "solutions": ["class Solution {\n    public int shortestSubarray(int[] A, int K) {\n        int N = A.length;\n        long[] P = new long[N+1];\n        for (int i = 0; i < N; ++i)\n            P[i+1] = P[i] + (long) A[i];\n        // Want smallest y-x with P[y] - P[x] >= K\n        int ans = N+1; // N+1 is impossible\n        Deque<Integer> monoq = new LinkedList(); //opt(y) candidates, as indices of P\n        for (int y = 0; y < P.length; ++y) {\n            // Want opt(y) = largest x with P[x] <= P[y] - K;\n            while (!monoq.isEmpty() && P[y] <= P[monoq.getLast()])\n                monoq.removeLast();\n            while (!monoq.isEmpty() && P[y] >= P[monoq.getFirst()] + K)\n                ans = Math.min(ans, y - monoq.removeFirst());\n            monoq.addLast(y);\n        }\n        return ans < N+1 ? ans : -1;\n    }\n}\n"]}
{"number": 863, "statement": "We are given a binary tree (with root noderoot), a target node, and an integer value K.\nReturn a list of the values of allnodes that have a distance K from the target node. The answer can be returned in any order.\n", "solutions": ["class Solution {\n    Map<TreeNode, TreeNode> parent;\n    public List<Integer> distanceK(TreeNode root, TreeNode target, int K) {\n        parent = new HashMap();\n        dfs(root, null);\n        Queue<TreeNode> queue = new LinkedList();\n        queue.add(null);\n        queue.add(target);\n        Set<TreeNode> seen = new HashSet();\n        seen.add(target);\n        seen.add(null);\n        int dist = 0;\n        while (!queue.isEmpty()) {\n            TreeNode node = queue.poll();\n            if (node == null) {\n                if (dist == K) {\n                    List<Integer> ans = new ArrayList();\n                    for (TreeNode n: queue)\n                        ans.add(n.val);\n                    return ans;\n                }\n                queue.offer(null);\n                dist++;\n            } else {\n                if (!seen.contains(node.left)) {\n                    seen.add(node.left);\n                    queue.offer(node.left);\n                }\n                if (!seen.contains(node.right)) {\n                    seen.add(node.right);\n                    queue.offer(node.right);\n                }\n                TreeNode par = parent.get(node);\n                if (!seen.contains(par)) {\n                    seen.add(par);\n                    queue.offer(par);\n                }\n            }\n        }\n        return new ArrayList<Integer>();\n    }\n    public void dfs(TreeNode node, TreeNode par) {\n        if (node != null) {\n            parent.put(node, par);\n            dfs(node.left, node);\n            dfs(node.right, node);\n        }\n    }\n}\n", "class Solution {\n    List<Integer> ans;\n    TreeNode target;\n    int K;\n    public List<Integer> distanceK(TreeNode root, TreeNode target, int K) {\n        ans = new LinkedList();\n        this.target = target;\n        this.K = K;\n        dfs(root);\n        return ans;\n    }\n    // Return vertex distance from node to target if exists, else -1\n    // Vertex distance: the number of vertices on the path from node to target\n    public int dfs(TreeNode node) {\n        if (node == null)\n            return -1;\n        else if (node == target) {\n            subtree_add(node, 0);\n            return 1;\n        } else {\n            int L = dfs(node.left), R = dfs(node.right);\n            if (L != -1) {\n                if (L == K) ans.add(node.val);\n                subtree_add(node.right, L + 1);\n                return L + 1;\n            } else if (R != -1) {\n                if (R == K) ans.add(node.val);\n                subtree_add(node.left, R + 1);\n                return R + 1;\n            } else {\n                return -1;\n            }\n        }\n    }\n    // Add all nodes 'K - dist' from the node to answer.\n    public void subtree_add(TreeNode node, int dist) {\n        if (node == null) return;\n        if (dist == K)\n            ans.add(node.val);\n        else {\n            subtree_add(node.left, dist + 1);\n            subtree_add(node.right, dist + 1);\n        }\n    }\n}\n"]}
{"number": 864, "statement": "We are given a 2-dimensionalgrid.\".\" is an empty cell, \"#\" isa wall, \"@\" is the starting point, (\"a\", \"b\", ...) are keys, and (\"A\",\"B\", ...) are locks.\nWe start at the starting point, and one move consists of walking one space in one of the 4 cardinal directions. We cannot walk outside the grid, or walk into a wall. If we walk over a key, we pick it up. We can't walk over a lock unless we have the corresponding key.\nFor some 1 = K = 6, there is exactly one lowercase and one uppercase letter of the first K letters of the English alphabet in the grid. This means that there is exactly one key for each lock, and one lock for each key; and also that the letters used to represent the keys and locks werechosen in the same order as the English alphabet.\nReturn the lowest number of moves to acquire all keys. Ifit's impossible, return -1.\n", "solutions": ["import java.awt.Point;\nclass Solution {\n    int INF = Integer.MAX_VALUE;\n    String[] grid;\n    int R, C;\n    Map<Character, Point> location;\n    int[] dr = new int[]{-1, 0, 1, 0};\n    int[] dc = new int[]{0, -1, 0, 1};\n    public int shortestPathAllKeys(String[] grid) {\n        this.grid = grid;\n        R = grid.length;\n        C = grid[0].length();\n        //location['a'] = the coordinates of 'a' on the grid, etc.\n        location = new HashMap();\n        for (int r = 0; r < R; ++r)\n            for (int c = 0; c < C; ++c) {\n                char v = grid[r].charAt(c);\n                if (v != '.' && v != '#')\n                    location.put(v, new Point(r, c));\n            }\n        int ans = INF;\n        int num_keys = location.size() / 2;\n        String[] alphabet = new String[num_keys];\n        for (int i = 0; i < num_keys; ++i)\n            alphabet[i] = Character.toString((char)('a' + i));\n        //alphabet = [\"a\", \"b\", \"c\"], if there were 3 keys\n        search: for (String cand: permutations(alphabet, 0, num_keys)) {\n            //bns : the built candidate answer, consisting of the sum\n            //of distances of the segments from '@' to cand[0] to cand[1] etc.\n            int bns = 0;\n            for (int i = 0; i < num_keys; ++i) {\n                char source = i > 0 ? cand.charAt(i-1) : '@';\n                char target = cand.charAt(i);\n                //keymask : an integer with the 0-th bit set if we picked up\n                // key 'a', the 1-th bit set if we picked up key 'b', etc.\n                int keymask = 0;\n                for (int j = 0; j < i; ++j)\n                    keymask |= 1 << (cand.charAt(j) - 'a');\n                int d = bfs(source, target, keymask);\n                if (d == INF) continue search;\n                bns += d;\n                if (bns >= ans) continue search;\n            }\n            ans = bns;\n        }\n        return ans < INF ? ans : -1;\n    }\n    public int bfs(char source, char target, int keymask) {\n        int sr = location.get(source).x;\n        int sc = location.get(source).y;\n        int tr = location.get(target).x;\n        int tc = location.get(target).y;\n        boolean[][] seen = new boolean[R][C];\n        seen[sr][sc] = true;\n        int curDepth = 0;\n        Queue<Point> queue = new LinkedList();\n        queue.offer(new Point(sr, sc));\n        queue.offer(null);\n        while (!queue.isEmpty()) {\n            Point p = queue.poll();\n            if (p == null) {\n                curDepth++;\n                if (!queue.isEmpty())\n                    queue.offer(null);\n                continue;\n            }\n            int r = p.x, c = p.y;\n            if (r == tr && c == tc) return curDepth;\n            for (int i = 0; i < 4; ++i) {\n                int cr = r + dr[i];\n                int cc = c + dc[i];\n                if (0 <= cr && cr < R && 0 <= cc && cc < C && !seen[cr][cc]){\n                    char cur = grid[cr].charAt(cc);\n                    if (cur != '#') {\n                        if (Character.isUpperCase(cur) && (((1 << (cur - 'A')) & keymask) <= 0))\n                            continue; // at lock and don't have key\n                        queue.offer(new Point(cr, cc));\n                        seen[cr][cc] = true;\n                    }\n                }\n            }\n        }\n        return INF;\n    }\n    public List<String> permutations(String[] alphabet, int used, int size) {\n        List<String> ans = new ArrayList();\n        if (size == 0) {\n            ans.add(new String(\"\"));\n            return ans;\n        }\n        for (int b = 0; b < alphabet.length; ++b)\n            if (((used >> b) & 1) == 0)\n                for (String rest: permutations(alphabet, used | (1 << b), size - 1))\n                    ans.add(alphabet[b] + rest);\n        return ans;\n    }\n}\n", "import java.awt.Point;\nclass Solution {\n    int INF = Integer.MAX_VALUE;\n    String[] grid;\n    int R, C;\n    Map<Character, Point> location;\n    int[] dr = new int[]{-1, 0, 1, 0};\n    int[] dc = new int[]{0, -1, 0, 1};\n    public int shortestPathAllKeys(String[] grid) {\n        this.grid = grid;\n        R = grid.length;\n        C = grid[0].length();\n        //location : the points of interest\n        location = new HashMap();\n        for (int r = 0; r < R; ++r)\n            for (int c = 0; c < C; ++c) {\n                char v = grid[r].charAt(c);\n                if (v != '.' && v != '#')\n                    location.put(v, new Point(r, c));\n            }\n        int targetState = (1 << (location.size() / 2)) - 1;\n        Map<Character, Map<Character, Integer>> dists = new HashMap();\n        for (char place: location.keySet())\n            dists.put(place, bfsFrom(place));\n        //Dijkstra\n        PriorityQueue<ANode> pq = new PriorityQueue<ANode>((a, b) ->\n                Integer.compare(a.dist, b.dist));\n        pq.offer(new ANode(new Node('@', 0), 0));\n        Map<Node, Integer> finalDist = new HashMap();\n        finalDist.put(new Node('@', 0), 0);\n        while (!pq.isEmpty()) {\n            ANode anode = pq.poll();\n            Node node = anode.node;\n            int d = anode.dist;\n            if (finalDist.getOrDefault(node, INF) < d) continue;\n            if (node.state == targetState) return d;\n            for (char destination: dists.get(node.place).keySet()) {\n                int d2 = dists.get(node.place).get(destination);\n                int state2 = node.state;\n                if (Character.isLowerCase(destination)) //key\n                    state2 |= (1 << (destination - 'a'));\n                if (Character.isUpperCase(destination)) //lock\n                    if ((node.state & (1 << (destination - 'A'))) == 0) // no key\n                        continue;\n                if (d + d2 < finalDist.getOrDefault(new Node(destination, state2), INF)) {\n                    finalDist.put(new Node(destination, state2), d + d2);\n                    pq.offer(new ANode(new Node(destination, state2), d+d2));\n                }\n            }\n        }\n        return -1;\n    }\n    public Map<Character, Integer> bfsFrom(char source) {\n        int sr = location.get(source).x;\n        int sc = location.get(source).y;\n        boolean[][] seen = new boolean[R][C];\n        seen[sr][sc] = true;\n        int curDepth = 0;\n        Queue<Point> queue = new LinkedList();\n        queue.offer(new Point(sr, sc));\n        queue.offer(null);\n        Map<Character, Integer> dist = new HashMap();\n        while (!queue.isEmpty()) {\n            Point p = queue.poll();\n            if (p == null) {\n                curDepth++;\n                if (!queue.isEmpty())\n                    queue.offer(null);\n                continue;\n            }\n            int r = p.x, c = p.y;\n            if (grid[r].charAt(c) != source && grid[r].charAt(c) != '.') {\n                dist.put(grid[r].charAt(c), curDepth);\n                continue; // Stop walking from here if we reach a point of interest\n            }\n            for (int i = 0; i < 4; ++i) {\n                int cr = r + dr[i];\n                int cc = c + dc[i];\n                if (0 <= cr && cr < R && 0 <= cc && cc < C && !seen[cr][cc]){\n                    if (grid[cr].charAt(cc) != '#') {\n                        queue.offer(new Point(cr, cc));\n                        seen[cr][cc] = true;\n                    }\n                }\n            }\n        }\n        return dist;\n    }\n}\n// ANode: Annotated Node\nclass ANode {\n    Node node;\n    int dist;\n    ANode(Node n, int d) {\n        node = n;\n        dist = d;\n    }\n}\nclass Node {\n    char place;\n    int state;\n    Node(char p, int s) {\n        place = p;\n        state = s;\n    }\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (!(o instanceof Node)) return false;\n        Node other = (Node) o;\n        return (place == other.place && state == other.state);\n    }\n    @Override\n    public int hashCode() {\n        return 256 * state + place;\n    }\n}\n"]}
{"number": 865, "statement": "Given a binary tree rooted at root, the depth of each node is the shortest distance to the root.\nA node is deepest if it has the largest depth possible amongany node in the entire tree.\nThe subtree of a node is that node, plus the set of all descendants of that node.\nReturn the node with the largest depth such that it contains all the deepest nodes in its subtree.\n", "solutions": ["class Solution {\n    Map<TreeNode, Integer> depth;\n    int max_depth;\n    public TreeNode subtreeWithAllDeepest(TreeNode root) {\n        depth = new HashMap();\n        depth.put(null, -1);\n        dfs(root, null);\n        max_depth = -1;\n        for (Integer d: depth.values())\n            max_depth = Math.max(max_depth, d);\n        return answer(root);\n    }\n    public void dfs(TreeNode node, TreeNode parent) {\n        if (node != null) {\n            depth.put(node, depth.get(parent) + 1);\n            dfs(node.left, node);\n            dfs(node.right, node);\n        }\n    }\n    public TreeNode answer(TreeNode node) {\n        if (node == null || depth.get(node) == max_depth)\n            return node;\n        TreeNode L = answer(node.left),\n                 R = answer(node.right);\n        if (L != null && R != null) return node;\n        if (L != null) return L;\n        if (R != null) return R;\n        return null;\n    }\n}\n", "class Solution {\n    public TreeNode subtreeWithAllDeepest(TreeNode root) {\n        return dfs(root).node;\n    }\n    // Return the result of the subtree at this node.\n    public Result dfs(TreeNode node) {\n        if (node == null) return new Result(null, 0);\n        Result L = dfs(node.left),\n               R = dfs(node.right);\n        if (L.dist > R.dist) return new Result(L.node, L.dist + 1);\n        if (L.dist < R.dist) return new Result(R.node, R.dist + 1);\n        return new Result(node, L.dist + 1);\n    }\n}\n/**\n * The result of a subtree is:\n *       Result.node: the largest depth node that is equal to or\n *                    an ancestor of all the deepest nodes of this subtree.\n *       Result.dist: the number of nodes in the path from the root\n *                    of this subtree, to the deepest node in this subtree.\n */\nclass Result {\n    TreeNode node;\n    int dist;\n    Result(TreeNode n, int d) {\n        node = n;\n        dist = d;\n    }\n}\n"]}
{"number": 866, "statement": "Find the smallest prime palindrome greater than or equal to N.\nRecall that anumber is prime if it's only divisors are 1 and itself, and it is greater than 1.\nFor example, 2,3,5,7,11 and 13 areprimes.\nRecall that a number is a palindrome if it reads the same from left to right as it does from right to left.\nFor example, 12321 is a palindrome.\n", "solutions": ["class Solution {\n    public int primePalindrome(int N) {\n        for (int L = 1; L <= 5; ++L) {\n            //Check for odd-length palindromes\n            for (int root = (int)Math.pow(10, L - 1); root < (int)Math.pow(10, L); ++root) {\n                StringBuilder sb = new StringBuilder(Integer.toString(root));\n                for (int k = L-2; k >= 0; --k)\n                    sb.append(sb.charAt(k));\n                int x = Integer.valueOf(sb.toString());\n                if (x >= N && isPrime(x))\n                    return x;\n                    //If we didn't check for even-length palindromes:\n                    //return N <= 11 ? min(x, 11) : x\n            }\n            //Check for even-length palindromes\n            for (int root = (int)Math.pow(10, L - 1); root < (int)Math.pow(10, L); ++root) {\n                StringBuilder sb = new StringBuilder(Integer.toString(root));\n                for (int k = L-1; k >= 0; --k)\n                    sb.append(sb.charAt(k));\n                int x = Integer.valueOf(sb.toString());\n                if (x >= N && isPrime(x))\n                    return x;\n            }\n        }\n        throw null;\n    }\n    public boolean isPrime(int N) {\n        if (N < 2) return false;\n        int R = (int) Math.sqrt(N);\n        for (int d = 2; d <= R; ++d)\n            if (N % d == 0) return false;\n        return true;\n    }\n}\n", "class Solution {\n    public int primePalindrome(int N) {\n        while (true) {\n            if (N == reverse(N) && isPrime(N))\n                return N;\n            N++;\n            if (10_000_000 < N && N < 100_000_000)\n                N = 100_000_000;\n        }\n    }\n    public boolean isPrime(int N) {\n        if (N < 2) return false;\n        int R = (int) Math.sqrt(N);\n        for (int d = 2; d <= R; ++d)\n            if (N % d == 0) return false;\n        return true;\n    }\n    public int reverse(int N) {\n        int ans = 0;\n        while (N > 0) {\n            ans = 10 * ans + (N % 10);\n            N /= 10;\n        }\n        return ans;\n    }\n}\n"]}
{"number": 867, "statement": "Given amatrix A, return the transpose of A.\nThe transpose of a matrix is the matrix flipped over it's main diagonal, switching the row and column indices of the matrix.\n", "solutions": ["class Solution {\n    public int[][] transpose(int[][] A) {\n        int R = A.length, C = A[0].length;\n        int[][] ans = new int[C][R];\n        for (int r = 0; r < R; ++r)\n            for (int c = 0; c < C; ++c) {\n                ans[c][r] = A[r][c];\n            }\n        return ans;\n    }\n}\n"]}
{"number": 868, "statement": "Given a positiveinteger N, find and return the longest distance between two consecutive 1's in the binary representation of N.\nIf there aren't two consecutive 1's, return 0.\n", "solutions": ["class Solution {\n    public int binaryGap(int N) {\n        int[] A = new int[32];\n        int t = 0;\n        for (int i = 0; i < 32; ++i)\n            if (((N >> i) & 1) != 0)\n                A[t++] = i;\n        int ans = 0;\n        for (int i = 0; i < t - 1; ++i)\n            ans = Math.max(ans, A[i+1] - A[i]);\n        return ans;\n    }\n}\n", "class Solution {\n    public int binaryGap(int N) {\n        int last = -1, ans = 0;\n        for (int i = 0; i < 32; ++i)\n            if (((N >> i) & 1) > 0) {\n                if (last >= 0)\n                    ans = Math.max(ans, i - last);\n                last = i;\n            }\n        return ans;\n    }\n}\n"]}
{"number": 869, "statement": "Starting with a positive integer N, we reorder the digits in any order (including the original order) such that the leading digit is not zero.\nReturn trueif and only if we can do this in a way such that the resulting number is a power of 2.\n", "solutions": ["class Solution {\n    public boolean reorderedPowerOf2(int N) {\n        // Build eg. N = 128 -> A = [1, 2, 8]\n        String S = Integer.toString(N);\n        int[] A = new int[S.length()];\n        for (int i = 0; i < S.length(); ++i)\n            A[i] = S.charAt(i) - '0';\n        return permutations(A, 0);\n    }\n    // Return true if A represents a valid power of 2\n    public boolean isPowerOfTwo(int[] A) {\n        if (A[0] == 0) return false;  // no leading zero\n        // Build eg. A = [1, 2, 8] -> N = 128\n        int N = 0;\n        for (int x: A)\n            N = 10 * N + x;\n        // Remove the largest power of 2\n        while (N > 0 && ((N & 1) == 0))\n            N >>= 1;\n        // Check that there are no other factors besides 2\n        return N == 1;\n    }\n    /**\n     * Returns true if some permutation of (A[start], A[start+1], ...)\n     * can result in A representing a power of 2.\n     */\n    public boolean permutations(int[] A, int start) {\n        if (start == A.length)\n            return isPowerOfTwo(A);\n        // Choose some index i from [start, A.length - 1]\n        // to be placed into position A[start].\n        for (int i = start; i < A.length; ++i) {\n            // Place A[start] with value A[i].\n            swap(A, start, i);\n            // For each such placement of A[start], if a permutation\n            // of (A[start+1], A[start+2], ...) can result in A\n            // representing a power of 2, return true.\n            if (permutations(A, start + 1))\n                return true;\n            // Restore the array to the state it was in before\n            // A[start] was placed with value A[i].\n            swap(A, start, i);\n        }\n        return false;\n    }\n    public void swap(int[] A, int i, int j) {\n        int t = A[i];\n        A[i] = A[j];\n        A[j] = t;\n    }\n}\n", "class Solution {\n    public boolean reorderedPowerOf2(int N) {\n        int[] A = count(N);\n        for (int i = 0; i < 31; ++i)\n            if (Arrays.equals(A, count(1 << i)))\n                return true;\n        return false;\n    }\n    // Returns the count of digits of N\n    // Eg. N = 112223334, returns [0,2,3,3,1,0,0,0,0,0]\n    public int[] count(int N) {\n        int[] ans = new int[10];\n        while (N > 0) {\n            ans[N % 10]++;\n            N /= 10;\n        }\n        return ans;\n    }\n}\n"]}
{"number": 870, "statement": "Given two arrays A and B of equal size, the advantage of A with respect to B is the number of indices ifor which A[i]  B[i].\nReturn any permutation of A that maximizes its advantage with respect to B.\n", "solutions": ["class Solution {\n    public int[] advantageCount(int[] A, int[] B) {\n        int[] sortedA = A.clone();\n        Arrays.sort(sortedA);\n        int[] sortedB = B.clone();\n        Arrays.sort(sortedB);\n        // assigned[b] = list of a that are assigned to beat b\n        Map<Integer, Deque<Integer>> assigned = new HashMap();\n        for (int b: B) assigned.put(b, new LinkedList());\n        // remaining = list of a that are not assigned to any b\n        Deque<Integer> remaining = new LinkedList();\n        // populate (assigned, remaining) appropriately\n        // sortedB[j] is always the smallest unassigned element in B\n        int j = 0;\n        for (int a: sortedA) {\n            if (a > sortedB[j]) {\n                assigned.get(sortedB[j++]).add(a);\n            } else {\n                remaining.add(a);\n            }\n        }\n        // Reconstruct the answer from annotations (assigned, remaining)\n        int[] ans = new int[B.length];\n        for (int i = 0; i < B.length; ++i) {\n            // if there is some a assigned to b...\n            if (assigned.get(B[i]).size() > 0)\n                ans[i] = assigned.get(B[i]).pop();\n            else\n                ans[i] = remaining.pop();\n        }\n        return ans;\n    }\n}\n"]}
{"number": 871, "statement": "A car travels from a starting position to a destination which is target miles east of the starting position.\nAlong the way, there are gas stations. Each station[i]represents a gas station that is station[i][0] miles east of the starting position, and has station[i][1] liters of gas.\nThe car starts with an infinite tank of gas, which initially hasstartFuelliters of fuel in it. It uses 1 liter of gas per 1 mile that it drives.\nWhen the carreaches a gas station, it may stop and refuel, transferring all the gas from the station into the car.\nWhat is the least number of refueling stops the car must make in order to reach its destination? If it cannot reach the destination, return -1.\nNote that if the car reaches a gas station with 0 fuel left, the car can still refuel there. If the car reaches the destination with 0 fuel left, it is still considered to have arrived.\n", "solutions": ["class Solution {\n    public int minRefuelStops(int target, int startFuel, int[][] stations) {\n        int N = stations.length;\n        long[] dp = new long[N + 1];\n        dp[0] = startFuel;\n        for (int i = 0; i < N; ++i)\n            for (int t = i; t >= 0; --t)\n                if (dp[t] >= stations[i][0])\n                    dp[t+1] = Math.max(dp[t+1], dp[t] + (long) stations[i][1]);\n        for (int i = 0; i <= N; ++i)\n            if (dp[i] >= target) return i;\n        return -1;\n    }\n}\n", "class Solution {\n    public int minRefuelStops(int target, int tank, int[][] stations) {\n        // pq is a maxheap of gas station capacities\n        PriorityQueue<Integer> pq = new PriorityQueue(Collections.reverseOrder());\n        int ans = 0, prev = 0;\n        for (int[] station: stations) {\n            int location = station[0];\n            int capacity = station[1];\n            tank -= location - prev;\n            while (!pq.isEmpty() && tank < 0) {  // must refuel in past\n                tank += pq.poll();\n                ans++;\n            }\n            if (tank < 0) return -1;\n            pq.offer(capacity);\n            prev = location;\n        }\n        // Repeat body for station = (target, inf)\n        {\n            tank -= target - prev;\n            while (!pq.isEmpty() && tank < 0) {\n                tank += pq.poll();\n                ans++;\n            }\n            if (tank < 0) return -1;\n        }\n        return ans;\n    }\n}\n"]}
{"number": 872, "statement": "Consider all the leaves of a binary tree. Fromleft to right order, the values of thoseleaves form a leaf value sequence.\nFor example, in the given tree above, the leaf value sequence is (6, 7, 4, 9, 8).\nTwo binary trees are considered leaf-similarif their leaf value sequence is the same.\nReturn true if and only if the two given trees with head nodes root1 and root2 are leaf-similar.\nConstraints:\nBoth of the given trees will have between 1 and 200 nodes.\nBoth of the given trees will have values between 0 and 200\n", "solutions": ["class Solution {\npublic:\n    bool leafSimilar(TreeNode* root1, TreeNode* root2) {\n        vector<int> leaves1;\n        vector<int> leaves2;\n        dfs(root1, leaves1);\n        dfs(root2, leaves2);\n        return leaves1 == leaves2;\n    }\n    void dfs(TreeNode* node, vector<int>& leaves) {\n        if (node == NULL) return;\n        if (node->left == NULL && node->right == NULL)\n            leaves.push_back(node->val);\n        dfs(node->left, leaves);\n        dfs(node->right, leaves);\n    }\n};\n"]}
{"number": 873, "statement": "A sequence X_1, X_2, ..., X_nis fibonacci-like if:\nn = 3\nX_i + X_{i+1} = X_{i+2}for alli + 2 = n\nGiven a strictly increasingarrayA of positive integers forming a sequence, find the length of the longest fibonacci-like subsequence of A. If one does not exist, return 0.\n(Recall that a subsequence is derived from another sequence A bydeleting any number ofelements (including none)from A, without changing the order of the remaining elements. For example, [3, 5, 8] is a subsequence of [3, 4, 5, 6, 7, 8].)\n", "solutions": ["class Solution {\npublic:\n    int lenLongestFibSubseq(vector<int>& A) {\n        int N = A.size();\n        unordered_set<int> S(A.begin(), A.end());\n        int ans = 0;\n        for (int i = 0; i < N; ++i)\n            for (int j = i+1; j < N; ++j) {\n                /* With the starting pair (A[i], A[j]),\n                 * y represents the future expected value in\n                 * the fibonacci subsequence, and x represents\n                 * the most current value found. */\n                int x = A[j], y = A[i] + A[j];\n                int length = 2;\n                while (S.find(y) != S.end()) {\n                    int z = x + y;\n                    x = y;\n                    y = z;\n                    ans = max(ans, ++length);\n                }\n            }\n        return ans >= 3 ? ans : 0;\n    }\n};\n", "class Solution {\npublic:\n    int lenLongestFibSubseq(vector<int>& A) {\n        int N = A.size();\n        unordered_map<int, int> index;\n        for (int i = 0; i < N; ++i)\n            index[A[i]] = i;\n        unordered_map<int, int> longest;\n        int ans = 0;\n        for (int k = 0; k < N; ++k)\n            for (int j = 0; j < k; ++j) {\n                if (A[k] - A[j] < A[j] && index.count(A[k] - A[j])) {\n                    int i = index[A[k] - A[j]];\n                    longest[j * N + k] = longest[i * N + j] + 1;\n                    ans = max(ans, longest[j * N + k] + 2);\n                }\n            }\n        return ans >= 3 ? ans : 0;\n    }\n};\n"]}
{"number": 874, "statement": "A robot on an infinite grid starts at point (0, 0) and faces north. The robot can receive one of three possible types of commands:\n-2: turn left 90 degrees\n-1: turn right 90 degrees\n1 = x = 9: move forward x units\nSome of the grid squares are obstacles.\nThe i-th obstacle is at grid point (obstacles[i][0], obstacles[i][1])\nIf the robot would try to move onto them, the robot stays on the previous grid square instead (but still continues following the rest of the route.)\nReturn the square of the maximum Euclidean distance that the robot will be from the origin.\n", "solutions": ["class Solution {\npublic:\n    int robotSim(vector<int>& commands, vector<vector<int>>& obstacles) {\n        int dx[4] = {0, 1, 0, -1};\n        int dy[4] = {1, 0, -1, 0};\n        int x = 0, y = 0, di = 0;\n        unordered_set<pair<int, int>> obstacleSet;\n        for (vector<int> obstacle: obstacles)\n            obstacleSet.insert(make_pair(obstacle[0], obstacle[1]));\n        int ans = 0;\n        for (int cmd: commands) {\n            if (cmd == -2)\n                di = (di + 3) % 4;\n            else if (cmd == -1)\n                di = (di + 1) % 4;\n            else {\n                for (int k = 0; k < cmd; ++k) {\n                    int nx = x + dx[di];\n                    int ny = y + dy[di];\n                    if (obstacleSet.find(make_pair(nx, ny)) == obstacleSet.end()) {\n                        x = nx;\n                        y = ny;\n                        ans = max(ans, x*x + y*y);\n                    }\n                }\n            }\n        }\n        return ans;\n    }\n};\n"]}
{"number": 875, "statement": "Koko loves to eat bananas. There are Npiles of bananas, the i-thpile has piles[i] bananas. The guards have gone and will come back in H hours.\nKoko can decide her bananas-per-hour eating speed of K. Each hour, she chooses some pile of bananas, and eats K bananas from that pile. If the pile has less than K bananas, she eats all of them instead, and won't eat any more bananas during this hour.\nKoko likes to eat slowly, but still wants to finish eating all the bananas before the guards come back.\nReturn the minimum integer K such that she can eat all the bananas within H hours.\n", "solutions": ["class Solution {\npublic:\n    int minEatingSpeed(vector<int>& piles, int H) {\n        int lo = 1, hi = pow(10, 9);\n        while (lo < hi) {\n            int mi = lo + (hi - lo) / 2;\n            if (!possible(piles, H, mi))\n                lo = mi + 1;\n            else\n                hi = mi;\n        }\n        return lo;\n    }\n    // Can Koko eat all bananas in H hours with eating speed K?\n    bool possible(vector<int>& piles, int H, int K) {\n        int time = 0;\n        for (int p: piles)\n            time += (p - 1) / K + 1;\n        return time <= H;\n    }\n};\n"]}
{"number": 876, "statement": "Given a non-empty, singlylinked list with head node head, returnamiddle node of linked list.\nIf there are two middle nodes, return the second middle node.\n", "solutions": ["class Solution {\npublic:\n    ListNode* middleNode(ListNode* head) {\n        vector<ListNode*> A = {head};\n        while (A.back()->next != NULL)\n            A.push_back(A.back()->next);\n        return A[A.size() / 2];\n    }\n};\n", "class Solution {\npublic:\n    ListNode* middleNode(ListNode* head) {\n        ListNode* slow = head;\n        ListNode* fast = head;\n        while (fast != NULL && fast->next != NULL) {\n            slow = slow->next;\n            fast = fast->next->next;\n        }\n        return slow;\n    }\n};\n"]}
{"number": 877, "statement": "Alex and Lee play a game with piles of stones. There are an even number ofpiles arranged in a row, and each pile has a positive integer number of stones piles[i].\nThe objective of the game is to end with the moststones. The total number of stones is odd, so there are no ties.\nAlex and Lee take turns, with Alex starting first. Each turn, a playertakes the entire pile of stones from either the beginning or the end of the row. This continues until there are no more piles left, at which point the person with the most stones wins.\nAssuming Alex and Lee play optimally, return Trueif and only if Alex wins the game.\n", "solutions": ["class Solution {\npublic:\n    bool stoneGame(vector<int>& piles) {\n        int N = piles.size();\n        // dp[i+1][j+1] = the value of the game [piles[i], ..., piles[j]]\n        int dp[N+2][N+2];\n        memset(dp, 0, sizeof(dp));\n        for (int size = 1; size <= N; ++size)\n            for (int i = 0, j = size - 1; j < N; ++i, ++j) {\n                int parity = (j + i + N) % 2;  // j - i - N; but +x = -x (mod 2)\n                if (parity == 1)\n                    dp[i+1][j+1] = max(piles[i] + dp[i+2][j+1], piles[j] + dp[i+1][j]);\n                else\n                    dp[i+1][j+1] = min(-piles[i] + dp[i+2][j+1], -piles[j] + dp[i+1][j]);\n            }\n        return dp[1][N] > 0;\n    }\n};\n", "class Solution {\npublic:\n    bool stoneGame(vector<int>& piles) {\n        return true;\n    }\n};\n"]}
{"number": 878, "statement": "A positive integeris magicalif it is divisible by either Aor B.\nReturn the N-th magical number. Since the answer may be very large, return it modulo 10^9 + 7.\n", "solutions": ["class Solution {\npublic:\n    int nthMagicalNumber(int N, int A, int B) {\n        int MOD = 1e9 + 7;\n        int L = A / gcd(A, B) * B;\n        int M = L / A + L / B - 1;\n        int q = N / M, r = N % M;\n        long ans = (long) q * L % MOD;\n        if (r == 0)\n            return (int) ans;\n        int heads[2] = {A, B};\n        for (int i = 0; i < r - 1; ++i) {\n            if (heads[0] <= heads[1])\n                heads[0] += A;\n            else\n                heads[1] += B;\n        }\n        ans += min(heads[0], heads[1]);\n        return (int) (ans % MOD);\n    }\n    int gcd(int x, int y) {\n        if (x == 0) return y;\n        return gcd(y % x, x);\n    }\n};\n", "class Solution {\npublic:\n    int nthMagicalNumber(int N, int A, int B) {\n        int MOD = 1e9 + 7;\n        int L = A / gcd(A, B) * B;\n        long lo = 0;\n        long hi = (long) N * min(A, B);\n        while (lo < hi) {\n            long mi = lo + (hi - lo) / 2;\n            // If there are not enough magic numbers below mi...\n            if (mi / A + mi / B - mi / L < N)\n                lo = mi + 1;\n            else\n                hi = mi;\n        }\n        return (int) (lo % MOD);\n    }\n    int gcd(int x, int y) {\n        if (x == 0) return y;\n        return gcd(y % x, x);\n    }\n};\n"]}
{"number": 879, "statement": "There are G people in a gang, and a list of various crimes they could commit.\nThe i-th crime generates a profit[i] and requires group[i] gang members to participate.\nIf a gang member participates in one crime, that member can't participate in another crime.\nLet's call a profitableschemeany subset of these crimes that generates at least P profit, and the total number of gang members participating in that subset of crimes is at most G.\nHow many schemes can be chosen? Since the answer may be verylarge, return it modulo 10^9 + 7.\n", "solutions": ["class Solution {\npublic:\n    int profitableSchemes(int G, int P, vector<int>& group, vector<int>& profit) {\n        int MOD = 1e9 + 7;\n        int N = group.size();\n        long dp[2][P+1][G+1];\n        memset(dp, 0, sizeof(dp));\n        dp[0][0][0] = 1;\n        for (int i = 0; i < N; ++i) {\n            int p0 = profit[i];  // the current crime profit\n            int g0 = group[i];  // the current crime group size\n            long (*cur)[G+1] = dp[i % 2];\n            long (*cur2)[G+1] = dp[(i + 1) % 2];\n            // Deep copy cur into cur2\n            for (int jp = 0; jp <= P; ++jp)\n                for (int jg = 0; jg <= G; ++jg)\n                    cur2[jp][jg] = cur[jp][jg];\n            for (int p1 = 0; p1 <= P; ++p1) {  // p1 : the current profit\n                // p2 : the new profit after committing this crime\n                int p2 = min(p1 + p0, P);\n                for (int g1 = 0; g1 <= G - g0; ++g1) {  // g1 : the current group size\n                    // g2 : the new group size after committing this crime\n                    int g2 = g1 + g0;\n                    cur2[p2][g2] += cur[p1][g1];\n                    cur2[p2][g2] %= MOD;\n                }\n            }\n        }\n        // Sum all schemes with profit P and group size 0 <= g <= G.\n        long ans = 0;\n        for (long x: dp[N % 2][P])\n            ans += x;\n        return (int) (ans % MOD);\n    }\n};\n"]}
{"number": 880, "statement": "An encoded string S is given. To find and write the decoded string to a tape, the encoded string is read one character at a timeand the following steps are taken:\nIf the character read is a letter, that letter is written onto the tape.\nIf the character read is a digit (say d), the entire current tape is repeatedly writtend-1more times in total.\nNow for some encoded string S, and an index K, find and return the K-th letter (1 indexed) in the decoded string.\n", "solutions": ["class Solution {\npublic:\n    string decodeAtIndex(string S, int K) {\n        long size = 0;\n        int N = S.size();\n        // Find size = length of decoded string\n        for (int i = 0; i < N; ++i) {\n            if (isdigit(S[i]))\n                size *= S[i] - '0';\n            else\n                size++;\n        }\n        for (int i = N-1; i >=0; --i) {\n            K %= size;\n            if (K == 0 && isalpha(S[i]))\n                return (string) \"\" + S[i];\n            if (isdigit(S[i]))\n                size /= S[i] - '0';\n            else\n                size--;\n        }\n    }\n};\n"]}
{"number": 881, "statement": "The i-th person has weight people[i], and each boat can carry a maximum weight of limit.\nEach boat carries at most 2 people at the same time, provided the sum of theweight of those people is at most limit.\nReturn the minimum number of boats to carry every given person. (It is guaranteed each person can be carried by a boat.)\n", "solutions": ["class Solution {\npublic:\n    int numRescueBoats(vector<int>& people, int limit) {\n        sort(people.begin(), people.end());\n        int i = 0, j = people.size() - 1;\n        int ans = 0;\n        while (i <= j) {\n            ans++;\n            if (people[i] + people[j] <= limit)\n                i++;\n            j--;\n        }\n        return ans;\n    }\n};\n"]}
{"number": 882, "statement": "Starting with anundirected graph (the \"original graph\") with nodes from 0 to N-1, subdivisions are made to some of the edges.\nThe graph is given as follows: edges[k] is a list of integer pairs (i, j, n) such that (i, j) is an edge of the original graph,\nand n is the total number of new nodes on that edge.\nThen, the edge (i, j) is deleted from the original graph,nnew nodes (x_1, x_2, ..., x_n) are added to the original graph,\nand n+1 newedges (i, x_1), (x_1, x_2), (x_2, x_3), ..., (x_{n-1}, x_n), (x_n, j)are added to the originalgraph.\nNow, you start at node 0from the original graph, and in each move, you travel along oneedge.\nReturn how many nodes you can reach in at most M moves.\n", "solutions": ["#define pii pair<int, int>\nclass Solution {\npublic:\n    int reachableNodes(vector<vector<int>>& edges, int M, int N) {\n        vector<vector<pii>> graph(N);\n        for (vector<int> edge: edges) {\n            int u = edge[0], v = edge[1], w = edge[2];\n            graph[u].push_back({v, w});\n            graph[v].push_back({u, w});\n        }\n        map<int, int> dist;\n        dist[0] = 0;\n        for (int i = 1; i < N; ++i)\n            dist[i] = M+1;\n        map<pii, int> used;\n        int ans = 0;\n        priority_queue<pii, vector<pii>, greater<pii>> pq;\n        pq.push({0, 0});\n        while (!pq.empty()) {\n            pii top = pq.top();\n            pq.pop();\n            int d = top.first, node = top.second;\n            if (d > dist[node]) continue;\n            dist[node] = d;\n            // Each node is only visited once.  We've reached\n            // a node in our original graph.\n            ans++;\n            for (auto pair: graph[node]) {\n                // M - d is how much further we can walk from this node;\n                // weight is how many new nodes there are on this edge.\n                // v is the maximum utilization of this edge.\n                int nei = pair.first;\n                int weight = pair.second;\n                used[{node, nei}] = min(weight, M - d);\n                // d2 is the total distance to reach 'nei' (neighbor) node\n                // in the original graph.\n                int d2 = d + weight + 1;\n                if (d2 < min(dist[nei], M+1)) {\n                    pq.push({d2, nei});\n                    dist[nei] = d2;\n                }\n            }\n        }\n        // At the end, each edge (u, v, w) can be used with a maximum\n        // of w new nodes: a max of used[u, v] nodes from one side,\n        // and used[v, u] nodes from the other.\n        for (vector<int> edge: edges) {\n            int u = edge[0], v = edge[1], w = edge[2];\n            ans += min(w, used[{u, v}] + used[{v, u}]);\n        }\n        return ans;\n    }\n};\n"]}
{"number": 883, "statement": "On aN*N grid, we place some1 * 1 * 1cubes that are axis-aligned with the x, y, and z axes.\nEach valuev = grid[i][j]represents a tower ofvcubes placed on top of grid cell (i, j).\nNow we view theprojectionof these cubesonto the xy, yz, and zx planes.\nA projection is like a shadow, thatmaps our 3 dimensional figure to a 2 dimensional plane.\nHere, we are viewing the \"shadow\" when looking at the cubes from the top, the front, and the side.\nReturn the total area of all three projections.\n", "solutions": ["class Solution {\npublic:\n    int projectionArea(vector<vector<int>>& grid) {\n        int N = grid.size();\n        int ans = 0;\n        for (int i = 0; i < N;  ++i) {\n            int bestRow = 0;  // largest of grid[i][j]\n            int bestCol = 0;  // largest of grid[j][i]\n            for (int j = 0; j < N; ++j) {\n                if (grid[i][j] > 0) ans++;  // top shadow\n                bestRow = max(bestRow, grid[i][j]);\n                bestCol = max(bestCol, grid[j][i]);\n            }\n            ans += bestRow + bestCol;\n        }\n        return ans;\n    }\n};\n"]}
{"number": 884, "statement": "We are given two sentences A and B. (A sentenceis a string of space separated words. Each word consists only of lowercase letters.)\nA word is uncommonif it appears exactly once in one of the sentences, and does not appear in the other sentence.\nReturn a list of all uncommon words.\nYou may return the list in any order.\n", "solutions": ["class Solution {\n    public String[] uncommonFromSentences(String A, String B) {\n        Map<String, Integer> count = new HashMap();\n        for (String word: A.split(\" \"))\n            count.put(word, count.getOrDefault(word, 0) + 1);\n        for (String word: B.split(\" \"))\n            count.put(word, count.getOrDefault(word, 0) + 1);\n        List<String> ans = new LinkedList();\n        for (String word: count.keySet())\n            if (count.get(word) == 1)\n                ans.add(word);\n        return ans.toArray(new String[ans.size()]);\n    }\n}\n"]}
{"number": 885, "statement": "On a 2 dimensional grid with R rows and C columns, we start at (r0, c0) facing east.\nHere, the north-west corner of the grid is at thefirst row and column, and the south-east corner of the grid is at the last row and column.\nNow, we walk in a clockwise spiral shape to visit every position in this grid.\nWhenever we would move outside the boundary of the grid, we continue our walk outside the grid (but may return to the grid boundary later.)\nEventually, we reach all R * C spaces of the grid.\nReturn a list of coordinates representing the positions of the grid in the order they were visited.\n", "solutions": ["class Solution {\n    public int[][] spiralMatrixIII(int R, int C, int r0, int c0) {\n        int[] dr = new int[]{0, 1, 0, -1};\n        int[] dc = new int[]{1, 0, -1, 0};\n        int[][] ans = new int[R*C][2];\n        int t = 0;\n        ans[t++] = new int[]{r0, c0};\n        if (R * C == 1) return ans;\n        for (int k = 1; k < 2*(R+C); k += 2)\n            for (int i = 0; i < 4; ++i) {  // i: direction index\n                int dk = k + (i / 2);  // number of steps in this direction\n                for (int j = 0; j < dk; ++j) {  // for each step in this direction...\n                    // step in the i-th direction\n                    r0 += dr[i];\n                    c0 += dc[i];\n                    if (0 <= r0 && r0 < R && 0 <= c0 && c0 < C) {\n                        ans[t++] = new int[]{r0, c0};\n                        if (t == R * C) return ans;\n                    }\n                }\n            }\n        throw null;\n    }\n}\n"]}
{"number": 886, "statement": "Given a set of Npeople (numbered 1, 2, ..., N), we would like to split everyone into two groups of any size.\nEach person may dislike some other people, and they should not go into the same group.\nFormally, if dislikes[i] = [a, b], it means it is not allowed to put the people numbered a and b into the same group.\nReturn trueif and only if it is possible to split everyone into two groups in this way.\n", "solutions": ["class Solution {\n    ArrayList<Integer>[] graph;\n    Map<Integer, Integer> color;\n    public boolean possibleBipartition(int N, int[][] dislikes) {\n        graph = new ArrayList[N+1];\n        for (int i = 1; i <= N; ++i)\n            graph[i] = new ArrayList();\n        for (int[] edge: dislikes) {\n            graph[edge[0]].add(edge[1]);\n            graph[edge[1]].add(edge[0]);\n        }\n        color = new HashMap();\n        for (int node = 1; node <= N; ++node)\n            if (!color.containsKey(node) && !dfs(node, 0))\n                return false;\n        return true;\n    }\n    public boolean dfs(int node, int c) {\n        if (color.containsKey(node))\n            return color.get(node) == c;\n        color.put(node, c);\n        for (int nei: graph[node])\n            if (!dfs(nei, c ^ 1))\n                return false;\n        return true;\n    }\n}\n"]}
{"number": 887, "statement": "You are given K eggs, and you have access to a building with N floors from 1 to N.\nEach egg is identical in function, and if an egg breaks, you cannot drop itagain.\nYou know that there exists a floor F with 0 = F = N such that any egg dropped at a floor higher than F will break, and any egg dropped at or below floor F will not break.\nEach move, you may take an egg (if you have an unbroken one) and drop it from any floor X (with1 = X = N).\nYour goal is to knowwith certaintywhat the value of F is.\nWhat is the minimum number of moves that you need to know with certaintywhat F is, regardless of the initial value of F?\n", "solutions": ["class Solution {\n    public int superEggDrop(int K, int N) {\n        return dp(K, N);\n    }\n    Map<Integer, Integer> memo = new HashMap();\n    public int dp(int K, int N) {\n        if (!memo.containsKey(N * 100 + K)) {\n            int ans;\n            if (N == 0)\n                ans = 0;\n            else if (K == 1)\n                ans = N;\n            else {\n                int lo = 1, hi = N;\n                while (lo + 1 < hi) {\n                    int x = (lo + hi) / 2;\n                    int t1 = dp(K-1, x-1);\n                    int t2 = dp(K, N-x);\n                    if (t1 < t2)\n                        lo = x;\n                    else if (t1 > t2)\n                        hi = x;\n                    else\n                        lo = hi = x;\n                }\n                ans = 1 + Math.min(Math.max(dp(K-1, lo-1), dp(K, N-lo)),\n                                   Math.max(dp(K-1, hi-1), dp(K, N-hi)));\n            }\n            memo.put(N * 100 + K, ans);\n        }\n        return memo.get(N * 100 + K);\n    }\n}\n", "class Solution {\n    public int superEggDrop(int K, int N) {\n        // Right now, dp[i] represents dp(1, i)\n        int[] dp = new int[N+1];\n        for (int i = 0; i <= N; ++i)\n            dp[i] = i;\n        for (int k = 2; k <= K; ++k) {\n            // Now, we will develop dp2[i] = dp(k, i)\n            int[] dp2 = new int[N+1];\n            int x = 1;\n            for (int n = 1; n <= N; ++n) {\n                // Let's find dp2[n] = dp(k, n)\n                // Increase our optimal x while we can make our answer better.\n                // Notice max(dp[x-1], dp2[n-x]) > max(dp[x], dp2[n-x-1])\n                // is simply max(T1(x-1), T2(x-1)) > max(T1(x), T2(x)).\n                while (x < n && Math.max(dp[x-1], dp2[n-x]) > Math.max(dp[x], dp2[n-x-1]))\n                    x++;\n                // The final answer happens at this x.\n                dp2[n] = 1 + Math.max(dp[x-1], dp2[n-x]);\n            }\n            dp = dp2;\n        }\n        return dp[N];\n    }\n}\n", "class Solution {\n    public int superEggDrop(int K, int N) {\n        int lo = 1, hi = N;\n        while (lo < hi) {\n            int mi = (lo + hi) / 2;\n            if (f(mi, K, N) < N)\n                lo = mi + 1;\n            else\n                hi = mi;\n        }\n        return lo;\n    }\n    public int f(int x, int K, int N) {\n        int ans = 0, r = 1;\n        for (int i = 1; i <= K; ++i) {\n            r *= x-i+1;\n            r /= i;\n            ans += r;\n            if (ans >= N) break;\n        }\n        return ans;\n    }\n}\n"]}
{"number": 888, "statement": "Alice and Bob have candy bars of different sizes: A[i] is the size of the i-th bar of candy that Alice has, and B[j] is the size of the j-th bar of candy that Bob has.\nSince they are friends, they would like to exchange one candy bar each so that after the exchange, they both have the same totalamount of candy. (The total amount of candya person has is the sum of the sizes of candybars they have.)\nReturn an integer array answhere ans[0] is the size of the candy bar that Alice must exchange, and ans[1] is the size of the candy bar that Bob must exchange.\nIf there are multiple answers, you may return any one of them. It is guaranteed an answer exists.\n", "solutions": ["class Solution {\n    public int[] fairCandySwap(int[] A, int[] B) {\n        int sa = 0, sb = 0;  // sum of A, B respectively\n        for (int x: A) sa += x;\n        for (int x: B) sb += x;\n        int delta = (sb - sa) / 2;\n        // If Alice gives x, she expects to receive x + delta\n        Set<Integer> setB = new HashSet();\n        for (int x: B) setB.add(x);\n        for (int x: A)\n            if (setB.contains(x + delta))\n                return new int[]{x, x + delta};\n        throw null;\n    }\n}\n"]}
{"number": 889, "statement": "Return any binary tree that matches the given preorder and postorder traversals.\nValues in the traversalspre and postare distinctpositive integers.\n", "solutions": ["class Solution {\n    public TreeNode constructFromPrePost(int[] pre, int[] post) {\n        int N = pre.length;\n        if (N == 0) return null;\n        TreeNode root = new TreeNode(pre[0]);\n        if (N == 1) return root;\n        int L = 0;\n        for (int i = 0; i < N; ++i)\n            if (post[i] == pre[1])\n                L = i+1;\n        root.left = constructFromPrePost(Arrays.copyOfRange(pre, 1, L+1),\n                                         Arrays.copyOfRange(post, 0, L));\n        root.right = constructFromPrePost(Arrays.copyOfRange(pre, L+1, N),\n                                          Arrays.copyOfRange(post, L, N-1));\n        return root;\n    }\n}\n", "class Solution {\n    int[] pre, post;\n    public TreeNode constructFromPrePost(int[] pre, int[] post) {\n        this.pre = pre;\n        this.post = post;\n        return make(0, 0, pre.length);\n    }\n    public TreeNode make(int i0, int i1, int N) {\n        if (N == 0) return null;\n        TreeNode root = new TreeNode(pre[i0]);\n        if (N == 1) return root;\n        int L = 1;\n        for (; L < N; ++L)\n            if (post[i1 + L-1] == pre[i0 + 1])\n                break;\n        root.left = make(i0+1, i1, L);\n        root.right = make(i0+L+1, i1+L, N-1-L);\n        return root;\n    }\n}\n"]}
{"number": 890, "statement": "You have a list ofwords and a pattern, and you want to know which words in words matches the pattern.\nA word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word.\n(Recall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.)\nReturn a list of the words in wordsthat match the given pattern.\nYou may return the answer in any order.\n", "solutions": ["class Solution {\n    public List<String> findAndReplacePattern(String[] words, String pattern) {\n        List<String> ans = new ArrayList();\n        for (String word: words)\n            if (match(word, pattern))\n                ans.add(word);\n        return ans;\n    }\n    public boolean match(String word, String pattern) {\n        Map<Character, Character> m1 = new HashMap();\n        Map<Character, Character> m2 = new HashMap();\n        for (int i = 0; i < word.length(); ++i) {\n            char w = word.charAt(i);\n            char p = pattern.charAt(i);\n            if (!m1.containsKey(w)) m1.put(w, p);\n            if (!m2.containsKey(p)) m2.put(p, w);\n            if (m1.get(w) != p || m2.get(p) != w)\n                return false;\n        }\n        return true;\n    }\n}\n", "class Solution {\n    public List<String> findAndReplacePattern(String[] words, String pattern) {\n        List<String> ans = new ArrayList();\n        for (String word: words)\n            if (match(word, pattern))\n                ans.add(word);\n        return ans;\n    }\n    public boolean match(String word, String pattern) {\n        Map<Character, Character> M = new HashMap();\n        for (int i = 0; i < word.length(); ++i) {\n            char w = word.charAt(i);\n            char p = pattern.charAt(i);\n            if (!M.containsKey(w)) M.put(w, p);\n            if (M.get(w) != p) return false;\n        }\n        boolean[] seen = new boolean[26];\n        for (char p: M.values()) {\n            if (seen[p - 'a']) return false;\n            seen[p - 'a'] = true;\n        }\n        return true;\n    }\n}\n"]}
{"number": 891, "statement": "Given an array of integers A, consider all non-empty subsequences of A.\nFor any sequence S, let thewidthof S be the difference between the maximum and minimum element of S.\nReturn the sum of the widths of all subsequences of A.\nAs the answer may be very large, return the answer modulo 10^9 + 7.\n", "solutions": ["class Solution {\n    public int sumSubseqWidths(int[] A) {\n        int MOD = 1_000_000_007;\n        int N = A.length;\n        Arrays.sort(A);\n        long[] pow2 = new long[N];\n        pow2[0] = 1;\n        for (int i = 1; i < N; ++i)\n            pow2[i] = pow2[i-1] * 2 % MOD;\n        long ans = 0;\n        for (int i = 0; i < N; ++i)\n            ans = (ans + (pow2[i] - pow2[N-1-i]) * A[i]) % MOD;\n        return (int) ans;\n    }\n}\n"]}
{"number": 892, "statement": "On aN*Ngrid, we place some1 * 1 * 1cubes.\nEach valuev = grid[i][j]represents a tower ofvcubes placed on top of grid cell(i, j).\nReturn the total surface area of the resulting shapes.\n", "solutions": ["class Solution {\n    public int surfaceArea(int[][] grid) {\n        int[] dr = new int[]{0, 1, 0, -1};\n        int[] dc = new int[]{1, 0, -1, 0};\n        int N = grid.length;\n        int ans = 0;\n        for (int r = 0; r < N; ++r)\n            for (int c = 0; c < N; ++c)\n                if (grid[r][c] > 0) {\n                    ans += 2;\n                    for (int k = 0; k < 4; ++k) {\n                        int nr = r + dr[k];\n                        int nc = c + dc[k];\n                        int nv = 0;\n                        if (0 <= nr && nr < N && 0 <= nc && nc < N)\n                            nv = grid[nr][nc];\n                        ans += Math.max(grid[r][c] - nv, 0);\n                    }\n                }\n        return ans;\n    }\n}\n"]}
{"number": 893, "statement": "You are given an array A of strings.\nA moveonto S consists of swapping any two even indexed characters of S, or any two odd indexed characters of S.\nTwo strings S and T arespecial-equivalentif after any number of moves onto S, S == T.\nFor example, S = \"zzxy\" and T = \"xyzz\" are special-equivalent because we may make the moves \"zzxy\" - \"xzzy\" - \"xyzz\"that swap S[0] and S[2], then S[1] and S[3].\nNow, a group of special-equivalent strings from Ais a non-empty subset ofA such that:\nEvery pair of strings in the group are special equivalent, and;\nThe group is the largest size possible (ie., there isn't a string S not in the group such that S is special equivalent to every string in the group)\nReturn the number of groups of special-equivalent strings from A.\n", "solutions": ["class Solution {\n    public int numSpecialEquivGroups(String[] A) {\n        Set<String> seen = new HashSet();\n        for (String S: A) {\n            int[] count = new int[52];\n            for (int i = 0; i < S.length(); ++i)\n                count[S.charAt(i) - 'a' + 26 * (i % 2)]++;\n            seen.add(Arrays.toString(count));\n        }\n        return seen.size();\n    }\n}\n"]}
{"number": 894, "statement": "A full binary treeis a binary tree where each node has exactly 0 or 2children.\nReturn a list of all possible full binary trees with N nodes. Each element of the answer is the root node of one possible tree.\nEach node of eachtree in the answer must have node.val = 0.\nYou may return the final list of trees in any order.\n", "solutions": ["class Solution {\n    Map<Integer, List<TreeNode>> memo = new HashMap();\n    public List<TreeNode> allPossibleFBT(int N) {\n        if (!memo.containsKey(N)) {\n            List<TreeNode> ans = new LinkedList();\n            if (N == 1) {\n                ans.add(new TreeNode(0));\n            } else if (N % 2 == 1) {\n                for (int x = 0; x < N; ++x) {\n                    int y = N - 1 - x;\n                    for (TreeNode left: allPossibleFBT(x))\n                        for (TreeNode right: allPossibleFBT(y)) {\n                            TreeNode bns = new TreeNode(0);\n                            bns.left = left;\n                            bns.right = right;\n                            ans.add(bns);\n                        }\n                }\n            }\n            memo.put(N, ans);\n        }\n        return memo.get(N);\n    }\n}\n"]}
{"number": 895, "statement": "Implement FreqStack, a class which simulates the operation of a stack-like data structure.\nFreqStackhas two functions:\npush(int x), which pushes an integer x onto the stack.\npop(), which removes and returns the most frequent element in the stack.\nIf there is a tie for most frequent element, the element closest to the top of the stack is removed and returned.\n", "solutions": ["class FreqStack {\n    Map<Integer, Integer> freq;\n    Map<Integer, Stack<Integer>> group;\n    int maxfreq;\n    public FreqStack() {\n        freq = new HashMap();\n        group = new HashMap();\n        maxfreq = 0;\n    }\n    public void push(int x) {\n        int f = freq.getOrDefault(x, 0) + 1;\n        freq.put(x, f);\n        if (f > maxfreq)\n            maxfreq = f;\n        group.computeIfAbsent(f, z-> new Stack()).push(x);\n    }\n    public int pop() {\n        int x = group.get(maxfreq).pop();\n        freq.put(x, freq.get(x) - 1);\n        if (group.get(maxfreq).size() == 0)\n            maxfreq--;\n        return x;\n    }\n}\n"]}
{"number": 896, "statement": "An array is monotonic if it is either monotone increasing or monotone decreasing.\nAn array A is monotone increasing if for all i = j, A[i] = A[j]. An array A is monotone decreasing if for all i = j, A[i] = A[j].\nReturn true if and only if the given array A is monotonic.\n", "solutions": ["class Solution {\n    public boolean isMonotonic(int[] A) {\n        return increasing(A) || decreasing(A);\n    }\n    public boolean increasing(int[] A) {\n        for (int i = 0; i < A.length - 1; ++i)\n            if (A[i] > A[i+1]) return false;\n        return true;\n    }\n    public boolean decreasing(int[] A) {\n        for (int i = 0; i < A.length - 1; ++i)\n            if (A[i] < A[i+1]) return false;\n        return true;\n    }\n}\n", "class Solution {\n    public boolean isMonotonic(int[] A) {\n        int store = 0;\n        for (int i = 0; i < A.length - 1; ++i) {\n            int c = Integer.compare(A[i], A[i+1]);\n            if (c != 0) {\n                if (c != store && store != 0)\n                    return false;\n                store = c;\n            }\n        }\n        return true;\n    }\n}\n", "class Solution {\n    public boolean isMonotonic(int[] A) {\n        boolean increasing = true;\n        boolean decreasing = true;\n        for (int i = 0; i < A.length - 1; ++i) {\n            if (A[i] > A[i+1])\n                increasing = false;\n            if (A[i] < A[i+1])\n                decreasing = false;\n        }\n        return increasing || decreasing;\n    }\n}\n"]}
{"number": 897, "statement": "Given a binary search tree, rearrange the tree in in-order so that the leftmost node in the tree is now the root of the tree, and every node has no left child and only 1 right child.\n", "solutions": ["class Solution {    \n    public TreeNode increasingBST(TreeNode root) {\n        List<Integer> vals = new ArrayList();\n        inorder(root, vals);\n        TreeNode ans = new TreeNode(0), cur = ans;\n        for (int v: vals) {\n            cur.right = new TreeNode(v);\n            cur = cur.right;\n        }\n        return ans.right;\n    }\n    public void inorder(TreeNode node, List<Integer> vals) {\n        if (node == null) return;\n        inorder(node.left, vals);\n        vals.add(node.val);\n        inorder(node.right, vals);\n    }\n}\n", "class Solution {\n    TreeNode cur;\n    public TreeNode increasingBST(TreeNode root) {\n        TreeNode ans = new TreeNode(0);\n        cur = ans;\n        inorder(root);\n        return ans.right;\n    }\n    public void inorder(TreeNode node) {\n        if (node == null) return;\n        inorder(node.left);\n        node.left = null;\n        cur.right = node;\n        cur = node;\n        inorder(node.right);\n    }\n}\n"]}
{"number": 898, "statement": "We have an array A of non-negative integers.\nFor every (contiguous) subarray B =[A[i], A[i+1], ..., A[j]] (with i = j), we take the bitwise OR of all the elements in B, obtaining a result A[i] | A[i+1] | ... | A[j].\nReturn the number of possibleresults. (Results that occur more than once are only counted once in the final answer.)\n", "solutions": ["class Solution {\n    public int subarrayBitwiseORs(int[] A) {\n        Set<Integer> ans = new HashSet();\n        Set<Integer> cur = new HashSet();\n        cur.add(0);\n        for (int x: A) {\n            Set<Integer> cur2 = new HashSet();\n            for (int y: cur)\n                cur2.add(x | y);\n            cur2.add(x);\n            cur = cur2;\n            ans.addAll(cur);\n        }\n        return ans.size();\n    }\n}\n"]}
{"number": 899, "statement": "A string S of lowercase letters is given. Then, we may make any number of moves.\nIn each move, wechoose oneof the first K letters (starting from the left), remove it,and place it at the end of the string.\nReturn the lexicographically smallest string we could have after any number of moves.\n", "solutions": ["class Solution {\n    public String orderlyQueue(String S, int K) {\n        if (K == 1) {\n            String ans = S;\n            for (int i = 0; i < S.length(); ++i) {\n                String T = S.substring(i) + S.substring(0, i);\n                if (T.compareTo(ans) < 0) ans = T;\n            }\n            return ans;\n        } else {\n            char[] ca = S.toCharArray();\n            Arrays.sort(ca);\n            return new String(ca);\n        }\n    }\n}\n"]}
{"number": 900, "statement": "Write an iterator that iterates through a run-length encoded sequence.\nThe iterator is initialized by RLEIterator(int[] A), where A is a run-length encoding of somesequence. More specifically,for all even i,A[i] tells us the number of times that the non-negative integer value A[i+1] is repeated in the sequence.\nThe iterator supports one function:next(int n), which exhausts the next n elements(n = 1) and returns the last element exhausted in this way. If there is no element left to exhaust, nextreturns -1 instead.\nFor example, we start with A = [3,8,0,9,2,5], which is a run-length encoding of the sequence [8,8,8,5,5]. This is because the sequence can be read as\"three eights, zero nines, two fives\".\n", "solutions": ["class RLEIterator {\n    int[] A;\n    int i, q;\n    public RLEIterator(int[] A) {\n        this.A = A;\n        i = q = 0;\n    }\n    public int next(int n) {\n        while (i < A.length) {\n            if (q + n > A[i]) {\n                n -= A[i] - q;\n                q = 0;\n                i += 2;\n            } else {\n                q += n;\n                return A[i+1];\n            }\n        }\n        return -1;\n    }\n}\n"]}
{"number": 901, "statement": "Write a class StockSpanner which collects daily price quotes for some stock, and returns the spanof that stock's price for the current day.\nThe span of the stock's price todayis defined as the maximum number of consecutive days (starting from today and going backwards)for which the price of the stock was less than or equal to today's price.\nFor example, if the price of a stock over the next 7 days were [100, 80, 60, 70, 60, 75, 85], then the stock spans would be [1, 1, 1, 2, 1, 4, 6].\n", "solutions": ["class StockSpanner {\n    Stack<Integer> prices, weights;\n    public StockSpanner() {\n        prices = new Stack();\n        weights = new Stack();\n    }\n    public int next(int price) {\n        int w = 1;\n        while (!prices.isEmpty() && prices.peek() <= price) {\n            prices.pop();\n            w += weights.pop();\n        }\n        prices.push(price);\n        weights.push(w);\n        return w;\n    }\n}\n"]}
{"number": 902, "statement": "We have a sorted set of digits D, a non-empty subset of {'1','2','3','4','5','6','7','8','9'}. (Note that '0' is not included.)\nNow, we write numbers using these digits, using each digit as many times as we want. For example, if D = {'1','3','5'}, we may write numbers such as '13', '551', '1351315'.\nReturn the number of positive integers that can be written (using the digits of D) that are less than or equal to N.\n", "solutions": ["class Solution {\n    public int atMostNGivenDigitSet(String[] D, int N) {\n        String S = String.valueOf(N);\n        int K = S.length();\n        int[] dp = new int[K+1];\n        dp[K] = 1;\n        for (int i = K-1; i >= 0; --i) {\n            // compute dp[i]\n            int Si = S.charAt(i) - '0';\n            for (String d: D) {\n                if (Integer.valueOf(d) < Si)\n                    dp[i] += Math.pow(D.length, K-i-1);\n                else if (Integer.valueOf(d) == Si)\n                    dp[i] += dp[i+1];\n            }\n        }\n        for (int i = 1; i < K; ++i)\n            dp[0] += Math.pow(D.length, i);\n        return dp[0];\n    }\n}\n", "class Solution {\n    public int atMostNGivenDigitSet(String[] D, int N) {\n        int B = D.length; // bijective-base B\n        char[] ca = String.valueOf(N).toCharArray();\n        int K = ca.length;\n        int[] A = new int[K];\n        int t = 0;\n        for (char c: ca) {\n            int c_index = 0;  // Largest such that c >= D[c_index - 1]\n            boolean match = false;\n            for (int i = 0; i < B; ++i) {\n                if (c >= D[i].charAt(0))\n                    c_index = i+1;\n                if (c == D[i].charAt(0))\n                    match = true;\n            }\n            A[t++] = c_index;\n            if (match) continue;\n            if (c_index == 0) { // subtract 1\n                for (int j = t-1; j > 0; --j) {\n                    if (A[j] > 0) break;\n                    A[j] += B;\n                    A[j-1]--;\n                }\n            }\n            while (t < K)\n                A[t++] = B;\n            break;\n        }\n        int ans = 0;\n        for (int x: A)\n            ans = ans * B + x;\n        return ans;\n    }\n}\n"]}
{"number": 903, "statement": "We are given S, a length n string of characters from the set {'D', 'I'}. (These letters stand for \"decreasing\" and \"increasing\".)\nAvalid permutationis a permutation P[0], P[1], ..., P[n] of integers{0, 1, ..., n}, such that for all i:\nIf S[i] == 'D', then P[i]  P[i+1], and;\nIf S[i] == 'I', then P[i]  P[i+1].\nHow many valid permutations are there? Since the answer may be large, return your answer modulo 10^9 + 7.\n", "solutions": ["class Solution {\n    public int numPermsDISequence(String S) {\n        int MOD = 1_000_000_007;\n        int N = S.length();\n        // dp[i][j] : Num ways to place P_i with relative rank j\n        int[][] dp = new int[N+1][N+1];\n        Arrays.fill(dp[0], 1);\n        for (int i = 1; i <= N; ++i) {\n            for (int j = 0; j <= i; ++j) {\n                if (S.charAt(i-1) == 'D') {\n                    for (int k = j; k < i; ++k) {\n                        dp[i][j] += dp[i-1][k];\n                        dp[i][j] %= MOD;\n                    }\n                } else {\n                    for (int k = 0; k < j; ++k) {\n                        dp[i][j] += dp[i-1][k];\n                        dp[i][j] %= MOD;\n                    }\n                }\n            }\n        }\n        int ans = 0;\n        for (int x: dp[N]) {\n            ans += x;\n            ans %= MOD;\n        }\n        return ans;\n    }\n}\n", "from functools import lru_cache\nclass Solution:\n    def numPermsDISequence(self, S):\n        MOD = 10**9 + 7\n        N = len(S)\n        @lru_cache(None)\n        def dp(i, j):\n            # How many ways to place P_i with relative rank j?\n            if not(0 <= j <= i):\n                return 0\n            if i == 0:\n                return 1\n            elif S[i-1] == 'D':\n                return (dp(i, j+1) + dp(i-1, j)) % MOD\n            else:\n                return (dp(i, j-1) + dp(i-1, j-1)) % MOD\n        return sum(dp(N, j) for j in range(N+1)) % MOD\n", "from functools import lru_cache\nclass Solution:\n    def numPermsDISequence(self, S):\n        MOD = 10**9 + 7\n        fac = [1, 1]\n        for x in range(2, 201):\n            fac.append(fac[-1] * x % MOD)\n        facinv = [pow(f, MOD-2, MOD) for f in fac]\n        def binom(n, k):\n            return fac[n] * facinv[n-k] % MOD * facinv[k] % MOD\n        @lru_cache(None)\n        def dp(i, j):\n            if i >= j: return 1\n            ans = 0\n            n = j - i + 2\n            if S[i] == 'I': ans += dp(i+1, j)\n            if S[j] == 'D': ans += dp(i, j-1)\n            for k in range(i+1, j+1):\n                if S[k-1:k+1] == 'DI':\n                    ans += binom(n-1, k-i) * dp(i, k-2) % MOD * dp(k+1, j) % MOD\n                    ans %= MOD\n            return ans\n        return dp(0, len(S) - 1)\n"]}
{"number": 904, "statement": "In a row of trees, the i-th treeproducesfruit with typetree[i].\nYou start at any treeof your choice, then repeatedly perform the following steps:\nAdd one piece of fruit from this tree to your baskets. If you cannot, stop.\nMove to the next tree to the right of the current tree. If there is no tree to the right, stop.\nNote that you do not have any choice after the initial choice of starting tree:you must perform step 1, then step 2, then back to step 1, then step 2, and so on until you stop.\nYou have two baskets, and each basket can carry any quantity of fruit, but you want each basket to only carry one type of fruit each.\nWhat is the total amount of fruit you can collect with this procedure?\n", "solutions": ["class Solution {\n    public int totalFruit(int[] tree) {\n        // We'll make a list of indexes for which a block starts.\n        List<Integer> blockLefts = new ArrayList();\n        // Add the left boundary of each block\n        for (int i = 0; i < tree.length; ++i)\n            if (i == 0 || tree[i-1] != tree[i])\n                blockLefts.add(i);\n        // Add tree.length as a sentinel for convenience\n        blockLefts.add(tree.length);\n        int ans = 0, i = 0;\n        search: while (true) {\n            // We'll start our scan at block[i].\n            // types : the different values of tree[i] seen\n            // weight : the total number of trees represented\n            //          by blocks under consideration\n            Set<Integer> types = new HashSet();\n            int weight = 0;\n            // For each block from the i-th and going forward,\n            for (int j = i; j < blockLefts.size() - 1; ++j) {\n                // Add each block to consideration\n                types.add(tree[blockLefts.get(j)]);\n                weight += blockLefts.get(j+1) - blockLefts.get(j);\n                // If we have 3+ types, this is an illegal subarray\n                if (types.size() >= 3) {\n                    i = j - 1;\n                    continue search;\n                }\n                // If it is a legal subarray, record the answer\n                ans = Math.max(ans, weight);\n            }\n            break;\n        }\n        return ans;\n    }\n}\n", "class Solution {\n    public int totalFruit(int[] tree) {\n        int ans = 0, i = 0;\n        Counter count = new Counter();\n        for (int j = 0; j < tree.length; ++j) {\n            count.add(tree[j], 1);\n            while (count.size() >= 3) {\n                count.add(tree[i], -1);\n                if (count.get(tree[i]) == 0)\n                    count.remove(tree[i]);\n                i++;\n            }\n            ans = Math.max(ans, j - i + 1);\n        }\n        return ans;\n    }\n}\nclass Counter extends HashMap<Integer, Integer> {\n    public int get(int k) {\n        return containsKey(k) ? super.get(k) : 0;\n    }\n    public void add(int k, int v) {\n        put(k, get(k) + v);\n    }\n}\n"]}
{"number": 905, "statement": "Given an array A of non-negative integers, return an array consisting of all the even elements of A, followed by all the odd elements of A.\nYou may return any answer array that satisfies this condition.\n", "solutions": ["class Solution {\n    public int[] sortArrayByParity(int[] A) {\n        Integer[] B = new Integer[A.length];\n        for (int t = 0; t < A.length; ++t)\n            B[t] = A[t];\n        Arrays.sort(B, (a, b) -> Integer.compare(a%2, b%2));\n        for (int t = 0; t < A.length; ++t)\n            A[t] = B[t];\n        return A;\n        /* Alternative:\n        return Arrays.stream(A)\n                     .boxed()\n                     .sorted((a, b) -> Integer.compare(a%2, b%2))\n                     .mapToInt(i -> i)\n                     .toArray();\n        */\n    }\n}\n", "class Solution {\n    public int[] sortArrayByParity(int[] A) {\n        int[] ans = new int[A.length];\n        int t = 0;\n        for (int i = 0; i < A.length; ++i)\n            if (A[i] % 2 == 0)\n                ans[t++] = A[i];\n        for (int i = 0; i < A.length; ++i)\n            if (A[i] % 2 == 1)\n                ans[t++] = A[i];\n        return ans;\n    }\n}\n", "class Solution {\n    public int[] sortArrayByParity(int[] A) {\n        int i = 0, j = A.length - 1;\n        while (i < j) {\n            if (A[i] % 2 > A[j] % 2) {\n                int tmp = A[i];\n                A[i] = A[j];\n                A[j] = tmp;\n            }\n            if (A[i] % 2 == 0) i++;\n            if (A[j] % 2 == 1) j--;\n        }\n        return A;\n    }\n}\n"]}
{"number": 906, "statement": "Let's say a positive integer is asuperpalindromeif it is a palindrome, and it is also the square of a palindrome.\nNow, given two positiveintegers L and R (represented as strings), return the number of superpalindromes in the inclusive range [L, R].\n", "solutions": ["class Solution {\n    public int superpalindromesInRange(String sL, String sR) {\n        long L = Long.valueOf(sL);\n        long R = Long.valueOf(sR);\n        int MAGIC = 100000;\n        int ans = 0;\n        // count odd length;\n        for (int k = 1; k < MAGIC; ++k) {\n            StringBuilder sb = new StringBuilder(Integer.toString(k));\n            for (int i = sb.length() - 2; i >= 0; --i)\n                sb.append(sb.charAt(i));\n            long v = Long.valueOf(sb.toString());\n            v *= v;\n            if (v > R) break;\n            if (v >= L && isPalindrome(v)) ans++;\n        }\n        // count even length;\n        for (int k = 1; k < MAGIC; ++k) {\n            StringBuilder sb = new StringBuilder(Integer.toString(k));\n            for (int i = sb.length() - 1; i >= 0; --i)\n                sb.append(sb.charAt(i));\n            long v = Long.valueOf(sb.toString());\n            v *= v;\n            if (v > R) break;\n            if (v >= L && isPalindrome(v)) ans++;\n        }\n        return ans;\n    }\n    public boolean isPalindrome(long x) {\n        return x == reverse(x);\n    }\n    public long reverse(long x) {\n        long ans = 0;\n        while (x > 0) {\n            ans = 10 * ans + x % 10;\n            x /= 10;\n        }\n        return ans;\n    }\n}\n"]}
{"number": 907, "statement": "Given an array of integers A, find the sum of min(B), where B ranges overevery (contiguous) subarray of A.\nSince the answer may be large, return the answer modulo 10^9 + 7.\n", "solutions": ["class Solution {\n    public int sumSubarrayMins(int[] A) {\n        int MOD = 1_000_000_007;\n        int N = A.length;\n        // prev has i* - 1 in increasing order of A[i* - 1]\n        // where i* is the answer to query j\n        Stack<Integer> stack = new Stack();\n        int[] prev = new int[N];\n        for (int i = 0; i < N; ++i) {\n            while (!stack.isEmpty() && A[i] <= A[stack.peek()])\n                stack.pop();\n            prev[i] = stack.isEmpty() ? -1 : stack.peek();\n            stack.push(i);\n        }\n        // next has k* + 1 in increasing order of A[k* + 1]\n        // where k* is the answer to query j\n        stack = new Stack();\n        int[] next = new int[N];\n        for (int k = N-1; k >= 0; --k) {\n            while (!stack.isEmpty() && A[k] < A[stack.peek()])\n                stack.pop();\n            next[k] = stack.isEmpty() ? N : stack.peek();\n            stack.push(k);\n        }\n        // Use prev/next array to count answer\n        long ans = 0;\n        for (int i = 0; i < N; ++i) {\n            ans += (i - prev[i]) * (next[i] - i) % MOD * A[i] % MOD;\n            ans %= MOD;\n        }\n        return (int) ans;\n    }\n}\n", "class Solution {\n    public int sumSubarrayMins(int[] A) {\n        int MOD = 1_000_000_007;\n        Stack<RepInteger> stack = new Stack();\n        int ans = 0, dot = 0;\n        for (int j = 0; j < A.length; ++j) {\n            // Add all answers for subarrays [i, j], i <= j\n            int count = 1;\n            while (!stack.isEmpty() && stack.peek().val >= A[j]) {\n                RepInteger node = stack.pop();\n                count += node.count;\n                dot -= node.val * node.count;\n            }\n            stack.push(new RepInteger(A[j], count));\n            dot += A[j] * count;\n            ans += dot;\n            ans %= MOD;\n        }\n        return ans;\n    }\n}\nclass RepInteger {\n    int val, count;\n    RepInteger(int v, int c) {\n        val = v;\n        count = c;\n    }\n}\n"]}
{"number": 908, "statement": "Given an array A of integers, for each integer A[i] we may choose any x with -K = x = K, and add x to A[i].\nAfter this process, we have some array B.\nReturn the smallest possible difference between the maximum value of Band the minimum value of B.\n", "solutions": ["class Solution {\n    public int smallestRangeI(int[] A, int K) {\n        int min = A[0], max = A[0];\n        for (int x: A) {\n            min = Math.min(min, x);\n            max = Math.max(max, x);\n        }\n        return Math.max(0, max - min - 2*K);\n    }\n}\n"]}
{"number": 909, "statement": "On an N x N board, the numbers from 1 to N*N are writtenboustrophedonicallystarting from the bottomleft of the board, and alternating direction each row. For example, for a 6 x 6 board, the numbers are written as follows:\nYou start on square 1 of the board (which is always in the last row andfirst column). Each move, starting from square x, consists of the following:\nYou choose a destination square S with numberx+1, x+2, x+3, x+4, x+5, or x+6, provided thisnumber is=N*N.\n(This choice simulates the result of a standard 6-sided die roll: ie., there are always at most 6 destinations, regardless of the size of the board.)\nIf Shas a snake or ladder, you move to the destination of that snake or ladder. Otherwise, you move to S.\nA board square on row r and column chas a \"snake or ladder\" if board[r][c] != -1. The destination of that snake or ladder is board[r][c].\nNote that you only take a snake or ladder at most once per move: if the destination to a snake or ladder is the start of anothersnake or ladder, you do not continue moving. (For example, if the board is `[[4,-1],[-1,3]]`, and on the first move your destination square is `2`, then you finish your first move at`3`, because you do not continue moving to `4`.)\nReturn the least number of moves required to reach square N*N. If it is not possible, return -1.\n", "solutions": ["class Solution {\n    public int snakesAndLadders(int[][] board) {\n        int N = board.length;\n        Map<Integer, Integer> dist = new HashMap();\n        dist.put(1, 0);\n        Queue<Integer> queue = new LinkedList();\n        queue.add(1);\n        while (!queue.isEmpty()) {\n            int s = queue.remove();\n            if (s == N*N) return dist.get(s);\n            for (int s2 = s+1; s2 <= Math.min(s+6, N*N); ++s2) {\n                int rc = get(s2, N);\n                int r = rc / N, c = rc % N;\n                int s2Final = board[r][c] == -1 ? s2 : board[r][c];\n                if (!dist.containsKey(s2Final)) {\n                    dist.put(s2Final, dist.get(s) + 1);\n                    queue.add(s2Final);\n                }\n            }\n        }\n        return -1;\n    }\n    public int get(int s, int N) {\n        // Given a square num s, return board coordinates (r, c) as r*N + c\n        int quot = (s-1) / N;\n        int rem = (s-1) % N;\n        int row = N - 1 - quot;\n        int col = row % 2 != N % 2 ? rem : N - 1 - rem;\n        return row * N + col;\n    }\n}\n"]}
{"number": 910, "statement": "Given an array A of integers, for each integer A[i] we need to choose eitherx = -Kor x = K, and add x to A[i] (only once).\nAfter this process, we have some array B.\nReturn the smallest possible difference between the maximum value of Band the minimum value of B.\n", "solutions": ["class Solution {\n    public int smallestRangeII(int[] A, int K) {\n        int N = A.length;\n        Arrays.sort(A);\n        int ans = A[N-1] - A[0];\n        for (int i = 0; i < A.length - 1; ++i) {\n            int a = A[i], b = A[i+1];\n            int high = Math.max(A[N-1] - K, a + K);\n            int low = Math.min(A[0] + K, b - K);\n            ans = Math.min(ans, high - low);\n        }\n        return ans;\n    }\n}\n"]}
{"number": 911, "statement": "In an election, the i-thvote was cast for persons[i] at time times[i].\nNow, we would like to implement the following query function: TopVotedCandidate.q(int t) will return the number of the person that was leading the election at time t.\nVotes cast at time t will count towards our query. In the case of a tie, the most recent vote (among tied candidates) wins.\n", "solutions": ["class TopVotedCandidate {\n    List<List<Vote>> A;\n    public TopVotedCandidate(int[] persons, int[] times) {\n        A = new ArrayList();\n        Map<Integer, Integer> count = new HashMap();\n        for (int i = 0; i < persons.length; ++i) {\n            int p = persons[i], t = times[i];\n            int c = count.getOrDefault(p, 0) + 1;\n            count.put(p, c);\n            while (A.size() <= c)\n                A.add(new ArrayList<Vote>());\n            A.get(c).add(new Vote(p, t));\n        }\n    }\n    public int q(int t) {\n        // Binary search on A[i][0].time for smallest i\n        // such that A[i][0].time > t\n        int lo = 1, hi = A.size();\n        while (lo < hi) {\n            int mi = lo + (hi - lo) / 2;\n            if (A.get(mi).get(0).time <= t)\n                lo = mi + 1;\n            else\n                hi = mi;\n        }\n        int i = lo - 1;\n        // Binary search on A[i][j].time for smallest j\n        // such that A[i][j].time > t\n        lo = 0; hi = A.get(i).size();\n        while (lo < hi) {\n            int mi = lo + (hi - lo) / 2;\n            if (A.get(i).get(mi).time <= t)\n                lo = mi + 1;\n            else\n                hi = mi;\n        }\n        int j = Math.max(lo-1, 0);\n        return A.get(i).get(j).person;\n    }\n}\nclass Vote {\n    int person, time;\n    Vote(int p, int t) {\n        person = p;\n        time = t;\n    }\n}\n", "class TopVotedCandidate {\n    List<Vote> A;\n    public TopVotedCandidate(int[] persons, int[] times) {\n        A = new ArrayList();\n        Map<Integer, Integer> count = new HashMap();\n        int leader = -1;  // current leader\n        int m = 0;  // current number of votes for leader\n        for (int i = 0; i < persons.length; ++i) {\n            int p = persons[i], t = times[i];\n            int c = count.getOrDefault(p, 0) + 1;\n            count.put(p, c);\n            if (c >= m) {\n                if (p != leader) {  // lead change\n                    leader = p;\n                    A.add(new Vote(leader, t));\n                }\n                if (c > m) m = c;\n            }\n        }\n    }\n    public int q(int t) {\n        int lo = 1, hi = A.size();\n        while (lo < hi) {\n            int mi = lo + (hi - lo) / 2;\n            if (A.get(mi).time <= t)\n                lo = mi + 1;\n            else\n                hi = mi;\n        }\n        return A.get(lo - 1).person;\n    }\n}\nclass Vote {\n    int person, time;\n    Vote(int p, int t) {\n        person = p;\n        time = t;\n    }\n}\n"]}
{"number": 913, "statement": "A game on an undirected graph is played by two players, Mouse and Cat, who alternate turns.\nThe graph is given as follows: graph[a] is a list of all nodes b such that ab is an edge of the graph.\nMouse starts at node 1 and goes first, Cat starts at node 2 and goes second, and there is a Hole at node 0.\nDuring each player's turn, they must travel along oneedge of the graph that meets where they are. For example, if the Mouse is at node 1, it must travel to any node in graph[1].\nAdditionally, it is not allowed for the Cat to travel to the Hole (node 0.)\nThen, the game can end in 3 ways:\nIf ever the Cat occupies the same node as the Mouse, the Cat wins.\nIf ever the Mouse reaches the Hole, the Mouse wins.\nIf ever a position is repeated (ie.the players are in the same position as a previous turn, andit is the same player's turn to move), the game is a draw.\nGiven a graph, and assuming both players play optimally, return 1if the game is won by Mouse, 2if the game is won by Cat, and 0if the game is a draw.\n", "solutions": ["class Solution {\n    public int catMouseGame(int[][] graph) {\n        int N = graph.length;\n        final int DRAW = 0, MOUSE = 1, CAT = 2;\n        int[][][] color = new int[50][50][3];\n        int[][][] degree = new int[50][50][3];\n        // degree[node] : the number of neutral children of this node\n        for (int m = 0; m < N; ++m)\n            for (int c = 0; c < N; ++c) {\n                degree[m][c][1] = graph[m].length;\n                degree[m][c][2] = graph[c].length;\n                for (int x: graph[c]) if (x == 0) {\n                    degree[m][c][2]--;\n                    break;\n                }\n            }\n        // enqueued : all nodes that are colored\n        Queue<int[]> queue = new LinkedList();\n        for (int i = 0; i < N; ++i)\n            for (int t = 1; t <= 2; ++t) {\n                color[0][i][t] = MOUSE;\n                queue.add(new int[]{0, i, t, MOUSE});\n                if (i > 0) {\n                    color[i][i][t] = CAT;\n                    queue.add(new int[]{i, i, t, CAT});\n                }\n            }\n        // percolate\n        while (!queue.isEmpty()) {\n            // for nodes that are colored :\n            int[] node = queue.remove();\n            int i = node[0], j = node[1], t = node[2], c = node[3];\n            // for every parent of this node i, j, t :\n            for (int[] parent: parents(graph, i, j, t)) {\n                int i2 = parent[0], j2 = parent[1], t2 = parent[2];\n                // if this parent is not colored :\n                if (color[i2][j2][t2] == DRAW) {\n                    // if the parent can make a winning move (ie. mouse to MOUSE), do so\n                    if (t2 == c) {\n                        color[i2][j2][t2] = c;\n                        queue.add(new int[]{i2, j2, t2, c});\n                    } else {\n                        // else, this parent has degree[parent]--, and enqueue\n                        // if all children of this parent are colored as losing moves\n                        degree[i2][j2][t2]--;\n                        if (degree[i2][j2][t2] == 0) {\n                            color[i2][j2][t2] = 3 - t2;\n                            queue.add(new int[]{i2, j2, t2, 3 - t2});\n                        }\n                    }\n                }\n            }\n        }\n        return color[1][2][1];\n    }\n    // What nodes could play their turn to\n    // arrive at node (m, c, t) ?\n    public List<int[]> parents(int[][] graph, int m, int c, int t) {\n        List<int[]> ans = new ArrayList();\n        if (t == 2) {\n            for (int m2: graph[m])\n                ans.add(new int[]{m2, c, 3-t});\n        } else {\n            for (int c2: graph[c]) if (c2 > 0)\n                ans.add(new int[]{m, c2, 3-t});\n        }\n        return ans;\n    }\n}\n"]}
{"number": 914, "statement": "In a deck of cards, each card has an integer written on it.\nReturn true if and only if you can chooseX = 2 such thatit is possible to split the entire deckinto 1 or more groups of cards, where:\nEach group has exactly X cards.\nAll the cards in each group have the same integer.\n", "solutions": ["class Solution {\n    public boolean hasGroupsSizeX(int[] deck) {\n        int N = deck.length;\n        int[] count = new int[10000];\n        for (int c: deck)\n            count[c]++;\n        List<Integer> values = new ArrayList();\n        for (int i = 0; i < 10000; ++i)\n            if (count[i] > 0)\n                values.add(count[i]);\n        search: for (int X = 2; X <= N; ++X)\n            if (N % X == 0) {\n                for (int v: values)\n                    if (v % X != 0)\n                        continue search;\n                return true;\n            }\n        return false;\n    }\n}\n", "class Solution {\n    public boolean hasGroupsSizeX(int[] deck) {\n        int[] count = new int[10000];\n        for (int c: deck)\n            count[c]++;\n        int g = -1;\n        for (int i = 0; i < 10000; ++i)\n            if (count[i] > 0) {\n                if (g == -1)\n                    g = count[i];\n                else\n                    g = gcd(g, count[i]);\n            }\n        return g >= 2;\n    }\n    public int gcd(int x, int y) {\n        return x == 0 ? y : gcd(y%x, x);\n    }\n}\n"]}
{"number": 915, "statement": "Given an array A, partition itinto two (contiguous) subarraysleftand rightso that:\nEvery element in leftis less than or equal to every element in right.\nleft and right are non-empty.\nlefthas the smallest possible size.\nReturn the length of left after such a partitioning. It is guaranteed that such a partitioning exists.\n", "solutions": ["class Solution {\n    public int partitionDisjoint(int[] A) {\n        int N = A.length;\n        int[] maxleft = new int[N];\n        int[] minright = new int[N];\n        int m = A[0];\n        for (int i = 0; i < N; ++i) {\n            m = Math.max(m, A[i]);\n            maxleft[i] = m;\n        }\n        m = A[N-1];\n        for (int i = N-1; i >= 0; --i) {\n            m = Math.min(m, A[i]);\n            minright[i] = m;\n        }\n        for (int i = 1; i < N; ++i)\n            if (maxleft[i-1] <= minright[i])\n                return i;\n        throw null;\n    }\n}\n"]}
{"number": 916, "statement": "We are given two arrays A and B of words. Each word is a string of lowercase letters.\nNow, say thatword b is a subset of word aif every letter in b occurs in a, including multiplicity. For example, \"wrr\" is a subset of \"warrior\", but is not a subset of \"world\".\nNow say a word a from A is universal if for every b in B, bis a subset of a.\nReturn a list of all universal words in A. You can return the words in any order.\n", "solutions": ["class Solution {\n    public List<String> wordSubsets(String[] A, String[] B) {\n        int[] bmax = count(\"\");\n        for (String b: B) {\n            int[] bCount = count(b);\n            for (int i = 0; i < 26; ++i)\n                bmax[i] = Math.max(bmax[i], bCount[i]);\n        }\n        List<String> ans = new ArrayList();\n        search: for (String a: A) {\n            int[] aCount = count(a);\n            for (int i = 0; i < 26; ++i)\n                if (aCount[i] < bmax[i])\n                    continue search;\n            ans.add(a);\n        }\n        return ans;\n    }\n    public int[] count(String S) {\n        int[] ans = new int[26];\n        for (char c: S.toCharArray())\n            ans[c - 'a']++;\n        return ans;\n    }\n}\n"]}
{"number": 917, "statement": "Given a string S, return the \"reversed\" string where all characters that are not a letterstay in the same place, and all letters reverse their positions.\n", "solutions": ["class Solution {\n    public String reverseOnlyLetters(String S) {\n        Stack<Character> letters = new Stack();\n        for (char c: S.toCharArray())\n            if (Character.isLetter(c))\n                letters.push(c);\n        StringBuilder ans = new StringBuilder();\n        for (char c: S.toCharArray()) {\n            if (Character.isLetter(c))\n                ans.append(letters.pop());\n            else\n                ans.append(c);\n        }\n        return ans.toString();\n    }\n}\n", "class Solution {\n    public String reverseOnlyLetters(String S) {\n        StringBuilder ans = new StringBuilder();\n        int j = S.length() - 1;\n        for (int i = 0; i < S.length(); ++i) {\n            if (Character.isLetter(S.charAt(i))) {\n                while (!Character.isLetter(S.charAt(j)))\n                    j--;\n                ans.append(S.charAt(j--));\n            } else {\n                ans.append(S.charAt(i));\n            }\n        }\n        return ans.toString();\n    }\n}\n"]}
{"number": 918, "statement": "Given a circulararrayC of integers represented byA, find the maximum possible sum of a non-empty subarray of C.\nHere, acirculararray means the end of the array connects to the beginning of the array. (Formally, C[i] = A[i] when 0 = i  A.length, and C[i+A.length] = C[i]wheni = 0.)\nAlso, a subarray may only include each element of the fixed buffer A at most once. (Formally, for a subarray C[i], C[i+1], ..., C[j], there does not exist i = k1, k2 = j with k1 % A.length= k2 % A.length.)\n", "solutions": ["class Solution {\n    public int maxSubarraySumCircular(int[] A) {\n        int N = A.length;\n        int ans = A[0], cur = A[0];\n        for (int i = 1; i < N; ++i) {\n            cur = A[i] + Math.max(cur, 0);\n            ans = Math.max(ans, cur);\n        }\n        // ans is the answer for 1-interval subarrays.\n        // Now, let's consider all 2-interval subarrays.\n        // For each i, we want to know\n        // the maximum of sum(A[j:]) with j >= i+2\n        // rightsums[i] = A[i] + A[i+1] + ... + A[N-1]\n        int[] rightsums = new int[N];\n        rightsums[N-1] = A[N-1];\n        for (int i = N-2; i >= 0; --i)\n            rightsums[i] = rightsums[i+1] + A[i];\n        // maxright[i] = max_{j >= i} rightsums[j]\n        int[] maxright = new int[N];\n        maxright[N-1] = A[N-1];\n        for (int i = N-2; i >= 0; --i)\n            maxright[i] = Math.max(maxright[i+1], rightsums[i]);\n        int leftsum = 0;\n        for (int i = 0; i < N-2; ++i) {\n            leftsum += A[i];\n            ans = Math.max(ans, leftsum + maxright[i+2]);\n        }\n        return ans;\n    }\n}\n", "class Solution {\n    public int maxSubarraySumCircular(int[] A) {\n        int N = A.length;\n        // Compute P[j] = B[0] + B[1] + ... + B[j-1]\n        // for fixed array B = A+A\n        int[] P = new int[2*N+1];\n        for (int i = 0; i < 2*N; ++i)\n            P[i+1] = P[i] + A[i % N];\n        // Want largest P[j] - P[i] with 1 <= j-i <= N\n        // For each j, want smallest P[i] with i >= j-N\n        int ans = A[0];\n        // deque: i's, increasing by P[i]\n        Deque<Integer> deque = new ArrayDeque();\n        deque.offer(0);\n        for (int j = 1; j <= 2*N; ++j) {\n            // If the smallest i is too small, remove it.\n            if (deque.peekFirst() < j-N)\n                deque.pollFirst();\n            // The optimal i is deque[0], for cand. answer P[j] - P[i].\n            ans = Math.max(ans, P[j] - P[deque.peekFirst()]);\n            // Remove any i1's with P[i2] <= P[i1].\n            while (!deque.isEmpty() && P[j] <= P[deque.peekLast()])\n                deque.pollLast();\n            deque.offerLast(j);\n        }\n        return ans;\n    }\n}\n", "class Solution {\n    public int maxSubarraySumCircular(int[] A) {\n        int S = 0;  // S = sum(A)\n        for (int x: A)\n            S += x;\n        int ans1 = kadane(A, 0, A.length-1, 1);\n        int ans2 = S + kadane(A, 1, A.length-1, -1);\n        int ans3 = S + kadane(A, 0, A.length-2, -1);\n        return Math.max(ans1, Math.max(ans2, ans3));\n    }\n    public int kadane(int[] A, int i, int j, int sign) {\n        // The maximum non-empty subarray for array\n        // [sign * A[i], sign * A[i+1], ..., sign * A[j]]\n        int ans = Integer.MIN_VALUE;\n        int cur = Integer.MIN_VALUE;\n        for (int k = i; k <= j; ++k) {\n            cur = sign * A[k] + Math.max(cur, 0);\n            ans = Math.max(ans, cur);\n        }\n        return ans;\n    }\n}\n", "class Solution {\n    public int maxSubarraySumCircular(int[] A) {\n        // S: sum of A\n        int S = 0;\n        for (int x: A)\n            S += x;\n        // ans1: answer for one-interval subarray\n        int ans1 = Integer.MIN_VALUE;\n        int cur = Integer.MIN_VALUE;\n        for (int x: A) {\n            cur = x + Math.max(cur, 0);\n            ans1 = Math.max(ans1, cur);\n        }\n        // ans2: answer for two-interval subarray, interior in A[1:]\n        int ans2 = Integer.MAX_VALUE;\n        cur = Integer.MAX_VALUE;\n        for (int i = 1; i < A.length; ++i) {\n            cur = A[i] + Math.min(cur, 0);\n            ans2 = Math.min(ans2, cur);\n        }\n        ans2 = S - ans2;\n        // ans3: answer for two-interval subarray, interior in A[:-1]\n        int ans3 = Integer.MAX_VALUE;\n        cur = Integer.MAX_VALUE;\n        for (int i = 0; i < A.length - 1; ++i) {\n            cur = A[i] + Math.min(cur, 0);\n            ans3 = Math.min(ans3, cur);\n        }\n        return Math.max(ans1, Math.max(ans2, ans3));\n    }\n}\n"]}
{"number": 919, "statement": "A complete binary tree is a binary tree in which every level, except possibly the last, is completely filled, and all nodes are as far left as possible.\nWrite a data structureCBTInserterthat is initialized with a complete binary tree and supports the following operations:\nCBTInserter(TreeNode root) initializes the data structure on a given treewith head node root;\nCBTInserter.insert(int v) will insert a TreeNodeinto the tree with value node.val =vso that the tree remains complete, and returns the value of the parent of the inserted TreeNode;\nCBTInserter.get_root() will return the head node of the tree.\n", "solutions": ["class CBTInserter {\n    TreeNode root;\n    Deque<TreeNode> deque;\n    public CBTInserter(TreeNode root) {\n        this.root = root;\n        deque = new LinkedList();\n        Queue<TreeNode> queue = new LinkedList();\n        queue.offer(root);\n        // BFS to populate deque\n        while (!queue.isEmpty()) {\n            TreeNode node = queue.poll();\n            if (node.left == null || node.right == null)\n                deque.offerLast(node);\n            if (node.left != null)\n                queue.offer(node.left);\n            if (node.right != null)\n                queue.offer(node.right);\n        }\n    }\n    public int insert(int v) {\n        TreeNode node = deque.peekFirst();\n        deque.offerLast(new TreeNode(v));\n        if (node.left == null)\n            node.left = deque.peekLast();\n        else {\n            node.right = deque.peekLast();\n            deque.pollFirst();\n        }\n        return node.val;\n    }\n    public TreeNode get_root() {\n        return root;\n    }\n}\n"]}
{"number": 920, "statement": "Your music player contains Ndifferent songs and she wants to listen to L (not necessarily different) songs during your trip. Youcreatea playlist sothat:\nEvery song is played at least once\nA song can only be played again only ifKother songs have been played\nReturn the number of possible playlists. As the answer can be very large, return it modulo 10^9 + 7.\n", "solutions": ["class Solution {\n    public int numMusicPlaylists(int N, int L, int K) {\n        int MOD = 1_000_000_007;\n        long[][] dp = new long[L+1][N+1];\n        dp[0][0] = 1;\n        for (int i = 1; i <= L; ++i)\n            for (int j = 1; j <= N; ++j) {\n                dp[i][j] += dp[i-1][j-1] * (N-j+1);\n                dp[i][j] += dp[i-1][j] * Math.max(j-K, 0);\n                dp[i][j] %= MOD;\n            }\n        return (int) dp[L][N];\n    }\n}\n", "class Solution {\n    public int numMusicPlaylists(int N, int L, int K) {\n        int MOD = 1_000_000_007;\n        // dp[S] at time P = <S, P> as discussed in article\n        long[] dp = new long[L-N+1];\n        Arrays.fill(dp, 1);\n        for (int p = 2; p <= N-K; ++p)\n            for (int i = 1; i <= L-N; ++i) {\n                dp[i] += dp[i-1] * p;\n                dp[i] %= MOD;\n            }\n        // Multiply by N!\n        long ans = dp[L-N];\n        for (int k = 2; k <= N; ++k)\n            ans = ans * k % MOD;\n        return (int) ans;\n    }\n}\n"]}
{"number": 921, "statement": "Given a stringS of '(' and ')' parentheses, we add the minimum number of parentheses ( '(' or ')', and in any positions ) so that the resulting parentheses string is valid.\nFormally, a parentheses string is valid if and only if:\nIt is the empty string, or\nIt can be written as AB(A concatenated with B), where A and B are valid strings, or\nIt can be written as (A), where A is a valid string.\nGiven a parentheses string, return the minimum number of parentheses we must add to make the resulting string valid.\n", "solutions": ["class Solution {\n    public int minAddToMakeValid(String S) {\n        int ans = 0, bal = 0;\n        for (int i = 0; i < S.length(); ++i) {\n            bal += S.charAt(i) == '(' ? 1 : -1;\n            // It is guaranteed bal >= -1\n            if (bal == -1) {\n                ans++;\n                bal++;\n            }\n        }\n        return ans + bal;\n    }\n}\n"]}
{"number": 922, "statement": "Given an array Aof non-negative integers, half of the integers in A are odd, and half of the integers are even.\nSort the array so that whenever A[i] is odd, i is odd; and whenever A[i] is even, i is even.\nYou may return any answer array that satisfies this condition.\n", "solutions": ["class Solution {\n    public int[] sortArrayByParityII(int[] A) {\n        int N = A.length;\n        int[] ans = new int[N];\n        int t = 0;\n        for (int x: A) if (x % 2 == 0) {\n            ans[t] = x;\n            t += 2;\n        }\n        t = 1;\n        for (int x: A) if (x % 2 == 1) {\n            ans[t] = x;\n            t += 2;\n        }\n        return ans;\n    }\n}\n", "class Solution {\n    public int[] sortArrayByParityII(int[] A) {\n        int j = 1;\n        for (int i = 0; i < A.length; i += 2)\n            if (A[i] % 2 == 1) {\n                while (A[j] % 2 == 1)\n                    j += 2;\n                // Swap A[i] and A[j]\n                int tmp = A[i];\n                A[i] = A[j];\n                A[j] = tmp;\n            }\n        return A;\n    }\n}\n"]}
{"number": 923, "statement": "Given an integer array A, and an integer target, return the number oftuplesi, j, k such that i  j  k andA[i] + A[j] + A[k] == target.\nAs the answer can be very large, return it modulo10^9 + 7.\n", "solutions": ["class Solution {\n    public int threeSumMulti(int[] A, int target) {\n        int MOD = 1_000_000_007;\n        long ans = 0;\n        Arrays.sort(A);\n        for (int i = 0; i < A.length; ++i) {\n            // We'll try to find the number of i < j < k\n            // with A[j] + A[k] == T, where T = target - A[i].\n            // The below is a \"two sum with multiplicity\".\n            int T = target - A[i];\n            int j = i+1, k = A.length - 1;\n            while (j < k) {\n                // These steps proceed as in a typical two-sum.\n                if (A[j] + A[k] < T)\n                    j++;\n                else if (A[j] + A[k] > T)\n                    k--;\n                else if (A[j] != A[k]) {  // We have A[j] + A[k] == T.\n                    // Let's count \"left\": the number of A[j] == A[j+1] == A[j+2] == ...\n                    // And similarly for \"right\".\n                    int left = 1, right = 1;\n                    while (j+1 < k && A[j] == A[j+1]) {\n                        left++;\n                        j++;\n                    }\n                    while (k-1 > j && A[k] == A[k-1]) {\n                        right++;\n                        k--;\n                    }\n                    ans += left * right;\n                    ans %= MOD;\n                    j++;\n                    k--;\n                } else {\n                    // M = k - j + 1\n                    // We contributed M * (M-1) / 2 pairs.\n                    ans += (k-j+1) * (k-j) / 2;\n                    ans %= MOD;\n                    break;\n                }\n            }\n        }\n        return (int) ans;\n    }\n}\n", "class Solution {\n    public int threeSumMulti(int[] A, int target) {\n        int MOD = 1_000_000_007;\n        long[] count = new long[101];\n        for (int x: A)\n            count[x]++;\n        long ans = 0;\n        // All different\n        for (int x = 0; x <= 100; ++x)\n            for (int y = x+1; y <= 100; ++y) {\n                int z = target - x - y;\n                if (y < z && z <= 100) {\n                    ans += count[x] * count[y] * count[z];\n                    ans %= MOD;\n                }\n            }\n        // x == y != z\n        for (int x = 0; x <= 100; ++x) {\n            int z = target - 2*x;\n            if (x < z && z <= 100) {\n                ans += count[x] * (count[x] - 1) / 2 * count[z];\n                ans %= MOD;\n            }\n        }\n        // x != y == z\n        for (int x = 0; x <= 100; ++x) {\n            if (target % 2 == x % 2) {\n                int y = (target - x) / 2;\n                if (x < y && y <= 100) {\n                    ans += count[x] * count[y] * (count[y] - 1) / 2;\n                    ans %= MOD;\n                }\n            }\n        }\n        // x == y == z\n        if (target % 3 == 0) {\n            int x = target / 3;\n            if (0 <= x && x <= 100) {\n                ans += count[x] * (count[x] - 1) * (count[x] - 2) / 6;\n                ans %= MOD;\n            }\n        }\n        return (int) ans;\n    }\n}\n", "class Solution {\n    public int threeSumMulti(int[] A, int target) {\n        int MOD = 1_000_000_007;\n        // Initializing as long saves us the trouble of\n        // managing count[x] * count[y] * count[z] overflowing later.\n        long[] count = new long[101];\n        int uniq = 0;\n        for (int x: A) {\n            count[x]++;\n            if (count[x] == 1)\n                uniq++;\n        }\n        int[] keys = new int[uniq];\n        int t = 0;\n        for (int i = 0; i <= 100; ++i)\n            if (count[i] > 0)\n                keys[t++] = i;\n        long ans = 0;\n        // Now, let's do a 3sum on \"keys\", for i <= j <= k.\n        // We will use count to add the correct contribution to ans.\n        for (int i = 0; i < keys.length; ++i) {\n            int x = keys[i];\n            int T = target - x;\n            int j = i, k = keys.length - 1;\n            while (j <= k) {\n                int y = keys[j], z = keys[k];\n                if (y + z < T) {\n                    j++;\n                } else if (y + z > T) {\n                    k--;\n                } else {  // # x+y+z == T, now calc the size of the contribution\n                    if (i < j && j < k) {\n                        ans += count[x] * count[y] * count[z];\n                    } else if (i == j && j < k) {\n                        ans += count[x] * (count[x] - 1) / 2 * count[z];\n                    } else if (i < j && j == k) {\n                        ans += count[x] * count[y] * (count[y] - 1) / 2;\n                    } else {  // i == j == k\n                        ans += count[x] * (count[x] - 1) * (count[x] - 2) / 6;\n                    }\n                    ans %= MOD;\n                    j++;\n                    k--;\n                }\n            }\n        }\n        return (int) ans;\n    }\n}\n"]}
{"number": 924, "statement": "In a network of nodes, each node i is directly connected to another node j if and only ifgraph[i][j] = 1.\nSome nodes initial are initially infected by malware. Whenever two nodes are directly connected and at least one of those two nodes is infected by malware, both nodes will be infected by malware. This spread of malware will continue until no more nodes can be infected in this manner.\nSuppose M(initial)is the final number of nodes infected with malware in the entire network, after the spread of malware stops.\nWe willremove one node from the initial list. Return the node that if removed, would minimizeM(initial). If multiple nodes could be removed to minimize M(initial), return such a node with the smallest index.\nNote that if a node was removed from the initiallist of infected nodes, it may still be infected later as a result of the malware spread.\n", "solutions": ["class Solution {\n    public int minMalwareSpread(int[][] graph, int[] initial) {\n        // 1. Color each component.\n        // colors[node] = the color of this node.\n        int N = graph.length;\n        int[] colors = new int[N];\n        Arrays.fill(colors, -1);\n        int C = 0;\n        for (int node = 0; node < N; ++node)\n            if (colors[node] == -1)\n                dfs(graph, colors, node, C++);\n        // 2. Size of each color.\n        int[] size = new int[C];\n        for (int color: colors)\n            size[color]++;\n        // 3. Find unique colors.\n        int[] colorCount = new int[C];\n        for (int node: initial)\n            colorCount[colors[node]]++;\n        // 4. Answer\n        int ans = Integer.MAX_VALUE;\n        for (int node: initial) {\n            int c = colors[node];\n            if (colorCount[c] == 1) {\n                if (ans == Integer.MAX_VALUE)\n                    ans = node;\n                else if (size[c] > size[colors[ans]])\n                    ans = node;\n                else if (size[c] == size[colors[ans]] && node < ans)\n                    ans = node;\n            }\n        }\n        if (ans == Integer.MAX_VALUE)\n            for (int node: initial)\n                ans = Math.min(ans, node);\n        return ans;\n    }\n    public void dfs(int[][] graph, int[] colors, int node, int color) {\n        colors[node] = color;\n        for (int nei = 0; nei < graph.length; ++nei)\n            if (graph[node][nei] == 1 && colors[nei] == -1)\n                dfs(graph, colors, nei, color);\n    }\n}\n", "class Solution {\n    public int minMalwareSpread(int[][] graph, int[] initial) {\n        int N = graph.length;\n        DSU dsu = new DSU(N);\n        for (int i = 0; i < N; ++i)\n            for (int j = i+1; j < N; ++j)\n                if (graph[i][j] == 1)\n                    dsu.union(i, j);\n        int[] count = new int[N];\n        for (int node: initial)\n            count[dsu.find(node)]++;\n        int ans = -1, ansSize = -1;\n        for (int node: initial) {\n            int root = dsu.find(node);\n            if (count[root] == 1) {  // unique color\n                int rootSize = dsu.size(root);\n                if (rootSize > ansSize) {\n                    ansSize = rootSize;\n                    ans = node;\n                } else if (rootSize == ansSize && node < ans) {\n                    ansSize = rootSize;\n                    ans = node;\n                }\n            }\n        }\n        if (ans == -1) {\n            ans = Integer.MAX_VALUE;\n            for (int node: initial)\n                ans = Math.min(ans, node);\n        }\n        return ans;\n    }\n}\nclass DSU {\n    int[] p, sz;\n    DSU(int N) {\n        p = new int[N];\n        for (int x = 0; x < N; ++x)\n            p[x] = x;\n        sz = new int[N];\n        Arrays.fill(sz, 1);\n    }\n    public int find(int x) {\n        if (p[x] != x)\n            p[x] = find(p[x]);\n        return p[x];\n    }\n    public void union(int x, int y) {\n        int xr = find(x);\n        int yr = find(y);\n        p[xr] = yr;\n        sz[yr] += sz[xr];\n    }\n    public int size(int x) {\n        return sz[find(x)];\n    }\n}\n"]}
{"number": 925, "statement": "Your friend is typing his nameinto a keyboard. Sometimes, when typing a character c, the key might get long pressed, and the character will be typed 1 or more times.\nYou examine the typedcharacters of the keyboard. Return True if it is possible that it was your friends name, with some characters (possibly none) being long pressed.\n", "solutions": ["class Solution {\n    public boolean isLongPressedName(String name, String typed) {\n        Group g1 = groupify(name);\n        Group g2 = groupify(typed);\n        if (!g1.key.equals(g2.key))\n            return false;\n        for (int i = 0; i < g1.count.size(); ++i)\n            if (g1.count.get(i) > g2.count.get(i))\n                return false;\n        return true;\n    }\n    public Group groupify(String S) {\n        StringBuilder key = new StringBuilder();\n        List<Integer> count = new ArrayList();\n        int anchor = 0;\n        int N = S.length();\n        for (int i = 0; i < N; ++i) {\n            if (i == N-1 || S.charAt(i) != S.charAt(i+1)) { // end of group\n                key.append(S.charAt(i));\n                count.add(i - anchor + 1);\n                anchor = i+1;\n            }\n        }\n        return new Group(key.toString(), count);\n    }\n}\nclass Group {\n    String key;\n    List<Integer> count;\n    Group(String k, List<Integer> c) {\n        key = k;\n        count = c;\n    }\n}\n", "class Solution {\n    public boolean isLongPressedName(String name, String typed) {\n        int j = 0;\n        for (char c: name.toCharArray()) {\n            if (j == typed.length())\n                return false;\n            // If mismatch...\n            if (typed.charAt(j) != c) {\n                // If it's the first char of the block, ans is false.\n                if (j==0 || typed.charAt(j-1) != typed.charAt(j))\n                    return false;\n                // Discard all similar chars\n                char cur = typed.charAt(j);\n                while (j < typed.length() && typed.charAt(j) == cur)\n                    j++;\n                // If next isn't a match, ans is false.\n                if (j == typed.length() || typed.charAt(j) != c)\n                    return false;\n            }\n            j++;\n        }\n        return true;\n    }\n}\n"]}
{"number": 926, "statement": "A string of '0's and '1's is monotone increasing if it consists of some number of '0's (possibly 0), followed by some number of '1's (also possibly 0.)\nWe are given a string S of '0's and '1's, and we may flip any '0' to a '1' or a '1' to a '0'.\nReturn the minimum number of flips to make Smonotone increasing.\n", "solutions": ["class Solution {\n    public int minFlipsMonoIncr(String S) {\n        int N = S.length();\n        int[] P = new int[N + 1];\n        for (int i = 0; i < N; ++i)\n            P[i+1] = P[i] + (S.charAt(i) == '1' ? 1 : 0);\n        int ans = Integer.MAX_VALUE;\n        for (int j = 0; j <= N; ++j) {\n            ans = Math.min(ans, P[j] + N-j-(P[N]-P[j]));\n        }\n        return ans;\n    }\n}\n"]}
{"number": 927, "statement": "Given an array A of 0s and 1s, divide the array into 3 non-empty parts such that all of these parts represent the same binary value.\nIf it is possible, return any [i, j]with i+1  j, such that:\nA[0], A[1], ..., A[i] is the first part;\nA[i+1], A[i+2], ..., A[j-1] is the second part, and\nA[j], A[j+1], ..., A[A.length - 1] is the third part.\nAll three parts have equal binary value.\nIf it is not possible, return [-1, -1].\nNote that the entire part is used when considering what binary value it represents. For example, [1,1,0]represents 6in decimal,not 3. Also, leading zeros are allowed, so[0,1,1] and [1,1] represent the same value.\n", "solutions": ["class Solution {\n    public int[] threeEqualParts(int[] A) {\n        int[] IMP = new int[]{-1, -1};\n        int N = A.length;\n        int S = 0;\n        for (int x: A) S += x;\n        if (S % 3 != 0) return IMP;\n        int T = S / 3;\n        if (T == 0)\n            return new int[]{0, N - 1};\n        int i1 = -1, j1 = -1, i2 = -1, j2 = -1, i3 = -1, j3 = -1;\n        int su = 0;\n        for (int i = 0; i < N; ++i) {\n            if (A[i] == 1) {\n                su += 1;\n                if (su == 1) i1 = i;\n                if (su == T) j1 = i;\n                if (su == T+1) i2 = i;\n                if (su == 2*T) j2 = i;\n                if (su == 2*T + 1) i3 = i;\n                if (su == 3*T) j3 = i;\n            }\n        }\n        // The array is in the form W [i1, j1] X [i2, j2] Y [i3, j3] Z\n        // where [i1, j1] is a block of 1s, etc.\n        int[] part1 = Arrays.copyOfRange(A, i1, j1+1);\n        int[] part2 = Arrays.copyOfRange(A, i2, j2+1);\n        int[] part3 = Arrays.copyOfRange(A, i3, j3+1);\n        if (!Arrays.equals(part1, part2)) return IMP;\n        if (!Arrays.equals(part1, part3)) return IMP;\n        // x, y, z: the number of zeros after part 1, 2, 3\n        int x = i2 - j1 - 1;\n        int y = i3 - j2 - 1;\n        int z = A.length - j3 - 1;\n        if (x < z || y < z) return IMP;\n        return new int[]{j1+z, j2+z+1};\n    }\n}\n"]}
{"number": 928, "statement": "(This problem is the same as Minimize Malware Spread, with the differences bolded.)\nIn a network of nodes, each node i is directly connected to another node j if and only ifgraph[i][j] = 1.\nSome nodes initial are initially infected by malware. Whenever two nodes are directly connected and at least one of those two nodes is infected by malware, both nodes will be infected by malware. This spread of malware will continue until no more nodes can be infected in this manner.\nSuppose M(initial)is the final number of nodes infected with malware in the entire network, after the spread of malware stops.\nWe willremove one node from the initial list, completely removing it and any connections from this node to any other node. Return the node that if removed, would minimizeM(initial). If multiple nodes could be removed to minimize M(initial), return such a node with the smallest index.\n", "solutions": ["class Solution {\n    public int minMalwareSpread(int[][] graph, int[] initial) {\n        int N = graph.length;\n        int[] clean = new int[N];\n        Arrays.fill(clean, 1);\n        for (int x: initial)\n            clean[x] = 0;\n        // For each node u in initial, dfs to find\n        // 'seen': all nodes not in initial that it can reach.\n        ArrayList<Integer>[] infectedBy = new ArrayList[N];\n        for (int i = 0; i < N; ++i)\n            infectedBy[i] = new ArrayList();\n        for (int u: initial) {\n            Set<Integer> seen = new HashSet();\n            dfs(graph, clean, u, seen);\n            for (int v: seen)\n                infectedBy[v].add(u);\n        }\n        // For each node u in initial, for every v not in initial\n        // that is uniquely infected by u, add 1 to the contribution for u.\n        int[] contribution = new int[N];\n        for (int v = 0; v < N; ++v)\n            if (infectedBy[v].size() == 1)\n                contribution[infectedBy[v].get(0)]++;\n        // Take the best answer.\n        Arrays.sort(initial);\n        int ans = initial[0], ansSize = -1;\n        for (int u: initial) {\n            int score = contribution[u];\n            if (score > ansSize || score == ansSize && u < ans) {\n                ans = u;\n                ansSize = score;\n            }\n        }\n        return ans;\n    }\n    public void dfs(int[][] graph, int[] clean, int u, Set<Integer> seen) {\n        for (int v = 0; v < graph.length; ++v)\n            if (graph[u][v] == 1 && clean[v] == 1 && !seen.contains(v)) {\n                seen.add(v);\n                dfs(graph, clean, v, seen);\n            }\n    }\n}\n", "class Solution {\n    public int minMalwareSpread(int[][] graph, int[] initial) {\n        int N = graph.length;\n        DSU dsu = new DSU(N);\n        // clean[u] == 1 if its a node in the graph not in initial.\n        int[] clean = new int[N];\n        Arrays.fill(clean, 1);\n        for (int x: initial) clean[x] = 0;\n        for (int u = 0; u < N; ++u) if (clean[u] == 1)\n            for (int v = 0; v < N; ++v) if (clean[v] == 1)\n                if (graph[u][v] == 1)\n                    dsu.union(u, v);\n        // dsu now represents the components of the graph without\n        // any nodes from initial.  Let's call this graph G.\n        int[] count = new int[N];\n        Map<Integer, Set<Integer>> nodeToCompo = new HashMap();\n        for (int u: initial) {\n            Set<Integer> components = new HashSet();\n            for (int v = 0; v < N; ++v) if (clean[v] == 1) {\n                if (graph[u][v] == 1)\n                    components.add(dsu.find(v));\n            }\n            nodeToCompo.put(u, components);\n            for (int c: components)\n                count[c]++;\n        }\n        // For each node u in initial, nodeToCompo.get(u)\n        // now has every component from G that u neighbors.\n        int ans = -1, ansSize = -1;\n        for (int u: nodeToCompo.keySet()) {\n            Set<Integer> components = nodeToCompo.get(u);\n            int score = 0;\n            for (int c: components)\n                if (count[c] == 1) // uniquely infected\n                    score += dsu.size(c);\n            if (score > ansSize || score == ansSize && u < ans) {\n                ansSize = score;\n                ans = u;\n            }\n        }\n        return ans;\n    }\n}\nclass DSU {\n    int[] p, sz;\n    DSU(int N) {\n        p = new int[N];\n        for (int x = 0; x < N; ++x)\n            p[x] = x;\n        sz = new int[N];\n        Arrays.fill(sz, 1);\n    }\n    public int find(int x) {\n        if (p[x] != x)\n            p[x] = find(p[x]);\n        return p[x];\n    }\n    public void union(int x, int y) {\n        int xr = find(x);\n        int yr = find(y);\n        p[xr] = yr;\n        sz[yr] += sz[xr];\n    }\n    public int size(int x) {\n        return sz[find(x)];\n    }\n}\n"]}
{"number": 929, "statement": "Every email consists of a local name and a domain name, separated by the @ sign.\nFor example, in alice@leetcode.com,alice is the local name, and leetcode.com is the domain name.\nBesides lowercase letters, these emails may contain '.'s or '+'s.\nIf you add periods ('.') between some characters in the local name part of an email address, mail sent there will be forwarded to the same address without dots in the local name. For example, \"alice.z@leetcode.com\" and \"alicez@leetcode.com\" forward to the same email address. (Note that this rule does not apply for domain names.)\nIf you add a plus ('+') in the local name, everything after the first plus sign will beignored. This allows certain emails to be filtered, for examplem.y+name@email.comwill be forwarded tomy@email.com. (Again, this rule does not apply for domain names.)\nIt is possible to use both of these rules at the same time.\nGiven a list of emails, we send one email to each address in the list.How many different addresses actually receive mails?\n", "solutions": ["class Solution {\n  public int numUniqueEmails(String[] emails) {\n    Set<String> seen = new HashSet();\n    for (String email : emails) {\n      int i = email.indexOf('@');\n      String local = email.substring(0, i);\n      String rest = email.substring(i);\n      if (local.contains(\"+\")) {\n        local = local.substring(0, local.indexOf('+'));\n      }\n      // Note: one should escape the specific character '.',\n      // since it is treated as a regex expression.\n      local = local.replaceAll(\"\\\\.\", \"\");\n      seen.add(local + rest);\n    }\n    return seen.size();\n  }\n}\n"]}
{"number": 930, "statement": "In an array A of 0s and 1s, how many non-empty subarrays have sum S?\n", "solutions": ["class Solution {\n    public int numSubarraysWithSum(int[] A, int S) {\n        int su = 0;\n        for (int x: A) su += x;\n        // indexes[i] = location of i-th one (1 indexed)\n        int[] indexes = new int[su + 2];\n        int t = 0;\n        indexes[t++] = -1;\n        for (int i = 0; i < A.length; ++i)\n            if (A[i] == 1)\n                indexes[t++] = i;\n        indexes[t] = A.length;\n        int ans = 0;\n        if (S == 0) {\n            for (int i = 0; i < indexes.length - 1; ++i) {\n                // w: number of zeros between consecutive ones\n                int w = indexes[i+1] - indexes[i] - 1;\n                ans += w * (w + 1) / 2;\n            }\n            return ans;\n        }\n        for (int i = 1; i < indexes.length - S; ++i) {\n            int j = i + S - 1;\n            int left = indexes[i] - indexes[i-1];\n            int right = indexes[j+1] - indexes[j];\n            ans += left * right;\n        }\n        return ans;\n    }\n}\n", "class Solution {\n    public int numSubarraysWithSum(int[] A, int S) {\n        int N = A.length;\n        int[] P = new int[N + 1];\n        for (int i = 0; i < N; ++i)\n            P[i+1] = P[i] + A[i];\n        Map<Integer, Integer> count = new HashMap();\n        int ans = 0;\n        for (int x: P) {\n            ans += count.getOrDefault(x, 0);\n            count.put(x+S, count.getOrDefault(x+S, 0) + 1);\n        }\n        return ans;\n    }\n}\n", "class Solution {\n    public int numSubarraysWithSum(int[] A, int S) {\n        int iLo = 0, iHi = 0;\n        int sumLo = 0, sumHi = 0;\n        int ans = 0;\n        for (int j = 0; j < A.length; ++j) {\n            // While sumLo is too big, iLo++\n            sumLo += A[j];\n            while (iLo < j && sumLo > S)\n                sumLo -= A[iLo++];\n            // While sumHi is too big, or equal and we can move, iHi++\n            sumHi += A[j];\n            while (iHi < j && (sumHi > S || sumHi == S && A[iHi] == 0))\n                sumHi -= A[iHi++];\n            if (sumLo == S)\n                ans += iHi - iLo + 1;\n        }\n        return ans;\n    }\n}\n"]}
{"number": 931, "statement": "Given a square array of integers A, we want the minimum sum of a falling path through A.\nA falling path starts at any element in the first row, and chooses one element from each row. The next row's choice must be in a column that is different from the previous row's column by at most one.\n", "solutions": ["class Solution {\n    public int minFallingPathSum(int[][] A) {\n        int N = A.length;\n        for (int r = N-2; r >= 0; --r) {\n            for (int c = 0; c < N; ++c) {\n                // best = min(A[r+1][c-1], A[r+1][c], A[r+1][c+1])\n                int best = A[r+1][c];\n                if (c > 0)\n                    best = Math.min(best, A[r+1][c-1]);\n                if (c+1 < N)\n                    best = Math.min(best, A[r+1][c+1]);\n                A[r][c] += best;\n            }\n        }\n        int ans = Integer.MAX_VALUE;\n        for (int x: A[0])\n            ans = Math.min(ans, x);\n        return ans;\n    }\n}\n"]}
{"number": 932, "statement": "For some fixed N, an array A is beautiful if it is a permutation of the integers 1, 2, ..., N, such that:\nFor every i  j, there is nok with i  k  jsuch that A[k] * 2 = A[i] + A[j].\nGiven N, return any beautiful array A. (It is guaranteed that one exists.)\n", "solutions": ["class Solution {\n    Map<Integer, int[]> memo;\n    public int[] beautifulArray(int N) {\n        memo = new HashMap();\n        return f(N);\n    }\n    public int[] f(int N) {\n        if (memo.containsKey(N))\n            return memo.get(N);\n        int[] ans = new int[N];\n        if (N == 1) {\n            ans[0] = 1;\n        } else {\n            int t = 0;\n            for (int x: f((N+1)/2))  // odds\n                ans[t++] = 2*x - 1;\n            for (int x: f(N/2))  // evens\n                ans[t++] = 2*x;\n        }\n        memo.put(N, ans);\n        return ans;\n    }\n}\n"]}
{"number": 933, "statement": "Write a class RecentCounter to count recent requests.\nIt has only one method:ping(int t), where t represents some time in milliseconds.\nReturn the number of pings that have been made from 3000 milliseconds ago until now.\nAny ping with time in [t - 3000, t] will count, including the current ping.\nIt is guaranteed that every call to ping uses a strictly larger value oft than before.\n", "solutions": ["class RecentCounter {\n    Queue<Integer> q;\n    public RecentCounter() {\n        q = new LinkedList();\n    }\n    public int ping(int t) {\n        q.add(t);\n        while (q.peek() < t - 3000)\n            q.poll();\n        return q.size();\n    }\n}\n"]}
{"number": 934, "statement": "In a given 2D binary array A, there are two islands. (An island is a 4-directionally connected group of1s not connected to any other 1s.)\nNow, we may change 0s to 1s so as to connect the two islands together to form 1 island.\nReturn the smallest number of 0s that must be flipped. (It is guaranteed that the answer is at least 1.)\n", "solutions": ["class Solution {\n    public int shortestBridge(int[][] A) {\n        int R = A.length, C = A[0].length;\n        int[][] colors = getComponents(A);\n        Queue<Node> queue = new LinkedList();\n        Set<Integer> target = new HashSet();\n        for (int r = 0; r < R; ++r)\n            for (int c = 0; c < C; ++c) {\n                if (colors[r][c] == 1) {\n                    queue.add(new Node(r, c, 0));\n                } else if (colors[r][c] == 2) {\n                    target.add(r * C + c);\n                }\n            }\n        while (!queue.isEmpty()) {\n            Node node = queue.poll();\n            if (target.contains(node.r * C + node.c))\n                return node.depth - 1;\n            for (int nei: neighbors(A, node.r, node.c)) {\n                int nr = nei / C, nc = nei % C;\n                if (colors[nr][nc] != 1) {\n                    queue.add(new Node(nr, nc, node.depth + 1));\n                    colors[nr][nc] = 1;\n                }\n            }\n        }\n        throw null;\n    }\n    public int[][] getComponents(int[][] A) {\n        int R = A.length, C = A[0].length;\n        int[][] colors = new int[R][C];\n        int t = 0;\n        for (int r0 = 0; r0 < R; ++r0)\n            for (int c0 = 0; c0 < C; ++c0)\n                if (colors[r0][c0] == 0 && A[r0][c0] == 1) {\n                    // Start dfs\n                    Stack<Integer> stack = new Stack();\n                    stack.push(r0 * C + c0);\n                    colors[r0][c0] = ++t;\n                    while (!stack.isEmpty()) {\n                        int node = stack.pop();\n                        int r = node / C, c = node % C;\n                        for (int nei: neighbors(A, r, c)) {\n                            int nr = nei / C, nc = nei % C;\n                            if (A[nr][nc] == 1 && colors[nr][nc] == 0) {\n                                colors[nr][nc] = t;\n                                stack.push(nr * C + nc);\n                            }\n                        }\n                    }\n                }\n        return colors;\n    }\n    public List<Integer> neighbors(int[][] A, int r, int c) {\n        int R = A.length, C = A[0].length;\n        List<Integer> ans = new ArrayList();\n        if (0 <= r-1) ans.add((r-1) * R + c);\n        if (0 <= c-1) ans.add(r * R + (c-1));\n        if (r+1 < R) ans.add((r+1) * R + c);\n        if (c+1 < C) ans.add(r * R + (c+1));\n        return ans;\n    }\n}\nclass Node {\n    int r, c, depth;\n    Node(int r, int c, int d) {\n        this.r = r;\n        this.c = c;\n        depth = d;\n    }\n}\n"]}
{"number": 935, "statement": "A chess knight can move as indicated in the chess diagram below:\n.     \nThis time, we place our chess knight on any numbered key of a phone pad (indicated above), and the knight makes N-1 hops. Each hop must be from one key to another numbered key.\nEach time it lands on a key (including the initial placement of the knight), it presses the number of that key, pressing N digits total.\nHow many distinct numbers can you dial in this manner?\nSince the answer may be large, output the answermodulo 10^9 + 7.\n", "solutions": ["class Solution {\n    public int knightDialer(int N) {\n        int MOD = 1_000_000_007;\n        int[][] moves = new int[][]{\n            {4,6},{6,8},{7,9},{4,8},{3,9,0},\n            {},{1,7,0},{2,6},{1,3},{2,4}};\n        int[][] dp = new int[2][10];\n        Arrays.fill(dp[0], 1);\n        for (int hops = 0; hops < N-1; ++hops) {\n            Arrays.fill(dp[~hops & 1], 0);\n            for (int node = 0; node < 10; ++node)\n                for (int nei: moves[node]) {\n                    dp[~hops & 1][nei] += dp[hops & 1][node];\n                    dp[~hops & 1][nei] %= MOD;\n                }\n        }\n        long ans = 0;\n        for (int x: dp[~N & 1])\n            ans += x;\n        return (int) (ans % MOD);\n    }\n}\n"]}
{"number": 936, "statement": "You want to form a targetstring of lowercase letters.\nAt the beginning, your sequence is target.length'?' marks. You also have a stampof lowercase letters.\nOn each turn, you may place the stamp over the sequence, and replace every letter in the sequence with the corresponding letter from the stamp. You can make up to 10 * target.length turns.\nFor example, if the initial sequence is \"?????\", and your stamp is \"abc\", then you may make \"abc??\", \"?abc?\", \"??abc\"in the first turn. (Note that the stamp must be fully contained in the boundaries of the sequence in order to stamp.)\nIf the sequence is possible to stamp, then return an array ofthe index of the left-most letter being stamped at each turn. If the sequence is not possible to stamp, return an empty array.\nFor example, if the sequence is \"ababc\", and the stamp is \"abc\", then we could return the answer [0, 2], corresponding to the moves \"?????\" - \"abc??\" - \"ababc\".\nAlso, if the sequence is possible to stamp, it is guaranteed it is possible to stamp within 10 * target.lengthmoves. Any answers specifying more than this number of moveswill not be accepted.\n", "solutions": ["class Solution {\n    public int[] movesToStamp(String stamp, String target) {\n        int M = stamp.length(), N = target.length();\n        Queue<Integer> queue = new ArrayDeque();\n        boolean[] done = new boolean[N];\n        Stack<Integer> ans = new Stack();\n        List<Node> A = new ArrayList();\n        for (int i = 0; i <= N-M; ++i) {\n            // For each window [i, i+M), A[i] will contain\n            // info on what needs to change before we can\n            // reverse stamp at this window.\n            Set<Integer> made = new HashSet();\n            Set<Integer> todo = new HashSet();\n            for (int j = 0; j < M; ++j) {\n                if (target.charAt(i+j) == stamp.charAt(j))\n                    made.add(i+j);\n                else\n                    todo.add(i+j);\n            }\n            A.add(new Node(made, todo));\n            // If we can reverse stamp at i immediately,\n            // enqueue letters from this window.\n            if (todo.isEmpty()) {\n                ans.push(i);\n                for (int j = i; j < i + M; ++j) if (!done[j]) {\n                    queue.add(j);\n                    done[j] = true;\n                }\n            }\n        }\n        // For each enqueued letter (position),\n        while (!queue.isEmpty()) {\n            int i = queue.poll();\n            // For each window that is potentially affected,\n            // j: start of window\n            for (int j = Math.max(0, i-M+1); j <= Math.min(N-M, i); ++j) {\n                if (A.get(j).todo.contains(i)) {  // This window is affected\n                    A.get(j).todo.remove(i);\n                    if (A.get(j).todo.isEmpty()) {\n                        ans.push(j);\n                        for (int m: A.get(j).made) if (!done[m]) {\n                            queue.add(m);\n                            done[m] = true;\n                        }\n                    }\n                }\n            }\n        }\n        for (boolean b: done)\n            if (!b) return new int[0];\n        int[] ret = new int[ans.size()];\n        int t = 0;\n        while (!ans.isEmpty())\n            ret[t++] = ans.pop();\n        return ret;\n    }\n}\nclass Node {\n    Set<Integer> made, todo;\n    Node(Set<Integer> m, Set<Integer> t) {\n        made = m;\n        todo = t;\n    }\n}\n"]}
{"number": 937, "statement": "You have an array of logs. Each log is a space delimited string of words.\nFor each log, the first word in each log is an alphanumeric identifier. Then, either:\nEach word after the identifier will consist only of lowercase letters, or;\nEach word after the identifier will consist only of digits.\nWe will call these two varieties of logs letter-logs and digit-logs. It is guaranteed that each log has at least one word after its identifier.\nReorder the logs so that all of the letter-logs come before any digit-log. The letter-logs are ordered lexicographically ignoring identifier, with the identifier used in case of ties. The digit-logs should be put in their original order.\nReturn the final order of the logs.\n", "solutions": ["class Solution {\n    public String[] reorderLogFiles(String[] logs) {\n        Arrays.sort(logs, (log1, log2) -> {\n            String[] split1 = log1.split(\" \", 2);\n            String[] split2 = log2.split(\" \", 2);\n            boolean isDigit1 = Character.isDigit(split1[1].charAt(0));\n            boolean isDigit2 = Character.isDigit(split2[1].charAt(0));\n            if (!isDigit1 && !isDigit2) {\n                int cmp = split1[1].compareTo(split2[1]);\n                if (cmp != 0) return cmp;\n                return split1[0].compareTo(split2[0]);\n            }\n            return isDigit1 ? (isDigit2 ? 0 : 1) : -1;\n        });\n        return logs;\n    }\n}\n"]}
{"number": 938, "statement": "Given the root node of a binary search tree, return the sum of values of all nodes with value between L and R (inclusive).\nThe binary search tree is guaranteed to have unique values.\n", "solutions": ["class Solution {\n    int ans;\n    public int rangeSumBST(TreeNode root, int L, int R) {\n        ans = 0;\n        dfs(root, L, R);\n        return ans;\n    }\n    public void dfs(TreeNode node, int L, int R) {\n        if (node != null) {\n            if (L <= node.val && node.val <= R)\n                ans += node.val;\n            if (L < node.val)\n                dfs(node.left, L, R);\n            if (node.val < R)\n                dfs(node.right, L, R);\n        }\n    }\n}\n", "class Solution {\n    public int rangeSumBST(TreeNode root, int L, int R) {\n        int ans = 0;\n        Stack<TreeNode> stack = new Stack();\n        stack.push(root);\n        while (!stack.isEmpty()) {\n            TreeNode node = stack.pop();\n            if (node != null) {\n                if (L <= node.val && node.val <= R)\n                    ans += node.val;\n                if (L < node.val)\n                    stack.push(node.left);\n                if (node.val < R)\n                    stack.push(node.right);\n            }\n        }\n        return ans;\n    }\n}\n"]}
{"number": 939, "statement": "Given a set of points in the xy-plane, determine the minimum area of a rectangle formed from these points, with sides parallel to the x and y axes.\nIf there isn't any rectangle, return 0.\n", "solutions": ["class Solution {\n    public int minAreaRect(int[][] points) {\n        Map<Integer, List<Integer>> rows = new TreeMap();\n        for (int[] point: points) {\n            int x = point[0], y = point[1];\n            rows.computeIfAbsent(x, z-> new ArrayList()).add(y);\n        }\n        int ans = Integer.MAX_VALUE;\n        Map<Integer, Integer> lastx = new HashMap();\n        for (int x: rows.keySet()) {\n            List<Integer> row = rows.get(x);\n            Collections.sort(row);\n            for (int i = 0; i < row.size(); ++i)\n                for (int j = i+1; j < row.size(); ++j) {\n                    int y1 = row.get(i), y2 = row.get(j);\n                    int code = 40001 * y1 + y2;\n                    if (lastx.containsKey(code))\n                        ans = Math.min(ans, (x - lastx.get(code)) * (y2-y1));\n                    lastx.put(code, x);\n                }\n        }\n        return ans < Integer.MAX_VALUE ? ans : 0;\n    }\n}\n", "class Solution {\n    public int minAreaRect(int[][] points) {\n        Set<Integer> pointSet = new HashSet();\n        for (int[] point: points)\n            pointSet.add(40001 * point[0] + point[1]);\n        int ans = Integer.MAX_VALUE;\n        for (int i = 0; i < points.length; ++i)\n            for (int j = i+1; j < points.length; ++j) {\n                if (points[i][0] != points[j][0] && points[i][1] != points[j][1]) {\n                    if (pointSet.contains(40001 * points[i][0] + points[j][1]) &&\n                            pointSet.contains(40001 * points[j][0] + points[i][1])) {\n                        ans = Math.min(ans, Math.abs(points[j][0] - points[i][0]) *\n                                            Math.abs(points[j][1] - points[i][1]));\n                    }\n                }\n            }\n        return ans < Integer.MAX_VALUE ? ans : 0;\n    }\n}\n"]}
{"number": 940, "statement": "Given a string S, count the number of distinct, non-empty subsequences of S .\nSince the result may be large, return the answer modulo 10^9 + 7.\n", "solutions": ["class Solution {\n    public int distinctSubseqII(String S) {\n        int MOD = 1_000_000_007;\n        int N = S.length();\n        int[] dp = new int[N+1];\n        dp[0] = 1;\n        int[] last = new int[26];\n        Arrays.fill(last, -1);\n        for (int i = 0; i < N; ++i) {\n            int x = S.charAt(i) - 'a';\n            dp[i+1] = dp[i] * 2 % MOD;\n            if (last[x] >= 0)\n                dp[i+1] -= dp[last[x]];\n            dp[i+1] %= MOD;\n            last[x] = i;\n        }\n        dp[N]--;\n        if (dp[N] < 0) dp[N] += MOD;\n        return dp[N];\n    }\n}\n"]}
{"number": 941, "statement": "Given an array A of integers, return true if and only if it is a valid mountain array.\nRecall that A is a mountain array if and only if:\nA.length = 3\nThere exists some i with0  i A.length - 1such that:\nA[0]  A[1]  ... A[i-1]  A[i] \nA[i]  A[i+1]  ...  A[A.length - 1]\n", "solutions": ["class Solution {\n    public boolean validMountainArray(int[] A) {\n        int N = A.length;\n        int i = 0;\n        // walk up\n        while (i+1 < N && A[i] < A[i+1])\n            i++;\n        // peak can't be first or last\n        if (i == 0 || i == N-1)\n            return false;\n        // walk down\n        while (i+1 < N && A[i] > A[i+1])\n            i++;\n        return i == N-1;\n    }\n}\n"]}
{"number": 942, "statement": "Given a string S that only contains \"I\" (increase) or \"D\" (decrease), let N = S.length.\nReturn any permutation A of [0, 1, ..., N] such that for all i = 0,..., N-1:\nIf S[i] == \"I\", then A[i]  A[i+1]\nIf S[i] == \"D\", then A[i]  A[i+1]\n", "solutions": ["class Solution {\n    public int[] diStringMatch(String S) {\n        int N = S.length();\n        int lo = 0, hi = N;\n        int[] ans = new int[N + 1];\n        for (int i = 0; i < N; ++i) {\n            if (S.charAt(i) == 'I')\n                ans[i] = lo++;\n            else\n                ans[i] = hi--;\n        }\n        ans[N] = lo;\n        return ans;\n    }\n}\n"]}
{"number": 944, "statement": "We are given an arrayA of N lowercase letter strings, all of the same length.\nNow, we may choose any set of deletion indices, and for each string, we delete all the characters in those indices.\nFor example, if we have an array A = [\"abcdef\",\"uvwxyz\"] and deletion indices {0, 2, 3}, then the final array after deletions is [\"bef\", \"vyz\"],and the remaining columns of A are[\"b\",\"v\"], [\"e\",\"y\"], and [\"f\",\"z\"]. (Formally, the c-th column is [A[0][c], A[1][c], ..., A[A.length-1][c]]).\nSuppose we chose a set of deletion indices D such that after deletions, each remaining column in A is in non-decreasing sorted order.\nReturn the minimum possible value of D.length.\n", "solutions": ["class Solution {\n    public int minDeletionSize(String[] A) {\n        int ans = 0;\n        for (int c = 0; c < A[0].length(); ++c)\n            for (int r = 0; r < A.length - 1; ++r)\n                if (A[r].charAt(c) > A[r+1].charAt(c)) {\n                    ans++;\n                    break;\n                }\n        return ans;\n    }\n}\n"]}
{"number": 945, "statement": "Given an array of integers A, a move consists of choosing any A[i], and incrementing it by 1.\nReturn the least number of moves to make every value in A unique.\n", "solutions": ["class Solution {\n    public int minIncrementForUnique(int[] A) {\n        int[] count = new int[100000];\n        for (int x: A) count[x]++;\n        int ans = 0, taken = 0;\n        for (int x = 0; x < 100000; ++x) {\n            if (count[x] >= 2) {\n                taken += count[x] - 1;\n                ans -= x * (count[x] - 1);\n            }\n            else if (taken > 0 && count[x] == 0) {\n                taken--;\n                ans += x;\n            }\n        }\n        return ans;\n    }\n}\n", "class Solution {\n    public int minIncrementForUnique(int[] A) {\n        Arrays.sort(A);\n        int ans = 0, taken = 0;\n        for (int i = 1; i < A.length; ++i) {\n            if (A[i-1] == A[i]) {\n                taken++;\n                ans -= A[i];\n            } else {\n                int give = Math.min(taken, A[i] - A[i-1] - 1);\n                ans += give * (give + 1) / 2 + give * A[i-1];\n                taken -= give;\n            }\n        }\n        if (A.length > 0)\n            ans += taken * (taken + 1) / 2 + taken * A[A.length - 1];\n        return ans;\n    }\n}\n"]}
{"number": 946, "statement": "Given two sequences pushed and poppedwith distinct values,return true if and only if this could have been the result of a sequence of push and pop operations on an initially empty stack.\n", "solutions": ["class Solution {\n    public boolean validateStackSequences(int[] pushed, int[] popped) {\n        int N = pushed.length;\n        Stack<Integer> stack = new Stack();\n        int j = 0;\n        for (int x: pushed) {\n            stack.push(x);\n            while (!stack.isEmpty() && j < N && stack.peek() == popped[j]) {\n                stack.pop();\n                j++;\n            }\n        }\n        return j == N;\n    }\n}\n"]}
{"number": 947, "statement": "On a 2D plane, we place stones at some integer coordinate points. Each coordinate point may have at most one stone.\nNow, a move consists of removing a stonethat shares a column or row with another stone on the grid.\nWhat is the largest possible number of moves we can make?\n", "solutions": ["class Solution {\n    public int removeStones(int[][] stones) {\n        int N = stones.length;\n        // graph[i][0] = the length of the 'list' graph[i][1:]\n        int[][] graph = new int[N][N];\n        for (int i = 0; i < N; ++i)\n            for (int j = i+1; j < N; ++j)\n                if (stones[i][0] == stones[j][0] || stones[i][1] == stones[j][1]) {\n                    graph[i][++graph[i][0]] = j;\n                    graph[j][++graph[j][0]] = i;\n                }\n        int ans = 0;\n        boolean[] seen = new boolean[N];\n        for (int i = 0; i < N; ++i) if (!seen[i]) {\n            Stack<Integer> stack = new Stack();\n            stack.push(i);\n            seen[i] = true;\n            ans--;\n            while (!stack.isEmpty()) {\n                int node = stack.pop();\n                ans++;\n                for (int k = 1; k <= graph[node][0]; ++k) {\n                    int nei = graph[node][k];\n                    if (!seen[nei]) {\n                        stack.push(nei);\n                        seen[nei] = true;\n                    }\n                }\n            }\n        }\n        return ans;\n    }\n}\n", "class Solution {\n    public int removeStones(int[][] stones) {\n        int N = stones.length;\n        DSU dsu = new DSU(20000);\n        for (int[] stone: stones)\n            dsu.union(stone[0], stone[1] + 10000);\n        Set<Integer> seen = new HashSet();\n        for (int[] stone: stones)\n            seen.add(dsu.find(stone[0]));\n        return N - seen.size();\n    }\n}\nclass DSU {\n    int[] parent;\n    public DSU(int N) {\n        parent = new int[N];\n        for (int i = 0; i < N; ++i)\n            parent[i] = i;\n    }\n    public int find(int x) {\n        if (parent[x] != x) parent[x] = find(parent[x]);\n        return parent[x];\n    }\n    public void union(int x, int y) {\n        parent[find(x)] = find(y);\n    }\n}\n"]}
{"number": 948, "statement": "You have an initial power P, an initial score of 0 points, and a bag of tokens.\nEach token can be used at most once, has a value token[i], and has potentially two ways to use it.\nIf we have at least token[i] power, we may play the token face up, losing token[i] power, and gaining 1 point.\nIf we have at least 1 point, we may play the token face down, gaining token[i] power, and losing 1 point.\nReturn the largest number of points we can have after playing any number of tokens.\n", "solutions": ["class Solution {\n    public int bagOfTokensScore(int[] tokens, int P) {\n        Arrays.sort(tokens);\n        int lo = 0, hi = tokens.length - 1;\n        int points = 0, ans = 0;\n        while (lo <= hi && (P >= tokens[lo] || points > 0)) {\n            while (lo <= hi && P >= tokens[lo]) {\n                P -= tokens[lo++];\n                points++;\n            }\n            ans = Math.max(ans, points);\n            if (lo <= hi && points > 0) {\n                P += tokens[hi--];\n                points--;\n            }\n        }\n        return ans;\n    }\n}\n"]}
{"number": 949, "statement": "Given an array of 4 digits, return the largest 24 hour time that can be made.\nThe smallest 24 hour time is 00:00, and the largest is 23:59. Starting from 00:00, a time is larger if more time has elapsed since midnight.\nReturn the answer as a string of length 5. If no valid time can be made, return an empty string.\n", "solutions": ["// Solution inspired by @rock\nclass Solution {\n    public String largestTimeFromDigits(int[] A) {\n        int ans = -1;\n        // Choose different indices i, j, k, l as a permutation of 0, 1, 2, 3\n        for (int i = 0; i < 4; ++i)\n            for (int j = 0; j < 4; ++j) if (j != i)\n                for (int k = 0; k < 4; ++k) if (k != i && k != j) {\n                    int l = 6 - i - j - k;\n                    // For each permutation of A[i], read out the time and\n                    // record the largest legal time.\n                    int hours = 10 * A[i] + A[j];\n                    int mins = 10 * A[k] + A[l];\n                    if (hours < 24 && mins < 60)\n                        ans = Math.max(ans, hours * 60 + mins);\n                }\n        return ans >= 0 ? String.format(\"%02d:%02d\", ans / 60, ans % 60) : \"\";\n    }\n}\n"]}
{"number": 950, "statement": "In a deck of cards, every card has a unique integer. You can order the deck inany order you want.\nInitially, all the cards start face down (unrevealed) in one deck.\nNow, you do the following steps repeatedly, until all cards are revealed:\nTake the top card of the deck, reveal it, and take it out of the deck.\nIf there are still cards in the deck, put the next top card of the deck atthe bottom of the deck.\nIf there are still unrevealed cards, go back to step 1. Otherwise, stop.\nReturn an ordering of the deck that would reveal the cardsin increasing order.\nThe first entry in the answer is considered to be the top of the deck.\n", "solutions": ["class Solution {\n    public int[] deckRevealedIncreasing(int[] deck) {\n        int N = deck.length;\n        Deque<Integer> index = new LinkedList();\n        for (int i = 0; i < N; ++i)\n            index.add(i);\n        int[] ans = new int[N];\n        Arrays.sort(deck);\n        for (int card: deck) {\n            ans[index.pollFirst()] = card;\n            if (!index.isEmpty())\n                index.add(index.pollFirst());\n        }\n        return ans;\n    }\n}\n"]}
{"number": 951, "statement": "For a binary tree T, we can define a flip operation as follows: choose any node, and swap the left and right child subtrees.\nA binary tree Xis flip equivalent to a binary tree Y if and only if we can make X equal to Y after some number of flip operations.\nWrite a function that determines whether two binary treesare flip equivalent. The trees are given by root nodes root1 and root2.\n", "solutions": ["class Solution {\n    public boolean flipEquiv(TreeNode root1, TreeNode root2) {\n        if (root1 == root2)\n            return true;\n        if (root1 == null || root2 == null || root1.val != root2.val)\n            return false;\n        return (flipEquiv(root1.left, root2.left) && flipEquiv(root1.right, root2.right) ||\n                flipEquiv(root1.left, root2.right) && flipEquiv(root1.right, root2.left));\n    }\n}\n", "class Solution {\n    public boolean flipEquiv(TreeNode root1, TreeNode root2) {\n        List<Integer> vals1 = new ArrayList();\n        List<Integer> vals2 = new ArrayList();\n        dfs(root1, vals1);\n        dfs(root2, vals2);\n        return vals1.equals(vals2);\n    }\n    public void dfs(TreeNode node, List<Integer> vals) {\n        if (node != null) {\n            vals.add(node.val);\n            int L = node.left != null ? node.left.val : -1;\n            int R = node.right != null ? node.right.val : -1;\n            if (L < R) {\n                dfs(node.left, vals);\n                dfs(node.right, vals);\n            } else {\n                dfs(node.right, vals);\n                dfs(node.left, vals);\n            }\n            vals.add(null);\n        }\n    }\n}\n"]}
{"number": 952, "statement": "Given a non-emptyarray of unique positive integers A, consider the following graph:\nThere are A.length nodes, labelled A[0] to A[A.length - 1];\nThere is an edge between A[i] and A[j]if and only ifA[i] and A[j] share a common factor greater than 1.\nReturn the size of the largest connected component in the graph.\n", "solutions": ["class Solution {\n    public int largestComponentSize(int[] A) {\n        int N = A.length;\n        // factored[i] = a list of unique prime factors of A[i]\n        ArrayList<Integer>[] factored = new ArrayList[N];\n        for (int i = 0; i < N; ++i) {\n            factored[i] = new ArrayList<Integer>();\n            int d = 2, x = A[i];\n            while (d * d <= x) {\n                if (x % d == 0) {\n                    while (x % d == 0)\n                        x /= d;\n                    factored[i].add(d);\n                }\n                d++;\n            }\n            if (x > 1 || factored[i].isEmpty())\n                factored[i].add(x);\n        }\n        // primesL : a list of all primes that occur in factored\n        Set<Integer> primes = new HashSet();\n        for (List<Integer> facs: factored)\n            for (int x: facs)\n                primes.add(x);\n        int[] primesL = new int[primes.size()];\n        int t = 0;\n        for (int x: primes)\n            primesL[t++] = x;\n        // primeToIndex.get(v) == i  iff  primes[i] = v\n        Map<Integer, Integer> primeToIndex = new HashMap();\n        for (int i = 0; i < primesL.length; ++i)\n            primeToIndex.put(primesL[i], i);\n        DSU dsu = new DSU(primesL.length);\n        for (List<Integer> facs: factored)\n            for (int x: facs)\n                dsu.union(primeToIndex.get(facs.get(0)), primeToIndex.get(x));\n        int[] count = new int[primesL.length];\n        for (List<Integer> facs: factored)\n            count[dsu.find(primeToIndex.get(facs.get(0)))]++;\n        int ans = 0;\n        for (int x: count)\n            if (x > ans)\n                ans = x;\n        return ans;\n    }\n}\nclass DSU {\n    int[] parent;\n    public DSU(int N) {\n        parent = new int[N];\n        for (int i = 0; i < N; ++i)\n            parent[i] = i;\n    }\n    public int find(int x) {\n        if (parent[x] != x) parent[x] = find(parent[x]);\n        return parent[x];\n    }\n    public void union(int x, int y) {\n        parent[find(x)] = find(y);\n    }\n}\n"]}
{"number": 953, "statement": "In an alien language, surprisingly they also use english lowercase letters, but possiblyin a different order. Theorder of the alphabetis some permutationof lowercase letters.\nGiven a sequence of wordswritten in the alien language,and the order of the alphabet,return true if and only if the given wordsare sorted lexicographicaly in this alien language.\n", "solutions": ["class Solution {\n    public boolean isAlienSorted(String[] words, String order) {\n        int[] index = new int[26];\n        for (int i = 0; i < order.length(); ++i)\n            index[order.charAt(i) - 'a'] = i;\n        search: for (int i = 0; i < words.length - 1; ++i) {\n            String word1 = words[i];\n            String word2 = words[i+1];\n            // Find the first difference word1[k] != word2[k].\n            for (int k = 0; k < Math.min(word1.length(), word2.length()); ++k) {\n                if (word1.charAt(k) != word2.charAt(k)) {\n                    // If they compare badly, it's not sorted.\n                    if (index[word1.charAt(k) - 'a'] > index[word2.charAt(k) - 'a'])\n                        return false;\n                    continue search;\n                }\n            }\n            // If we didn't find a first difference, the\n            // words are like (\"app\", \"apple\").\n            if (word1.length() > word2.length())\n                return false;\n        }\n        return true;\n    }\n}\n"]}
{"number": 954, "statement": "Given an array of integers Awith even length, return true if and only if it is possible to reorder it such that A[2 * i + 1] = 2 * A[2 * i] for every 0 =i  len(A) / 2.\n", "solutions": ["class Solution {\n    public boolean canReorderDoubled(int[] A) {\n        // count[x] = the number of occurrences of x in A\n        Map<Integer, Integer> count = new HashMap();\n        for (int x: A)\n            count.put(x, count.getOrDefault(x, 0) + 1);\n        // B = A as Integer[], sorted by absolute value\n        Integer[] B = new Integer[A.length];\n        for (int i = 0; i < A.length; ++i)\n            B[i] = A[i];\n        Arrays.sort(B, Comparator.comparingInt(Math::abs));\n        for (int x: B) {\n            // If this can't be consumed, skip\n            if (count.get(x) == 0) continue;\n            // If this doesn't have a doubled partner, the answer is false\n            if (count.getOrDefault(2*x, 0) <= 0) return false;\n            // Write x, 2*x\n            count.put(x, count.get(x) - 1);\n            count.put(2*x, count.get(2*x) - 1);\n        }\n        // If we have written everything, the answer is true\n        return true;\n    }\n}\n"]}
{"number": 955, "statement": "We are given an arrayA of N lowercase letter strings, all of the same length.\nNow, we may choose any set of deletion indices, and for each string, we delete all the characters in those indices.\nFor example, if we have an array A = [\"abcdef\",\"uvwxyz\"] and deletion indices {0, 2, 3}, then the final array after deletions is [\"bef\",\"vyz\"].\nSuppose we chose a set of deletion indices D such that after deletions, the final array has its elements in lexicographic order (A[0] = A[1] = A[2] ... = A[A.length - 1]).\nReturn the minimum possible value of D.length.\n", "solutions": ["class Solution {\n    public int minDeletionSize(String[] A) {\n        int N = A.length;\n        int W = A[0].length();\n        int ans = 0;\n        // cur : all rows we have written\n        // For example, with A = [\"abc\",\"def\",\"ghi\"] we might have\n        // cur = [\"ab\", \"de\", \"gh\"].\n        String[] cur = new String[N];\n        for (int j = 0; j < W; ++j) {\n            // cur2 : What we potentially can write, including the\n            //        newest column col = [A[i][j] for i]\n            // Eg. if cur = [\"ab\",\"de\",\"gh\"] and col = (\"c\",\"f\",\"i\"),\n            // then cur2 = [\"abc\",\"def\",\"ghi\"].\n            String[] cur2 = Arrays.copyOf(cur, N);\n            for (int i = 0; i < N; ++i)\n                cur2[i] += A[i].charAt(j);\n            if (isSorted(cur2))\n                cur = cur2;\n            else\n                ans++;\n        }\n        return ans;\n    }\n    public boolean isSorted(String[] A) {\n        for (int i = 0; i < A.length - 1; ++i)\n            if (A[i].compareTo(A[i+1]) > 0)\n                return false;\n        return true;\n    }\n}\n", "class Solution {\n    public int minDeletionSize(String[] A) {\n        int N = A.length;\n        int W = A[0].length();\n        // cuts[j] is true : we don't need to check any new A[i][j] <= A[i][j+1]\n        boolean[] cuts = new boolean[N-1];\n        int ans = 0;\n        search: for (int j = 0; j < W; ++j) {\n            // Evaluate whether we can keep this column\n            for (int i = 0; i < N-1; ++i)\n                if (!cuts[i] && A[i].charAt(j) > A[i+1].charAt(j)) {\n                    // Can't keep the column - delete and continue\n                    ans++;\n                    continue search;\n                }\n            // Update 'cuts' information\n            for (int i = 0; i < N-1; ++i)\n                if (A[i].charAt(j) < A[i+1].charAt(j))\n                    cuts[i] = true;\n        }\n        return ans;\n    }\n}\n"]}
{"number": 956, "statement": "You are installing a billboard and want it to have the largest height. The billboard will have two steel supports, one on each side. Each steel support must be an equal height.\nYou have a collection of rods which can be welded together. For example, if you have rods of lengths 1, 2, and 3, you can weld them together to make a support of length 6.\nReturn the largest possible height of your billboard installation. If you cannot support the billboard, return 0.\n", "solutions": ["class Solution {\n    int NINF = Integer.MIN_VALUE / 3;\n    Integer[][] memo;\n    public int tallestBillboard(int[] rods) {\n        int N = rods.length;\n        // \"memo[n][x]\" will be stored at memo[n][5000+x]\n        // Using Integer for default value null\n        memo = new Integer[N][10001];\n        return (int) dp(rods, 0, 5000);\n    }\n    public int dp(int[] rods, int i, int s) {\n        if (i == rods.length) {\n            return s == 5000 ? 0 : NINF;\n        } else if (memo[i][s] != null) {\n            return memo[i][s];\n        } else {\n            int ans = dp(rods, i+1, s);\n            ans = Math.max(ans, dp(rods, i+1, s-rods[i]));\n            ans = Math.max(ans, rods[i] + dp(rods, i+1, s+rods[i]));\n            memo[i][s] = ans;\n            return ans;\n        }\n    }\n}\n", "import java.awt.Point;\nclass Solution {\n    public int tallestBillboard(int[] rods) {\n        int N = rods.length;\n        Map<Integer, Integer> Ldelta = make(Arrays.copyOfRange(rods, 0, N/2));\n        Map<Integer, Integer> Rdelta = make(Arrays.copyOfRange(rods, N/2, N));\n        int ans = 0;\n        for (int d: Ldelta.keySet())\n            if (Rdelta.containsKey(-d))\n                ans = Math.max(ans, Ldelta.get(d) + Rdelta.get(-d));\n        return ans;\n    }\n    public Map<Integer, Integer> make(int[] A) {\n        Point[] dp = new Point[60000];\n        int t = 0;\n        dp[t++] = new Point(0, 0);\n        for (int v: A) {\n            int stop = t;\n            for (int i = 0; i < stop; ++i) {\n                Point p = dp[i];\n                dp[t++] = new Point(p.x + v, p.y);\n                dp[t++] = new Point(p.x, p.y + v);\n            }\n        }\n        Map<Integer, Integer> ans = new HashMap();\n        for (int i = 0; i < t; ++i) {\n            int a = dp[i].x;\n            int b = dp[i].y;\n            ans.put(a-b, Math.max(ans.getOrDefault(a-b, 0), a));\n        }\n        return ans;\n    }\n}\n"]}
{"number": 957, "statement": "There are 8 prison cells in a row, and each cell is either occupied or vacant.\nEach day, whether the cell is occupied or vacant changes according to the following rules:\nIf a cell has two adjacent neighbors that are both occupied or both vacant,then the cell becomes occupied.\nOtherwise, it becomes vacant.\n(Note that because the prison is a row, the first and the last cells in the row can't have two adjacent neighbors.)\nWe describe the current state of the prisonin the following way:cells[i] == 1 if the i-th cell is occupied, else cells[i] == 0.\nGiven the initial state of the prison, return the state of the prison after N days (and N such changes described above.)\n", "solutions": ["class Solution {\n    public int[] prisonAfterNDays(int[] cells, int N) {\n        Map<Integer, Integer> seen = new HashMap();\n        // state  = integer representing state of prison\n        int state = 0;\n        for (int i = 0; i < 8; ++i) {\n            if (cells[i] > 0)\n                state ^= 1 << i;\n        }\n        // While days remaining, simulate a day\n        while (N > 0) {\n            // If this is a cycle, fast forward by\n            // seen.get(state) - N, the period of the cycle.\n            if (seen.containsKey(state)) {\n                N %= seen.get(state) - N;\n            }\n            seen.put(state, N);\n            if (N >= 1) {\n                N--;\n                state = nextDay(state);\n            }\n        }\n        // Convert the state back to the required answer.\n        int[] ans = new int[8];\n        for (int i = 0; i < 8; ++i) {\n            if (((state >> i) & 1) > 0) {\n                ans[i] = 1;\n            }\n        }\n        return ans;\n    }\n    public int nextDay(int state) {\n        int ans = 0;\n        // We only loop from 1 to 6 because 0 and 7 are impossible,\n        // as those cells only have one neighbor.\n        for (int i = 1; i <= 6; ++i) {\n            if (((state >> (i-1)) & 1) == ((state >> (i+1)) & 1)) {\n                ans ^= 1 << i;\n            }\n        }\n        return ans;\n    }\n}\n"]}
{"number": 958, "statement": "Given a binary tree, determine if it is a complete binary tree.\nDefinition of a complete binary tree from Wikipedia:\nIn a complete binary tree every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h.\n", "solutions": ["class Solution {\n    public boolean isCompleteTree(TreeNode root) {\n        List<ANode> nodes = new ArrayList();\n        nodes.add(new ANode(root, 1));\n        int i = 0;\n        while (i < nodes.size()) {\n            ANode anode = nodes.get(i++);\n            if (anode.node != null) {\n                nodes.add(new ANode(anode.node.left, anode.code * 2));\n                nodes.add(new ANode(anode.node.right, anode.code * 2 + 1));\n            }\n        }\n        return nodes.get(i-1).code == nodes.size();\n    }\n}\nclass ANode {  // Annotated Node\n    TreeNode node;\n    int code;\n    ANode(TreeNode node, int code) {\n        this.node = node;\n        this.code = code;\n    }\n}\n"]}
{"number": 959, "statement": "In a N x Ngrid composed of 1 x 1 squares, each 1 x 1 square consists of a /, \\, or blank space. These characters divide the square into contiguous regions.\n(Note that backslash characters are escaped, so a \\is represented as \"\\\\\".)\nReturn the number of regions.\n", "solutions": ["class Solution {\n    public int regionsBySlashes(String[] grid) {\n        int N = grid.length;\n        DSU dsu = new DSU(4 * N * N);\n        for (int r = 0; r < N; ++r)\n            for (int c = 0; c < N; ++c) {\n                int root = 4 * (r * N + c);\n                char val = grid[r].charAt(c);\n                if (val != '\\\\') {\n                    dsu.union(root + 0, root + 1);\n                    dsu.union(root + 2, root + 3);\n                }\n                if (val != '/') {\n                    dsu.union(root + 0, root + 2);\n                    dsu.union(root + 1, root + 3);\n                }\n                // north south\n                if (r + 1 < N)\n                    dsu.union(root + 3, (root + 4 * N) + 0);\n                if (r - 1 >= 0)\n                    dsu.union(root + 0, (root - 4 * N) + 3);\n                // east west\n                if (c + 1 < N)\n                    dsu.union(root + 2, (root + 4) + 1);\n                if (c - 1 >= 0)\n                    dsu.union(root + 1, (root - 4) + 2);\n            }\n        int ans = 0;\n        for (int x = 0; x < 4 * N * N; ++x) {\n            if (dsu.find(x) == x)\n                ans++;\n        }\n        return ans;\n    }\n}\nclass DSU {\n    int[] parent;\n    public DSU(int N) {\n        parent = new int[N];\n        for (int i = 0; i < N; ++i)\n            parent[i] = i;\n    }\n    public int find(int x) {\n        if (parent[x] != x) parent[x] = find(parent[x]);\n        return parent[x];\n    }\n    public void union(int x, int y) {\n        parent[find(x)] = find(y);\n    }\n}\n"]}
{"number": 960, "statement": "We are given an arrayA of N lowercase letter strings, all of the same length.\nNow, we may choose any set of deletion indices, and for each string, we delete all the characters in those indices.\nFor example, if we have an array A = [\"babca\",\"bbazb\"] and deletion indices {0, 1, 4}, then the final array after deletions is [\"bc\",\"az\"].\nSuppose we chose a set of deletion indices D such that after deletions, the final array has every element (row) inlexicographic order.\nFor clarity, A[0] is in lexicographic order (ie. A[0][0] = A[0][1] = ... = A[0][A[0].length - 1]), A[1] is in lexicographic order (ie. A[1][0] = A[1][1] = ... = A[1][A[1].length - 1]), and so on.\nReturn the minimum possible value of D.length.\n", "solutions": ["class Solution {\n    public int minDeletionSize(String[] A) {\n        int W = A[0].length();\n        int[] dp = new int[W];\n        Arrays.fill(dp, 1);\n        for (int i = W-2; i >= 0; --i)\n            search: for (int j = i+1; j < W; ++j) {\n                for (String row: A)\n                    if (row.charAt(i) > row.charAt(j))\n                        continue search;\n                dp[i] = Math.max(dp[i], 1 + dp[j]);\n            }\n        int kept = 0;\n        for (int x: dp)\n            kept = Math.max(kept, x);\n        return W - kept;\n    }\n}\n"]}
{"number": 961, "statement": "In a array A of size 2N, there are N+1 unique elements, and exactly one of these elements is repeated N times.\nReturn the element repeated N times.\n", "solutions": ["class Solution {\n    public int repeatedNTimes(int[] A) {\n        Map<Integer, Integer> count = new HashMap();\n        for (int x: A) {\n            count.put(x, count.getOrDefault(x, 0) + 1);\n        }\n        for (int k: count.keySet())\n            if (count.get(k) > 1)\n                return k;\n        throw null;\n    }\n}\n", "class Solution {\n    public int repeatedNTimes(int[] A) {\n        for (int k = 1; k <= 3; ++k)\n            for (int i = 0; i < A.length - k; ++i)\n                if (A[i] == A[i+k])\n                    return A[i];\n        throw null;\n    }\n}\n"]}
{"number": 962, "statement": "Given an array A of integers, a rampis a tuple (i, j) for which i  jandA[i] = A[j]. The width of such aramp is j - i.\nFind the maximum width of a ramp in A. If one doesn't exist, return 0.\n", "solutions": ["class Solution {\n    public int maxWidthRamp(int[] A) {\n        int N = A.length;\n        Integer[] B = new Integer[N];\n        for (int i = 0; i < N; ++i)\n            B[i] = i;\n        Arrays.sort(B, (i, j) -> ((Integer) A[i]).compareTo(A[j]));\n        int ans = 0;\n        int m = N;\n        for (int i: B) {\n            ans = Math.max(ans, i - m);\n            m = Math.min(m, i);\n        }\n        return ans;\n    }\n}\n", "import java.awt.Point;\nclass Solution {\n    public int maxWidthRamp(int[] A) {\n        int N = A.length;\n        int ans = 0;\n        List<Point> candidates = new ArrayList();\n        candidates.add(new Point(A[N-1], N-1));\n        // candidates: i's decreasing, by increasing value of A[i]\n        for (int i = N-2; i >= 0; --i) {\n            // Find largest j in candidates with A[j] >= A[i]\n            int lo = 0, hi = candidates.size();\n            while (lo < hi) {\n                int mi = lo + (hi - lo) / 2;\n                if (candidates.get(mi).x < A[i])\n                    lo = mi + 1;\n                else\n                    hi = mi;\n            }\n            if (lo < candidates.size()) {\n                int j = candidates.get(lo).y;\n                ans = Math.max(ans, j - i);\n            } else {\n                candidates.add(new Point(A[i], i));\n            }\n        }\n        return ans;\n    }\n}\n"]}
{"number": 963, "statement": "Given a set of points in the xy-plane, determine the minimum area of any rectangle formed from these points, with sides not necessarily parallel to the x and y axes.\nIf there isn't any rectangle, return 0.\n", "solutions": ["import java.awt.Point;\nclass Solution {\n    public double minAreaFreeRect(int[][] points) {\n        int N = points.length;\n        Point[] A = new Point[N];\n        Set<Point> pointSet = new HashSet();\n        for (int i = 0; i < N; ++i) {\n            A[i] = new Point(points[i][0], points[i][1]);\n            pointSet.add(A[i]);\n        }\n        double ans = Double.MAX_VALUE;\n        for (int i = 0; i < N; ++i) {\n            Point p1 = A[i];\n            for (int j = 0; j < N; ++j) if (j != i) {\n                Point p2 = A[j];\n                for (int k = j+1; k < N; ++k) if (k != i) {\n                    Point p3 = A[k];\n                    Point p4 = new Point(p2.x + p3.x - p1.x, p2.y + p3.y - p1.y);\n                    if (pointSet.contains(p4)) {\n                        int dot = ((p2.x - p1.x) * (p3.x - p1.x) +\n                                   (p2.y - p1.y) * (p3.y - p1.y));\n                        if (dot == 0) {\n                            double area = p1.distance(p2) * p1.distance(p3);\n                            if (area < ans)\n                                ans = area;\n                        }\n                    }\n                }\n            }\n        }\n        return ans < Double.MAX_VALUE ? ans : 0;\n    }\n}\n", "import java.awt.Point;\nclass Solution {\n    public double minAreaFreeRect(int[][] points) {\n        int N = points.length;\n        Point[] A = new Point[N];\n        for (int i = 0; i < N; ++i)\n            A[i] = new Point(points[i][0], points[i][1]);\n        Map<Integer, Map<Point, List<Point>>> seen = new HashMap();\n        for (int i = 0; i < N; ++i)\n            for (int j = i+1; j < N; ++j) {\n                // center is twice actual to keep integer precision\n                Point center = new Point(A[i].x + A[j].x, A[i].y + A[j].y);\n                int r2 = (A[i].x - A[j].x) * (A[i].x - A[j].x);\n                r2 += (A[i].y - A[j].y) * (A[i].y - A[j].y);\n                if (!seen.containsKey(r2))\n                    seen.put(r2, new HashMap<Point, List<Point>>());\n                if (!seen.get(r2).containsKey(center))\n                    seen.get(r2).put(center, new ArrayList<Point>());\n                seen.get(r2).get(center).add(A[i]);\n            }\n        double ans = Double.MAX_VALUE;\n        for (Map<Point, List<Point>> info: seen.values()) {\n            for (Point center: info.keySet()) {  // center is twice actual\n                List<Point> candidates = info.get(center);\n                int clen = candidates.size();\n                for (int i = 0; i < clen; ++i)\n                    for (int j = i+1; j < clen; ++j) {\n                        Point P = candidates.get(i);\n                        Point Q = candidates.get(j);\n                        Point Q2 = new Point(center);\n                        Q2.translate(-Q.x, -Q.y);\n                        double area = P.distance(Q) * P.distance(Q2);\n                        if (area < ans)\n                            ans = area;\n                    }\n            }\n        }\n        return ans < Double.MAX_VALUE ? ans : 0;\n    }\n}\n"]}
{"number": 964, "statement": "Given a single positive integer x, we will write an expression of the form x (op1) x (op2) x (op3) x ...where each operator op1, op2, etc. is either addition, subtraction, multiplication, or division (+, -, *, or /). For example, with x = 3, we might write 3 * 3 / 3 + 3 - 3which is a value of 3.\nWhen writing such an expression, we adhere to the following conventions:\nThe division operator (/) returns rational numbers.\nThere are no parentheses placed anywhere.\nWe use the usual order of operations: multiplication and division happens before addition and subtraction.\nIt's not allowed to use the unary negationoperator (-). For example, \"x- x\"is a valid expression as it only uses subtraction, but \"-x +x\" is not because it uses negation.\nWe would like to write an expression with the least number of operators such that the expression equals the given target. Return the least number of operators used.\n", "solutions": ["class Solution {\n    Map<String, Integer> memo;\n    int x;\n    public int leastOpsExpressTarget(int x, int target) {\n        memo = new HashMap();\n        this.x = x;\n        return dp(0, target) - 1;\n    }\n    public int dp(int i, int target) {\n        String code = \"\" + i + \"#\" + target;\n        if (memo.containsKey(code))\n            return memo.get(code);\n        int ans;\n        if (target == 0) {\n            ans = 0;\n        } else if (target == 1) {\n            ans = cost(i);\n        } else if (i >= 39) {\n            ans = target + 1;\n        } else {\n            int t = target / x;\n            int r = target % x;\n            ans = Math.min(r * cost(i) + dp(i+1, t),\n                           (x-r) * cost(i) + dp(i+1, t+1));\n        }\n        memo.put(code, ans);\n        return ans;\n    }\n    public int cost(int x) {\n        return x > 0 ? x : 2;\n    }\n}\n"]}
{"number": 965, "statement": "A binary tree is univalued if every node in the tree has the same value.\nReturn trueif and only if the given tree is univalued.\n", "solutions": ["class Solution {\n    List<Integer> vals;\n    public boolean isUnivalTree(TreeNode root) {\n        vals = new ArrayList();\n        dfs(root);\n        for (int v: vals)\n            if (v != vals.get(0))\n                return false;\n        return true;\n    }\n    public void dfs(TreeNode node) {\n        if (node != null) {\n            vals.add(node.val);\n            dfs(node.left);\n            dfs(node.right);\n        }\n    }\n}\n", "class Solution {\n    public boolean isUnivalTree(TreeNode root) {\n        boolean left_correct = (root.left == null ||\n                (root.val == root.left.val && isUnivalTree(root.left)));\n        boolean right_correct = (root.right == null ||\n                (root.val == root.right.val && isUnivalTree(root.right)));\n        return left_correct && right_correct;\n    }\n}\n"]}
{"number": 966, "statement": "Given awordlist, we want to implement a spellchecker that converts a query word into a correct word.\nFor a given query word, the spell checker handles two categories of spelling mistakes:\nCapitalization: If the query matches a word in the wordlist (case-insensitive), then the query word is returned with the same case as the case in the wordlist.\n", "solutions": ["class Solution {\n    Set<String> words_perfect;\n    Map<String, String> words_cap;\n    Map<String, String> words_vow;\n    public String[] spellchecker(String[] wordlist, String[] queries) {\n        words_perfect = new HashSet();\n        words_cap = new HashMap();\n        words_vow = new HashMap();\n        for (String word: wordlist) {\n            words_perfect.add(word);\n            String wordlow = word.toLowerCase();\n            words_cap.putIfAbsent(wordlow, word);\n            String wordlowDV = devowel(wordlow);\n            words_vow.putIfAbsent(wordlowDV, word);\n        }\n        String[] ans = new String[queries.length];\n        int t = 0;\n        for (String query: queries)\n            ans[t++] = solve(query);\n        return ans;\n    }\n    public String solve(String query) {\n        if (words_perfect.contains(query))\n            return query;\n        String queryL = query.toLowerCase();\n        if (words_cap.containsKey(queryL))\n            return words_cap.get(queryL);\n        String queryLV = devowel(queryL);\n        if (words_vow.containsKey(queryLV))\n            return words_vow.get(queryLV);\n        return \"\";\n    }\n    public String devowel(String word) {\n        StringBuilder ans = new StringBuilder();\n        for (char c: word.toCharArray())\n            ans.append(isVowel(c) ? '*' : c);\n        return ans.toString();\n    }\n    public boolean isVowel(char c) {\n        return (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u');\n    }\n}\n"]}
{"number": 967, "statement": "Return all non-negative integers of length N such that the absolute difference between every two consecutive digits is K.\nNote that every number in the answer must not have leading zeros except for the number 0 itself. For example, 01 has one leading zero and is invalid, but 0 is valid.\nYou may return the answer in any order.\n", "solutions": ["class Solution {\n    public int[] numsSameConsecDiff(int N, int K) {\n        Set<Integer> cur = new HashSet();\n        for (int i = 1; i <= 9; ++i)\n            cur.add(i);\n        for (int steps = 1; steps <= N-1; ++steps) {\n            Set<Integer> cur2 = new HashSet();\n            for (int x: cur) {\n                int d = x % 10;\n                if (d-K >= 0)\n                    cur2.add(10*x + (d-K));\n                if (d+K <= 9)\n                    cur2.add(10*x + (d+K));\n            }\n            cur = cur2;\n        }\n        if (N == 1)\n            cur.add(0);\n        int[] ans = new int[cur.size()];\n        int t = 0;\n        for (int x: cur)\n            ans[t++] = x;\n        return ans;\n    }\n}\n"]}
{"number": 968, "statement": "Given a binary tree, we install cameras on the nodes of the tree.\nEach camera ata node can monitor its parent, itself, and its immediate children.\nCalculate the minimum number of cameras needed to monitor all nodes of the tree.\n", "solutions": ["class Solution {\n    public int minCameraCover(TreeNode root) {\n        int[] ans = solve(root);\n        return Math.min(ans[1], ans[2]);\n    }\n    // 0: Strict ST; All nodes below this are covered, but not this one\n    // 1: Normal ST; All nodes below and incl this are covered - no camera\n    // 2: Placed camera; All nodes below this are covered, plus camera here\n    public int[] solve(TreeNode node) {\n        if (node == null)\n            return new int[]{0, 0, 99999};\n        int[] L = solve(node.left);\n        int[] R = solve(node.right);\n        int mL12 = Math.min(L[1], L[2]);\n        int mR12 = Math.min(R[1], R[2]);\n        int d0 = L[1] + R[1];\n        int d1 = Math.min(L[2] + mR12, R[2] + mL12);\n        int d2 = 1 + Math.min(L[0], mL12) + Math.min(R[0], mR12);\n        return new int[]{d0, d1, d2};\n    }\n}\n", "class Solution {\n    int ans;\n    Set<TreeNode> covered;\n    public int minCameraCover(TreeNode root) {\n        ans = 0;\n        covered = new HashSet();\n        covered.add(null);\n        dfs(root, null);\n        return ans;\n    }\n    public void dfs(TreeNode node, TreeNode par) {\n        if (node != null) {\n            dfs(node.left, node);\n            dfs(node.right, node);\n            if (par == null && !covered.contains(node) ||\n                    !covered.contains(node.left) ||\n                    !covered.contains(node.right)) {\n                ans++;\n                covered.add(node);\n                covered.add(par);\n                covered.add(node.left);\n                covered.add(node.right);\n            }\n        }\n    }\n}\n"]}
{"number": 969, "statement": "Given an array A, we can perform apancake flip:We choose some positive integerk = A.length, then reverse the order of the first k elements of A. We want to perform zero or more pancake flips (doing them one after another in succession) to sort the array A.\nReturn the k-values corresponding to a sequence of pancake flips that sort A. Anyvalid answer that sorts the array within 10 * A.length flips will be judged as correct.\n", "solutions": ["class Solution {\n    public List<Integer> pancakeSort(int[] A) {\n        List<Integer> ans = new ArrayList();\n        int N = A.length;\n        Integer[] B = new Integer[N];\n        for (int i = 0; i < N; ++i)\n            B[i] = i+1;\n        Arrays.sort(B, (i, j) -> A[j-1] - A[i-1]);\n        for (int i: B) {\n            for (int f: ans)\n                if (i <= f)\n                    i = f+1 - i;\n            ans.add(i);\n            ans.add(N--);\n        }\n        return ans;\n    }\n}\n"]}
{"number": 970, "statement": "Given two positive integers x and y, an integer is powerfulif it is equal to x^i + y^jforsome integers i = 0 and j = 0.\nReturn a list of all powerful integers that have value less than or equal to bound.\nYou may return the answer in any order. In your answer, each value should occur at most once.\n", "solutions": ["class Solution {\n    public List<Integer> powerfulIntegers(int x, int y, int bound) {\n        Set<Integer> seen = new HashSet();\n        for (int i = 0; i < 18 && Math.pow(x, i) <= bound; ++i)\n            for (int j = 0; j < 18 && Math.pow(y, j) <= bound; ++j) {\n                int v = (int) Math.pow(x, i) + (int) Math.pow(y, j);\n                if (v <= bound)\n                    seen.add(v);\n            }\n        return new ArrayList(seen);\n    }\n}\n"]}
{"number": 971, "statement": "Given a binary tree with N nodes, each node has a different value from{1, ..., N}.\nA node in this binary tree can be flippedby swapping the left child and the right child of that node.\nConsider the sequence ofN values reported by a preorder traversal starting from the root. Call such a sequence of N values thevoyageof the tree.\n(Recall that a preorder traversalof a node means we report the current node's value, then preorder-traverse the left child, then preorder-traverse the right child.)\nOur goal is to flip the least number of nodes in the tree so that the voyage of the tree matches the voyage we are given.\nIf we can do so, then return alistof the values of all nodes flipped. You may return the answer in any order.\nIf we cannot do so, then return the list [-1].\n", "solutions": ["class Solution {\n    List<Integer> flipped;\n    int index;\n    int[] voyage;\n    public List<Integer> flipMatchVoyage(TreeNode root, int[] voyage) {\n        flipped = new ArrayList();\n        index = 0;\n        this.voyage = voyage;\n        dfs(root);\n        if (!flipped.isEmpty() && flipped.get(0) == -1) {\n            flipped.clear();\n            flipped.add(-1);\n        }\n        return flipped;\n    }\n    public void dfs(TreeNode node) {\n        if (node != null) {\n            if (node.val != voyage[index++]) {\n                flipped.clear();\n                flipped.add(-1);\n                return;\n            }\n            if (index < voyage.length && node.left != null &&\n                    node.left.val != voyage[index]) {\n                flipped.add(node.val);\n                dfs(node.right);\n                dfs(node.left);\n            } else {\n                dfs(node.left);\n                dfs(node.right);\n            }\n        }\n    }\n}\n"]}
{"number": 972, "statement": "Given two strings S and T, each of which represents a non-negative rational number, return True if and only if they represent the same number. The strings may use parentheses to denote the repeating part of the rational number.\nIn general a rational number can be represented using up tothree parts: aninteger part, anon-repeating part, and arepeating part. The number will be representedin one of the following three ways:\nIntegerPart (e.g. 0, 12, 123)\nIntegerPart.NonRepeatingPart (e.g. 0.5, 1., 2.12, 2.0001)\nIntegerPart.NonRepeatingPart(RepeatingPart) (e.g. 0.1(6), 0.9(9), 0.00(1212))\nThe repeating portion of a decimal expansion is conventionally denoted within a pair of round brackets. For example:\n1 / 6 = 0.16666666... = 0.1(6) = 0.1666(6) = 0.166(66)\nBoth 0.1(6) or 0.1666(6) or 0.166(66) are correct representations of 1 / 6.\n", "solutions": ["class Solution {\n    public boolean isRationalEqual(String S, String T) {\n        Fraction f1 = convert(S);\n        Fraction f2 = convert(T);\n        return f1.n == f2.n && f1.d == f2.d;\n    }\n    public Fraction convert(String S) {\n        int state = 0; //whole, decimal, repeating\n        Fraction ans = new Fraction(0, 1);\n        int decimal_size = 0;\n        for (String part: S.split(\"[.()]\")) {\n            state++;\n            if (part.isEmpty()) continue;\n            long x = Long.valueOf(part);\n            int sz = part.length();\n            if (state == 1) { // whole\n                 ans.iadd(new Fraction(x, 1));\n            } else if (state == 2) { // decimal\n                 ans.iadd(new Fraction(x, (long) Math.pow(10, sz)));\n                 decimal_size = sz;\n            } else { // repeating\n                 long denom = (long) Math.pow(10, decimal_size);\n                 denom *= (long) (Math.pow(10, sz) - 1);\n                 ans.iadd(new Fraction(x, denom));\n            }\n        }\n        return ans;\n    }\n}\nclass Fraction {\n    long n, d;\n    Fraction(long n, long d) {\n        long g = gcd(n, d);\n        this.n = n / g;\n        this.d = d / g;\n    }\n    public void iadd(Fraction other) {\n        long numerator = this.n * other.d + this.d * other.n;\n        long denominator = this.d * other.d;\n        long g = Fraction.gcd(numerator, denominator);\n        this.n = numerator / g;\n        this.d = denominator / g;\n    }\n    static long gcd(long x, long y) {\n        return x != 0 ? gcd(y % x, x) : y;\n    }\n}\n"]}
{"number": 973, "statement": "We have a list of pointson the plane. Find the K closest points to the origin (0, 0).\n(Here, the distance between two points on a plane is the Euclidean distance.)\nYou may return the answer in any order. Theanswer is guaranteed to be unique (except for the order that it is in.)\n", "solutions": ["class Solution {\n    public int[][] kClosest(int[][] points, int K) {\n        int N = points.length;\n        int[] dists = new int[N];\n        for (int i = 0; i < N; ++i)\n            dists[i] = dist(points[i]);\n        Arrays.sort(dists);\n        int distK = dists[K-1];\n        int[][] ans = new int[K][2];\n        int t = 0;\n        for (int i = 0; i < N; ++i)\n            if (dist(points[i]) <= distK)\n                ans[t++] = points[i];\n        return ans;\n    }\n    public int dist(int[] point) {\n        return point[0] * point[0] + point[1] * point[1];\n    }\n}\n", "import java.util.concurrent.ThreadLocalRandom;\nclass Solution {\n    int[][] points;\n    public int[][] kClosest(int[][] points, int K) {\n        this.points = points;\n        sort(0, points.length - 1, K);\n        return Arrays.copyOfRange(points, 0, K);\n    }\n    public void sort(int i, int j, int K) {\n        if (i >= j) return;\n        int k = ThreadLocalRandom.current().nextInt(i, j);\n        swap(i, k);\n        int mid = partition(i, j);\n        int leftLength = mid - i + 1;\n        if (K < leftLength)\n            sort(i, mid - 1, K);\n        else if (K > leftLength)\n            sort(mid + 1, j, K - leftLength);\n    }\n    public int partition(int i, int j) {\n        int oi = i;\n        int pivot = dist(i);\n        i++;\n        while (true) {\n            while (i < j && dist(i) < pivot)\n                i++;\n            while (i <= j && dist(j) > pivot)\n                j--;\n            if (i >= j) break;\n            swap(i, j);\n        }\n        swap(oi, j);\n        return j;\n    }\n    public int dist(int i) {\n        return points[i][0] * points[i][0] + points[i][1] * points[i][1];\n    }\n    public void swap(int i, int j) {\n        int t0 = points[i][0], t1 = points[i][1];\n        points[i][0] = points[j][0];\n        points[i][1] = points[j][1];\n        points[j][0] = t0;\n        points[j][1] = t1;\n    }\n}\n"]}
{"number": 974, "statement": "Given an array A of integers, return the number of (contiguous, non-empty) subarrays that have a sum divisible by K.\n", "solutions": ["class Solution {\n    public int subarraysDivByK(int[] A, int K) {\n        int N = A.length;\n        int[] P = new int[N+1];\n        for (int i = 0; i < N; ++i)\n            P[i+1] = P[i] + A[i];\n        int[] count = new int[K];\n        for (int x: P)\n            count[(x % K + K) % K]++;\n        int ans = 0;\n        for (int v: count)\n            ans += v * (v - 1) / 2;\n        return ans;\n    }\n}\n"]}
{"number": 975, "statement": "You are given an integer array A. Fromsome starting index, you can make a series of jumps. The (1st, 3rd, 5th, ...)jumps in the series are called odd numbered jumps, and the (2nd, 4th, 6th, ...) jumps in the series are called even numbered jumps.\nYou may from index ijump forward to index j(with i j) in the following way:\nDuring odd numbered jumps (ie. jumps 1, 3, 5, ...), you jump to the index jsuch that A[i] = A[j] and A[j] is the smallest possible value. If there are multiple such indexes j, you can only jump to the smallest such index j.\nDuring even numbered jumps (ie. jumps 2, 4, 6, ...), you jump to the index jsuch that A[i] = A[j] and A[j] is the largestpossible value. If there are multiple such indexes j, you can only jump to the smallest such index j.\n(It may be the case that for some index i, there are no legal jumps.)\nA starting index is good if, starting from that index, you can reach the end of the array (index A.length - 1) by jumping some number of times (possibly 0 or more than once.)\nReturn the number of good starting indexes.\n", "solutions": ["class Solution(object):\n    def oddEvenJumps(self, A):\n        N = len(A)\n        def make(B):\n            ans = [None] * N\n            stack = []  # invariant: stack is decreasing\n            for i in B:\n                while stack and i > stack[-1]:\n                    ans[stack.pop()] = i\n                stack.append(i)\n            return ans\n        B = sorted(range(N), key = lambda i: A[i])\n        oddnext = make(B)\n        B.sort(key = lambda i: -A[i])\n        evennext = make(B)\n        odd = [False] * N\n        even = [False] * N\n        odd[N-1] = even[N-1] = True\n        for i in xrange(N-2, -1, -1):\n            if oddnext[i] is not None:\n                odd[i] = even[oddnext[i]]\n            if evennext[i] is not None:\n                even[i] = odd[evennext[i]]\n        return sum(odd)\n", "class Solution {\n    public int oddEvenJumps(int[] A) {\n        int N = A.length;\n        if (N <= 1) return N;\n        boolean[] odd = new boolean[N];\n        boolean[] even = new boolean[N];\n        odd[N-1] = even[N-1] = true;\n        TreeMap<Integer, Integer> vals = new TreeMap();\n        vals.put(A[N-1], N-1);\n        for (int i = N-2; i >= 0; --i) {\n            int v = A[i];\n            if (vals.containsKey(v)) {\n                odd[i] = even[vals.get(v)];\n                even[i] = odd[vals.get(v)];\n            } else {\n                Integer lower = vals.lowerKey(v);\n                Integer higher = vals.higherKey(v);\n                if (lower != null)\n                    even[i] = odd[vals.get(lower)];\n                if (higher != null) {\n                    odd[i] = even[vals.get(higher)];\n                }\n            }\n            vals.put(v, i);\n        }\n        int ans = 0;\n        for (boolean b: odd)\n            if (b) ans++;\n        return ans;\n    }\n}\n"]}
{"number": 976, "statement": "Given an array A of positive lengths, return the largest perimeter of a triangle with non-zero area, formed from 3 of these lengths.\nIf it is impossible to form anytriangle of non-zero area, return 0.\n", "solutions": ["class Solution {\n    public int largestPerimeter(int[] A) {\n        Arrays.sort(A);\n        for (int i = A.length - 3; i >= 0; --i)\n            if (A[i] + A[i+1] > A[i+2])\n                return A[i] + A[i+1] + A[i+2];\n        return 0;\n    }\n}\n"]}
{"number": 977, "statement": "Given an array of integers Asorted in non-decreasing order,return an array of the squares of each number,also in sorted non-decreasing order.\n", "solutions": ["class Solution {\n    public int[] sortedSquares(int[] A) {\n        int N = A.length;\n        int[] ans = new int[N];\n        for (int i = 0; i < N; ++i)\n            ans[i] = A[i] * A[i];\n        Arrays.sort(ans);\n        return ans;\n    }\n}\n", "class Solution {\n    public int[] sortedSquares(int[] A) {\n        int N = A.length;\n        int j = 0;\n        while (j < N && A[j] < 0)\n            j++;\n        int i = j-1;\n        int[] ans = new int[N];\n        int t = 0;\n        while (i >= 0 && j < N) {\n            if (A[i] * A[i] < A[j] * A[j]) {\n                ans[t++] = A[i] * A[i];\n                i--;\n            } else {\n                ans[t++] = A[j] * A[j];\n                j++;\n            }\n        }\n        while (i >= 0) {\n            ans[t++] = A[i] * A[i];\n            i--;\n        }\n        while (j < N) {\n            ans[t++] = A[j] * A[j];\n            j++;\n        }\n        return ans;\n    }\n}\n"]}
{"number": 978, "statement": "A subarray A[i], A[i+1], ..., A[j]of A is said to be turbulent if and only if:\nFor i = k  j, A[k]  A[k+1] when k is odd, and A[k]  A[k+1] when k is even;\nOR, for i = k  j, A[k]  A[k+1] when k is even, and A[k]  A[k+1] when k is odd.\nThat is, the subarray is turbulent if the comparison sign flips between each adjacent pair of elements in the subarray.\nReturn the length of amaximum size turbulent subarray of A.\n", "solutions": ["class Solution {\n    public int maxTurbulenceSize(int[] A) {\n        int N = A.length;\n        int ans = 1;\n        int anchor = 0;\n        for (int i = 1; i < N; ++i) {\n            int c = Integer.compare(A[i-1], A[i]);\n            if (c == 0) {\n                anchor = i;\n            } else if (i == N-1 || c * Integer.compare(A[i], A[i+1]) != -1) {\n                ans = Math.max(ans, i - anchor + 1);\n                anchor = i;\n            }\n        }\n        return ans;\n    }\n}\n"]}
{"number": 979, "statement": "Given the root of a binary tree with N nodes, each nodein the tree has node.val coins, and there are N coins total.\nIn one move, we may choose two adjacent nodes and move one coin from one node to another. (The move may be from parent to child, or from child to parent.)\nReturn the number of moves required to make every node have exactly one coin.\n", "solutions": ["class Solution {\n    int ans;\n    public int distributeCoins(TreeNode root) {\n        ans = 0;\n        dfs(root);\n        return ans;\n    }\n    public int dfs(TreeNode node) {\n        if (node == null) return 0;\n        int L = dfs(node.left);\n        int R = dfs(node.right);\n        ans += Math.abs(L) + Math.abs(R);\n        return node.val + L + R - 1;\n    }\n}\n"]}
{"number": 980, "statement": "On a 2-dimensionalgrid, there are 4 types of squares:\n1 represents the starting square. There is exactly one starting square.\n2 represents the ending square. There is exactly one ending square.\n0 represents empty squares we can walk over.\n-1 represents obstacles that we cannot walk over.\nReturn the number of 4-directional walksfrom the starting square to the ending square, that walk over every non-obstacle squareexactly once.\n", "solutions": ["class Solution {\n    int ans;\n    int[][] grid;\n    int tr, tc;\n    int[] dr = new int[]{0, -1, 0, 1};\n    int[] dc = new int[]{1, 0, -1, 0};\n    int R, C;\n    public int uniquePathsIII(int[][] grid) {\n        this.grid = grid;\n        R = grid.length;\n        C = grid[0].length;\n        int todo = 0;\n        int sr = 0, sc = 0;\n        for (int r = 0; r < R; ++r)\n            for (int c = 0; c < C; ++c) {\n                if (grid[r][c] != -1) {\n                    todo++;\n                }\n                if (grid[r][c] == 1) {\n                    sr = r;\n                    sc = c;\n                } else if (grid[r][c] == 2) {\n                    tr = r;\n                    tc = c;\n                }\n            }\n        ans = 0;\n        dfs(sr, sc, todo);\n        return ans;\n    }\n    public void dfs(int r, int c, int todo) {\n        todo--;\n        if (todo < 0) return;\n        if (r == tr && c == tc) {\n            if (todo == 0) ans++;\n            return;\n        }\n        grid[r][c] = 3;\n        for (int k = 0; k < 4; ++k) {\n            int nr = r + dr[k];\n            int nc = c + dc[k];\n            if (0 <= nr && nr < R && 0 <= nc && nc < C) {\n                if (grid[nr][nc] % 2 == 0)\n                    dfs(nr, nc, todo);\n            }\n        }\n        grid[r][c] = 0;\n    }\n}\n", "class Solution {\n    int ans;\n    int[][] grid;\n    int R, C;\n    int tr, tc, target;\n    int[] dr = new int[]{0, -1, 0, 1};\n    int[] dc = new int[]{1, 0, -1, 0};\n    Integer[][][] memo;\n    public int uniquePathsIII(int[][] grid) {\n        this.grid = grid;\n        R = grid.length;\n        C = grid[0].length;\n        target = 0;\n        int sr = 0, sc = 0;\n        for (int r = 0; r < R; ++r)\n            for (int c = 0; c < C; ++c) {\n                if (grid[r][c] % 2 == 0)\n                    target |= code(r, c);\n                if (grid[r][c] == 1) {\n                    sr = r;\n                    sc = c;\n                } else if (grid[r][c] == 2) {\n                    tr = r;\n                    tc = c;\n                }\n            }\n        memo = new Integer[R][C][1 << R*C];\n        return dp(sr, sc, target);\n    }\n    public int code(int r, int c) {\n        return 1 << (r * C + c);\n    }\n    public Integer dp(int r, int c, int todo) {\n        if (memo[r][c][todo] != null)\n            return memo[r][c][todo];\n        if (r == tr && c == tc) {\n            return todo == 0 ? 1 : 0;\n        }\n        int ans = 0;\n        for (int k = 0; k < 4; ++k) {\n            int nr = r + dr[k];\n            int nc = c + dc[k];\n            if (0 <= nr && nr < R && 0 <= nc && nc < C) {\n                if ((todo & code(nr, nc)) != 0)\n                    ans += dp(nr, nc, todo ^ code(nr, nc));\n            }\n        }\n        memo[r][c][todo] = ans;\n        return ans;\n    }\n}\n"]}
{"number": 981, "statement": "Create a timebased key-value store classTimeMap, that supports two operations.\n1. set(string key, string value, int timestamp)\nStores the key and value, along with the given timestamp.\n2. get(string key, int timestamp)\nReturns a value such that set(key, value, timestamp_prev) was called previously, with timestamp_prev = timestamp.\nIf there are multiple such values, it returns the one with the largest timestamp_prev.\nIf there are no values, it returns the empty string (\"\").\n", "solutions": ["class TimeMap {\n    Map<String, List<Pair<Integer, String>>> M;\n    public TimeMap() {\n        M = new HashMap();\n    }\n    public void set(String key, String value, int timestamp) {\n        if (!M.containsKey(key))\n            M.put(key, new ArrayList<Pair<Integer, String>>());\n        M.get(key).add(new Pair(timestamp, value));\n    }\n    public String get(String key, int timestamp) {\n        if (!M.containsKey(key)) return \"\";\n        List<Pair<Integer, String>> A = M.get(key);\n        int i = Collections.binarySearch(A, new Pair<Integer, String>(timestamp, \"{\"),\n                (a, b) -> Integer.compare(a.getKey(), b.getKey()));\n        if (i >= 0)\n            return A.get(i).getValue();\n        else if (i == -1)\n            return \"\";\n        else\n            return A.get(-i-2).getValue();\n    }\n}\n", "class TimeMap {\n    Map<String, TreeMap<Integer, String>> M;\n    public TimeMap() {\n        M = new HashMap();\n    }\n    public void set(String key, String value, int timestamp) {\n        if (!M.containsKey(key))\n            M.put(key, new TreeMap());\n        M.get(key).put(timestamp, value);\n    }\n    public String get(String key, int timestamp) {\n        if (!M.containsKey(key)) return \"\";\n        TreeMap<Integer, String> tree = M.get(key);\n        Integer t = tree.floorKey(timestamp);\n        return t != null ? tree.get(t) : \"\";\n    }\n}\n"]}
{"number": 983, "statement": "In a country popular for train travel, youhave planned some train travelling one year in advance. The days of the year that you will travel is given as an array days. Each day is an integer from 1 to 365.\nTrain tickets are sold in 3 different ways:\na 1-day pass is sold for costs[0] dollars;\na 7-day pass is sold for costs[1] dollars;\na 30-day pass is sold for costs[2] dollars.\nThe passes allow that many days of consecutive travel. For example, if we get a 7-day pass on day 2, then we can travel for 7 days: day 2, 3, 4, 5, 6, 7, and 8.\nReturn the minimum number of dollars you need to travel every day in the given list of days.\n", "solutions": ["class Solution {\n    int[] costs;\n    Integer[] memo;\n    Set<Integer> dayset;\n    public int mincostTickets(int[] days, int[] costs) {\n        this.costs = costs;\n        memo = new Integer[366];\n        dayset = new HashSet();\n        for (int d: days) dayset.add(d);\n        return dp(1);\n    }\n    public int dp(int i) {\n        if (i > 365)\n            return 0;\n        if (memo[i] != null)\n            return memo[i];\n        int ans;\n        if (dayset.contains(i)) {\n            ans = Math.min(dp(i+1) + costs[0],\n                               dp(i+7) + costs[1]);\n            ans = Math.min(ans, dp(i+30) + costs[2]);\n        } else {\n            ans = dp(i+1);\n        }\n        memo[i] = ans;\n        return ans;\n    }\n}\n", "class Solution {\n    int[] days, costs;\n    Integer[] memo;\n    int[] durations = new int[]{1, 7, 30};\n    public int mincostTickets(int[] days, int[] costs) {\n        this.days = days;\n        this.costs = costs;\n        memo = new Integer[days.length];\n        return dp(0);\n    }\n    public int dp(int i) {\n        if (i >= days.length)\n            return 0;\n        if (memo[i] != null)\n            return memo[i];\n        int ans = Integer.MAX_VALUE;\n        int j = i;\n        for (int k = 0; k < 3; ++k) {\n            while (j < days.length && days[j] < days[i] + durations[k])\n                j++;\n            ans = Math.min(ans, dp(j) + costs[k]);\n        }\n        memo[i] = ans;\n        return ans;\n    }\n}\n"]}
{"number": 984, "statement": "Given two integers A and B, return any string S such that:\nS has length A + B and contains exactly A 'a' letters, and exactly B 'b' letters;\nThe substring'aaa'does not occur in S;\nThe substring 'bbb' does not occur in S.\n", "solutions": ["class Solution {\n    public String strWithout3a3b(int A, int B) {\n        StringBuilder ans = new StringBuilder();\n        while (A > 0 || B > 0) {\n            boolean writeA = false;\n            int L = ans.length();\n            if (L >= 2 && ans.charAt(L-1) == ans.charAt(L-2)) {\n                if (ans.charAt(L-1) == 'b')\n                    writeA = true;\n            } else {\n                if (A >= B)\n                    writeA = true;\n            }\n            if (writeA) {\n                A--;\n                ans.append('a');\n            } else {\n                B--;\n                ans.append('b');\n            }\n        }\n        return ans.toString();\n    }\n}\n"]}
{"number": 985, "statement": "We have an array A of integers, and an array queriesof queries.\nFor the i-thquery val =queries[i][0], index= queries[i][1], we add valto A[index]. Then, the answer to the i-th query is the sum of the even values of A.\n(Here, the given index = queries[i][1] is a 0-based index, and each query permanently modifies the array A.)\nReturn the answer to all queries. Your answer array should haveanswer[i]asthe answer to the i-th query.\n", "solutions": ["class Solution {\n    public int[] sumEvenAfterQueries(int[] A, int[][] queries) {\n        int S = 0;\n        for (int x: A)\n            if (x % 2 == 0)\n                S += x;\n        int[] ans = new int[queries.length];\n        for (int i = 0; i < queries.length; ++i) {\n            int val = queries[i][0], index = queries[i][1];\n            if (A[index] % 2 == 0) S -= A[index];\n            A[index] += val;\n            if (A[index] % 2 == 0) S += A[index];\n            ans[i] = S;\n        }\n        return ans;\n    }\n}\n"]}
{"number": 986, "statement": "Given two listsof closed intervals, each list of intervals is pairwise disjoint and in sorted order.\nReturn the intersection of these two interval lists.\n(Formally, a closed interval [a, b] (with a = b) denotesthe set of real numbers x with a = x = b. Theintersection of two closed intervals is a set of real numbers that is either empty, or can be represented as a closed interval. For example, the intersection of [1, 3] and [2, 4] is [2, 3].)\n", "solutions": ["class Solution {\n  public int[][] intervalIntersection(int[][] A, int[][] B) {\n    List<int[]> ans = new ArrayList();\n    int i = 0, j = 0;\n    while (i < A.length && j < B.length) {\n      // Let's check if A[i] intersects B[j].\n      // lo - the startpoint of the intersection\n      // hi - the endpoint of the intersection\n      int lo = Math.max(A[i][0], B[j][0]);\n      int hi = Math.min(A[i][1], B[j][1]);\n      if (lo <= hi)\n        ans.add(new int[]{lo, hi});\n      // Remove the interval with the smallest endpoint\n      if (A[i][1] < B[j][1])\n        i++;\n      else\n        j++;\n    }\n    return ans.toArray(new int[ans.size()][]);\n  }\n}\n"]}
{"number": 987, "statement": "Given a binary tree, return the vertical order traversal of its nodesvalues.\nFor each node at position (X, Y), its left and right children respectivelywill be at positions (X-1, Y-1) and (X+1, Y-1).\nRunning a vertical line from X = -infinity to X = +infinity, whenever the vertical line touches some nodes, we report the values of the nodes in order from top to bottom (decreasing Y coordinates).\nIf two nodes have the same position, then the value of the node that is reported first is the value that is smaller.\nReturn an listof non-empty reports in order of X coordinate. Every report will have a list of values of nodes.\n", "solutions": ["class Triplet<F, S, T> {\n    public final F first;\n    public final S second;\n    public final T third;\n    public Triplet(F first, S second, T third) {\n        this.first = first;\n        this.second = second;\n        this.third = third;\n    }\n}\nclass Solution {\n    List<Triplet<Integer, Integer, Integer>> nodeList = new ArrayList<>();\n    private void BFS(TreeNode root) {\n        Queue<Triplet<TreeNode, Integer, Integer>> queue = new ArrayDeque();\n        int row = 0, column = 0;\n        queue.offer(new Triplet(root, row, column));\n        while (!queue.isEmpty()) {\n            Triplet<TreeNode, Integer, Integer> triplet = queue.poll();\n            root = triplet.first;\n            row = triplet.second;\n            column = triplet.third;\n            if (root != null) {\n                this.nodeList.add(new Triplet(column, row, root.val));\n                queue.offer(new Triplet(root.left, row + 1, column - 1));\n                queue.offer(new Triplet(root.right, row + 1, column + 1));\n            }\n        }\n    }\n    public List<List<Integer>> verticalTraversal(TreeNode root) {\n        List<List<Integer>> output = new ArrayList();\n        if (root == null) {\n            return output;\n        }\n        // step 1). BFS traversal\n        BFS(root);\n        // step 2). sort the global list by <column, row, value>\n        Collections.sort(this.nodeList, new Comparator<Triplet<Integer, Integer, Integer>>() {\n            @Override\n            public int compare(Triplet<Integer, Integer, Integer> t1,\n                    Triplet<Integer, Integer, Integer> t2) {\n                if (t1.first.equals(t2.first))\n                    if (t1.second.equals(t2.second))\n                        return t1.third - t2.third;\n                    else\n                        return t1.second - t2.second;\n                else\n                    return t1.first - t2.first;\n            }\n        });\n        // step 3). extract the values, partitioned by the column index.\n        List<Integer> currColumn = new ArrayList();\n        Integer currColumnIndex = this.nodeList.get(0).first;\n        for (Triplet<Integer, Integer, Integer> triplet : this.nodeList) {\n            Integer column = triplet.first, value = triplet.third;\n            if (column == currColumnIndex) {\n                currColumn.add(value);\n            } else {\n                output.add(currColumn);\n                currColumnIndex = column;\n                currColumn = new ArrayList();\n                currColumn.add(value);\n            }\n        }\n        output.add(currColumn);\n        return output;\n    }\n}\n", "class Triplet<F, S, T> {\n    public final F first;\n    public final S second;\n    public final T third;\n    public Triplet(F first, S second, T third) {\n        this.first = first;\n        this.second = second;\n        this.third = third;\n    }\n}\nclass Solution {\n    List<Triplet<Integer, Integer, Integer>> nodeList = new ArrayList<>();\n    private void DFS(TreeNode node, Integer row, Integer column) {\n        if (node == null)\n            return;\n        nodeList.add(new Triplet(column, row, node.val));\n        // preorder DFS traversal\n        this.DFS(node.left, row + 1, column - 1);\n        this.DFS(node.right, row + 1, column + 1);\n    }\n    public List<List<Integer>> verticalTraversal(TreeNode root) {\n        List<List<Integer>> output = new ArrayList();\n        if (root == null) {\n            return output;\n        }\n        // step 1). DFS traversal\n        DFS(root, 0, 0);\n        // step 2). sort the list by <column, row, value>\n        Collections.sort(this.nodeList, new Comparator<Triplet<Integer, Integer, Integer>>() {\n            @Override\n            public int compare(Triplet<Integer, Integer, Integer> t1,\n                    Triplet<Integer, Integer, Integer> t2) {\n                if (t1.first.equals(t2.first))\n                    if (t1.second.equals(t2.second))\n                        return t1.third - t2.third;\n                    else\n                        return t1.second - t2.second;\n                else\n                    return t1.first - t2.first;\n            }\n        });\n        // step 3). extract the values, grouped by the column index.\n        List<Integer> currColumn = new ArrayList();\n        Integer currColumnIndex = this.nodeList.get(0).first;\n        for (Triplet<Integer, Integer, Integer> triplet : this.nodeList) {\n            Integer column = triplet.first, value = triplet.third;\n            if (column == currColumnIndex) {\n                currColumn.add(value);\n            } else {\n                output.add(currColumn);\n                currColumnIndex = column;\n                currColumn = new ArrayList();\n                currColumn.add(value);\n            }\n        }\n        output.add(currColumn);\n        return output;\n    }\n}\n"]}
{"number": 988, "statement": "Given the root of a binary tree, each node has a value from 0 to 25 representing the letters 'a' to 'z': a value of 0 represents 'a', a value of 1 represents 'b', and so on.\nFind the lexicographically smallest string that starts at a leaf of this tree and ends at the root.\n(As a reminder, any shorter prefix of a string is lexicographically smaller: for example, \"ab\" is lexicographically smaller than \"aba\". A leaf of a node is a node that has no children.)\n", "solutions": ["class Solution {\n    String ans = \"~\";\n    public String smallestFromLeaf(TreeNode root) {\n        dfs(root, new StringBuilder());\n        return ans;\n    }\n    public void dfs(TreeNode node, StringBuilder sb) {\n        if (node == null) return;\n        sb.append((char)('a' + node.val));\n        if (node.left == null && node.right == null) {\n            sb.reverse();\n            String S = sb.toString();\n            sb.reverse();\n            if (S.compareTo(ans) < 0)\n                ans = S;\n        }\n        dfs(node.left, sb);\n        dfs(node.right, sb);\n        sb.deleteCharAt(sb.length() - 1);\n    }\n}\n"]}
{"number": 989, "statement": "For a non-negative integer X, thearray-form of Xis an array of its digits in left to right order. For example, if X = 1231, then the array form is[1,2,3,1].\nGiven the array-form A of a non-negativeinteger X, return the array-form of the integer X+K.\n", "solutions": ["class Solution {\n    public List<Integer> addToArrayForm(int[] A, int K) {\n        int N = A.length;\n        int cur = K;\n        List<Integer> ans = new ArrayList();\n        int i = N;\n        while (--i >= 0 || cur > 0) {\n            if (i >= 0)\n                cur += A[i];\n            ans.add(cur % 10);\n            cur /= 10;\n        }\n        Collections.reverse(ans);\n        return ans;\n    }\n}\n"]}
{"number": 990, "statement": "Given an array equationsof strings that represent relationships between variables, each string equations[i]has length 4 and takes one of two different forms: \"a==b\" or \"a!=b\". Here, a and b are lowercase letters (not necessarily different) that represent one-letter variable names.\nReturn trueif and only if it is possible to assign integers to variable namesso as to satisfy all the given equations.\n", "solutions": ["class Solution {\n    public boolean equationsPossible(String[] equations) {\n        ArrayList<Integer>[] graph = new ArrayList[26];\n        for (int i = 0; i < 26; ++i)\n            graph[i] = new ArrayList();\n        for (String eqn: equations) {\n            if (eqn.charAt(1) == '=') {\n                int x = eqn.charAt(0) - 'a';\n                int y = eqn.charAt(3) - 'a';\n                graph[x].add(y);\n                graph[y].add(x);\n            }\n        }\n        int[] color = new int[26];\n        int t = 0;\n        for (int start = 0; start < 26; ++start) {\n            if (color[start] == 0) {\n                t++;\n                Stack<Integer> stack = new Stack();\n                stack.push(start);\n                while (!stack.isEmpty()) {\n                    int node = stack.pop();\n                    for (int nei: graph[node]) {\n                        if (color[nei] == 0) {\n                            color[nei] = t;\n                            stack.push(nei);\n                        }\n                    }\n                }\n            }\n        }\n        for (String eqn: equations) {\n            if (eqn.charAt(1) == '!') {\n                int x = eqn.charAt(0) - 'a';\n                int y = eqn.charAt(3) - 'a';\n                if (x == y || color[x] != 0 && color[x] == color[y])\n                    return false;\n            }\n        }\n        return true;\n    }\n}\n"]}
{"number": 991, "statement": "On a broken calculator that has a number showing on its display, we can perform two operations:\nDouble: Multiply the number on the display by 2, or;\nDecrement: Subtract 1 from the number on the display.\nInitially, the calculator is displaying the number X.\nReturn the minimum number of operations needed to display the number Y.\n", "solutions": ["class Solution {\n    public int brokenCalc(int X, int Y) {\n        int ans = 0;\n        while (Y > X) {\n            ans++;\n            if (Y % 2 == 1)\n                Y++;\n            else\n                Y /= 2;\n        }\n        return ans + X - Y;\n    }\n}\n"]}
{"number": 992, "statement": "Given an array A of positive integers, call a (contiguous, not necessarily distinct) subarray of A good if the number of different integers in that subarray is exactly K.\n(For example, [1,2,3,1,2] has 3 different integers: 1, 2, and 3.)\nReturn the number of good subarrays of A.\n", "solutions": ["class Solution {\n    public int subarraysWithKDistinct(int[] A, int K) {\n        Window window1 = new Window();\n        Window window2 = new Window();\n        int ans = 0, left1 = 0, left2 = 0;\n        for (int right = 0; right < A.length; ++right) {\n            int x = A[right];\n            window1.add(x);\n            window2.add(x);\n            while (window1.different() > K)\n                window1.remove(A[left1++]);\n            while (window2.different() >= K)\n                window2.remove(A[left2++]);\n            ans += left2 - left1;\n        }\n        return ans;\n    }\n}\nclass Window {\n    Map<Integer, Integer> count;\n    int nonzero;\n    Window() {\n        count = new HashMap();\n        nonzero = 0;\n    }\n    void add(int x) {\n        count.put(x, count.getOrDefault(x, 0) + 1);\n        if (count.get(x) == 1)\n            nonzero++;\n    }\n    void remove(int x) {\n        count.put(x, count.get(x) - 1);\n        if (count.get(x) == 0)\n            nonzero--;\n    }\n    int different() {\n        return nonzero;\n    }\n}\n"]}
{"number": 993, "statement": "In a binary tree, the root node is at depth 0, and children of each depth k node are at depth k+1.\nTwo nodes of a binary tree are cousins if they have the same depth, but have different parents.\nWe are given the root of a binary tree with unique values, and the values xand yof two different nodes in the tree.\nReturntrueif and only if the nodes corresponding to the values x and y are cousins.\n", "solutions": ["/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    // To save the depth of the first node.\n    int recordedDepth = -1;\n    boolean isCousin = false;\n    private boolean dfs(TreeNode node, int depth, int x, int y) {\n        if (node == null) {\n            return false;\n        }\n        // Don't go beyond the depth restricted by the first node found.\n        if (this.recordedDepth != -1 && depth > this.recordedDepth) {\n            return false;\n        }\n        if (node.val == x || node.val == y) {\n            if (this.recordedDepth == -1) {\n                // Save depth for the first node found.\n                this.recordedDepth = depth;\n            }\n            // Return true, if the second node is found at the same depth.\n            return this.recordedDepth == depth;\n        }\n        boolean left = dfs(node.left, depth + 1, x, y);\n        boolean right = dfs(node.right, depth + 1, x, y);\n        // this.recordedDepth != depth + 1 would ensure node x and y are not\n        // immediate child nodes, otherwise they would become siblings.\n        if (left && right && this.recordedDepth != depth + 1) {\n            this.isCousin = true;\n        }\n        return left || right;\n    }\n    public boolean isCousins(TreeNode root, int x, int y) {\n        // Recurse the tree to find x and y\n        dfs(root, 0, x, y);\n        return this.isCousin;\n    }\n}\n", "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public boolean isCousins(TreeNode root, int x, int y) {\n        // Queue for BFS\n        Queue <TreeNode> queue = new LinkedList <> ();\n        queue.add(root);\n        while (!queue.isEmpty()) {\n            boolean siblings = false;\n            boolean cousins = false;\n            int nodesAtDepth = queue.size();\n            for (int i = 0; i < nodesAtDepth; i++) {\n                // FIFO\n                TreeNode node = queue.remove();\n                // Encountered the marker.\n                // Siblings should be set to false as we are crossing the boundary.\n                if (node == null) {\n                    siblings = false;\n                } else {\n                    if (node.val == x || node.val == y) {\n                        // Set both the siblings and cousins flag to true\n                        // for a potential first sibling/cousin found.\n                        if (!cousins) {\n                            siblings = cousins = true;\n                        } else {\n                            // If the siblings flag is still true this means we are still\n                            // within the siblings boundary and hence the nodes are not cousins.\n                            return !siblings;\n                        }\n                    }\n                    if (node.left != null) queue.add(node.left);\n                    if (node.right != null) queue.add(node.right);\n                    // Adding the null marker for the siblings\n                    queue.add(null);\n                }\n            }\n            // After the end of a level if `cousins` is set to true\n            // This means we found only one node at this level\n            if (cousins) return false;\n        }\n        return false;\n    }\n}\n"]}
{"number": 994, "statement": "In a given grid, each cell can have one of threevalues:\nthe value 0 representing an empty cell;\nthe value 1 representing a fresh orange;\nthe value 2 representing a rotten orange.\nEvery minute, any fresh orange that is adjacent (4-directionally) to a rotten orange becomes rotten.\nReturn the minimum number of minutes that must elapse until no cell has a fresh orange. If this is impossible, return -1 instead.\n", "solutions": ["class Solution {\n    public int orangesRotting(int[][] grid) {\n        Queue<Pair<Integer, Integer>> queue = new ArrayDeque();\n        // Step 1). build the initial set of rotten oranges\n        int freshOranges = 0;\n        int ROWS = grid.length, COLS = grid[0].length;\n        for (int r = 0; r < ROWS; ++r)\n            for (int c = 0; c < COLS; ++c)\n                if (grid[r][c] == 2)\n                    queue.offer(new Pair(r, c));\n                else if (grid[r][c] == 1)\n                    freshOranges++;\n        // Mark the round / level, _i.e_ the ticker of timestamp\n        queue.offer(new Pair(-1, -1));\n        // Step 2). start the rotting process via BFS\n        int minutesElapsed = -1;\n        int[][] directions = { {-1, 0}, {0, 1}, {1, 0}, {0, -1}};\n        while (!queue.isEmpty()) {\n            Pair<Integer, Integer> p = queue.poll();\n            int row = p.getKey();\n            int col = p.getValue();\n            if (row == -1) {\n                // We finish one round of processing\n                minutesElapsed++;\n                // to avoid the endless loop\n                if (!queue.isEmpty())\n                    queue.offer(new Pair(-1, -1));\n            } else {\n                // this is a rotten orange\n                // then it would contaminate its neighbors\n                for (int[] d : directions) {\n                    int neighborRow = row + d[0];\n                    int neighborCol = col + d[1];\n                    if (neighborRow >= 0 && neighborRow < ROWS && \n                        neighborCol >= 0 && neighborCol < COLS) {\n                        if (grid[neighborRow][neighborCol] == 1) {\n                            // this orange would be contaminated\n                            grid[neighborRow][neighborCol] = 2;\n                            freshOranges--;\n                            // this orange would then contaminate other oranges\n                            queue.offer(new Pair(neighborRow, neighborCol));\n                        }\n                    }\n                }\n            }\n        }\n        // return elapsed minutes if no fresh orange left\n        return freshOranges == 0 ? minutesElapsed : -1;\n    }\n}\n", "class Solution {\n    // run the rotting process, by marking the rotten oranges with the timestamp\n    public boolean runRottingProcess(int timestamp, int[][] grid, int ROWS, int COLS) {\n        int[][] directions = { {-1, 0}, {0, 1}, {1, 0}, {0, -1}};\n        // flag to indicate if the rotting process should be continued\n        boolean toBeContinued = false;\n        for (int row = 0; row < ROWS; ++row)\n            for (int col = 0; col < COLS; ++col)\n                if (grid[row][col] == timestamp)\n                    // current contaminated cell\n                    for (int[] d : directions) {\n                        int nRow = row + d[0], nCol = col + d[1];\n                        if (nRow >= 0 && nRow < ROWS && nCol >= 0 && nCol < COLS)\n                            if (grid[nRow][nCol] == 1) {\n                                // this fresh orange would be contaminated next\n                                grid[nRow][nCol] = timestamp + 1;\n                                toBeContinued = true;\n                            }\n                    }\n        return toBeContinued;\n    }\n    public int orangesRotting(int[][] grid) {\n        int ROWS = grid.length, COLS = grid[0].length;\n        int timestamp = 2;\n        while (runRottingProcess(timestamp, grid, ROWS, COLS))\n            timestamp++;\n        // end of process, to check if there are still fresh oranges left\n        for (int[] row : grid)\n            for (int cell : row)\n                // still got a fresh orange left\n                if (cell == 1)\n                    return -1;\n        // return elapsed minutes if no fresh orange left\n        return timestamp - 2;\n    }\n}\n"]}
{"number": 995, "statement": "In an array A containing only 0s and 1s, a K-bit flipconsists of choosing a (contiguous) subarray of length K and simultaneously changing every 0 in the subarray to 1, and every 1 in the subarray to 0.\nReturn the minimum number of K-bit flips required so that there is no 0 in the array. If it is not possible, return -1.\n", "solutions": ["class Solution {\n    public int minKBitFlips(int[] A, int K) {\n        int N = A.length;\n        int[] hint = new int[N];\n        int ans = 0, flip = 0;\n        // When we flip a subarray like A[i], A[i+1], ..., A[i+K-1]\n        // we can instead flip our current writing state, and put a hint at\n        // position i+K to flip back our writing state.\n        for (int i = 0; i < N; ++i) {\n            flip ^= hint[i];\n            if (A[i] == flip) {  // If we must flip the subarray starting here...\n                ans++;  // We're flipping the subarray from A[i] to A[i+K-1]\n                if (i + K > N) return -1;  //If we can't flip the entire subarray, its impossible\n                flip ^= 1;\n                if (i + K < N) hint[i + K] ^= 1;\n            }\n        }\n        return ans;\n    }\n}\n"]}
{"number": 996, "statement": "Given an array A of non-negative integers, the array is squareful if for every pair of adjacent elements, their sum is a perfect square.\nReturn the number of permutations of A that are squareful. Two permutations A1 and A2 differ if and only if there is some index i such that A1[i] != A2[i].\n", "solutions": ["class Solution {\n    Map<Integer, Integer> count;\n    Map<Integer, List<Integer>> graph;\n    public int numSquarefulPerms(int[] A) {\n        int N = A.length;\n        count = new HashMap();\n        graph = new HashMap();\n        // count.get(v) : number of v's in A\n        for (int x: A)\n            count.put(x, count.getOrDefault(x, 0) + 1);\n        // graph.get(v) : values w in A for which v + w is a square\n        //                (ie., \"vw\" is an edge)\n        for (int x: count.keySet())\n            graph.put(x, new ArrayList());\n        for (int x: count.keySet())\n            for (int y: count.keySet()) {\n                int r = (int) (Math.sqrt(x + y) + 0.5);\n                if (r * r == x + y)\n                    graph.get(x).add(y);\n            }\n        // Add the number of paths that start at x, for all possible x\n        int ans = 0;\n        for (int x: count.keySet())\n            ans += dfs(x, N - 1);\n        return ans;\n    }\n    public int dfs(int x, int todo) {\n        count.put(x, count.get(x) - 1);\n        int ans = 1;  // default if todo == 0\n        if (todo != 0) {\n            ans = 0;\n            for (int y: graph.get(x)) if (count.get(y) != 0) {\n                ans += dfs(y, todo - 1);\n            }\n        }\n        count.put(x, count.get(x) + 1);\n        return ans;\n    }\n}\n", "class Solution {\n    int N;\n    Map<Integer, List<Integer>> graph;\n    Integer[][] memo;\n    public int numSquarefulPerms(int[] A) {\n        N = A.length;\n        graph = new HashMap();\n        memo = new Integer[N][1 << N];\n        for (int i = 0; i < N; ++i)\n            graph.put(i, new ArrayList());\n        for (int i = 0; i < N; ++i)\n            for (int j = i+1; j < N; ++j) {\n                int r = (int) (Math.sqrt(A[i] + A[j]) + 0.5);\n                if (r * r == A[i] + A[j]) {\n                    graph.get(i).add(j);\n                    graph.get(j).add(i);\n                }\n            }\n        int[] factorial = new int[20];\n        factorial[0] = 1;\n        for (int i = 1; i < 20; ++i)\n            factorial[i] = i * factorial[i-1];\n        int ans = 0;\n        for (int i = 0; i < N; ++i)\n            ans += dfs(i, 1 << i);\n        Map<Integer, Integer> count = new HashMap();\n        for (int x: A)\n            count.put(x, count.getOrDefault(x, 0) + 1);\n        for (int v: count.values())\n            ans /= factorial[v];\n        return ans;\n    }\n    public int dfs(int node, int visited) {\n        if (visited == (1 << N) - 1)\n            return 1;\n        if (memo[node][visited] != null)\n            return memo[node][visited];\n        int ans = 0;\n        for (int nei: graph.get(node))\n            if (((visited >> nei) & 1) == 0)\n                ans += dfs(nei, visited | (1 << nei));\n        memo[node][visited] = ans;\n        return ans;\n    }\n}\n"]}
{"number": 997, "statement": "In a town, there are N people labelled from1 to N. There is a rumor that one of these people is secretly the town judge.\nIf thetown judge exists, then:\nThe town judge trusts nobody.\nEverybody (except for the town judge) trusts the town judge.\nThere is exactly one person that satisfies properties 1 and 2.\nYou are given trust, an array of pairs trust[i] = [a, b] representing that the person labelled a trusts the person labelled b.\nIf the town judge exists and can be identified, return the label of the town judge. Otherwise, return -1.\n", "solutions": ["public int findJudge(int N, int[][] trust) {\n    \n    if (trust.length < N - 1) {\n        return -1;\n    }\n    \n    int[] indegrees = new int[N + 1];\n    int[] outdegrees = new int[N + 1];\n    for (int[] relation : trust) {\n        outdegrees[relation[0]]++;\n        indegrees[relation[1]]++; \n    }\n    for (int i = 1; i <= N; i++) {\n        if (indegrees[i] == N - 1 && outdegrees[i] == 0) {\n            return i;\n        }\n    }\n    return -1;\n}\n", "public int findJudge(int N, int[][] trust) {\n        \n    if (trust.length < N - 1) {\n        return -1;\n    }\n    \n    int[] trustScores = new int[N + 1];\n    for (int[] relation : trust) {\n        trustScores[relation[0]]--;\n        trustScores[relation[1]]++; \n    }\n    \n    for (int i = 1; i <= N; i++) {\n        if (trustScores[i] == N - 1) {\n            return i;\n        }\n    }\n    return -1;\n}\n"]}
{"number": 1004, "statement": "Given an array Aof 0s and 1s, we may change up to Kvalues from 0 to 1.\nReturn the length of the longest (contiguous) subarray that contains only 1s.\n", "solutions": ["class Solution {\n  public int longestOnes(int[] A, int K) {\n    int left = 0, right;\n    for (right = 0; right < A.length; right++) {\n      // If we included a zero in the window we reduce the value of K.\n      // Since K is the maximum zeros allowed in a window.\n      if (A[right] == 0) K--;\n      // A negative K denotes we have consumed all allowed flips and window has\n      // more than allowed zeros, thus increment left pointer by 1 to keep the window size same.\n      if (K < 0) {\n        // If the left element to be thrown out is zero we increase K.\n        if (A[left] == 0) K++;\n        left++;\n      }\n    }\n    return right - left;\n  }\n}\n"]}
{"number": 1007, "statement": "In a row of dominoes, A[i] and B[i] represent the top and bottom halves of the i-th domino. (A domino is a tile with two numbers from 1 to 6 - one on each half of the tile.)\nWe may rotate the i-th domino, so that A[i] and B[i] swap values.\nReturn the minimum number of rotations so that all the values in A are the same, or all the values in Bare the same.\nIf it cannot be done, return -1.\n", "solutions": ["class Solution {\n  public:\n  /*\n  Return min number of rotations \n  if one could make all elements in A or B equal to x.\n  Else return -1.\n  */\n  int check(int x, vector<int>& A, vector<int>& B, int n) {\n    // how many rotations should be done\n    // to have all elements in A equal to x\n    // and to have all elements in B equal to x\n    int rotations_a = 0, rotations_b = 0;\n    for (int i = 0; i < n; i++) {\n      // rotations coudn't be done\n      if (A[i] != x && B[i] != x) return -1;\n      // A[i] != x and B[i] == x\n      else if (A[i] != x) rotations_a++;\n      // A[i] == x and B[i] != x    \n      else if (B[i] != x) rotations_b++;\n    }\n    // min number of rotations to have all\n    // elements equal to x in A or B\n    return min(rotations_a, rotations_b);\n  }\n  int minDominoRotations(vector<int>& A, vector<int>& B) {\n    int n = A.size();\n    int rotations = check(A[0], B, A, n);\n    // If one could make all elements in A or B equal to A[0]\n    if (rotations != -1 || A[0] == B[0]) return rotations;\n    // If one could make all elements in A or B equal to B[0]\n    else return check(B[0], B, A, n);\n  }\n};\n"]}
{"number": 1008, "statement": "Return the root node of a binary search tree that matches the given preorder traversal.\n(Recall that a binary search treeis a binary tree where for every node, any descendant of node.left has a value node.val, and any descendant of node.right has a value node.val. Also recall that a preorder traversaldisplays the value of thenode first, then traverses node.left, then traverses node.right.)\nIt's guaranteed that for the given test cases there is always possible to find a binary search tree with the given requirements.\n", "solutions": ["class Solution {\n  // start from first preorder element\n  int pre_idx = 0;\n  int[] preorder;\n  HashMap<Integer, Integer> idx_map = new HashMap<Integer, Integer>();\n  public TreeNode helper(int in_left, int in_right) {\n    // if there is no elements to construct subtrees\n    if (in_left == in_right)\n      return null;\n    // pick up pre_idx element as a root\n    int root_val = preorder[pre_idx];\n    TreeNode root = new TreeNode(root_val);\n    // root splits inorder list\n    // into left and right subtrees\n    int index = idx_map.get(root_val);\n    // recursion \n    pre_idx++;\n    // build left subtree\n    root.left = helper(in_left, index);\n    // build right subtree\n    root.right = helper(index + 1, in_right);\n    return root;\n  }\n  public TreeNode bstFromPreorder(int[] preorder) {\n    this.preorder = preorder;\n    int [] inorder = Arrays.copyOf(preorder, preorder.length);\n    Arrays.sort(inorder);\n    // build a hashmap value -> its index\n    int idx = 0;\n    for (Integer val : inorder)\n      idx_map.put(val, idx++);\n    return helper(0, inorder.length);\n  }\n}\n", "class Solution {\n  int idx = 0;\n  int[] preorder;\n  int n;\n  public TreeNode helper(int lower, int upper) {\n    // if all elements from preorder are used\n    // then the tree is constructed\n    if (idx == n) return null;\n    int val = preorder[idx];\n    // if the current element \n    // couldn't be placed here to meet BST requirements\n    if (val < lower || val > upper) return null;\n    // place the current element\n    // and recursively construct subtrees\n    idx++;\n    TreeNode root = new TreeNode(val);\n    root.left = helper(lower, val);\n    root.right = helper(val, upper);\n    return root;\n  }\n  public TreeNode bstFromPreorder(int[] preorder) {\n    this.preorder = preorder;\n    n = preorder.length;\n    return helper(Integer.MIN_VALUE, Integer.MAX_VALUE);\n  }\n}\n", "class Solution {\n  public TreeNode bstFromPreorder(int[] preorder) {\n    int n = preorder.length;\n    if (n == 0) return null;\n    TreeNode root = new TreeNode(preorder[0]);\n    Deque<TreeNode> deque = new ArrayDeque<TreeNode>();\n    deque.push(root);\n    for (int i = 1; i < n; i++) {\n      // take the last element of the deque as a parent\n      // and create a child from the next preorder element\n      TreeNode node = deque.peek();\n      TreeNode child = new TreeNode(preorder[i]);\n      // adjust the parent \n      while (!deque.isEmpty() && deque.peek().val < child.val)\n        node = deque.pop();\n      // follow BST logic to create a parent-child link\n      if (node.val < child.val) node.right = child;\n      else node.left = child;\n      // add the child into deque\n      deque.push(child);\n    }\n    return root;\n  }\n}\n"]}
{"number": 1009, "statement": "Every non-negative integer Nhas a binary representation. For example,5 can be represented as \"101\"in binary, 11 as \"1011\"in binary, and so on. Note that except for N = 0, there are no leading zeroes in anybinary representation.\nThe complementof a binary representationis the number in binary you get when changing every 1 to a 0 and 0 to a 1. For example, the complement of \"101\" in binary is \"010\" in binary.\nFor a given number N in base-10, return the complement of it's binary representation as abase-10 integer.\n", "solutions": ["class Solution {\n  public int bitwiseComplement(int N) {\n    if (N == 0) return 1;\n    int todo = N, bit = 1;\n    while (todo != 0) {\n      // flip current bit\n      N = N ^ bit;\n      // prepare for the next run\n      bit = bit << 1;\n      todo = todo >> 1;\n    }\n    return N;\n  }\n}\n", "class Solution {\n  public int bitwiseComplement(int N) {\n    // l is a length of N in binary representation\n    int l = (int)( Math.log(N) / Math.log(2) ) + 1;\n    // bitmask has the same length as num and contains only ones 1...1\n    int bitmask = (1 << l) - 1;\n    // flip all bits\n    return bitmask ^ N;\n  }\n}\n", "class Solution {\n  public int bitwiseComplement(int N) {\n    return N == 0 ? 1 : (Integer.highestOneBit(N) << 1) - N - 1;\n  }\n}\n", "class Solution {\n  public int bitwiseComplement(int N) {\n    if (N == 0) return 1;\n    // bitmask has the same length as N and contains only ones 1...1\n    int bitmask = N;\n    bitmask |= (bitmask >> 1);\n    bitmask |= (bitmask >> 2);\n    bitmask |= (bitmask >> 4);\n    bitmask |= (bitmask >> 8);\n    bitmask |= (bitmask >> 16);\n    // flip all bits \n    return bitmask ^ N;\n  }\n}\n"]}
{"number": 1029, "statement": "There are 2N people a company is planning to interview. The cost of flying the i-th person to city A is costs[i][0], and the cost of flying the i-th person to city B is costs[i][1].\nReturn the minimum cost to fly every person to a city such that exactly N people arrive in each city.\n", "solutions": ["class Solution {\n  public:\n  int twoCitySchedCost(vector<vector<int>>& costs) {\n    // Sort by a gain which company has \n    // by sending a person to city A and not to city B\n    sort(begin(costs), end(costs),\n            [](const vector<int> &o1, const vector<int> &o2) {\n      return (o1[0] - o1[1] < o2[0] - o2[1]);\n    });\n    int total = 0;\n    int n = costs.size() / 2;\n    // To optimize the company expenses,\n    // send the first n persons to the city A\n    // and the others to the city B\n    for (int i = 0; i < n; ++i) total += costs[i][0] + costs[i + n][1];\n    return total;\n  }\n};\n"]}
{"number": 1044, "statement": "Given a string S, consider all duplicated substrings: (contiguous) substrings of S that occur 2 or more times. (The occurrencesmay overlap.)\nReturn any duplicatedsubstring that has the longest possible length. (If S does not have a duplicated substring, the answer is \"\".)\n", "solutions": ["h = (h * a - nums[start - 1] * aL % modulus + modulus) % modulus;\nh = (h + nums[start + L - 1]) % modulus;\n", "class Solution {\n  /*\n  Rabin-Karp with polynomial rolling hash.\n      Search a substring of given length\n      that occurs at least 2 times.\n      Return start position if the substring exits and -1 otherwise.\n      */\n  public int search(int L, int a, long modulus, int n, int[] nums) {\n    // compute the hash of string S[:L]\n    long h = 0;\n    for(int i = 0; i < L; ++i) h = (h * a + nums[i]) % modulus;\n    // already seen hashes of strings of length L\n    HashSet<Long> seen = new HashSet();\n    seen.add(h);\n    // const value to be used often : a**L % modulus\n    long aL = 1;\n    for (int i = 1; i <= L; ++i) aL = (aL * a) % modulus;\n    for(int start = 1; start < n - L + 1; ++start) {\n      // compute rolling hash in O(1) time\n      h = (h * a - nums[start - 1] * aL % modulus + modulus) % modulus;\n      h = (h + nums[start + L - 1]) % modulus;\n      if (seen.contains(h)) return start;\n      seen.add(h);\n    }\n    return -1;\n  }\n  public String longestDupSubstring(String S) {\n    int n = S.length();\n    // convert string to array of integers\n    // to implement constant time slice\n    int[] nums = new int[n];\n    for(int i = 0; i < n; ++i) nums[i] = (int)S.charAt(i) - (int)'a';\n    // base value for the rolling hash function\n    int a = 26;\n    // modulus value for the rolling hash function to avoid overflow\n    long modulus = (long)Math.pow(2, 32);\n    // binary search, L = repeating string length\n    int left = 1, right = n;\n    int L;\n    while (left <= right) {\n      L = left + (right - left) / 2;\n      if (search(L, a, modulus, n, nums) != -1) left = L + 1;\n      else right = L - 1;\n    }\n    int start = search(left - 1, a, modulus, n, nums);\n    return S.substring(start, start + left - 1);\n  }\n}\n"]}
{"number": 1046, "statement": "We have a collection of stones, each stonehas a positive integer weight.\nEach turn, we choose the two heavieststonesand smash them together. Suppose the stones have weights x and y with x = y. The result of this smash is:\nIf x == y, both stones are totally destroyed;\nIf x != y, the stone of weight x is totally destroyed, and the stone of weight y has new weight y-x.\nAt the end, there is at most 1 stone left. Return the weight of this stone (or 0 if there are no stones left.)\n", "solutions": ["class Solution {\n    \n    private int removeLargest(List<Integer> stones) {\n        int indexOfLargest = stones.indexOf(Collections.max(stones));\n        int result = stones.get(indexOfLargest);\n        stones.set(indexOfLargest, stones.get(stones.size() - 1));\n        stones.remove(stones.size() - 1);\n        return result;\n    }\n    public int lastStoneWeight(int[] stones) {\n        List<Integer> stoneList = new ArrayList<>();\n        for (int weight : stones) {\n            stoneList.add(weight);\n        }\n        while (stoneList.size() > 1) {\n            int stone1 = removeLargest(stoneList);\n            int stone2 = removeLargest(stoneList);\n            if (stone1 != stone2) {\n                stoneList.add(stone1 - stone2);\n            }\n        }\n        return !stoneList.isEmpty() ? stoneList.remove(0) : 0;\n    }\n}\n", "class Solution {\n    public int lastStoneWeight(int[] stones) {\n        List<Integer> stoneList = new ArrayList<>();\n        for (int stone : stones) {\n            stoneList.add(stone);\n        }\n        Collections.sort(stoneList);\n        while (stoneList.size() > 1) {\n            int stone1 = stoneList.remove(stoneList.size() - 1);\n            int stone2 = stoneList.remove(stoneList.size() - 1);\n            if (stone1 != stone2) {\n                int newStone = stone1 - stone2;\n                int index = Collections.binarySearch(stoneList, newStone);\n                if (index == -1) {\n                    stoneList.add(newStone);\n                } else if (index < 0) {\n                    stoneList.add(-index - 1, newStone);\n                } else {\n                    stoneList.add(index, newStone);\n                }\n            }\n        }\n        return !stoneList.isEmpty() ? stoneList.remove(0) : 0;\n    }\n}\n", "class Solution {\n    \n    public int lastStoneWeight(int[] stones) {\n        \n        // Insert all the stones into a Max-Heap.\n        PriorityQueue<Integer> heap = new PriorityQueue<>(Comparator.reverseOrder());\n        for (int stone: stones) {\n            heap.add(stone);\n        }\n        // While there is more than one stone left, we need to remove the two largest\n        // and smash them together. If there is a resulting stone, we need to put into\n        // the heap.\n        while (heap.size() > 1) {\n            int stone1 = heap.remove();\n            int stone2 = heap.remove();\n            if (stone1 != stone2) {\n                heap.add(stone1 - stone2);\n            }\n        }\n        // Check whether or not there is a stone left to return.\n        return heap.isEmpty() ? 0 : heap.remove();\n    }\n}\n", "class Solution {\n    \n    public int lastStoneWeight(int[] stones) {\n        \n        // Set up the bucket array.\n        int maxWeight = stones[0];\n        for (int stone: stones) {\n            maxWeight = Math.max(maxWeight, stone);\n        }\n        int[] buckets = new int[maxWeight + 1];\n        // Bucket sort.\n        for (int weight : stones) {\n            buckets[weight]++;\n        }\n        // Scan through the buckets.\n        int biggestWeight = 0;\n        int currentWeight = maxWeight;\n        while (currentWeight > 0) {\n            if (buckets[currentWeight] == 0) {\n                currentWeight--;\n            } else if (biggestWeight == 0) {\n                buckets[currentWeight] %= 2;\n                if (buckets[currentWeight] == 1) {\n                    biggestWeight = currentWeight;\n                }\n                currentWeight--;\n            } else {\n                buckets[currentWeight]--;\n                if (biggestWeight - currentWeight <= currentWeight) {\n                    buckets[biggestWeight - currentWeight]++;\n                    biggestWeight = 0;\n                } else {\n                    biggestWeight -= currentWeight;\n                }\n            }\n        }\n        return biggestWeight;\n    }\n}\n"]}
{"number": 1047, "statement": "Given a string S of lowercase letters, a duplicate removal consists of choosing two adjacent and equal letters, and removingthem.\nWe repeatedly make duplicate removals on S until we no longer can.\nReturn the final string after all such duplicate removals have been made. It is guaranteed the answer is unique.\n", "solutions": ["class Solution {\n  public String removeDuplicates(String S) {\n    // generate 26 possible duplicates\n    HashSet<String> duplicates = new HashSet();\n    StringBuilder sb = new StringBuilder();\n    for(char i = 'a'; i <= 'z'; ++i) {\n      sb.setLength(0);\n      sb.append(i); sb.append(i);\n      duplicates.add(sb.toString());\n    }\n    int prevLength = -1;\n    while (prevLength != S.length()) {\n      prevLength = S.length();\n      for (String d : duplicates) S = S.replace(d, \"\");\n    }\n    return S;\n  }\n}\n", "class Solution {\n  public String removeDuplicates(String S) {\n    StringBuilder sb = new StringBuilder();\n    int sbLength = 0;\n    for(char character : S.toCharArray()) {\n      if (sbLength != 0 && character == sb.charAt(sbLength - 1))\n        sb.deleteCharAt(sbLength-- - 1);\n      else {\n        sb.append(character);\n        sbLength++;\n      }\n    }\n    return sb.toString();\n  }\n}\n"]}
{"number": 1060, "statement": "Given a sorted array A of unique numbers, find the K-th missing number starting from the leftmost number of the array.\n", "solutions": ["class Solution {\n  // Return how many numbers are missing until nums[idx]\n  int missing(int idx, int[] nums) {\n    return nums[idx] - nums[0] - idx;\n  }\n  public int missingElement(int[] nums, int k) {\n    int n = nums.length;\n    // If kth missing number is larger than \n    // the last element of the array\n    if (k > missing(n - 1, nums))\n      return nums[n - 1] + k - missing(n - 1, nums);\n    int idx = 1;\n    // find idx such that \n    // missing(idx - 1) < k <= missing(idx)\n    while (missing(idx, nums) < k) idx++;\n    // kth missing number is greater than nums[idx - 1]\n    // and less than nums[idx]\n    return nums[idx - 1] + k - missing(idx - 1, nums);\n  }\n}\n", "class Solution {\n  // Return how many numbers are missing until nums[idx]\n  int missing(int idx, int[] nums) {\n    return nums[idx] - nums[0] - idx;\n  }\n  public int missingElement(int[] nums, int k) {\n    int n = nums.length;\n    // If kth missing number is larger than \n    // the last element of the array\n    if (k > missing(n - 1, nums))\n      return nums[n - 1] + k - missing(n - 1, nums);\n    int left = 0, right = n - 1, pivot;\n    // find left = right index such that \n    // missing(left - 1) < k <= missing(left)\n    while (left != right) {\n      pivot = left + (right - left) / 2;\n      if (missing(pivot, nums) < k) left = pivot + 1;\n      else right = pivot;\n    }\n    // kth missing number is greater than nums[idx - 1]\n    // and less than nums[idx]\n    return nums[left - 1] + k - missing(left - 1, nums);\n  }\n}\n"]}
{"number": 1062, "statement": "Given a string S, find out the length of the longest repeating substring(s). Return 0 if no repeating substring exists.\n", "solutions": ["class Solution {\n  /*\n    Search a substring of given length\n    that occurs at least 2 times.\n    Return start position if the substring exits and -1 otherwise.\n    */\n  public int search(int L, int n, String S) {\n    // Subtask 2 : TODO\n  }\n  public int longestRepeatingSubstring(String S) {\n    int n = S.length();\n    // binary search, L = repeating string length\n    int left = 1, right = n;\n    int L;\n    while (left <= right) {\n      L = left + (right - left) / 2;\n      if (search(L, n, S) != -1) left = L + 1;\n      else right = L - 1;\n    }\n    return left - 1;\n  }\n}\n", "class Solution {\n  /*\n    Search a substring of given length\n    that occurs at least 2 times.\n    Return start position if the substring exits and -1 otherwise.\n    */\n  public int search(int L, int n, String S) {\n    HashSet<String> seen = new HashSet();\n    String tmp;\n    for(int start = 0; start < n - L + 1; ++start) {\n      tmp = S.substring(start, start + L);\n      if (seen.contains(tmp)) return start;\n      seen.add(tmp);\n    }\n    return -1;\n  }\n  public int longestRepeatingSubstring(String S) {\n    int n = S.length();\n    // binary search, L = repeating string length\n    int left = 1, right = n;\n    int L;\n    while (left <= right) {\n      L = left + (right - left) / 2;\n      if (search(L, n, S) != -1) left = L + 1;\n      else right = L - 1;\n    }\n    return left - 1;\n  }\n}\n", "class Solution {\n  /*\n    Search a substring of given length\n    that occurs at least 2 times.\n    Return start position if the substring exits and -1 otherwise.\n    */\n  public int search(int L, int n, String S) {\n    HashSet<Integer> seen = new HashSet();\n    String tmp;\n    int h;\n    for(int start = 0; start < n - L + 1; ++start) {\n      tmp = S.substring(start, start + L);\n      h = tmp.hashCode();\n      if (seen.contains(h)) return start;\n      seen.add(h);\n    }\n    return -1;\n  }\n  public int longestRepeatingSubstring(String S) {\n    int n = S.length();\n    // binary search, L = repeating string length\n    int left = 1, right = n;\n    int L;\n    while (left <= right) {\n      L = left + (right - left) / 2;\n      if (search(L, n, S) != -1) left = L + 1;\n      else right = L - 1;\n    }\n    return left - 1;\n  }\n}\n", "h = (h * a - nums[start - 1] * aL % modulus + modulus) % modulus;\nh = (h + nums[start + L - 1]) % modulus;\n", "class Solution {\n  /*\n  Rabin-Karp with polynomial rolling hash.\n      Search a substring of given length\n      that occurs at least 2 times.\n      Return start position if the substring exits and -1 otherwise.\n      */\n  public int search(int L, int a, long modulus, int n, int[] nums) {\n    // compute the hash of string S[:L]\n    long h = 0;\n    for(int i = 0; i < L; ++i) h = (h * a + nums[i]) % modulus;\n    // already seen hashes of strings of length L\n    HashSet<Long> seen = new HashSet();\n    seen.add(h);\n    // const value to be used often : a**L % modulus\n    long aL = 1;\n    for (int i = 1; i <= L; ++i) aL = (aL * a) % modulus;\n    for(int start = 1; start < n - L + 1; ++start) {\n      // compute rolling hash in O(1) time\n      h = (h * a - nums[start - 1] * aL % modulus + modulus) % modulus;\n      h = (h + nums[start + L - 1]) % modulus;\n      if (seen.contains(h)) return start;\n      seen.add(h);\n    }\n    return -1;\n  }\n  public int longestRepeatingSubstring(String S) {\n    int n = S.length();\n    // convert string to array of integers\n    // to implement constant time slice\n    int[] nums = new int[n];\n    for(int i = 0; i < n; ++i) nums[i] = (int)S.charAt(i) - (int)'a';\n    // base value for the rolling hash function\n    int a = 26;\n    // modulus value for the rolling hash function to avoid overflow\n    long modulus = (long)Math.pow(2, 24);\n    // binary search, L = repeating string length\n    int left = 1, right = n;\n    int L;\n    while (left <= right) {\n      L = left + (right - left) / 2;\n      if (search(L, a, modulus, n, nums) != -1) left = L + 1;\n      else right = L - 1;\n    }\n    return left - 1;\n  }\n}\n"]}
{"number": 1074, "statement": "Given a matrix, and a target, return the number of non-empty submatrices that sum to target.\nA submatrix x1, y1, x2, y2 is the set of all cells matrix[x][y] with x1 = x = x2 and y1 = y = y2.\nTwo submatrices (x1, y1, x2, y2) and (x1', y1', x2', y2') are different if they have some coordinatethat is different: for example, if x1 != x1'.\n", "solutions": ["// compute 2D prefix sum\nfor (int i = 1; i < r + 1; ++i) {\n  for (int j = 1; j < c + 1; ++j) {\n    ps[i][j] = ps[i - 1][j] + ps[i][j - 1] - ps[i - 1][j - 1] + matrix[i - 1][j - 1];\n  }\n}\n", "Map<Integer, Integer> h = new HashMap();\nh.put(0, 1);\nfor (int col = 1; col < c + 1; ++col) {\n  // current 1D prefix sum\n  currSum = ps[r2][col] - ps[r1 - 1][col];\n  // add subarrays which sum up to (currSum - target)\n  count += h.getOrDefault(currSum - target, 0);\n  // save current prefix sum\n  h.put(currSum, h.getOrDefault(currSum, 0) + 1);\n}\n", "class Solution {\n  public int numSubmatrixSumTarget(int[][] matrix, int target) {\n    int r = matrix.length, c = matrix[0].length;\n    // compute 2D prefix sum\n    int[][] ps = new int[r + 1][c + 1];\n    for (int i = 1; i < r + 1; ++i) {\n      for (int j = 1; j < c + 1; ++j) {\n        ps[i][j] = ps[i - 1][j] + ps[i][j - 1] - ps[i - 1][j - 1] + matrix[i - 1][j - 1];\n      }\n    }\n    int count = 0, currSum;\n    Map<Integer, Integer> h = new HashMap();\n    // reduce 2D problem to 1D one\n    // by fixing two rows r1 and r2 and \n    // computing 1D prefix sum for all matrices using [r1..r2] rows\n    for (int r1 = 1; r1 < r + 1; ++r1) {\n      for (int r2 = r1; r2 < r + 1; ++r2) {\n        h.clear();\n        h.put(0, 1);\n        for (int col = 1; col < c + 1; ++col) {\n          // current 1D prefix sum\n          currSum = ps[r2][col] - ps[r1 - 1][col];\n          // add subarrays which sum up to (currSum - target)\n          count += h.getOrDefault(currSum - target, 0);\n          // save current prefix sum\n          h.put(currSum, h.getOrDefault(currSum, 0) + 1);\n        }\n      }\n    }\n    return count;\n  }\n}\n", "class Solution {\n  public int numSubmatrixSumTarget(int[][] matrix, int target) {\n    int r = matrix.length, c = matrix[0].length;\n    // compute 2D prefix sum\n    int[][] ps = new int[r + 1][c + 1];\n    for (int i = 1; i < r + 1; ++i) {\n      for (int j = 1; j < c + 1; ++j) {\n        ps[i][j] = ps[i - 1][j] + ps[i][j - 1] - ps[i - 1][j - 1] + matrix[i - 1][j - 1];\n      }\n    }\n    int count = 0, currSum;\n    Map<Integer, Integer> h = new HashMap();\n    // reduce 2D problem to 1D one\n    // by fixing two columns c1 and c2 and \n    // computing 1D prefix sum for all matrices using [c1..c2] columns\n    for (int c1 = 1; c1 < c + 1; ++c1) {\n      for (int c2 = c1; c2 < c + 1; ++c2) {\n        h.clear();\n        h.put(0, 1);\n        for (int row = 1; row < r + 1; ++row) {\n          // current 1D prefix sum \n          currSum = ps[row][c2] - ps[row][c1 - 1];\n          // add subarrays which sum up to (currSum - target)\n          count += h.getOrDefault(currSum - target, 0);\n          // save current prefix sum\n          h.put(currSum, h.getOrDefault(currSum, 0) + 1);\n        }\n      }\n    }\n    return count;\n  }\n}\n"]}
{"number": 1089, "statement": "Given a fixed lengtharray arr of integers, duplicate each occurrence of zero, shifting the remaining elements to the right.\nNote that elements beyond the length of the original array are not written.\nDo the above modifications to the input array in place, do not return anything from your function.\n", "solutions": ["class Solution {\n    public void duplicateZeros(int[] arr) {\n        int possibleDups = 0;\n        int length_ = arr.length - 1;\n        // Find the number of zeros to be duplicated\n        // Stopping when left points beyond the last element in the original array\n        // which would be part of the modified array\n        for (int left = 0; left <= length_ - possibleDups; left++) {\n            // Count the zeros\n            if (arr[left] == 0) {\n                // Edge case: This zero can't be duplicated. We have no more space,\n                // as left is pointing to the last element which could be included  \n                if (left == length_ - possibleDups) {\n                    // For this zero we just copy it without duplication.\n                    arr[length_] = 0;\n                    length_ -= 1;\n                    break;\n                }\n                possibleDups++;\n            }\n        }\n        // Start backwards from the last element which would be part of new array.\n        int last = length_ - possibleDups;\n        // Copy zero twice, and non zero once.\n        for (int i = last; i >= 0; i--) {\n            if (arr[i] == 0) {\n                arr[i + possibleDups] = 0;\n                possibleDups--;\n                arr[i + possibleDups] = 0;\n            } else {\n                arr[i + possibleDups] = arr[i];\n            }\n        }\n    }\n}\n"]}
{"number": 1103, "statement": "We distribute somenumber of candies, to a row of n =num_peoplepeople in the following way:\nWe then give 1 candy to the first person, 2 candies to the second person, and so on until we give ncandies to the last person.\nThen, we go back to the start of the row, giving n+ 1 candies to the first person, n+ 2 candies to the second person, and so on until we give 2 * ncandies to the last person.\nThis process repeats (with us giving one more candy each time, and moving to the start of the row after we reach the end) until we run out of candies. The last person will receive all of our remaining candies (not necessarily one more than the previous gift).\nReturn an array (of length num_peopleand sum candies) that represents the final distribution of candies.\n", "solutions": ["class Solution {\n  public int[] distributeCandies(int candies, int num_people) {\n    int n = num_people;\n    // how many people received complete gifts\n    int p = (int)(Math.sqrt(2 * candies + 0.25) - 0.5);\n    int remaining = (int)(candies - (p + 1) * p * 0.5);\n    int rows = p / n, cols = p % n;\n    int[] d = new int[n];\n    for(int i = 0; i < n; ++i) {\n      // complete rows\n      d[i] = (i + 1) * rows + (int)(rows * (rows - 1) * 0.5) * n;\n      // cols in the last row\n      if (i < cols) d[i] += i + 1 + rows * n;\n    }\n    // remaining candies        \n    d[cols] += remaining;\n    return d;\n  }\n}\n"]}
{"number": 1114, "statement": "Suppose we have a class:\npublic class Foo {\n public void first() { print(\"first\"); }\n public void second() { print(\"second\"); }\n public void third() { print(\"third\"); }\n}\nThe same instance of Foo will be passed to three different threads. Thread A will call first(), thread B will call second(), and thread C will call third(). Design a mechanism and modify the programto ensure thatsecond()is executed afterfirst(), andthird() is executed aftersecond().\n", "solutions": ["int balance = 500;\nint withdraw(int amount) {\n  if (amount < balance) {\n    balance -= amount;\n  }\n  return balance;\n}\n", "#include <semaphore.h>\nclass Foo {\nprotected:\n    sem_t firstJobDone;\n    sem_t secondJobDone;\npublic:\n    Foo() {\n        sem_init(&firstJobDone, 0, 0);\n        sem_init(&secondJobDone, 0, 0);\n    }\n    void first(function<void()> printFirst) {\n        // printFirst() outputs \"first\".\n        printFirst();\n        sem_post(&firstJobDone);\n    }\n    void second(function<void()> printSecond) {\n        sem_wait(&firstJobDone);\n        // printSecond() outputs \"second\".\n        printSecond();\n        sem_post(&secondJobDone);\n        \n    }\n    void third(function<void()> printThird) {\n        sem_wait(&secondJobDone);\n        // printThird() outputs \"third\".\n        printThird();\n    }\n};\n"]}
{"number": 1137, "statement": "The Tribonacci sequence Tn is defined as follows:\nT0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n = 0.\nGiven n, return the value of Tn.\n", "solutions": ["class Solution {\n  public int tribonacci(int n) {\n    if (n < 3) return n == 0 ? 0 : 1;\n    int tmp, x = 0, y = 1, z = 1;\n    for (int i = 3; i <= n; ++i) {\n      tmp = x + y + z;\n      x = y;\n      y = z;\n      z = tmp;\n    }\n    return z;\n  }\n}\n", "class Tri {\n  private int n = 38;\n  public int[] nums = new int[n];\n  int helper(int k) {\n    if (k == 0) return 0;\n    if (nums[k] != 0) return nums[k];\n    nums[k] = helper(k - 1) + helper(k - 2) + helper(k - 3);\n    return nums[k];\n  }\n  Tri() {\n    nums[1] = 1;\n    nums[2] = 1;\n    helper(n - 1);\n  }\n}\nclass Solution {\n  public static Tri t = new Tri();\n  public int tribonacci(int n) {\n    return t.nums[n];\n  }\n}\n", "class Tri {\n  private int n = 38;\n  public int[] nums = new int[n];\n  Tri() {\n    nums[1] = 1;\n    nums[2] = 1;\n    for (int i = 3; i < n; ++i)\n      nums[i] = nums[i - 1] + nums[i - 2] + nums[i - 3];\n  }\n}\nclass Solution {\n  public static Tri t = new Tri();\n  public int tribonacci(int n) {\n    return t.nums[n];\n  }\n}\n"]}
{"number": 1143, "statement": "Given two strings text1 and text2, return the length of their longest common subsequence.\nA subsequence of a string is a new string generated from the original string with some characters(can be none) deleted without changing the relative order of the remaining characters. (eg, \"ace\" is a subsequence of \"abcde\" while \"aec\" is not).A common subsequenceof two strings is a subsequence that is common to both strings.\nIf there is no common subsequence, return 0.\n", "solutions": ["class Solution {\n    \n  private int[][] memo;\n  private String text1;\n  private String text2;\n    \n  public int longestCommonSubsequence(String text1, String text2) {\n    // Make the memo big enough to hold the cases where the pointers\n    // go over the edges of the strings.\n    this.memo = new int[text1.length() + 1][text2.length() + 1];\n    // We need to initialise the memo array to -1's so that we know\n    // whether or not a value has been filled in. Keep the base cases\n    // as 0's to simplify the later code a bit.\n    for (int i = 0; i < text1.length(); i++) {\n      for (int j = 0; j < text2.length(); j++) {\n        this.memo[i][j] = -1;\n      }\n    }\n    this.text1 = text1;\n    this.text2 = text2;\n    return memoSolve(0, 0);\n  }\n  private int memoSolve(int p1, int p2) {        \n    // Check whether or not we've already solved this subproblem.\n    // This also covers the base cases where p1 == text1.length\n    // or p2 == text2.length.\n    if (memo[p1][p2] != -1) {\n      return memo[p1][p2];\n    }\n    // Option 1: we don't include text1[p1] in the solution.\n    int option1 = memoSolve(p1 + 1, p2);\n    // Option 2: We include text1[p1] in the solution, as long as\n    // a match for it in text2 at or after p2 exists.\n    int firstOccurence = text2.indexOf(text1.charAt(p1), p2);\n    int option2 = 0;\n    if (firstOccurence != -1) {\n      option2 = 1 + memoSolve(p1 + 1, firstOccurence + 1);\n    }\n    // Add the best answer to the memo before returning it.\n    memo[p1][p2] = Math.max(option1, option2);\n    return memo[p1][p2];\n  }\n}\n", "class Solution {\n    \n  private int[][] memo;\n  private String text1;\n  private String text2;\n    \n  public int longestCommonSubsequence(String text1, String text2) {\n    // Make the memo big enough to hold the cases where the pointers\n    // go over the edges of the strings.\n    this.memo = new int[text1.length() + 1][text2.length() + 1];\n    // We need to initialise the memo array to -1's so that we know\n    // whether or not a value has been filled in. Keep the base cases\n    // as 0's to simplify the later code a bit.\n    for (int i = 0; i < text1.length(); i++) {\n      for (int j = 0; j < text2.length(); j++) {\n        this.memo[i][j] = -1;\n      }\n    }\n    this.text1 = text1;\n    this.text2 = text2;\n    return memoSolve(0, 0);\n  }\n  private int memoSolve(int p1, int p2) {        \n    // Check whether or not we've already solved this subproblem.\n    // This also covers the base cases where p1 == text1.length\n    // or p2 == text2.length.\n    if (memo[p1][p2] != -1) {\n      return memo[p1][p2];\n    }\n    // Recursive cases.\n    int answer = 0;\n    if (text1.charAt(p1) == text2.charAt(p2)) {\n      answer = 1 + memoSolve(p1 + 1, p2 + 1);\n    } else {\n      answer = Math.max(memoSolve(p1, p2 + 1), memoSolve(p1 + 1, p2));\n    }\n    \n    // Add the best answer to the memo before returning it.\n    memo[p1][p2] = answer;\n    return memo[p1][p2];\n  }\n}\n", "class Solution {\n    \n  public int longestCommonSubsequence(String text1, String text2) {    \n    \n    // Make a grid of 0's with text2.length() + 1 columns \n    // and text1.length() + 1 rows.\n    int[][] dpGrid = new int[text1.length() + 1][text2.length() + 1];\n        \n    // Iterate up each column, starting from the last one.\n    for (int col = text2.length() - 1; col >= 0; col--) {\n      for (int row = text1.length() - 1; row >= 0; row--) {\n        // If the corresponding characters for this cell are the same...\n        if (text1.charAt(row) == text2.charAt(col)) {\n          dpGrid[row][col] = 1 + dpGrid[row + 1][col + 1];\n        // Otherwise they must be different...\n        } else {\n          dpGrid[row][col] = Math.max(dpGrid[row + 1][col], dpGrid[row][col + 1]);\n        }\n      }\n    }\n        \n    // The original problem's answer is in dp_grid[0][0]. Return it.\n    return dpGrid[0][0];\n  }\n}\n", "class Solution {\n    \n  public int longestCommonSubsequence(String text1, String text2) {    \n    \n    // If text1 doesn't reference the shortest string, swap them.\n    if (text2.length() < text1.length()) {\n      String temp = text1;\n      text1 = text2;\n      text2 = temp;\n    }\n      \n    // The previous column starts with all 0's and like before is 1\n    // more than the length of the first word.\n    int[] previous = new int[text1.length() + 1];\n      \n    // Iterate through each column, starting from the last one.\n    for (int col = text2.length() - 1; col >= 0; col--) {\n      // Create a new array to represent the current column.\n      int[] current = new int[text1.length() + 1];  \n      for (int row = text1.length() - 1; row >= 0; row--) {\n        if (text1.charAt(row) == text2.charAt(col)) {\n          current[row] = 1 + previous[row + 1];\n        } else {\n          current[row] = Math.max(previous[row], current[row + 1]);\n        }\n      }\n      // The current column becomes the previous one.\n      previous = current;\n    }\n        \n    // The original problem's answer is in previous[0]. Return it.\n    return previous[0];\n  }\n}\n", "class Solution {\n    \n  public int longestCommonSubsequence(String text1, String text2) {    \n    \n    // If text1 doesn't reference the shortest string, swap them.\n    if (text2.length() < text1.length()) {\n      String temp = text1;\n      text1 = text2;\n      text2 = temp;\n    }\n      \n    // The previous and current column starts with all 0's and like \n    // before is 1 more than the length of the first word.\n    int[] previous = new int[text1.length() + 1];\n    int[] current = new int[text1.length() + 1];\n      \n    // Iterate through each column, starting from the last one.\n    for (int col = text2.length() - 1; col >= 0; col--) {\n      for (int row = text1.length() - 1; row >= 0; row--) {\n        if (text1.charAt(row) == text2.charAt(col)) {\n          current[row] = 1 + previous[row + 1];\n        } else {\n          current[row] = Math.max(previous[row], current[row + 1]);\n        }\n      }\n      // The current column becomes the previous one, and vice versa.\n      int[] temp = previous;\n      previous = current;\n      current = temp;\n    }\n        \n    // The original problem's answer is in previous[0]. Return it.\n    return previous[0];\n  }\n}\n"]}
{"number": 1161, "statement": "Given the root of a binary tree, the level of its root is 1,the level of its children is 2,and so on.\nReturn the smallest level X such that the sum of all the values of nodes at level X is maximal.\n", "solutions": ["class Solution {\n  int n = 10000;\n  int[] levelSum = new int[n];\n  public void inorder(TreeNode node, int level) {\n    if (node != null) {\n      inorder(node.left, level + 1);\n      levelSum[level] += node.val;\n      inorder(node.right, level + 1);\n    }\n  }\n  \n  public int maxLevelSum(TreeNode root) {\n    inorder(root, 1);\n    int maxIdx = 0;\n    for (int i = 0; i < n; ++i)\n      maxIdx = levelSum[i] > levelSum[maxIdx] ? i : maxIdx;\n    return maxIdx;\n  }\n}\n", "class Solution {\n  public int maxLevelSum(TreeNode root) {\n    int currLevel = 1, maxLevel = 1;\n    int maxSum = root.val, currSum = 0;\n    LinkedList<TreeNode> queue = new LinkedList();\n    TreeNode marker = null, x = root;\n    queue.addLast(root);\n    queue.addLast(marker);\n    while (queue.size() > 1) {\n      x = queue.removeFirst();\n      // continue current level\n      if (x != marker) {\n        currSum += x.val;\n        if (x.left != null) queue.addLast(x.left);\n        if (x.right != null) queue.addLast(x.right);\n      }\n      // end of current level, go to the next level\n      else {\n        if (currSum > maxSum) {\n          maxSum = currSum;\n          maxLevel = currLevel;\n        }\n        currSum = 0;\n        currLevel++;\n        queue.addLast(marker);\n      }\n    }\n    return maxLevel;\n  }\n}\n"]}
{"number": 1198, "statement": "Given a matrix matwhere every row is sorted in increasing order, returnthe smallest common element in all rows.\nIf there is no common element, return-1.\n", "solutions": ["int smallestCommonElement(vector<vector<int>>& mat) {\n    int count[10001] = {};\n    int n = mat.size(), m = mat[0].size();\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            ++count[mat[i][j]];\n        }\n    }\n    for (int k = 1; k <= 10000; ++k) {\n        if (count[k] == n) {\n            return k;\n        }\n    }\n    return -1;\n}\n", "int smallestCommonElement(vector<vector<int>>& mat) {\n    int count[10001] = {};\n    int n = mat.size(), m = mat[0].size();\n    for (int j = 0; j < m; ++j) {\n        for (int i = 0; i < n; ++i) {\n            if (++count[mat[i][j]] == n) {\n                return mat[i][j];\n            }\n        }\n    }\n    return -1;\n}\n", "int smallestCommonElement(vector<vector<int>>& mat) {\n    int n = mat.size(), m = mat[0].size();\n    for (int j = 0; j < m; ++j) {\n        bool found = true;\n        for (int i = 1; i < n && found; ++i) {\n            found = binary_search(begin(mat[i]), end(mat[i]), mat[0][j]);\n        }\n        if (found) {\n            return mat[0][j];\n        }\n    }\n    return -1;\n}\n", "int smallestCommonElement(vector<vector<int>>& mat) {\n    int n = mat.size(), m = mat[0].size();\n    vector<int> pos(n);\n    for (int j = 0; j < m; ++j) {\n        bool found = true;\n        for (int i = 1; i < n && found; ++i) {\n            pos[i] = lower_bound(begin(mat[i]) + pos[i], end(mat[i]), mat[0][j]) - begin(mat[i]);\n            if (pos[i] >= m) {\n                return -1;\n            }\n            found = mat[i][pos[i]] == mat[0][j];\n        }\n        if (found) {\n            return mat[0][j];\n        }\n    }\n    return -1;\n}\n", "int smallestCommonElement(vector<vector<int>>& mat) {\n    int n = mat.size(), m = mat[0].size();\n    int cur_max = 0, cnt = 0;\n    vector<int> pos(n);\n    while (true) {\n        for (int i = 0; i < n; ++i) {\n            while (pos[i] < m && mat[i][pos[i]] < cur_max) {\n                ++pos[i];\n            }\n            if (pos[i] >= m) {\n                return -1;\n            }\n            if (cur_max != mat[i][pos[i]]) {\n                cnt = 1;\n                cur_max = mat[i][pos[i]];\n            } else if (++cnt == n) {\n                return cur_max;\n            }\n        }\n    }\n    return -1;\n}\n", "int metaSearch(vector<int> &row, int pos, int val, int d = 1) {\n    int sz = row.size();\n    while (pos < sz && row[pos] < val) {\n        d <<= 1;\n        if (row[min(pos + d, sz - 1)] >= val) {\n            d = 1;\n        }\n        pos += d;\n    }\n    return pos;\n}\nint smallestCommonElement(vector<vector<int>>& mat) {\n    int n = mat.size(), m = mat[0].size();\n    int cur_max = 0, cnt = 0;\n    vector<int> pos(n);\n    while (true) {\n        for (int i = 0; i < n; ++i) {\n            pos[i] = metaSearch(mat[i], pos[i], cur_max);\n            if (pos[i] >= m) {\n                return -1;\n            }\n            if (cur_max != mat[i][pos[i]]) {\n                cnt = 1;\n                cur_max = mat[i][pos[i]];\n            } else if (++cnt == n) {\n                return cur_max;\n            }\n        }\n    }\n    return -1;\n}\n"]}
{"number": 1209, "statement": "Given a strings, a kduplicate removalconsists of choosing kadjacent and equal letters froms and removingthem causing the left and the right side of the deleted substring to concatenate together.\nWe repeatedly make k duplicate removals on s until we no longer can.\nReturn the final string after all such duplicate removals have been made.\nIt is guaranteed that the answer is unique.\n", "solutions": ["string removeDuplicates(string s, int k) {\n    int length = -1;\n    while (length != s.size()) {\n        length = s.size();\n        for (int i = 0, count = 1; i < s.size(); ++i) {\n            if (i == 0 || s[i] != s[i - 1]) {\n                count = 1;\n            } else if (++count == k) {\n                s.erase(i - k + 1, k);\n                break;\n            }\n        }\n    }\n    return s;\n}\n", "string removeDuplicates(string s, int k) {\n    vector<int> count(s.size());\n    for (int i = 0; i < s.size(); ++i) {\n        if (i == 0 || s[i] != s[i - 1]) {\n            count[i] = 1;\n        } else {\n            count[i] = count[i - 1] + 1;\n            if (count[i] == k) {\n                s.erase(i - k + 1, k);\n                i = i - k;\n            }\n        };\n    }\n    return s;\n}\n"]}
{"number": 1214, "statement": "Given two binary search trees, return Trueif and only if there is a node in the first tree and a node in the second tree whose valuessum up to a given integertarget.\n", "solutions": ["public List<Integer> inorder(TreeNode root, List<Integer> arr) {\n  if (root == null) return arr;\n  inorder(root.left, arr);\n  arr.add(root.val);\n  inorder(root.right, arr);\n  return arr;\n}  \n", "class Solution {\n  public Set<Integer> inHashset(TreeNode r, int target, Set<Integer> s) {\n    if (r == null) return s;\n    inHashset(r.left, target, s);\n    s.add(target - r.val);\n    inHashset(r.right, target, s);\n    return s;\n  }\n  public boolean inCheck(TreeNode r, Set<Integer> s) {\n    if (r == null) return false;\n    return inCheck(r.left, s) || s.contains(r.val) || inCheck(r.right, s);\n  }\n  public boolean twoSumBSTs(TreeNode root1, TreeNode root2, int target) {\n    Set<Integer> s = inHashset(root1, target, new HashSet());\n    return inCheck(root2, s);\n  }\n}\n", "class Solution {\n  public boolean twoSumBSTs(TreeNode root1, TreeNode root2, int target) {\n    ArrayDeque<TreeNode> stack = new ArrayDeque();\n    Set<Integer> s = new HashSet();\n    // traverse the first tree \n    // and store node complements (target - val) in hashset\n    while (!stack.isEmpty() || root1 != null) {\n      while (root1 != null) {\n        stack.push(root1);\n        root1 = root1.left;\n      }\n      root1 = stack.pop();\n      s.add(target - root1.val);\n      root1 = root1.right;\n    }\n    // traverse the second tree \n    // and check if one of the values exists in hashset\n    while (!stack.isEmpty() || root2 != null) {\n      while (root2 != null) {\n        stack.push(root2);\n        root2 = root2.left;\n      }\n      root2 = stack.pop();\n      if (s.contains(root2.val)) {\n        return true;\n      }\n      root2 = root2.right;\n    }\n    \n    return false;\n  }\n}\n"]}
{"number": 1249, "statement": "Given a string sof'(',')'and lowercase English characters.\nYour task is to remove the minimum number of parentheses ('('or')',in any positions ) so that the resulting parentheses string is valid and return any valid string.\nFormally, a parentheses string is valid if and only if:\nIt is the empty string, contains only lowercase characters, or\nIt can be written asAB(Aconcatenated withB), whereAandBare valid strings, or\nIt can be written as(A), whereAis a valid string.\n", "solutions": ["class Solution {\n    public String minRemoveToMakeValid(String s) {\n        Set<Integer> indexesToRemove = new HashSet<>();\n        Stack<Integer> stack = new Stack<>();\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == '(') {\n                stack.push(i);\n            } if (s.charAt(i) == ')') {\n                if (stack.isEmpty()) {\n                    indexesToRemove.add(i);\n                } else {\n                    stack.pop();\n                }\n            }\n        }\n        // Put any indexes remaining on stack into the set.\n        while (!stack.isEmpty()) indexesToRemove.add(stack.pop());\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < s.length(); i++) {\n            if (!indexesToRemove.contains(i)) {\n                sb.append(s.charAt(i));\n            }\n        }\n        return sb.toString();\n    }\n}\n", "class Solution {\n    private StringBuilder removeInvalidClosing(CharSequence string, char open, char close) {\n        StringBuilder sb = new StringBuilder();\n        int balance = 0;\n        for (int i = 0; i < string.length(); i++) {\n            char c = string.charAt(i);\n            if (c == open) {\n                balance++;\n            } if (c == close) {\n                if (balance == 0) continue;\n                balance--;\n            }\n            sb.append(c);\n        }  \n        return sb;\n    }\n    public String minRemoveToMakeValid(String s) {\n        StringBuilder result = removeInvalidClosing(s, '(', ')');\n        result = removeInvalidClosing(result.reverse(), ')', '(');\n        return result.reverse().toString();\n    }\n}\n"]}
{"number": 1260, "statement": "Given a 2D grid of size m x nand an integer k. You need to shift the gridk times.\nIn one shift operation:\nElement at grid[i][j] moves to grid[i][j + 1].\nElement at grid[i][n - 1] moves to grid[i + 1][0].\nElement at grid[m- 1][n - 1] moves to grid[0][0].\nReturn the 2D grid after applying shift operation k times.\n", "solutions": ["class Solution {\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\n        // Repeat the transform k times.\n        for (;k > 0; k--) {\n            // We'll write the transform into a new 2D array.\n            int[][] newGrid = new int[grid.length][grid[0].length];\n            // Case #1: Move everything not in the last column.\n            for (int row = 0; row < grid.length; row++) {\n                for (int col = 0; col < grid[0].length - 1; col++) {\n                    newGrid[row][col + 1] = grid[row][col];\n                }\n            }\n            // Case #2: Move everything in last column, but not last row.\n            for (int row = 0; row < grid.length - 1; row++) {\n                newGrid[row + 1][0] = grid[row][grid[0].length - 1];\n            }\n            // Case #3: Move the bottom right.\n            newGrid[0][0] = grid[grid.length - 1][grid[0].length - 1];\n            // Update grid to be the transformed grid.\n            grid = newGrid;\n        }\n        // Copy the grid into a list for returning.\n        List<List<Integer>> result = new ArrayList<>();\n        for (int[] row : grid) {\n            List<Integer> listRow = new ArrayList<>();\n            result.add(listRow);\n            for (int v : row) listRow.add(v);\n        }\n        return result;\n    }\n}\n", "class Solution {\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\n        // Repeat the transform k times.\n        for (;k > 0; k--) {\n            int previous = grid[grid.length - 1][grid[0].length - 1];\n            for (int row = 0; row < grid.length; row++) {\n                for (int col = 0; col < grid[0].length; col++) {\n                    int temp = grid[row][col];\n                    grid[row][col] = previous;\n                    previous = temp;\n                }\n            }\n        }\n        // Copy the grid into a list for returning.\n        List<List<Integer>> result = new ArrayList<>();\n        for (int[] row : grid) {\n            List<Integer> listRow = new ArrayList<>();\n            result.add(listRow);\n            for (int v : row) listRow.add(v);\n        }\n        return result;\n    }\n}\n", "class Solution {\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\n        int numCols = grid[0].length;\n        int numRows = grid.length;\n        // Setup the 2d list.\n        List<List<Integer>> newGrid = new ArrayList<>();\n        for (int row = 0; row < numRows; row++) {\n            List<Integer> newRow = new ArrayList<>();\n            newGrid.add(newRow);\n            for (int col = 0; col < numCols; col++) {\n                newRow.add(0);\n            }\n        }\n        for (int row = 0; row < numRows; row++) {\n            for (int col = 0; col < numCols; col++) {\n                int newCol = (col + k) % numCols;\n                int wrapAroundCount = (col + k) / numCols;\n                int newRow = (row + wrapAroundCount) % numRows;\n                newGrid.get(newRow).set(newCol, grid[row][col]);\n            }\n        }\n        return newGrid;\n    }\n}\n"]}
{"number": 1272, "statement": "Given a sorted list of disjoint intervals, each interval intervals[i] = [a, b] represents the set of real numbersx such thata = x  b.\nWe remove the intersections between any interval in intervals and the interval toBeRemoved.\nReturn a sortedlist of intervals after all such removals.\n", "solutions": ["class Solution {\n  public List<List<Integer>> removeInterval(int[][] intervals, int[] toBeRemoved) {\n    int removeStart = toBeRemoved[0], removeEnd = toBeRemoved[1];\n    List<List<Integer>> output = new ArrayList<List<Integer>>();\n    for (int[] interval : intervals) {\n      int start = interval[0], end = interval[1];\n      if (end <= removeStart || start >= removeEnd) {\n        // if current interval ends before toBeRemoved\n        // or starts after\n        output.add(new ArrayList<Integer>() {{add(start); add(end); }});\n      } else if (start < removeStart && end > removeEnd) {\n        // if the interval to be removed is inside \n        // of the current interval\n        output.add(new ArrayList<Integer>() {{add(start); add(removeStart); }});\n        output.add(new ArrayList<Integer>() {{add(removeEnd); add(end); }});\n      } else if (start < removeStart && end <= removeEnd) {\n        // \"left\" overlap\n        output.add(new ArrayList<Integer>() {{add(start); add(removeStart); }});\n      } else if (start >= removeStart && end > removeEnd) {\n        // \"right\" overlap\n        output.add(new ArrayList<Integer>() {{add(removeEnd); add(end); }});\n      }\n    }\n    return output;\n  }\n}\n"]}
{"number": 1286, "statement": "Design an Iterator class, which has:\nA constructor that takes a stringcharactersof sorted distinct lowercase English letters and a numbercombinationLength as arguments.\nA function next()that returns the next combination of length combinationLengthin lexicographical order.\nA function hasNext() that returns Trueif and only ifthere exists a next combination.\n", "solutions": ["class CombinationIterator {\n    public Deque < String > combinations = new ArrayDeque < String > ();\n    String characters;\n    int n, k;\n    public void backtrack(int first, StringBuilder curr) {\n        // if the combination is done\n        if (curr.length() == k) {\n            combinations.push(curr.toString());\n            // speed up by non-constructing combinations \n            // with more than k elements  \n            return;\n        }\n        for (int i = first; i < n; ++i) {\n            // add i into the current combination\n            curr.append(characters.charAt(i));\n            // use next integers to complete the combination\n            backtrack(i + 1, curr);\n            // backtrack\n            curr.deleteCharAt(curr.length() - 1);\n        }\n    }\n    public CombinationIterator(String characters, int combinationLength) {\n        this.n = characters.length();\n        this.k = combinationLength;\n        this.characters = characters;\n        backtrack(0, new StringBuilder());\n    }\n    public String next() {\n        return combinations.removeLast();\n    }\n    public boolean hasNext() {\n        return (!combinations.isEmpty());\n    }\n}\n", "class CombinationIterator {\n    public Deque < String > combinations = new ArrayDeque < String > ();\n    public CombinationIterator(String characters, int combinationLength) {\n        int n = characters.length();\n        int k = combinationLength;\n        // generate bitmasks from 0..00 to 1..11  \n        for (int bitmask = 0; bitmask < 1 << n; bitmask++) {\n            // use bitmasks with k 1-bits\n            if (Integer.bitCount(bitmask) == k) {\n                // convert bitmask into combination\n                // 111 --> \"abc\", 000 --> \"\"\n                // 110 --> \"ab\", 101 --> \"ac\", 011 --> \"bc\"\n                StringBuilder curr = new StringBuilder();\n                for (int j = 0; j < n; j++) {\n                    if ((bitmask & (1 << n - j - 1)) != 0) {\n                        curr.append(characters.charAt(j));\n                    }\n                }\n                combinations.push(curr.toString());\n            }\n        }\n    }\n    public String next() {\n        return combinations.pop();\n    }\n    public boolean hasNext() {\n        return (!combinations.isEmpty());\n    }\n}\n", "class CombinationIterator {\n    int bitmask, n, k;\n    String chars;\n    public CombinationIterator(String characters, int combinationLength) {\n        n = characters.length();\n        k = combinationLength;\n        chars = characters;\n        // generate first bitmask 1(k)0(n - k)\n        bitmask = (1 << n) - (1 << n - k);\n    }\n    public String next() {\n        // convert bitmask into combination\n        // 111 --> \"abc\", 000 --> \"\"\n        // 110 --> \"ab\", 101 --> \"ac\", 011 --> \"bc\"\n        StringBuilder curr = new StringBuilder();\n        for (int j = 0; j < n; j++) {\n            if ((bitmask & (1 << n - j - 1)) != 0) {\n                curr.append(chars.charAt(j));\n            }\n        }\n        // generate next bitmask\n        bitmask--;\n        while (bitmask > 0 && Integer.bitCount(bitmask) != k) {\n            bitmask--;\n        }\n        return curr.toString();\n    }\n    public boolean hasNext() {\n        return bitmask > 0;\n    }\n}\n", "class CombinationIterator {\n    public Deque < String > combinations = new ArrayDeque < String > ();\n    public CombinationIterator(String characters, int combinationLength) {\n        int n = characters.length(), k = combinationLength;\n        // init the first combination\n        int[] nums = new int[k + 1];\n        for (int i = 0; i < k; ++i) {\n            nums[i] = i;\n        }\n        nums[k] = n;\n        int j = 0;\n        while (j < k) {\n            // add current combination\n            StringBuilder sb = new StringBuilder();\n            for (int i = k - 1; i > -1; i--) {\n                sb.append(characters.charAt(n - 1 - nums[i]));\n            }\n            combinations.push(sb.toString());\n            // Generate next combination.\n            // Find the first j such that nums[j] + 1 != nums[j + 1].\n            // Increase nums[j] by one.\n            j = 0;\n            while ((j < k) && (nums[j + 1] == nums[j] + 1)) {\n                nums[j] = j;\n                j++;\n            }\n            nums[j]++;\n        }\n    }\n    public String next() {\n        return combinations.pop();\n    }\n    public boolean hasNext() {\n        return (!combinations.isEmpty());\n    }\n}\n", "class CombinationIterator {\n    int[] nums;\n    boolean has_next;\n    int n, k;\n    String chars;\n    public CombinationIterator(String characters, int combinationLength) {\n        n = characters.length();\n        k = combinationLength;\n        chars = characters;\n        // init the first combination\n        has_next = true;\n        nums = new int[k];\n        for (int i = 0; i < k; ++i) {\n            nums[i] = i;\n        }\n    }\n    public String next() {\n        StringBuilder curr = new StringBuilder();\n        for (int j: nums) {\n            curr.append(chars.charAt(j));\n        }\n        // Generate next combination.\n        // Find the first j such that nums[j] != n - k + j.\n        // Increase nums[j] by one.\n        int j = k - 1;\n        while (j >= 0 && nums[j] == n - k + j) {\n            j--;\n        }\n        if (j >= 0) {\n            nums[j]++;\n            for (int i = j + 1; i < k; i++) {\n                nums[i] = nums[j] + i - j;\n            }\n        } else {\n            has_next = false;\n        }\n        return curr.toString();\n    }\n    public boolean hasNext() {\n        return has_next;\n    }\n}\n"]}
{"number": 1288, "statement": "Given a list of intervals, remove all intervals that are covered by another interval in the list.Interval [a,b) is covered byinterval [c,d) if and only if c = a and b = d.\nAfter doing so, return the number of remaining intervals.\n", "solutions": ["class Solution {\n  public:\n  int removeCoveredIntervals(vector<vector<int>>& intervals) {\n    // If two intervals share the same start point,\n    // put the longer one to be the first.\n    sort(begin(intervals), end(intervals),\n      [](const vector<int> &o1, const vector<int> &o2) {\n      return o1[0] == o2[0] ? o2[1] < o1[1] : o1[0] < o2[0];\n    });\n    int count = 0;\n    int end, prev_end = 0;\n    for (auto curr : intervals) {\n      end = curr[1];\n      // if current interval is not covered\n      // by the previous one\n      if (prev_end < end) {\n        ++count;\n        prev_end = end;\n      }\n    }\n    return count;\n  }\n};\n"]}
{"number": 1291, "statement": "Aninteger has sequential digits if and only if each digit in the number is one more than the previous digit.\nReturn a sorted list of all the integersin the range [low, high]inclusive that have sequential digits.\n", "solutions": ["class Solution {\n  public List<Integer> sequentialDigits(int low, int high) {\n    String sample = \"123456789\";\n    int n = 10;\n    List<Integer> nums = new ArrayList();\n    int lowLen = String.valueOf(low).length();\n    int highLen = String.valueOf(high).length();\n    for (int length = lowLen; length < highLen + 1; ++length) {\n      for (int start = 0; start < n - length; ++start) {\n        int num = Integer.parseInt(sample.substring(start, start + length));\n        if (num >= low && num <= high) nums.add(num);\n      }\n    }\n    return nums;\n  }\n}\n", "class Seq {\n  public List<Integer> nums = new ArrayList();\n  Seq() {\n    String sample = \"123456789\";\n    int n = 10;\n    for (int length = 2; length < n; ++length) {\n      for (int start = 0; start < n - length; ++start) {\n        int num = Integer.parseInt(sample.substring(start, start + length));\n        nums.add(num);\n      }\n    }\n  }\n}\nclass Solution {\n  public static Seq s = new Seq();\n  public List<Integer> sequentialDigits(int low, int high) {\n    List<Integer> output = new ArrayList();\n    for (int num : s.nums) {\n      if (num >= low && num <= high) output.add(num);\n    }\n    return output;\n  }\n}\n"]}
{"number": 1302, "statement": "Given a binary tree, return the sum of values of its deepest leaves.\n", "solutions": ["class Solution {\n  public int deepestLeavesSum(TreeNode root) {\n    int deepestSum = 0, depth = 0, currDepth;\n    Deque<Pair<TreeNode, Integer>> stack = new ArrayDeque();\n    stack.push(new Pair(root, 0));\n    while (!stack.isEmpty()) {\n      Pair<TreeNode, Integer> p = stack.pop();\n      root = p.getKey();\n      currDepth = p.getValue();\n      if (root.left == null && root.right == null) {\n        // if this leaf is the deepest one seen so far\n        if (depth < currDepth) {\n          deepestSum = root.val;      // start new sum\n          depth = currDepth;          // note new depth    \n        } else if (depth == currDepth) {\n          // if there were already leaves at this depth\n          deepestSum += root.val;     // update existing sum    \n        }\n      } else {\n        if (root.right != null) {\n          stack.push(new Pair(root.right, currDepth + 1));\n        }\n        if (root.left != null) {\n          stack.push(new Pair(root.left, currDepth + 1));\n        }\n      }\n    }\n    return deepestSum;\n  }\n}\n", "class Solution {\n  public int deepestLeavesSum(TreeNode root) {\n    int deepestSum = 0, depth = 0, currDepth;\n    Deque<Pair<TreeNode, Integer>> queue = new ArrayDeque();\n    queue.offer(new Pair(root, 0));\n    while (!queue.isEmpty()) {\n      Pair<TreeNode, Integer> p = queue.poll();\n      root = p.getKey();\n      currDepth = p.getValue();\n      if (root.left == null && root.right == null) {\n        // if this leaf is the deepest one seen so far\n        if (depth < currDepth) {\n          deepestSum = root.val;      // start new sum\n          depth = currDepth;          // note new depth    \n        } else if (depth == currDepth) {\n          // if there were already leaves at this depth\n          deepestSum += root.val;     // update existing sum    \n        }\n      } else {\n        if (root.left != null) {\n          queue.offer(new Pair(root.left, currDepth + 1));\n        }\n        if (root.right != null) {\n          queue.offer(new Pair(root.right, currDepth + 1));\n        }\n      }\n    }\n    return deepestSum;\n  }\n}\n", "class Solution {\n  public int deepestLeavesSum(TreeNode root) {\n    ArrayDeque<TreeNode>  nextLevel = new ArrayDeque(),\n                          currLevel = new ArrayDeque();\n    nextLevel.offer(root);\n    while (!nextLevel.isEmpty()) {\n      // prepare for the next level\n      currLevel = nextLevel.clone();\n      nextLevel.clear();\n      for (TreeNode node: currLevel) {\n        // add child nodes of the current level\n        // in the queue for the next level\n        if (node.left != null) {\n          nextLevel.offer(node.left);\n        }\n        if (node.right != null) {\n          nextLevel.offer(node.right);\n        }\n      }\n    }\n    int deepestSum = 0;\n    for (TreeNode node: currLevel) {\n      deepestSum += node.val;\n    }\n    return deepestSum;\n  }\n}\n"]}
{"number": 1305, "statement": "Given two binary search trees root1 and root2.\nReturn a list containing all the integers from both trees sorted in ascending order.\n", "solutions": ["public List<Integer> inorder(TreeNode root, List<Integer> arr) {\n  if (root == null) return arr;\n  inorder(root.left, arr);\n  arr.add(root.val);\n  inorder(root.right, arr);\n  return arr;\n}  \n", "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n  public List<Integer> inorder(TreeNode root, List<Integer> arr) {\n    if (root == null) return arr;\n    inorder(root.left, arr);\n    arr.add(root.val);\n    inorder(root.right, arr);\n    return arr;\n  }\n  public List<Integer> getAllElements(TreeNode root1, TreeNode root2) {\n    List<Integer> output = new ArrayList<>();\n    Stream.of(inorder(root1, new ArrayList()), inorder(root2, new ArrayList())).forEach(output::addAll);\n    Collections.sort(output);\n    return output;\n  }\n}\n"]}
{"number": 1332, "statement": "Given a string s consisting only ofletters'a' and 'b'. In a single step you can remove onepalindromic subsequencefrom s.\nReturn the minimum number of steps to make the given string empty.\nA string is a subsequence of a given string, if it is generated by deleting some characters of a given string without changing its order.\nA string is called palindrome if is one that reads the same backward as well as forward.\n", "solutions": ["class Solution {\n    public int removePalindromeSub(String s) {\n        if (s.isEmpty()) {\n            return 0;\n        }\n        // See below for code that compacts this into one line.\n        StringBuilder sb = new StringBuilder(s);\n        sb.reverse();\n        String reversedString = sb.toString();\n        if (reversedString.equals(s)) {\n            return 1;\n        }\n        return 2;\n    }\n}\n", "class Solution {\n    public int removePalindromeSub(String s) {\n        if (s.isEmpty()) {\n            return 0;\n        }\n        String reversedString = new StringBuilder(s).reverse().toString();\n        if (reversedString.equals(s)) {\n            return 1;\n        }\n        return 2;\n    }\n}\n", "class Solution {\n    public int removePalindromeSub(String s) {\n        if (s.isEmpty()) {\n            return 0;\n        }\n        if (isPalindrome(s)) {\n            return 1;\n        }\n        return 2;\n    }\n    private boolean isPalindrome(String s) {\n        int lo = 0;\n        int hi = s.length() - 1;\n        while (lo < hi) {\n            if (s.charAt(lo) != s.charAt(hi)) {\n                return false;\n            }\n            lo++;\n            hi--;\n        }\n        return true;\n    }\n}\n"]}
{"number": 1337, "statement": "Given a m* nmatrix mat of ones(representing soldiers) and zeros(representing civilians), return the indexes of the k weakest rows in the matrix ordered from the weakest to the strongest.\nA row i is weaker than row j, if the number of soldiers in row i is less than the number of soldiers in row j, or they have the same number of soldiers but i is less than j. Soldiers are always stand in the frontier of a row, that is, always onesmay appear first and then zeros.\n", "solutions": ["class Solution {\n    public int[] kWeakestRows(int[][] mat, int k) {\n        int m = mat.length;\n        int n = mat[0].length;\n        // Calculate all the strengths and put strength/ index pairs into an array.\n        int[][] pairs = new int[m][2];\n        for (int i = 0; i < m; i++) {\n            int strength = 0;\n            for (int j = 0; j < n; j++) {\n                if (mat[i][j] == 0) break;\n                strength++;\n            }\n            pairs[i][0] = strength;\n            pairs[i][1] = i;\n        }\n        /* Sort the pairs, firstly on strength and secondly on index. We'll need\n         * to implement a comparator to do this. */\n        Arrays.sort(pairs, (a, b) -> {\n            if (a[0] == b[0]) return a[1] - b[1];\n            else return a[0] - b[0];\n        });\n        // Pull out the first k indexes of the sorted array to return.\n        int[] indexes = new int[k];\n        for (int i = 0; i < k; i++) {\n            indexes[i] = pairs[i][1];\n        }\n        return indexes;\n    }\n}\n", "def kWeakestRows(self, mat: List[List[int]], k: int) -> List[int]:\n    # Build a list of (strength, index) pairs.\n    strengths = [(sum(row), i) for i, row in enumerate(mat)]\n    # Sort.\n    strengths.sort()\n    # Pull out and return the indexes of the first k entries.\n    return [i for strength, i in strengths[:k]]\n", "class Solution {\n    public int[] kWeakestRows(int[][] mat, int k) {\n        int m = mat.length;\n        int n = mat[0].length;\n        // Calculate all the strengths and put them into a HashMap.\n        Map<Integer, List<Integer>> strengths = new HashMap<>();\n        for (int i = 0; i < m; i++) {\n            int strength = 0;\n            for (int j = 0; j < n; j++) {\n                if (mat[i][j] == 0) break;\n                strength++;\n            }\n            if (!strengths.containsKey(strength)) {\n                strengths.put(strength, new ArrayList<>());\n            }\n            strengths.get(strength).add(i);\n        }\n        // Note that if we'd used a TreeMap instead of HashMap, the keys would\n        // have already been sorted.\n        List<Integer> sortedStrengths = new ArrayList<>(strengths.keySet());\n        Collections.sort(sortedStrengths);\n        // Pull out indexes for the k smallest strengths.\n        int[] indexes = new int[k];\n        int i = 0;\n        for (int key : sortedStrengths) {\n            for (int index : strengths.get(key)) {\n                indexes[i] = index;\n                i++;\n                if (i == k) break;\n            }\n            if (i == k) break;\n        }\n        return indexes;\n    }\n}\n", "class Solution {\n    public int[] kWeakestRows(int[][] mat, int k) {\n        int m = mat.length;\n        int n = mat[0].length;\n        // Calculate all the strengths and put them into a TreeMap.\n        Map<Integer, List<Integer>> strengths = new TreeMap<>();\n        for (int i = 0; i < m; i++) {\n            int strength = 0;\n            for (int j = 0; j < n; j++) {\n                if (mat[i][j] == 0) break;\n                strength++;\n            }\n            if (!strengths.containsKey(strength)) {\n                strengths.put(strength, new ArrayList<>());\n            }\n            strengths.get(strength).add(i);\n        }\n        int[] indexes = new int[k];\n        int i = 0;\n        for (int key : strengths.keySet()) {\n            for (int index : strengths.get(key)) {\n                indexes[i] = index;\n                i++;\n                if (i == k) break;\n            }\n            if (i == k) break;\n        }\n        return indexes;\n    }\n}\n", "class Solution {\n    private int binarySearch(int[] row) {\n        int low = 0;\n        int high = row.length;\n        while (low < high) {\n            int mid = low + (high - low) / 2;\n            if (row[mid] == 1) {\n                low = mid + 1;\n            } else {\n                high = mid;\n            }\n        }\n        return low;\n    }\n    public int[] kWeakestRows(int[][] mat, int k) {\n        // Calculate all the strengths using Binary Search and\n        // put them into a TreeMap.\n        Map<Integer, List<Integer>> strengths = new HashMap<>();\n        for (int i = 0; i < mat.length; i++) {\n            int strength = binarySearch(mat[i]);\n            if (!strengths.containsKey(strength)) {\n                strengths.put(strength, new ArrayList<>());\n            }\n            strengths.get(strength).add(i);\n        }\n        // Note that if we'd used a TreeMap instead of HashMap, the keys would\n        // have already been sorted.\n        List<Integer> sortedStrengths = new ArrayList<>(strengths.keySet());\n        Collections.sort(sortedStrengths);\n        int[] indexes = new int[k];\n        int i = 0;\n        for (int key : sortedStrengths) {\n            for (int index : strengths.get(key)) {\n                indexes[i] = index;\n                i++;\n                if (i == k) break;\n            }\n            if (i == k) break;\n        }\n        return indexes;\n    }\n}\n", "class Solution {\n    private int binarySearch(int[] row) {\n        int low = 0;\n        int high = row.length;\n        while (low < high) {\n            int mid = low + (high - low) / 2;\n            if (row[mid] == 1) {\n                low = mid + 1;\n            } else {\n                high = mid;\n            }\n        }\n        return low;\n    }\n    public int[] kWeakestRows(int[][] mat, int k) {\n        int m = mat.length;\n        int n = mat[0].length;\n        // Create a Priority Queue that measures firstly on strength and then indexes.\n        PriorityQueue<int[]> pq = new  PriorityQueue<>((a, b) -> {\n            if (a[0] == b[0]) return b[1] - a[1];\n            else return b[0] - a[0];\n        });\n        // Add strength/index pairs to the pq. Whenever length > k, remove the largest.\n        for (int i = 0; i < m; i++) {\n            int strength = binarySearch(mat[i]);\n            int[] entry = new int[]{strength, i};\n            pq.add(entry);\n            if (pq.size() > k) {\n                pq.poll();\n            }\n        }\n        // Pull the indexes out of the priority queue.\n        int[] indexes = new int[k];\n        for (int i = k - 1; i >= 0; i--) {\n            int[] pair = pq.poll();\n            indexes[i] = pair[1];\n        }\n        return indexes;\n    }\n}\n", "class Solution {\n    public int[] kWeakestRows(int[][] mat, int k) {\n        int m = mat.length;\n        int n = mat[0].length;\n        int [] indexes = new int[k];\n        int nextInsertIndex = 0;\n        // This code does the same as the animation above.\n        for (int c = 0; c < n && nextInsertIndex < k; c++) {\n            for (int r = 0; r < m && nextInsertIndex < k; r++) {\n                // If this is the first 0 in the current row.\n                if (mat[r][c] == 0 && (c == 0 || mat[r][c - 1] == 1)) {\n                    indexes[nextInsertIndex] = r;\n                    nextInsertIndex++;\n                }\n            }\n        }\n        /* If there aren't enough, it's because some of the first k weakest rows\n         * are entirely 1's. We need to include the ones with the lowest indexes\n         * until we have at least k. */\n        for (int r = 0; nextInsertIndex < k ; r++) {\n            /* If index i in the last column is 1, this was a full row and therefore\n             * couldn't have been included in the output yet. */\n            if (mat[r][n - 1] == 1) {\n                indexes[nextInsertIndex] = r;\n                nextInsertIndex++;\n            }\n        }\n        return indexes;\n    }\n}\n"]}
{"number": 1338, "statement": "Given an array arr. You can choose a set of integers and remove all the occurrences of these integers in the array.\nReturn the minimum size of the set so that at least half of the integers of the array are removed.\n", "solutions": ["class Solution {\n    public int minSetSize(int[] arr) {\n        \n        // Sort the input numbers.\n        Arrays.sort(arr);\n        \n        // Make the List of Counts\n        List<Integer> counts = new ArrayList<>();\n        int currentRun = 1;\n        for (int i = 1; i < arr.length; i++) {\n            if (arr[i] == arr[i - 1]) {\n                currentRun += 1;\n                continue;\n            }\n            counts.add(currentRun);\n            currentRun = 1;\n        }\n        counts.add(currentRun);\n        \n        Collections.sort(counts);\n        Collections.reverse(counts);\n        \n        // Remove numbers until at least half are removed.\n        int numbersRemovedFromArr = 0;\n        int setSize = 0;\n        for (int count : counts) {\n            numbersRemovedFromArr += count;\n            setSize += 1;   \n            if (numbersRemovedFromArr >= arr.length / 2) {\n                break;\n            }\n        }\n        \n        return setSize;\n    }\n}\n", "class Solution {\n    public int minSetSize(int[] arr) {\n        \n        // Do the counting with a HashMap.\n        Map<Integer, Integer> countsMap = new HashMap<>();\n        for (int num : arr) {\n            if (!countsMap.containsKey(num)) {\n                countsMap.put(num, 1);\n                continue;\n            }\n            countsMap.put(num, countsMap.get(num) + 1);\n        }\n        \n        // Reverse sort a list of the Map values.\n        List<Integer> counts = new ArrayList<>(countsMap.values());\n        Collections.sort(counts);\n        Collections.reverse(counts);\n        \n        // Remove numbers until at least half are removed.\n        int numbersRemovedFromArr = 0;\n        int setSize = 0;\n        for (int count : counts) {\n            numbersRemovedFromArr += count;\n            setSize += 1;   \n            if (numbersRemovedFromArr >= arr.length / 2) {\n                break;\n            }\n        }\n        \n        return setSize;\n    }\n}\n", "class Solution {\n    public int minSetSize(int[] arr) {\n        \n        Map<Integer, Integer> counts = new HashMap<>();\n        int maxCount = 0;\n        for (int num : arr) {\n            if (!counts.containsKey(num)) {\n                counts.put(num, 0);\n            }\n            int newCount = counts.get(num) + 1;\n            counts.put(num, newCount);\n            maxCount = Math.max(maxCount, newCount);\n        }\n        \n        // Put the counts into buckets.\n        int[] buckets = new int[maxCount + 1];\n        for (int count : counts.values()) {\n            buckets[count]++;\n        }\n        // Determine setSize.\n        int setSize = 0;\n        int numbersToRemoveFromArr = arr.length / 2;\n        int bucket = maxCount;\n        while (numbersToRemoveFromArr > 0) {\n            int maxNeededFromBucket = numbersToRemoveFromArr / bucket;\n            if (numbersToRemoveFromArr % bucket != 0) {\n                maxNeededFromBucket++;\n            }\n            int setSizeIncrease = Math.min(buckets[bucket], maxNeededFromBucket);\n            setSize += setSizeIncrease;\n            numbersToRemoveFromArr -= setSizeIncrease * bucket;\n            bucket--;\n        }\n        return setSize;        \n    }\n}\n"]}
{"number": 1339, "statement": "Given a binary tree root.Split the binary tree into two subtrees by removing1 edge such that the product of the sums of the subtrees are maximized.\nSince the answermay be too large,return it modulo10^9 + 7.\n", "solutions": ["class Solution {\n    private List<Integer> allSums = new ArrayList<>();\n    public int maxProduct(TreeNode root) {\n        // long is a 64-bit integer.\n        long totalSum = treeSum(root);\n        long best = 0;\n        for (long sum : allSums) {\n            best = Math.max(best, sum * (totalSum - sum));\n        }\n        // We have to cast back to an int to match return value.\n        return (int)(best % 1000000007);\n    }\n    private int treeSum(TreeNode subroot) {\n        if (subroot == null) return 0;\n        int leftSum = treeSum(subroot.left);\n        int rightSum = treeSum(subroot.right);\n        int totalSum = leftSum + rightSum + subroot.val;\n        allSums.add(totalSum);\n        return totalSum;\n    }\n}\n", "class Solution {\n    private long maximumProduct = 0;\n    private int totalTreeSum = 0;\n    private int treeSum(TreeNode subroot) {\n        if (subroot == null) return 0;\n        int leftSum = treeSum(subroot.left);\n        int rightSum = treeSum(subroot.right);\n        int totalSum = leftSum + rightSum + subroot.val;\n        return totalSum;\n    }\n    private int findMaximumProduct(TreeNode subroot) {\n        if (subroot == null) return 0;\n        int leftSum = findMaximumProduct(subroot.left);\n        int rightSum = findMaximumProduct(subroot.right);\n        int totalSum = leftSum + rightSum + subroot.val;\n        long totalProduct = (long)totalSum * (totalTreeSum - totalSum);\n        this.maximumProduct = Math.max(this.maximumProduct, totalProduct);\n        return totalSum;\n    }\n    public int maxProduct(TreeNode root) {\n        this.totalTreeSum = treeSum(root);\n        findMaximumProduct(root);\n        return (int)(maximumProduct % 1000000007);\n    }\n}\n", "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    private static final int MOD = 1000000007;\n    private List<Integer> allSums = new ArrayList<>();\n    public int maxProduct(TreeNode root) {\n        int totalSum = treeSum(root);\n        int nearestToHalf = 0;\n        int smallestDistanceBetween = Integer.MAX_VALUE;\n        for (int sum : allSums) {\n            // We want to do this in a way that doesn't require floats.\n            // One way is to minimise the *distance* between the 2 halves.\n            int distanceBetween = Math.abs(totalSum - sum * 2);\n            if (distanceBetween < smallestDistanceBetween) {\n                smallestDistanceBetween = distanceBetween;\n                nearestToHalf = sum;\n            }\n        }\n        return modularMultiplication(nearestToHalf, totalSum - nearestToHalf, MOD);\n    }\n    private int modularMultiplication(int a, int b, int m) {\n        int product = 0;\n        int currentSum = a;\n        while (b > 0) {\n            int bit = b % 2;\n            b >>= 1;\n            if (bit == 1) {\n                product += currentSum;\n                product %= m;\n            }\n            currentSum <<= 1;\n            currentSum %= m;\n        }\n        return product;\n    }    \n    private int treeSum(TreeNode subroot) {\n        if (subroot == null) return 0;\n        int leftSum = treeSum(subroot.left);\n        int rightSum = treeSum(subroot.right);\n        int totalSum = leftSum + rightSum + subroot.val;\n        allSums.add(totalSum);\n        return totalSum;\n    }\n}\n"]}
{"number": 1342, "statement": "Given a non-negative integer num, return the number of steps to reduce it to zero. If the current number is even, you have to divide it by 2, otherwise, you have to subtract 1 from it.\n", "solutions": ["public int numberOfSteps(int num) {\n    int steps = 0; // We need to keep track of how many steps this takes.\n    while (num != 0) { // Remember, we're taking steps until num is 0.\n        if (num % 2 == 0) { // Modulus operator tells us num is *even*.\n            num = num / 2; // So we divide num by 2.\n        } else { // Otherwise, num must be *odd*.\n            num = num - 1; // So we subtract 1 from num.\n        }\n        steps = steps + 1; // We *always* increment steps by 1.\n    }\n    return steps; // And at the end, the answer is in steps so we return it.\n}\n", "public int numberOfSteps(int num) {\n    \n    // Get the binary for num, as a String.\n    String binaryString = Integer.toBinaryString(num);\n    \n    int steps = 0;\n    // Iterate over all the bits in the binary string.\n    for (char bit : binaryString.toCharArray()) {\n        if (bit == '1') { // If the bit is a 1 \n            steps = steps + 2; // Then it'll take 2 to remove.\n        } else { // bit == '0'\n            steps = steps + 1; // Then it'll take 1 to remove.\n        }\n    }\n    // We need to subtract 1, because the last bit was over-counted.\n    return steps - 1;\n}\n", "def numberOfSteps (self, num: int) -> int:\n    binary = bin(num)[2:]\n    ones = binary.count(\"1\")\n    total = len(binary)\n    return ones + total - 1\n", "public int numberOfSteps(int num) {\n    // We need to handle this as a special case, otherwise it'll return -1.\n    if (num == 0) return 0;\n    int steps = 0;\n    for (int powerOfTwo = 1; powerOfTwo <= num; powerOfTwo = powerOfTwo * 2) {\n        // Apply the bit mask to check if the bit at \"powerOfTwo\" is a 1.\n        if ((powerOfTwo & num) != 0) {\n            steps = steps + 2;\n        } else {\n            steps = steps + 1;\n        }\n    }\n    // We need to subtract 1, because the last bit was over-counted.\n    return steps - 1;\n}\n"]}
{"number": 1344, "statement": "Given two numbers, hour and minutes. Return the smaller angle (in degrees) formed between the hour and the minute hand.\n", "solutions": ["class Solution {\n  public:\n  double angleClock(int hour, int minutes) {\n    int oneMinAngle = 6;\n    int oneHourAngle = 30;\n    double minutesAngle = oneMinAngle * minutes;\n    double hourAngle = (hour % 12 + minutes / 60.0) * oneHourAngle;\n    double diff = abs(hourAngle - minutesAngle);\n    return min(diff, 360 - diff);\n  }\n};\n"]}
{"number": 1354, "statement": "Given an array of integerstarget. From a starting array, Aconsisting of all 1's, you may perform the following procedure :\nlet x be the sum of all elements currently in your array.\nchoose index i, such that0 = i  target.size and set the value of A at index i to x.\nYou may repeat this procedureas many times as needed.\nReturn True if it is possible to construct the target array from A otherwisereturn False.\n", "solutions": ["class Solution {\n    public boolean isPossible(int[] target) {\n        \n        // Handle the n = 1 case.\n        if (target.length == 1) {\n            return target[0] == 1;\n        }\n        \n        int totalSum = Arrays.stream(target).sum();\n        \n        PriorityQueue<Integer> pq = new PriorityQueue<Integer>(Collections.reverseOrder());\n        for (int num : target) {\n            pq.add(num);\n        }\n        \n        while (pq.element() > 1) {\n            int largest = pq.remove();\n            int x = largest - (totalSum - largest);\n            if (x < 1) return false;\n            pq.add(x);\n            totalSum = totalSum - largest + x;\n        }\n        \n        return true; \n    }\n}\n", "class Solution {\n    public boolean isPossible(int[] target) {\n        \n        // Handle the n = 1 case.\n        if (target.length == 1) {\n            return target[0] == 1;\n        }\n        \n        int totalSum = Arrays.stream(target).sum();\n        \n        PriorityQueue<Integer> pq = new PriorityQueue<Integer>(Collections.reverseOrder());\n        for (int num : target) {\n            pq.add(num);\n        }\n        \n        while (pq.element() > 1) {\n            int largest = pq.remove();\n            int rest = totalSum - largest;\n            \n            // This will only occur if n = 2.\n            if (rest == 1) {\n                return true;\n            }\n            int x = largest % rest;\n            \n            // If x is now 0 (invalid) or didn't\n            // change, then we know this is impossible.\n            if (x == 0 || x == largest) {\n                return false;\n            }\n            pq.add(x);\n            totalSum = totalSum - largest + x;\n        }\n        \n        return true; \n    }\n}\n"]}
{"number": 1394, "statement": "Given an array of integers arr, a lucky integer is an integer which has a frequency in the array equal to its value.\nReturn a lucky integerin the array. If there are multiple lucky integers return the largest of them. If there is no luckyinteger return -1.\n", "solutions": ["public int findLucky(int[] arr) {\n    int maxLuckyNumber = -1;\n    for (int num : arr) {\n        int occurencesOfNum = countOccurences(arr, num);\n        //  If num is a lucky number, and is the biggest lucky number so far.\n        if (occurencesOfNum == num && num > maxLuckyNumber) {\n            maxLuckyNumber = num;\n        }\n    }\n    return maxLuckyNumber;\n}\nprivate int countOccurences(int[] arr, int candidateNum) {\n    int count = 0;\n    for (int num : arr) {\n        if (num == candidateNum) {\n            count++;\n        }\n    }\n    return count;\n}\n", "public int findLucky(int[] arr) {\n    Arrays.sort(arr);\n    int currentStreak = 0;\n    // In Java, it's best to just go backwards, as we can't\n    // trivially reverse-sort an Array of primitives. \n    // We could also have used the Stream API to box the ints and then\n    // sort using a library comparator.\n    for (int i = arr.length - 1; i >= 0; i--) {\n        currentStreak++;\n        // If this is the last element in the current streak (as the next is\n        // different, or we're at the start of the array).\n        if (i == 0 || arr[i] != arr[i - 1]) {\n            // If this is a lucky number\n            if (currentStreak == arr[i]) {\n                return currentStreak;\n            }\n            currentStreak = 0;\n        }\n    }\n    return -1;\n}\n", "import heapq\ndef findLucky(self, arr: List[int]) -> int:\n    \n    # Convert all numbers to negative, as we want a max-heap.\n    for i in range(len(arr)): arr[i] *= -1\n    heapq.heapify(arr)\n    \n    current_streak = 0\n    current_number = -1\n    \n    while arr:\n        # Convert num back to positive.\n        num = -heapq.heappop(arr)\n        if num == current_number:\n            current_streak += 1\n        else: \n            # Before setting current_number and current_streak to the new num,\n            # we should check if the old streak represented a lucky number.\n            if current_number == current_streak:\n                return current_streak\n            current_number = num\n            current_streak = 1\n    # Check if the last number was a lucky number.\n    if current_number == current_streak:\n        return current_streak\n    \n    # Otherwise, no lucky numbers were found.\n    return -1\n", "public int findLucky(int[] arr) {\n        \n    // Use a HashMap to count how many times each num\n    // appears in arr.\n    Map<Integer, Integer> counts = new HashMap<>();\n    for (Integer num : arr) {\n        counts.put(num, counts.getOrDefault(num, 0) + 1);\n    }\n    \n    int largestLuckyNumber = -1;\n    // Iterate over the key/ value pairs of the dictionary.\n    for (Map.Entry<Integer, Integer> entry : counts.entrySet()) {\n        // If this is a lucky number\n        if (entry.getKey().equals(entry.getValue())) {\n            // Keep the largest out of this lucky number and our current largest.\n            largestLuckyNumber = Math.max(largestLuckyNumber, entry.getKey());\n        }\n    }\n    \n    return largestLuckyNumber;\n}\n"]}
{"number": 1396, "statement": "Implement the class UndergroundSystem that supports three methods:\n1.checkIn(int id, string stationName, int t)\nA customer with id card equal to id, gets in the station stationName at time t.\nA customercan only be checked into one place at a time.\n2.checkOut(int id, string stationName, int t)\nA customer with id card equal to id, gets out from the station stationName at time t.\n3.getAverageTime(string startStation, string endStation)\nReturns the average time to travel between the startStation and the endStation.\nThe average time is computed from all the previous traveling from startStation to endStation that happened directly.\nCall to getAverageTime is always valid.\nYou can assume all calls to checkIn and checkOut methods are consistent. That is, if a customer gets in at time t1 at some station, then it gets out at time t2 with t2  t1.All events happen in chronological order.\n", "solutions": ["class UndergroundSystem {\n    private Map<String, Pair<Double, Double>> journeyData = new HashMap<>();\n    private Map<Integer, Pair<String, Integer>> checkInData = new HashMap<>();\n    \n    public UndergroundSystem() {\n    }\n    \n    public void checkIn(int id, String stationName, int t) {\n        checkInData.put(id, new Pair<>(stationName, t));\n    }\n    \n    public void checkOut(int id, String stationName, int t) {\n        // Look up the check in station and check in time for this id.\n        // You could combine this \"unpacking\" into the other lines of code\n        // to have less lines of code overall, but we've chosen to be verbose\n        // here to make it easy for all learners to follow.\n        Pair<String, Integer> checkInDataForId = checkInData.get(id);\n        String startStation = checkInDataForId.getKey();\n        Integer checkInTime = checkInDataForId.getValue();\n        \n        // Lookup the current travel time data for this route.\n        String routeKey = stationsKey(startStation, stationName);\n        Pair<Double, Double> routeStats  = journeyData.getOrDefault(routeKey, new Pair<>(0.0, 0.0));\n        Double totalTripTime = routeStats.getKey();\n        Double totalTrips = routeStats.getValue();\n        \n        // Update the travel time data with this trip.\n        double tripTime = t - checkInTime;\n        journeyData.put(routeKey, new Pair<>(totalTripTime + tripTime, totalTrips + 1));\n        \n        // Remove check in data for this id.\n        // Note that this is optional, we'll talk about it in the space complexity analysis.\n        checkInData.remove(id);\n    }\n    \n    public double getAverageTime(String startStation, String endStation) {\n        // Lookup how many times this journey has been made, and the total time.\n        String routeKey = stationsKey(startStation, endStation);\n        Double totalTime = journeyData.get(routeKey).getKey();\n        Double totalTrips = journeyData.get(routeKey).getValue();\n        // The average is simply the total divided by the number of trips.\n        return totalTime / totalTrips;\n    }\n    \n    private String stationsKey(String startStation, String endStation) {\n        return startStation + \"->\" + endStation;\n    }\n}\n"]}
{"number": 1426, "statement": "Given an integer array arr, count how many elementsxthere are, such that x + 1 is also in arr.\nIf there're duplicates inarr, count them seperately.\n", "solutions": ["class Solution {\n    public int countElements(int[] arr) {\n        int count = 0;\n        for (int x : arr) {\n            if (integerInArray(arr, x + 1)) {\n                count++;\n            }\n        }\n        return count;\n    }\n    public boolean integerInArray(int[] arr, int target) {\n        for (int x : arr) {\n            if (x == target) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n", "public int countElements(int[] arr) {\n    Set<Integer> hashSet = new HashSet<>();\n    for (int x : arr) {\n        hashSet.add(x);\n    }\n    int count = 0;\n    for (int x : arr) {\n        if (hashSet.contains(x + 1)) {\n            count++;\n        }\n    }\n    return count;\n}\n", "public int countElements(int[] arr) {\n    Arrays.sort(arr);\n    int count = 0;\n    int runLength = 1;\n    for (int i = 1; i < arr.length; i++) {\n        if (arr[i - 1] != arr[i]) {\n            if (arr[i - 1] + 1 == arr[i]) {\n                count += runLength;\n            }\n            runLength = 0;\n        }\n        runLength++;\n    }\n    return count;\n}\n"]}
{"number": 1427, "statement": "You are given a string scontaining lowercase English letters, and a matrixshift, whereshift[i] = [direction, amount]:\ndirectioncan be 0(for left shift) or 1(for right shift).\namountis the amount by which stringsis to be shifted.\nA left shift by 1 means remove the first character of s and append it to the end.\nSimilarly, a right shift by 1 means remove the last character of s and add it to the beginning.\nReturn the final string after all operations.\n", "solutions": ["class Solution {\n  public String stringShift(String string, int[][] shift) {\n    int len = string.length();\n    for (int[] move : shift) {\n      int direction = move[0];\n      int amount = move[1] % len;\n      if (direction == 0) {\n        // Move necessary amount of characters from front to end \n        string = string.substring(amount) + string.substring(0, amount);\n      } else {\n        // Move necessary amount of characters from end to front\n        string = string.substring(len - amount) + string.substring(0, len - amount);\n      }\n    }\n    return string;\n  }\n}\n", "class Solution {\n  public String stringShift(String string, int[][] shift) {\n    \n    // Add up the left shifts and right shifts.\n    int[] overallShifts = new int[2];\n    for (int[] move : shift) {\n      overallShifts[move[0]] += move[1];\n    }\n    int leftShifts = overallShifts[0];\n    int rightShifts = overallShifts[1];\n      \n    // Determine which shift (if any) to perform.\n    int len = string.length();\n    if (leftShifts > rightShifts) {\n      leftShifts = (leftShifts - rightShifts) % len;\n      string = string.substring(leftShifts) + string.substring(0, leftShifts);\n    }\n    else if (rightShifts > leftShifts) {\n      rightShifts = (rightShifts - leftShifts) % len;\n      string = string.substring(len - rightShifts) + string.substring(0, len - rightShifts);\n    }\n    \n    return string;\n  }\n}\n", "class Solution {\n  public String stringShift(String s, int[][] shift) {\n    // Count the number of left shifts. A right shift is a negative left shift.\n    int leftShifts = 0;\n    for (int[] move : shift) {\n      if (move[0] == 1) {\n        move[1] = - move[1];\n      }\n      leftShifts += move[1];\n    }\n    \n    // Convert back to a positive, do left shifts, and return.\n    leftShifts = Math.floorMod(leftShifts, s.length());\n    s = s.substring(leftShifts) + s.substring(0, leftShifts);\n    return s;\n  }\n}\n"]}
{"number": 1428, "statement": "(This problem is aninteractive problem.)\nA binary matrix means that all elements are0or1. For eachindividual row of the matrix, this rowis sorted in non-decreasing order.\nGiven a row-sorted binary matrix binaryMatrix, return leftmost column index(0-indexed) with at least a1in it. If suchindexdoesn't exist, return -1.\nYou can't access the Binary Matrix directly. You may only access the matrix using aBinaryMatrixinterface:\nBinaryMatrix.get(row, col) returns the element of the matrixat index (row, col)(0-indexed).\nBinaryMatrix.dimensions()returns a list of 2 elements[rows, cols], which means the matrix is rows * cols.\nSubmissions making more than 1000calls toBinaryMatrix.getwill be judged Wrong Answer. Also, any solutions that attempt to circumvent the judgewill result in disqualification.\nFor custom testing purposes you're given the binary matrix matas inputin the following four examples. You will not haveaccess the binary matrix directly.\n", "solutions": ["class Solution {\n  public int leftMostColumnWithOne(BinaryMatrix binaryMatrix) {\n    int rows = binaryMatrix.dimensions().get(0);\n    int cols = binaryMatrix.dimensions().get(1);\n    int smallestIndex = cols;\n    for (int row = 0; row < rows; row++) {\n      for (int col = 0; col < cols; col++) {\n        if (binaryMatrix.get(row, col) == 1) {\n          smallestIndex = Math.min(smallestIndex, col);\n          break;\n        }\n      }\n    }\n    return smallestIndex == cols ? -1 : smallestIndex;    \n  }\n}\n", "class Solution {\n  public int leftMostColumnWithOne(BinaryMatrix binaryMatrix) {\n    int rows = binaryMatrix.dimensions().get(0);\n    int cols = binaryMatrix.dimensions().get(1);\n    int smallestIndex = cols;\n    for (int row = 0; row < rows; row++) {\n      // Binary Search for the first 1 in the row.\n      int lo = 0;\n      int hi = cols - 1;\n      while (lo < hi) {\n        int mid = (lo + hi) / 2;\n        if (binaryMatrix.get(row, mid) == 0) {\n          lo = mid + 1;\n        }\n        else {\n          hi = mid;\n        }\n        // If the last element in the search space is a 1, then this row\n        // contained a 1.\n        if (binaryMatrix.get(row, lo) == 1) {\n          smallestIndex = Math.min(smallestIndex, lo);\n        }\n      }\n    }\n    // If smallest_index is still set to cols, then there were no 1's in \n    // the grid. \n    return smallestIndex == cols ? -1 : smallestIndex;\n  }\n}\n", "class Solution {\n  public int leftMostColumnWithOne(BinaryMatrix binaryMatrix) {\n    \n    int rows = binaryMatrix.dimensions().get(0);\n    int cols = binaryMatrix.dimensions().get(1);\n    // Set pointers to the top-right corner.\n    int currentRow = 0;\n    int currentCol = cols - 1;\n    \n    // Repeat the search until it goes off the grid.\n    while (currentRow < rows && currentCol >= 0) {\n      if (binaryMatrix.get(currentRow, currentCol) == 0) {\n        currentRow++;\n      } else {\n        currentCol--; \n      }\n    }\n    \n    // If we never left the last column, this is because it was all 0's.\n    return (currentCol == cols - 1) ? -1 : currentCol + 1;\n  }\n}\n"]}
{"number": 1429, "statement": "You have a queue of integers, you need to retrieve the first unique integer in the queue.\nImplement the FirstUniqueclass:\nFirstUnique(int[] nums) Initializes the object with the numbers in the queue.\nint showFirstUnique()returns the value of thefirst unique integer of the queue, and returns -1 if there is no such integer.\nvoid add(int value)insert valuetothe queue.", "solutions": ["class FirstUnique {\n  private Queue<Integer> queue = new ArrayDeque<>();\n  \n  public FirstUnique(int[] nums) {\n    for (int num : nums) {\n      queue.add(num);\n    }\n  }\n    \n  public int showFirstUnique() {\n    for (int num : queue) {\n      int count = Collections.frequency(queue, num);\n      if (count == 1) {\n        return num;\n      }\n    }\n    return -1;\n  }\n    \n  public void add(int value) {\n    queue.add(value);    \n  }\n}\n", "class FirstUnique {\n  private Queue<Integer> queue = new ArrayDeque<>();\n  private Map<Integer, Boolean> isUnique = new HashMap<>();\n  public FirstUnique(int[] nums) {\n    for (int num : nums) {\n      // Notice that we're calling the \"add\" method of FirstUnique; not of the queue. \n      this.add(num);\n    }\n  }\n  public int showFirstUnique() {\n    // We need to start by \"cleaning\" the queue of any non-uniques at the start.\n    // Note that we know that if a value is in the queue, then it is also in\n    // isUnique, as the implementation of add() guarantees this.\n    while (!queue.isEmpty() && !isUnique.get(queue.peek())) {\n      queue.remove();\n    }\n    // Check if there is still a value left in the queue. There might be no uniques.\n    if (!queue.isEmpty()) {\n      return queue.peek(); // We don't want to actually *remove* the value.\n    }\n    return -1;\n  }\n  public void add(int value) {\n    // Case 1: We need to add the number to the queue and mark it as unique. \n    if (!isUnique.containsKey(value)) {\n      isUnique.put(value, true);\n      queue.add(value);\n    // Case 2 and 3: We need to mark the number as no longer unique.\n    } else {\n      isUnique.put(value, false);\n    }\n  }\n}\n"]}
